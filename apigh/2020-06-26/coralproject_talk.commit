{
  "sha": "302613a1857f43fdd939bf3fd2eef164c599ca16",
  "node_id": "MDY6Q29tbWl0NzI0NTQyNDI6MzAyNjEzYTE4NTdmNDNmZGQ5MzliZjNmZDJlZWYxNjRjNTk5Y2ExNg==",
  "commit": {
    "author": {
      "name": "Wyatt Johnson",
      "email": "me@wyattjoh.ca",
      "date": "2020-06-25T19:08:56Z"
    },
    "committer": {
      "name": "Wyatt Johnson",
      "email": "me@wyattjoh.ca",
      "date": "2020-06-25T19:08:56Z"
    },
    "message": "Merge branch 'release/6.2'",
    "tree": {
      "sha": "f3a05347d3bea1798e15d179ad1314643808030e",
      "url": "https://api.github.com/repos/coralproject/talk/git/trees/f3a05347d3bea1798e15d179ad1314643808030e"
    },
    "url": "https://api.github.com/repos/coralproject/talk/git/commits/302613a1857f43fdd939bf3fd2eef164c599ca16",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/coralproject/talk/commits/302613a1857f43fdd939bf3fd2eef164c599ca16",
  "html_url": "https://github.com/coralproject/talk/commit/302613a1857f43fdd939bf3fd2eef164c599ca16",
  "comments_url": "https://api.github.com/repos/coralproject/talk/commits/302613a1857f43fdd939bf3fd2eef164c599ca16/comments",
  "author": {
    "login": "wyattjoh",
    "id": 633002,
    "node_id": "MDQ6VXNlcjYzMzAwMg==",
    "avatar_url": "https://avatars2.githubusercontent.com/u/633002?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wyattjoh",
    "html_url": "https://github.com/wyattjoh",
    "followers_url": "https://api.github.com/users/wyattjoh/followers",
    "following_url": "https://api.github.com/users/wyattjoh/following{/other_user}",
    "gists_url": "https://api.github.com/users/wyattjoh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wyattjoh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wyattjoh/subscriptions",
    "organizations_url": "https://api.github.com/users/wyattjoh/orgs",
    "repos_url": "https://api.github.com/users/wyattjoh/repos",
    "events_url": "https://api.github.com/users/wyattjoh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wyattjoh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "wyattjoh",
    "id": 633002,
    "node_id": "MDQ6VXNlcjYzMzAwMg==",
    "avatar_url": "https://avatars2.githubusercontent.com/u/633002?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wyattjoh",
    "html_url": "https://github.com/wyattjoh",
    "followers_url": "https://api.github.com/users/wyattjoh/followers",
    "following_url": "https://api.github.com/users/wyattjoh/following{/other_user}",
    "gists_url": "https://api.github.com/users/wyattjoh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wyattjoh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wyattjoh/subscriptions",
    "organizations_url": "https://api.github.com/users/wyattjoh/orgs",
    "repos_url": "https://api.github.com/users/wyattjoh/repos",
    "events_url": "https://api.github.com/users/wyattjoh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wyattjoh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f3ef9ef778ccefa855a94b7e48d3a249cf759043",
      "url": "https://api.github.com/repos/coralproject/talk/commits/f3ef9ef778ccefa855a94b7e48d3a249cf759043",
      "html_url": "https://github.com/coralproject/talk/commit/f3ef9ef778ccefa855a94b7e48d3a249cf759043"
    },
    {
      "sha": "bf04b4c2a6d268fd75360fe29431b191cda39712",
      "url": "https://api.github.com/repos/coralproject/talk/commits/bf04b4c2a6d268fd75360fe29431b191cda39712",
      "html_url": "https://github.com/coralproject/talk/commit/bf04b4c2a6d268fd75360fe29431b191cda39712"
    }
  ],
  "stats": {
    "total": 1423,
    "additions": 717,
    "deletions": 706
  },
  "files": [
    {
      "sha": "03a2c152de72d9ba513a55dbe32de2711357ed1f",
      "filename": "src/core/server/graph/resolvers/StorySettings.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 18,
      "changes": 20,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/graph/resolvers/StorySettings.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/graph/resolvers/StorySettings.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/resolvers/StorySettings.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -1,11 +1,6 @@\n import * as story from \"coral-server/models/story\";\n-import { hasFeatureFlag } from \"coral-server/models/tenant\";\n \n-import {\n-  GQLFEATURE_FLAG,\n-  GQLSTORY_MODE,\n-  GQLStorySettingsTypeResolver,\n-} from \"../schema/__generated__/types\";\n+import { GQLStorySettingsTypeResolver } from \"../schema/__generated__/types\";\n \n import { LiveConfigurationInput } from \"./LiveConfiguration\";\n \n@@ -35,18 +30,7 @@ export const StorySettings: GQLStorySettingsTypeResolver<StorySettingsInput> = {\n     };\n   },\n   // FEATURE_FLAG:ENABLE_QA\n-  mode: (s, input, ctx) => {\n-    if (s.mode) {\n-      return s.mode;\n-    }\n-\n-    // FEATURE_FLAG:DEFAULT_QA_STORY_MODE\n-    if (hasFeatureFlag(ctx.tenant, GQLFEATURE_FLAG.DEFAULT_QA_STORY_MODE)) {\n-      return GQLSTORY_MODE.QA;\n-    }\n-\n-    return GQLSTORY_MODE.COMMENTS;\n-  },\n+  mode: (s, input, ctx) => story.resolveStoryMode(s, ctx.tenant),\n   experts: (s, input, ctx) => {\n     if (s.expertIDs) {\n       return ctx.loaders.Users.user.loadMany(s.expertIDs);"
    },
    {
      "sha": "9fe6495b8a64eb15156a588476e5c75f11c5434c",
      "filename": "src/core/server/models/story/helpers.ts",
      "status": "modified",
      "additions": 23,
      "deletions": 2,
      "changes": 25,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/models/story/helpers.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/models/story/helpers.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/models/story/helpers.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -2,9 +2,14 @@ import { DateTime } from \"luxon\";\n import { URL } from \"url\";\n \n import { parseQuery, stringifyQuery } from \"coral-common/utils\";\n-import { Tenant } from \"coral-server/models/tenant\";\n+import { hasFeatureFlag, Tenant } from \"coral-server/models/tenant\";\n \n-import { Story } from \".\";\n+import {\n+  GQLFEATURE_FLAG,\n+  GQLSTORY_MODE,\n+} from \"coral-server/graph/schema/__generated__/types\";\n+\n+import { Story } from \"./story\";\n \n /**\n  * getURLWithCommentID returns the url with the comment id.\n@@ -61,3 +66,19 @@ export function getStoryClosedAt(\n \n   return null;\n }\n+\n+export function resolveStoryMode(\n+  storySettings: Story[\"settings\"],\n+  tenant: Pick<Tenant, \"featureFlags\">\n+) {\n+  if (storySettings.mode) {\n+    return storySettings.mode;\n+  }\n+\n+  // FEATURE_FLAG:DEFAULT_QA_STORY_MODE\n+  if (hasFeatureFlag(tenant, GQLFEATURE_FLAG.DEFAULT_QA_STORY_MODE)) {\n+    return GQLSTORY_MODE.QA;\n+  }\n+\n+  return GQLSTORY_MODE.COMMENTS;\n+}"
    },
    {
      "sha": "179fd50a6fbaf22a16785dc64681d7781917893a",
      "filename": "src/core/server/models/story/index.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 682,
      "changes": 683,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/models/story/index.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/models/story/index.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/models/story/index.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -1,683 +1,2 @@\n-import { Db, MongoError } from \"mongodb\";\n-import { v4 as uuid } from \"uuid\";\n-\n-import { DeepPartial, FirstDeepPartial } from \"coral-common/types\";\n-import { dotize } from \"coral-common/utils/dotize\";\n-import {\n-  DuplicateStoryIDError,\n-  DuplicateStoryURLError,\n-  StoryNotFoundError,\n-} from \"coral-server/errors\";\n-import {\n-  Connection,\n-  ConnectionInput,\n-  Query,\n-  resolveConnection,\n-} from \"coral-server/models/helpers\";\n-import { GlobalModerationSettings } from \"coral-server/models/settings\";\n-import { TenantResource } from \"coral-server/models/tenant\";\n-import { stories as collection } from \"coral-server/services/mongodb/collections\";\n-\n-import {\n-  GQLSTORY_MODE,\n-  GQLStoryMetadata,\n-  GQLStorySettings,\n-} from \"coral-server/graph/schema/__generated__/types\";\n-\n-import {\n-  createEmptyRelatedCommentCounts,\n-  RelatedCommentCounts,\n-  updateRelatedCommentCounts,\n-} from \"../comment/counts\";\n-\n+export * from \"./story\";\n export * from \"./helpers\";\n-\n-export interface StreamModeSettings {\n-  /**\n-   * mode is whether the story stream is in commenting or Q&A mode.\n-   * This will determine the appearance of the stream and how it functions.\n-   * This is an optional parameter and if unset, defaults to commenting.\n-   */\n-  mode?: GQLSTORY_MODE;\n-\n-  /**\n-   * experts are used during Q&A mode to assign users to answer questions\n-   * on a Q&A stream. It is an optional parameter and is only used when\n-   * the story stream is in Q&A mode.\n-   */\n-  expertIDs?: string[];\n-}\n-\n-export type StorySettings = StreamModeSettings &\n-  GlobalModerationSettings &\n-  Pick<GQLStorySettings, \"messageBox\" | \"mode\" | \"experts\">;\n-\n-export type StoryMetadata = GQLStoryMetadata;\n-\n-export interface Story extends TenantResource {\n-  readonly id: string;\n-\n-  /**\n-   * url is the URL to the Story page.\n-   */\n-  url: string;\n-\n-  /**\n-   * metadata stores the scraped metadata from the Story page.\n-   */\n-  metadata?: StoryMetadata;\n-\n-  /**\n-   * scrapedAt is the Time that the Story had it's metadata scraped at.\n-   */\n-  scrapedAt?: Date;\n-\n-  /**\n-   * commentCounts stores all the comment counters.\n-   */\n-  commentCounts: RelatedCommentCounts;\n-\n-  /**\n-   * settings provides a point where the settings can be overridden for a\n-   * specific Story.\n-   */\n-  settings: DeepPartial<StorySettings>;\n-\n-  /**\n-   * closedAt is the date that the Story was forced closed at, or false to\n-   * indicate that the story was re-opened.\n-   */\n-  closedAt?: Date | false;\n-\n-  /**\n-   * createdAt is the date that the Story was added to the Coral database.\n-   */\n-  createdAt: Date;\n-\n-  /**\n-   * lastCommentedAt is the last time someone commented on this story.\n-   */\n-  lastCommentedAt?: Date;\n-\n-  /**\n-   * siteID references the site the story belongs to\n-   */\n-  siteID: string;\n-}\n-\n-export interface UpsertStoryInput {\n-  id?: string;\n-  url: string;\n-  siteID: string;\n-}\n-\n-export interface UpsertStoryResult {\n-  story: Story;\n-  wasUpserted: boolean;\n-}\n-\n-export async function upsertStory(\n-  mongo: Db,\n-  tenantID: string,\n-  { id = uuid(), url, siteID }: UpsertStoryInput,\n-  now = new Date()\n-): Promise<UpsertStoryResult> {\n-  // Create the story, optionally sourcing the id from the input, additionally\n-  // porting in the tenantID.\n-  const story: Story = {\n-    id,\n-    url,\n-    tenantID,\n-    siteID,\n-    createdAt: now,\n-    commentCounts: createEmptyRelatedCommentCounts(),\n-    settings: {},\n-  };\n-\n-  try {\n-    // Perform the find and update operation to try and find and or create the\n-    // story.\n-    const result = await collection(mongo).findOneAndUpdate(\n-      {\n-        url,\n-        tenantID,\n-      },\n-      { $setOnInsert: story },\n-      {\n-        // Create the object if it doesn't already exist.\n-        upsert: true,\n-\n-        // True to return the original document instead of the updated document.\n-        // This will ensure that when an upsert operation adds a new Story, it\n-        // should return null.\n-        returnOriginal: true,\n-      }\n-    );\n-\n-    return {\n-      // The story will either be found (via `result.value`) or upserted (via\n-      // `story`).\n-      story: result.value || story,\n-\n-      // The story was upserted if the value isn't provided.\n-      wasUpserted: !result.value,\n-    };\n-  } catch (err) {\n-    // Evaluate the error, if it is in regards to violating the unique index,\n-    // then return a duplicate Story error.\n-    if (err instanceof MongoError && err.code === 11000) {\n-      throw new DuplicateStoryIDError(err, id, url);\n-    }\n-\n-    throw err;\n-  }\n-}\n-\n-export interface FindStoryInput {\n-  id?: string;\n-  url?: string;\n-}\n-\n-export async function findStory(\n-  mongo: Db,\n-  tenantID: string,\n-  { id, url }: FindStoryInput\n-) {\n-  if (id) {\n-    return retrieveStory(mongo, tenantID, id);\n-  }\n-\n-  if (url) {\n-    return retrieveStoryByURL(mongo, tenantID, url);\n-  }\n-\n-  // Story can't be found with that ID/URL combination and scraping is\n-  // disabled, so we fail here.\n-  return null;\n-}\n-\n-export interface FindOrCreateStoryInput {\n-  id?: string;\n-  url?: string;\n-}\n-\n-export interface FindOrCreateStoryResult {\n-  story: Story | null;\n-  wasUpserted: boolean;\n-}\n-\n-export async function findOrCreateStory(\n-  mongo: Db,\n-  tenantID: string,\n-  { id, url }: FindOrCreateStoryInput,\n-  siteID: string | null,\n-  now = new Date()\n-): Promise<FindOrCreateStoryResult> {\n-  if (id) {\n-    if (url && siteID) {\n-      // The URL was specified, this is an upsert operation.\n-      return upsertStory(\n-        mongo,\n-        tenantID,\n-        {\n-          id,\n-          url,\n-          siteID,\n-        },\n-        now\n-      );\n-    }\n-\n-    // The URL was not specified, this is a lookup operation.\n-    const story = await retrieveStory(mongo, tenantID, id);\n-\n-    // Return the result object.\n-    return {\n-      story,\n-      wasUpserted: false,\n-    };\n-  }\n-\n-  // The ID was not specified, this is an upsert operation. Check to see that\n-  // the URL exists.\n-  if (!url) {\n-    throw new Error(\"cannot upsert an story without the url\");\n-  }\n-\n-  if (!siteID) {\n-    throw new Error(\"cannot upsert story without site ID\");\n-  }\n-\n-  return upsertStory(mongo, tenantID, { url, siteID }, now);\n-}\n-\n-export type CreateStoryInput = Partial<\n-  Pick<Story, \"metadata\" | \"scrapedAt\" | \"closedAt\">\n-> & {\n-  siteID: string;\n-};\n-\n-export async function createStory(\n-  mongo: Db,\n-  tenantID: string,\n-  id: string,\n-  url: string,\n-  input: CreateStoryInput,\n-  now = new Date()\n-) {\n-  // Create the story.\n-  const story: Story = {\n-    ...input,\n-    id,\n-    url,\n-    tenantID,\n-    createdAt: now,\n-    commentCounts: createEmptyRelatedCommentCounts(),\n-    settings: {},\n-  };\n-\n-  try {\n-    // Insert the story into the database.\n-    await collection(mongo).insertOne(story);\n-  } catch (err) {\n-    // Evaluate the error, if it is in regards to violating the unique index,\n-    // then return a duplicate Story error.\n-    if (err instanceof MongoError && err.code === 11000) {\n-      throw new DuplicateStoryURLError(err, url, id);\n-    }\n-\n-    throw err;\n-  }\n-\n-  // Return the created story.\n-  return story;\n-}\n-\n-export async function retrieveStoryByURL(\n-  mongo: Db,\n-  tenantID: string,\n-  url: string\n-) {\n-  return collection(mongo).findOne({ url, tenantID });\n-}\n-\n-export async function retrieveStory(mongo: Db, tenantID: string, id: string) {\n-  return collection(mongo).findOne({ id, tenantID });\n-}\n-\n-export async function retrieveManyStories(\n-  mongo: Db,\n-  tenantID: string,\n-  ids: string[]\n-) {\n-  const cursor = collection(mongo).find({\n-    id: { $in: ids },\n-    tenantID,\n-  });\n-\n-  const stories = await cursor.toArray();\n-\n-  return ids.map((id) => stories.find((story) => story.id === id) || null);\n-}\n-\n-export async function retrieveManyStoriesByURL(\n-  mongo: Db,\n-  tenantID: string,\n-  urls: string[]\n-) {\n-  const cursor = collection(mongo).find({\n-    url: { $in: urls },\n-    tenantID,\n-  });\n-\n-  const stories = await cursor.toArray();\n-\n-  return urls.map((url) => stories.find((story) => story.url === url) || null);\n-}\n-\n-export type UpdateStoryInput = Omit<\n-  Partial<Story>,\n-  \"id\" | \"tenantID\" | \"closedAt\" | \"createdAt\" | \"siteID\"\n->;\n-\n-export async function updateStory(\n-  mongo: Db,\n-  tenantID: string,\n-  id: string,\n-  input: UpdateStoryInput,\n-  now = new Date()\n-) {\n-  // Only update fields that have been updated.\n-  const update = {\n-    $set: {\n-      ...dotize(input, { embedArrays: true }),\n-      // Always update the updated at time.\n-      updatedAt: now,\n-    },\n-  };\n-\n-  try {\n-    const result = await collection(mongo).findOneAndUpdate(\n-      { id, tenantID },\n-      update,\n-      // False to return the updated document instead of the original\n-      // document.\n-      { returnOriginal: false }\n-    );\n-\n-    return result.value || null;\n-  } catch (err) {\n-    // Evaluate the error, if it is in regards to violating the unique index,\n-    // then return a duplicate Story error.\n-    if (input.url && err instanceof MongoError && err.code === 11000) {\n-      throw new DuplicateStoryURLError(err, input.url, id);\n-    }\n-\n-    throw err;\n-  }\n-}\n-export type UpdateStorySettingsInput = DeepPartial<StorySettings>;\n-\n-export async function updateStorySettings(\n-  mongo: Db,\n-  tenantID: string,\n-  id: string,\n-  input: UpdateStorySettingsInput,\n-  now = new Date()\n-) {\n-  // Only update fields that have been updated.\n-  const update = {\n-    $set: {\n-      ...dotize({ settings: input }, { embedArrays: true }),\n-      // Always update the updated at time.\n-      updatedAt: now,\n-    },\n-  };\n-\n-  const result = await collection(mongo).findOneAndUpdate(\n-    { id, tenantID },\n-    update,\n-    // False to return the updated document instead of the original\n-    // document.\n-    { returnOriginal: false }\n-  );\n-\n-  return result.value || null;\n-}\n-\n-export async function openStory(\n-  mongo: Db,\n-  tenantID: string,\n-  id: string,\n-  now = new Date()\n-) {\n-  const result = await collection(mongo).findOneAndUpdate(\n-    { id, tenantID },\n-    {\n-      $set: {\n-        closedAt: false,\n-        // Always update the updated at time.\n-        updatedAt: now,\n-      },\n-    },\n-    // False to return the updated document instead of the original\n-    // document.\n-    { returnOriginal: false }\n-  );\n-\n-  return result.value || null;\n-}\n-\n-export async function closeStory(\n-  mongo: Db,\n-  tenantID: string,\n-  id: string,\n-  now = new Date()\n-) {\n-  const result = await collection(mongo).findOneAndUpdate(\n-    { id, tenantID },\n-    {\n-      $set: {\n-        closedAt: now,\n-        // Always update the updated at time.\n-        updatedAt: now,\n-      },\n-    },\n-    // False to return the updated document instead of the original\n-    // document.\n-    { returnOriginal: false }\n-  );\n-\n-  return result.value || null;\n-}\n-\n-export async function removeStory(mongo: Db, tenantID: string, id: string) {\n-  const result = await collection(mongo).findOneAndDelete({\n-    id,\n-    tenantID,\n-  });\n-\n-  return result.value || null;\n-}\n-\n-/**\n- * removeStories will remove the stories specified by the set of id's.\n- */\n-export async function removeStories(\n-  mongo: Db,\n-  tenantID: string,\n-  ids: string[]\n-) {\n-  return collection(mongo).deleteMany({\n-    tenantID,\n-    id: {\n-      $in: ids,\n-    },\n-  });\n-}\n-\n-export type StoryConnectionInput = ConnectionInput<Story>;\n-\n-export async function retrieveStoryConnection(\n-  mongo: Db,\n-  tenantID: string,\n-  input: StoryConnectionInput\n-): Promise<Readonly<Connection<Readonly<Story>>>> {\n-  // Create the query.\n-  const query = new Query(collection(mongo)).where({ tenantID });\n-\n-  // If a filter is being applied, filter it as well.\n-  if (input.filter) {\n-    query.where(input.filter);\n-  }\n-\n-  return retrieveConnection(input, query);\n-}\n-\n-async function retrieveConnection(\n-  input: StoryConnectionInput,\n-  query: Query<Story>\n-): Promise<Readonly<Connection<Readonly<Story>>>> {\n-  // Apply the pagination arguments to the query.\n-  query.orderBy({ createdAt: -1 });\n-  if (input.after) {\n-    query.where({ createdAt: { $lt: input.after as Date } });\n-  }\n-\n-  // Return a connection.\n-  return resolveConnection(query, input, (story) => story.createdAt);\n-}\n-\n-export async function retrieveActiveStories(\n-  mongo: Db,\n-  tenantID: string,\n-  limit: number\n-) {\n-  const stories = await collection(mongo)\n-    .find({\n-      tenantID,\n-      // We limit this query to stories that have the following field. This\n-      // allows us to use the index.\n-      lastCommentedAt: {\n-        $exists: true,\n-      },\n-    })\n-    .sort({ lastCommentedAt: -1 })\n-    .limit(limit)\n-    .toArray();\n-\n-  return stories;\n-}\n-\n-export async function updateStoryLastCommentedAt(\n-  mongo: Db,\n-  tenantID: string,\n-  storyID: string,\n-  now: Date\n-) {\n-  await collection(mongo).updateOne(\n-    {\n-      tenantID,\n-      id: storyID,\n-    },\n-    {\n-      $set: {\n-        lastCommentedAt: now,\n-      },\n-    }\n-  );\n-}\n-\n-/**\n- * updateStoryCounts will update the comment counts for the story indicated.\n- *\n- * @param mongo mongodb database handle\n- * @param tenantID ID of the Tenant where the Story is on\n- * @param id the ID of the Story that we are updating counts on\n- * @param commentCounts the counts that we are updating\n- */\n-export const updateStoryCounts = (\n-  mongo: Db,\n-  tenantID: string,\n-  id: string,\n-  commentCounts: FirstDeepPartial<RelatedCommentCounts>\n-) => updateRelatedCommentCounts(collection(mongo), tenantID, id, commentCounts);\n-\n-export async function addExpert(\n-  mongo: Db,\n-  tenantID: string,\n-  storyID: string,\n-  userID: string\n-) {\n-  const story = await collection(mongo).findOne({ tenantID, id: storyID });\n-  if (!story) {\n-    throw new StoryNotFoundError(storyID);\n-  }\n-\n-  const result = await collection(mongo).findOneAndUpdate(\n-    {\n-      tenantID,\n-      id: storyID,\n-    },\n-    {\n-      $addToSet: {\n-        \"settings.expertIDs\": userID,\n-      },\n-    },\n-    {\n-      returnOriginal: false,\n-    }\n-  );\n-\n-  if (!result.ok) {\n-    throw new Error(\"unable to add expert to story\");\n-  }\n-\n-  return result.value || null;\n-}\n-\n-export async function removeExpert(\n-  mongo: Db,\n-  tenantID: string,\n-  storyID: string,\n-  userID: string\n-) {\n-  const story = await collection(mongo).findOne({ tenantID, id: storyID });\n-  if (!story) {\n-    throw new StoryNotFoundError(storyID);\n-  }\n-\n-  const result = await collection(mongo).findOneAndUpdate(\n-    {\n-      tenantID,\n-      id: storyID,\n-    },\n-    {\n-      $pull: {\n-        \"settings.expertIDs\": userID,\n-      },\n-    },\n-    {\n-      returnOriginal: false,\n-    }\n-  );\n-\n-  if (!result.ok) {\n-    throw new Error(\"unable to remove expert from story\");\n-  }\n-\n-  return result.value || null;\n-}\n-\n-export async function setStoryMode(\n-  mongo: Db,\n-  tenantID: string,\n-  storyID: string,\n-  mode: GQLSTORY_MODE\n-) {\n-  const story = await collection(mongo).findOne({ tenantID, id: storyID });\n-  if (!story) {\n-    throw new StoryNotFoundError(storyID);\n-  }\n-\n-  const result = await collection(mongo).findOneAndUpdate(\n-    {\n-      tenantID,\n-      id: storyID,\n-    },\n-    {\n-      $set: {\n-        \"settings.mode\": mode,\n-      },\n-    },\n-    {\n-      returnOriginal: false,\n-    }\n-  );\n-\n-  if (!result.ok) {\n-    throw new Error(\"unable to enable Q&A on story\");\n-  }\n-\n-  return result.value || null;\n-}\n-\n-/**\n- * retrieveStorySections will return the sections used by stories in the\n- * database for a given Tenant sorted alphabetically.\n- *\n- * @param mongo the database connection to use to retrieve the data\n- * @param tenantID the ID of the Tenant that we're retrieving data\n- */\n-export async function retrieveStorySections(\n-  mongo: Db,\n-  tenantID: string\n-): Promise<string[]> {\n-  const results: Array<string | null> = await collection(\n-    mongo\n-  ).distinct(\"metadata.section\", { tenantID });\n-\n-  // We perform the type assertion here because we know that after filtering out\n-  // the null entries, the resulting array can not contain null.\n-  return results.filter((section) => section !== null).sort() as string[];\n-}"
    },
    {
      "sha": "d7b73e557af35d7482462f522f116820bd461c31",
      "filename": "src/core/server/models/story/story.ts",
      "status": "added",
      "additions": 683,
      "deletions": 0,
      "changes": 683,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/models/story/story.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/models/story/story.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/models/story/story.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -0,0 +1,683 @@\n+import { Db, MongoError } from \"mongodb\";\n+import { v4 as uuid } from \"uuid\";\n+\n+import { DeepPartial, FirstDeepPartial } from \"coral-common/types\";\n+import { dotize } from \"coral-common/utils/dotize\";\n+import {\n+  DuplicateStoryIDError,\n+  DuplicateStoryURLError,\n+  StoryNotFoundError,\n+} from \"coral-server/errors\";\n+import {\n+  Connection,\n+  ConnectionInput,\n+  Query,\n+  resolveConnection,\n+} from \"coral-server/models/helpers\";\n+import { GlobalModerationSettings } from \"coral-server/models/settings\";\n+import { TenantResource } from \"coral-server/models/tenant\";\n+import { stories as collection } from \"coral-server/services/mongodb/collections\";\n+\n+import {\n+  GQLSTORY_MODE,\n+  GQLStoryMetadata,\n+  GQLStorySettings,\n+} from \"coral-server/graph/schema/__generated__/types\";\n+\n+import {\n+  createEmptyRelatedCommentCounts,\n+  RelatedCommentCounts,\n+  updateRelatedCommentCounts,\n+} from \"../comment/counts\";\n+\n+export * from \"./helpers\";\n+\n+export interface StreamModeSettings {\n+  /**\n+   * mode is whether the story stream is in commenting or Q&A mode.\n+   * This will determine the appearance of the stream and how it functions.\n+   * This is an optional parameter and if unset, defaults to commenting.\n+   */\n+  mode?: GQLSTORY_MODE;\n+\n+  /**\n+   * experts are used during Q&A mode to assign users to answer questions\n+   * on a Q&A stream. It is an optional parameter and is only used when\n+   * the story stream is in Q&A mode.\n+   */\n+  expertIDs?: string[];\n+}\n+\n+export type StorySettings = StreamModeSettings &\n+  GlobalModerationSettings &\n+  Pick<GQLStorySettings, \"messageBox\" | \"mode\" | \"experts\">;\n+\n+export type StoryMetadata = GQLStoryMetadata;\n+\n+export interface Story extends TenantResource {\n+  readonly id: string;\n+\n+  /**\n+   * url is the URL to the Story page.\n+   */\n+  url: string;\n+\n+  /**\n+   * metadata stores the scraped metadata from the Story page.\n+   */\n+  metadata?: StoryMetadata;\n+\n+  /**\n+   * scrapedAt is the Time that the Story had it's metadata scraped at.\n+   */\n+  scrapedAt?: Date;\n+\n+  /**\n+   * commentCounts stores all the comment counters.\n+   */\n+  commentCounts: RelatedCommentCounts;\n+\n+  /**\n+   * settings provides a point where the settings can be overridden for a\n+   * specific Story.\n+   */\n+  settings: DeepPartial<StorySettings>;\n+\n+  /**\n+   * closedAt is the date that the Story was forced closed at, or false to\n+   * indicate that the story was re-opened.\n+   */\n+  closedAt?: Date | false;\n+\n+  /**\n+   * createdAt is the date that the Story was added to the Coral database.\n+   */\n+  createdAt: Date;\n+\n+  /**\n+   * lastCommentedAt is the last time someone commented on this story.\n+   */\n+  lastCommentedAt?: Date;\n+\n+  /**\n+   * siteID references the site the story belongs to\n+   */\n+  siteID: string;\n+}\n+\n+export interface UpsertStoryInput {\n+  id?: string;\n+  url: string;\n+  siteID: string;\n+}\n+\n+export interface UpsertStoryResult {\n+  story: Story;\n+  wasUpserted: boolean;\n+}\n+\n+export async function upsertStory(\n+  mongo: Db,\n+  tenantID: string,\n+  { id = uuid(), url, siteID }: UpsertStoryInput,\n+  now = new Date()\n+): Promise<UpsertStoryResult> {\n+  // Create the story, optionally sourcing the id from the input, additionally\n+  // porting in the tenantID.\n+  const story: Story = {\n+    id,\n+    url,\n+    tenantID,\n+    siteID,\n+    createdAt: now,\n+    commentCounts: createEmptyRelatedCommentCounts(),\n+    settings: {},\n+  };\n+\n+  try {\n+    // Perform the find and update operation to try and find and or create the\n+    // story.\n+    const result = await collection(mongo).findOneAndUpdate(\n+      {\n+        url,\n+        tenantID,\n+      },\n+      { $setOnInsert: story },\n+      {\n+        // Create the object if it doesn't already exist.\n+        upsert: true,\n+\n+        // True to return the original document instead of the updated document.\n+        // This will ensure that when an upsert operation adds a new Story, it\n+        // should return null.\n+        returnOriginal: true,\n+      }\n+    );\n+\n+    return {\n+      // The story will either be found (via `result.value`) or upserted (via\n+      // `story`).\n+      story: result.value || story,\n+\n+      // The story was upserted if the value isn't provided.\n+      wasUpserted: !result.value,\n+    };\n+  } catch (err) {\n+    // Evaluate the error, if it is in regards to violating the unique index,\n+    // then return a duplicate Story error.\n+    if (err instanceof MongoError && err.code === 11000) {\n+      throw new DuplicateStoryIDError(err, id, url);\n+    }\n+\n+    throw err;\n+  }\n+}\n+\n+export interface FindStoryInput {\n+  id?: string;\n+  url?: string;\n+}\n+\n+export async function findStory(\n+  mongo: Db,\n+  tenantID: string,\n+  { id, url }: FindStoryInput\n+) {\n+  if (id) {\n+    return retrieveStory(mongo, tenantID, id);\n+  }\n+\n+  if (url) {\n+    return retrieveStoryByURL(mongo, tenantID, url);\n+  }\n+\n+  // Story can't be found with that ID/URL combination and scraping is\n+  // disabled, so we fail here.\n+  return null;\n+}\n+\n+export interface FindOrCreateStoryInput {\n+  id?: string;\n+  url?: string;\n+}\n+\n+export interface FindOrCreateStoryResult {\n+  story: Story | null;\n+  wasUpserted: boolean;\n+}\n+\n+export async function findOrCreateStory(\n+  mongo: Db,\n+  tenantID: string,\n+  { id, url }: FindOrCreateStoryInput,\n+  siteID: string | null,\n+  now = new Date()\n+): Promise<FindOrCreateStoryResult> {\n+  if (id) {\n+    if (url && siteID) {\n+      // The URL was specified, this is an upsert operation.\n+      return upsertStory(\n+        mongo,\n+        tenantID,\n+        {\n+          id,\n+          url,\n+          siteID,\n+        },\n+        now\n+      );\n+    }\n+\n+    // The URL was not specified, this is a lookup operation.\n+    const story = await retrieveStory(mongo, tenantID, id);\n+\n+    // Return the result object.\n+    return {\n+      story,\n+      wasUpserted: false,\n+    };\n+  }\n+\n+  // The ID was not specified, this is an upsert operation. Check to see that\n+  // the URL exists.\n+  if (!url) {\n+    throw new Error(\"cannot upsert an story without the url\");\n+  }\n+\n+  if (!siteID) {\n+    throw new Error(\"cannot upsert story without site ID\");\n+  }\n+\n+  return upsertStory(mongo, tenantID, { url, siteID }, now);\n+}\n+\n+export type CreateStoryInput = Partial<\n+  Pick<Story, \"metadata\" | \"scrapedAt\" | \"closedAt\">\n+> & {\n+  siteID: string;\n+};\n+\n+export async function createStory(\n+  mongo: Db,\n+  tenantID: string,\n+  id: string,\n+  url: string,\n+  input: CreateStoryInput,\n+  now = new Date()\n+) {\n+  // Create the story.\n+  const story: Story = {\n+    ...input,\n+    id,\n+    url,\n+    tenantID,\n+    createdAt: now,\n+    commentCounts: createEmptyRelatedCommentCounts(),\n+    settings: {},\n+  };\n+\n+  try {\n+    // Insert the story into the database.\n+    await collection(mongo).insertOne(story);\n+  } catch (err) {\n+    // Evaluate the error, if it is in regards to violating the unique index,\n+    // then return a duplicate Story error.\n+    if (err instanceof MongoError && err.code === 11000) {\n+      throw new DuplicateStoryURLError(err, url, id);\n+    }\n+\n+    throw err;\n+  }\n+\n+  // Return the created story.\n+  return story;\n+}\n+\n+export async function retrieveStoryByURL(\n+  mongo: Db,\n+  tenantID: string,\n+  url: string\n+) {\n+  return collection(mongo).findOne({ url, tenantID });\n+}\n+\n+export async function retrieveStory(mongo: Db, tenantID: string, id: string) {\n+  return collection(mongo).findOne({ id, tenantID });\n+}\n+\n+export async function retrieveManyStories(\n+  mongo: Db,\n+  tenantID: string,\n+  ids: string[]\n+) {\n+  const cursor = collection(mongo).find({\n+    id: { $in: ids },\n+    tenantID,\n+  });\n+\n+  const stories = await cursor.toArray();\n+\n+  return ids.map((id) => stories.find((story) => story.id === id) || null);\n+}\n+\n+export async function retrieveManyStoriesByURL(\n+  mongo: Db,\n+  tenantID: string,\n+  urls: string[]\n+) {\n+  const cursor = collection(mongo).find({\n+    url: { $in: urls },\n+    tenantID,\n+  });\n+\n+  const stories = await cursor.toArray();\n+\n+  return urls.map((url) => stories.find((story) => story.url === url) || null);\n+}\n+\n+export type UpdateStoryInput = Omit<\n+  Partial<Story>,\n+  \"id\" | \"tenantID\" | \"closedAt\" | \"createdAt\" | \"siteID\"\n+>;\n+\n+export async function updateStory(\n+  mongo: Db,\n+  tenantID: string,\n+  id: string,\n+  input: UpdateStoryInput,\n+  now = new Date()\n+) {\n+  // Only update fields that have been updated.\n+  const update = {\n+    $set: {\n+      ...dotize(input, { embedArrays: true }),\n+      // Always update the updated at time.\n+      updatedAt: now,\n+    },\n+  };\n+\n+  try {\n+    const result = await collection(mongo).findOneAndUpdate(\n+      { id, tenantID },\n+      update,\n+      // False to return the updated document instead of the original\n+      // document.\n+      { returnOriginal: false }\n+    );\n+\n+    return result.value || null;\n+  } catch (err) {\n+    // Evaluate the error, if it is in regards to violating the unique index,\n+    // then return a duplicate Story error.\n+    if (input.url && err instanceof MongoError && err.code === 11000) {\n+      throw new DuplicateStoryURLError(err, input.url, id);\n+    }\n+\n+    throw err;\n+  }\n+}\n+export type UpdateStorySettingsInput = DeepPartial<StorySettings>;\n+\n+export async function updateStorySettings(\n+  mongo: Db,\n+  tenantID: string,\n+  id: string,\n+  input: UpdateStorySettingsInput,\n+  now = new Date()\n+) {\n+  // Only update fields that have been updated.\n+  const update = {\n+    $set: {\n+      ...dotize({ settings: input }, { embedArrays: true }),\n+      // Always update the updated at time.\n+      updatedAt: now,\n+    },\n+  };\n+\n+  const result = await collection(mongo).findOneAndUpdate(\n+    { id, tenantID },\n+    update,\n+    // False to return the updated document instead of the original\n+    // document.\n+    { returnOriginal: false }\n+  );\n+\n+  return result.value || null;\n+}\n+\n+export async function openStory(\n+  mongo: Db,\n+  tenantID: string,\n+  id: string,\n+  now = new Date()\n+) {\n+  const result = await collection(mongo).findOneAndUpdate(\n+    { id, tenantID },\n+    {\n+      $set: {\n+        closedAt: false,\n+        // Always update the updated at time.\n+        updatedAt: now,\n+      },\n+    },\n+    // False to return the updated document instead of the original\n+    // document.\n+    { returnOriginal: false }\n+  );\n+\n+  return result.value || null;\n+}\n+\n+export async function closeStory(\n+  mongo: Db,\n+  tenantID: string,\n+  id: string,\n+  now = new Date()\n+) {\n+  const result = await collection(mongo).findOneAndUpdate(\n+    { id, tenantID },\n+    {\n+      $set: {\n+        closedAt: now,\n+        // Always update the updated at time.\n+        updatedAt: now,\n+      },\n+    },\n+    // False to return the updated document instead of the original\n+    // document.\n+    { returnOriginal: false }\n+  );\n+\n+  return result.value || null;\n+}\n+\n+export async function removeStory(mongo: Db, tenantID: string, id: string) {\n+  const result = await collection(mongo).findOneAndDelete({\n+    id,\n+    tenantID,\n+  });\n+\n+  return result.value || null;\n+}\n+\n+/**\n+ * removeStories will remove the stories specified by the set of id's.\n+ */\n+export async function removeStories(\n+  mongo: Db,\n+  tenantID: string,\n+  ids: string[]\n+) {\n+  return collection(mongo).deleteMany({\n+    tenantID,\n+    id: {\n+      $in: ids,\n+    },\n+  });\n+}\n+\n+export type StoryConnectionInput = ConnectionInput<Story>;\n+\n+export async function retrieveStoryConnection(\n+  mongo: Db,\n+  tenantID: string,\n+  input: StoryConnectionInput\n+): Promise<Readonly<Connection<Readonly<Story>>>> {\n+  // Create the query.\n+  const query = new Query(collection(mongo)).where({ tenantID });\n+\n+  // If a filter is being applied, filter it as well.\n+  if (input.filter) {\n+    query.where(input.filter);\n+  }\n+\n+  return retrieveConnection(input, query);\n+}\n+\n+async function retrieveConnection(\n+  input: StoryConnectionInput,\n+  query: Query<Story>\n+): Promise<Readonly<Connection<Readonly<Story>>>> {\n+  // Apply the pagination arguments to the query.\n+  query.orderBy({ createdAt: -1 });\n+  if (input.after) {\n+    query.where({ createdAt: { $lt: input.after as Date } });\n+  }\n+\n+  // Return a connection.\n+  return resolveConnection(query, input, (story) => story.createdAt);\n+}\n+\n+export async function retrieveActiveStories(\n+  mongo: Db,\n+  tenantID: string,\n+  limit: number\n+) {\n+  const stories = await collection(mongo)\n+    .find({\n+      tenantID,\n+      // We limit this query to stories that have the following field. This\n+      // allows us to use the index.\n+      lastCommentedAt: {\n+        $exists: true,\n+      },\n+    })\n+    .sort({ lastCommentedAt: -1 })\n+    .limit(limit)\n+    .toArray();\n+\n+  return stories;\n+}\n+\n+export async function updateStoryLastCommentedAt(\n+  mongo: Db,\n+  tenantID: string,\n+  storyID: string,\n+  now: Date\n+) {\n+  await collection(mongo).updateOne(\n+    {\n+      tenantID,\n+      id: storyID,\n+    },\n+    {\n+      $set: {\n+        lastCommentedAt: now,\n+      },\n+    }\n+  );\n+}\n+\n+/**\n+ * updateStoryCounts will update the comment counts for the story indicated.\n+ *\n+ * @param mongo mongodb database handle\n+ * @param tenantID ID of the Tenant where the Story is on\n+ * @param id the ID of the Story that we are updating counts on\n+ * @param commentCounts the counts that we are updating\n+ */\n+export const updateStoryCounts = (\n+  mongo: Db,\n+  tenantID: string,\n+  id: string,\n+  commentCounts: FirstDeepPartial<RelatedCommentCounts>\n+) => updateRelatedCommentCounts(collection(mongo), tenantID, id, commentCounts);\n+\n+export async function addExpert(\n+  mongo: Db,\n+  tenantID: string,\n+  storyID: string,\n+  userID: string\n+) {\n+  const story = await collection(mongo).findOne({ tenantID, id: storyID });\n+  if (!story) {\n+    throw new StoryNotFoundError(storyID);\n+  }\n+\n+  const result = await collection(mongo).findOneAndUpdate(\n+    {\n+      tenantID,\n+      id: storyID,\n+    },\n+    {\n+      $addToSet: {\n+        \"settings.expertIDs\": userID,\n+      },\n+    },\n+    {\n+      returnOriginal: false,\n+    }\n+  );\n+\n+  if (!result.ok) {\n+    throw new Error(\"unable to add expert to story\");\n+  }\n+\n+  return result.value || null;\n+}\n+\n+export async function removeExpert(\n+  mongo: Db,\n+  tenantID: string,\n+  storyID: string,\n+  userID: string\n+) {\n+  const story = await collection(mongo).findOne({ tenantID, id: storyID });\n+  if (!story) {\n+    throw new StoryNotFoundError(storyID);\n+  }\n+\n+  const result = await collection(mongo).findOneAndUpdate(\n+    {\n+      tenantID,\n+      id: storyID,\n+    },\n+    {\n+      $pull: {\n+        \"settings.expertIDs\": userID,\n+      },\n+    },\n+    {\n+      returnOriginal: false,\n+    }\n+  );\n+\n+  if (!result.ok) {\n+    throw new Error(\"unable to remove expert from story\");\n+  }\n+\n+  return result.value || null;\n+}\n+\n+export async function setStoryMode(\n+  mongo: Db,\n+  tenantID: string,\n+  storyID: string,\n+  mode: GQLSTORY_MODE\n+) {\n+  const story = await collection(mongo).findOne({ tenantID, id: storyID });\n+  if (!story) {\n+    throw new StoryNotFoundError(storyID);\n+  }\n+\n+  const result = await collection(mongo).findOneAndUpdate(\n+    {\n+      tenantID,\n+      id: storyID,\n+    },\n+    {\n+      $set: {\n+        \"settings.mode\": mode,\n+      },\n+    },\n+    {\n+      returnOriginal: false,\n+    }\n+  );\n+\n+  if (!result.ok) {\n+    throw new Error(\"unable to enable Q&A on story\");\n+  }\n+\n+  return result.value || null;\n+}\n+\n+/**\n+ * retrieveStorySections will return the sections used by stories in the\n+ * database for a given Tenant sorted alphabetically.\n+ *\n+ * @param mongo the database connection to use to retrieve the data\n+ * @param tenantID the ID of the Tenant that we're retrieving data\n+ */\n+export async function retrieveStorySections(\n+  mongo: Db,\n+  tenantID: string\n+): Promise<string[]> {\n+  const results: Array<string | null> = await collection(\n+    mongo\n+  ).distinct(\"metadata.section\", { tenantID });\n+\n+  // We perform the type assertion here because we know that after filtering out\n+  // the null entries, the resulting array can not contain null.\n+  return results.filter((section) => section !== null).sort() as string[];\n+}"
    },
    {
      "sha": "939b65a2841450c4df539b17e96255b1efe4d935",
      "filename": "src/core/server/services/comments/pipeline/phases/tagExpertAnswers.ts",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/services/comments/pipeline/phases/tagExpertAnswers.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/services/comments/pipeline/phases/tagExpertAnswers.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/services/comments/pipeline/phases/tagExpertAnswers.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -1,4 +1,5 @@\n import { getDepth } from \"coral-server/models/comment\";\n+import { resolveStoryMode } from \"coral-server/models/story\";\n import {\n   IntermediateModerationPhase,\n   IntermediatePhaseResult,\n@@ -12,11 +13,12 @@ import {\n export const tagExpertAnswers: IntermediateModerationPhase = ({\n   author,\n   story,\n+  tenant,\n   comment,\n }): IntermediatePhaseResult | void => {\n   if (\n     // If we're in Q&A mode...\n-    story.settings.mode === GQLSTORY_MODE.QA &&\n+    resolveStoryMode(story.settings, tenant) === GQLSTORY_MODE.QA &&\n     // And we have experts for this story...\n     story.settings.expertIDs &&\n     // And the author is in expert list..."
    },
    {
      "sha": "b1d9e9202ba7da3d96727f1ef5718a5ed570f1c1",
      "filename": "src/core/server/services/comments/pipeline/phases/tagUnansweredQuestions.ts",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/services/comments/pipeline/phases/tagUnansweredQuestions.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/services/comments/pipeline/phases/tagUnansweredQuestions.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/services/comments/pipeline/phases/tagUnansweredQuestions.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -1,3 +1,4 @@\n+import { resolveStoryMode } from \"coral-server/models/story\";\n import {\n   IntermediateModerationPhase,\n   IntermediatePhaseResult,\n@@ -11,10 +12,10 @@ import {\n export const tagUnansweredQuestions: IntermediateModerationPhase = ({\n   comment,\n   story,\n-  now,\n+  tenant,\n }): IntermediatePhaseResult | void => {\n   // We only show unanswered tags in Q&A.\n-  if (story.settings.mode !== GQLSTORY_MODE.QA) {\n+  if (resolveStoryMode(story.settings, tenant) !== GQLSTORY_MODE.QA) {\n     return;\n   }\n "
    },
    {
      "sha": "08821d732cb8305149da566dbf4194bc23026275",
      "filename": "src/core/server/stacks/createComment.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/coralproject/talk/blob/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/stacks/createComment.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/302613a1857f43fdd939bf3fd2eef164c599ca16/src/core/server/stacks/createComment.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/stacks/createComment.ts?ref=302613a1857f43fdd939bf3fd2eef164c599ca16",
      "patch": "@@ -27,6 +27,7 @@ import {\n   hasPublishedStatus,\n } from \"coral-server/models/comment/helpers\";\n import {\n+  resolveStoryMode,\n   retrieveStory,\n   Story,\n   updateStoryLastCommentedAt,\n@@ -70,7 +71,7 @@ const markCommentAsAnswered = async (\n   now: Date\n ) => {\n   // We only process this if we're in Q&A mode.\n-  if (story.settings.mode !== GQLSTORY_MODE.QA) {\n+  if (resolveStoryMode(story.settings, tenant) !== GQLSTORY_MODE.QA) {\n     return;\n   }\n "
    }
  ]
}

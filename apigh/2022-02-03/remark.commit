{
  "sha": "603decabf6c44df7d331356e1f1c2d44b2239f3b",
  "node_id": "C_kwDOBtgov9oAKDYwM2RlY2FiZjZjNDRkZjdkMzMxMzU2ZTFmMWMyZDQ0YjIyMzlmM2I",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2022-01-30T21:07:05Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2022-01-31T20:28:18Z"
    },
    "message": "add QR API endpoint for Telegram auth and notifications\n\nTelegram authentication requires you to open a chat on the phone.\nIt's convenient to have a QR code for the case when you want to\nlog in on the computer but have Telegram only on your phone\nand would be able to scan the QR instead of copy-pasting the link\nfrom the computer to the phone any other way.\n\nOriginally we thought of generating QR on the client but found\nbackend-generated QR a better alternative because we avoid adding\none more JavaScript dependency to the frontend that way.",
    "tree": {
      "sha": "954344ba72e1e4725eb3c751a6dc92e7b4a9c356",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/954344ba72e1e4725eb3c751a6dc92e7b4a9c356"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/603decabf6c44df7d331356e1f1c2d44b2239f3b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/603decabf6c44df7d331356e1f1c2d44b2239f3b",
  "html_url": "https://github.com/umputun/remark42/commit/603decabf6c44df7d331356e1f1c2d44b2239f3b",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/603decabf6c44df7d331356e1f1c2d44b2239f3b/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8d42d0714fca9a15eecea0ac1a6ce1fb292bcc0f",
      "url": "https://api.github.com/repos/umputun/remark42/commits/8d42d0714fca9a15eecea0ac1a6ce1fb292bcc0f",
      "html_url": "https://github.com/umputun/remark42/commit/8d42d0714fca9a15eecea0ac1a6ce1fb292bcc0f"
    }
  ],
  "stats": {
    "total": 5918,
    "additions": 5918,
    "deletions": 0
  },
  "files": [
    {
      "sha": "c2df98dc0c1dd301eaf61a39f608fa7394fb6bea",
      "filename": "backend/_example/memory_store/go.sum",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/_example/memory_store/go.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/_example/memory_store/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/_example/memory_store/go.sum?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -278,6 +278,7 @@ github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf\n github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\n github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\n github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\n+github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e/go.mod h1:XV66xRDqSt+GTGFMVlhk3ULuV0y9ZmzeVGR4mloJI3M=\n github.com/slack-go/slack v0.10.1/go.mod h1:wWL//kk0ho+FcQXcBTmEafUI5dz4qz5f4mMk8oIkioQ=\n github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\n github.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA="
    },
    {
      "sha": "9c3309abecef1c9a9e3bbea698c3fc97e0541066",
      "filename": "backend/app/rest/api/rest.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/rest.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/rest.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/rest/api/rest.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -272,6 +272,7 @@ func (s *Rest) routes() chi.Router {\n \t\t\tropen.Use(tollbooth_chi.LimitHandler(tollbooth.NewLimiter(10, nil)))\n \t\t\tropen.Use(authMiddleware.Trace, logInfoWithBody)\n \t\t\tropen.Get(\"/picture/{user}/{id}\", s.pubRest.loadPictureCtrl)\n+\t\t\tropen.Get(\"/qr/telegram\", s.pubRest.telegramQrCtrl)\n \t\t})\n \n \t\t// protected routes, require auth"
    },
    {
      "sha": "1ce0ed4ee4924d22b8ed69d17f15e7ba3031bbb2",
      "filename": "backend/app/rest/api/rest_public.go",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/rest_public.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/rest_public.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/rest/api/rest_public.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -18,6 +18,7 @@ import (\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/pkg/errors\"\n+\t\"github.com/skip2/go-qrcode\"\n \n \t\"github.com/umputun/remark42/backend/app/rest\"\n \t\"github.com/umputun/remark42/backend/app/store\"\n@@ -364,6 +365,34 @@ func (s *public) robotsCtrl(w http.ResponseWriter, r *http.Request) {\n \trender.PlainText(w, r, \"User-agent: *\\nDisallow: /auth/\\nDisallow: /api/\\n\"+strings.Join(allowed, \"\\n\")+\"\\n\")\n }\n \n+// GET /qr/telegram - generates QR for provided URL, used for Telegram auth and notifications subscription. The first\n+// step of both is the user opening a link to Telegram and writing bot a message, and the user might try to log in\n+// from a computer but have Telegram installed only on the mobile device.\n+// Provided text should start with https://t.me/.\n+func (s *public) telegramQrCtrl(w http.ResponseWriter, r *http.Request) {\n+\ttext := r.URL.Query().Get(\"url\")\n+\tif text == \"\" {\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(\"missing parameter\"), \"text parameter is required\", rest.ErrInternal)\n+\t\treturn\n+\t}\n+\n+\tif !strings.HasPrefix(text, \"https://t.me/\") {\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(\"wrong parameter\"), \"text parameter should start with https://t.me/\", rest.ErrInternal)\n+\t\treturn\n+\t}\n+\n+\tpng, err := qrcode.Encode(text, qrcode.Medium, 256)\n+\tif err != nil {\n+\t\trest.SendErrorJSON(w, r, http.StatusInternalServerError, err, \"can't generate QR\", rest.ErrInternal)\n+\t\treturn\n+\t}\n+\n+\tw.Header().Set(\"Content-Type\", \"image/png\")\n+\tif _, err = w.Write(png); err != nil {\n+\t\tlog.Printf(\"[WARN] can't render qr, %v\", err)\n+\t}\n+}\n+\n func (s *public) applyView(comments []store.Comment, view string) []store.Comment {\n \tif strings.EqualFold(view, \"user\") {\n \t\tprojection := make([]store.Comment, 0, len(comments))"
    },
    {
      "sha": "aa7ba661be42b94335272e8c386b7fc6aaa94561",
      "filename": "backend/app/rest/api/rest_public_test.go",
      "status": "modified",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/rest_public_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/rest_public_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/rest/api/rest_public_test.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -5,6 +5,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -615,6 +616,44 @@ func TestRest_Config(t *testing.T) {\n \tassert.Equal(t, false, j[\"admin_edit\"].(bool))\n }\n \n+func TestRest_QR(t *testing.T) {\n+\tts, _, teardown := startupT(t)\n+\tdefer teardown()\n+\n+\t// missing parameter\n+\tbody, code := get(t, ts.URL+\"/api/v1/qr/telegram\")\n+\tassert.Equal(t, 400, code)\n+\tassert.Equal(t, \"{\\\"code\\\":0,\\\"details\\\":\\\"text parameter is required\\\",\\\"error\\\":\\\"missing parameter\\\"}\\n\", body)\n+\n+\t// too long request to build the qr\n+\tbody, code = get(t, ts.URL+\"/api/v1/qr/telegram?url=https://t.me/\"+strings.Repeat(\"string\", 1000))\n+\tassert.Equal(t, 500, code)\n+\tassert.Equal(t, \"{\\\"code\\\":0,\\\"details\\\":\\\"can't generate QR\\\",\\\"error\\\":\\\"content too long to encode\\\"}\\n\", body)\n+\n+\t// wrong request\n+\tbody, code = get(t, ts.URL+\"/api/v1/qr/telegram?url=nonsense\")\n+\tassert.Equal(t, 400, code)\n+\tassert.Equal(t, \"{\\\"code\\\":0,\\\"details\\\":\\\"text parameter should start with https://t.me/\\\",\\\"error\\\":\\\"wrong parameter\\\"}\\n\", body)\n+\n+\t// correct request\n+\tr, err := http.Get(ts.URL + \"/api/v1/qr/telegram?url=https://t.me/BotFather\")\n+\trequire.NoError(t, err)\n+\tbdy, err := io.ReadAll(r.Body)\n+\trequire.NoError(t, err)\n+\trequire.NoError(t, r.Body.Close())\n+\trequire.NotEmpty(t, bdy)\n+\tassert.Equal(t, \"image/png\", r.Header.Get(\"Content-Type\"))\n+\tassert.Equal(t, 200, r.StatusCode)\n+\n+\t// compare the image\n+\tfh, err := os.Open(\"testdata/qr_test.png\")\n+\tdefer func() { assert.NoError(t, fh.Close()) }()\n+\tassert.NoError(t, err)\n+\timg, err := io.ReadAll(fh)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, img, bdy)\n+}\n+\n func TestRest_Info(t *testing.T) {\n \tts, srv, teardown := startupT(t)\n \tdefer teardown()"
    },
    {
      "sha": "66bf2a0839b48f92d48460784edbebb4c1fa2d74",
      "filename": "backend/app/rest/api/testdata/qr_test.png",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/testdata/qr_test.png",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/app/rest/api/testdata/qr_test.png",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/rest/api/testdata/qr_test.png?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b"
    },
    {
      "sha": "50054e4bec51da69fdcba0d55addf1155542a506",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/go.mod?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -31,6 +31,7 @@ require (\n \tgithub.com/rakyll/statik v0.1.7\n \tgithub.com/rs/xid v1.3.0\n \tgithub.com/russross/blackfriday/v2 v2.1.0\n+\tgithub.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e\n \tgithub.com/slack-go/slack v0.10.1\n \tgithub.com/stretchr/objx v0.3.0 // indirect\n \tgithub.com/stretchr/testify v1.7.0"
    },
    {
      "sha": "14e868b6c243c59edef688dd2c215ff95821c87d",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/go.sum?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -315,6 +315,8 @@ github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQD\n github.com/sergi/go-diff v1.0.0 h1:Kpca3qRNrduNnOQeazBd0ysaKrUJiIuISHxogkT9RPQ=\n github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\n github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\n+github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e h1:MRM5ITcdelLK2j1vwZ3Je0FKVCfqOLp5zO6trqMLYs0=\n+github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e/go.mod h1:XV66xRDqSt+GTGFMVlhk3ULuV0y9ZmzeVGR4mloJI3M=\n github.com/slack-go/slack v0.10.1 h1:BGbxa0kMsGEvLOEoZmYs8T1wWfoZXwmQFBb6FgYCXUA=\n github.com/slack-go/slack v0.10.1/go.mod h1:wWL//kk0ho+FcQXcBTmEafUI5dz4qz5f4mMk8oIkioQ=\n github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc="
    },
    {
      "sha": "6fe12d37f96024352422b7551733d7cc6c98d7bf",
      "filename": "backend/remark.rest",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/remark.rest",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/remark.rest",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/remark.rest?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -150,6 +150,9 @@ X-JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZW1hcmsiLCJleHAiOjE5NzYw\n ### get config\n GET {{host}}/api/v1/config?site={{site}}\n \n+### generate a QR code for Telegram url\n+GET {{host}}/api/v1/qr/telegram?url=https://t.me/BotFather\n+\n ### deleteme (user's request). dev token for secret=12345, not admin\n POST {{host}}/api/v1/deleteme?site_id={{site}}\n X-JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJyZW1hcmsiLCJleHAiOjE5NzYwNTY3NTYsImp0aSI6IjJlOGJmMTE5OTI0MjQxMDRjYjFhZGRlODllMWYwNGFiMTg4YWZjMzQiLCJpYXQiOjE1NzYwNTY0NTYsImlzcyI6InJlbWFyazQyIiwidXNlciI6eyJuYW1lIjoiZGV2X3VzZXIiLCJpZCI6ImRldl91c2VyIiwicGljdHVyZSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9hcGkvdjEvYXZhdGFyL2NjZmEyYWJkMDE2Njc2MDViNGUxZmM0ZmNiOTFiMWUxYWYzMjMyNDAuaW1hZ2UiLCJhdHRycyI6eyJhZG1pbiI6dHJ1ZSwiYmxvY2tlZCI6ZmFsc2V9fX0.6Qt5s2enBMRC-Jmsua01yViVYI95Dx6BPBMaNjj36d4"
    },
    {
      "sha": "bc1be2bb9d639d5ca2041c79c3fb92cd18f6e6ba",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/.gitignore",
      "status": "added",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/.gitignore?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,4 @@\n+*.sw*\n+*.png\n+*.directory\n+qrcode/qrcode"
    },
    {
      "sha": "7ced8fb12ed4b2db510faca4d544ac83e4bc06d7",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/.travis.yml",
      "status": "added",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/.travis.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/.travis.yml?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,8 @@\n+language: go\n+\n+go:\n+ - 1.7\n+\n+script:\n+ - go test -v ./...\n+"
    },
    {
      "sha": "342c5e5ab6bb2c780c7fa96a0d0f092b92374252",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/LICENSE",
      "status": "added",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/LICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/LICENSE?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,19 @@\n+Copyright (c) 2014 Tom Harwood\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
    },
    {
      "sha": "0a800b727b20f4e9acbc9fe6467e822cfad67a5e",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/README.md",
      "status": "added",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/README.md",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/README.md?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,86 @@\n+# go-qrcode #\n+\n+<img src='https://skip.org/img/nyancat-youtube-qr.png' align='right'>\n+\n+Package qrcode implements a QR Code encoder. [![Build Status](https://travis-ci.org/skip2/go-qrcode.svg?branch=master)](https://travis-ci.org/skip2/go-qrcode)\n+\n+A QR Code is a matrix (two-dimensional) barcode. Arbitrary content may be encoded, with URLs being a popular choice :)\n+\n+Each QR Code contains error recovery information to aid reading damaged or obscured codes. There are four levels of error recovery: Low, medium, high and highest. QR Codes with a higher recovery level are more robust to damage, at the cost of being physically larger.\n+\n+## Install\n+\n+    go get -u github.com/skip2/go-qrcode/...\n+\n+A command-line tool `qrcode` will be built into `$GOPATH/bin/`.\n+\n+## Usage\n+\n+    import qrcode \"github.com/skip2/go-qrcode\"\n+\n+- **Create a 256x256 PNG image:**\n+\n+        var png []byte\n+        png, err := qrcode.Encode(\"https://example.org\", qrcode.Medium, 256)\n+\n+- **Create a 256x256 PNG image and write to a file:**\n+\n+        err := qrcode.WriteFile(\"https://example.org\", qrcode.Medium, 256, \"qr.png\")\n+\n+- **Create a 256x256 PNG image with custom colors and write to file:**\n+\n+        err := qrcode.WriteColorFile(\"https://example.org\", qrcode.Medium, 256, color.Black, color.White, \"qr.png\")\n+\n+All examples use the qrcode.Medium error Recovery Level and create a fixed 256x256px size QR Code. The last function creates a white on black instead of black on white QR Code.\n+\n+## Documentation\n+\n+[![godoc](https://godoc.org/github.com/skip2/go-qrcode?status.png)](https://godoc.org/github.com/skip2/go-qrcode)\n+\n+## Demoapp\n+\n+[http://go-qrcode.appspot.com](http://go-qrcode.appspot.com)\n+\n+## CLI\n+\n+A command-line tool `qrcode` will be built into `$GOPATH/bin/`.\n+\n+```\n+qrcode -- QR Code encoder in Go\n+https://github.com/skip2/go-qrcode\n+\n+Flags:\n+  -d\tdisable QR Code border\n+  -i\tinvert black and white\n+  -o string\n+    \tout PNG file prefix, empty for stdout\n+  -s int\n+    \timage size (pixel) (default 256)\n+  -t\tprint as text-art on stdout\n+\n+Usage:\n+  1. Arguments except for flags are joined by \" \" and used to generate QR code.\n+     Default output is STDOUT, pipe to imagemagick command \"display\" to display\n+     on any X server.\n+\n+       qrcode hello word | display\n+\n+  2. Save to file if \"display\" not available:\n+\n+       qrcode \"homepage: https://github.com/skip2/go-qrcode\" > out.png\n+\n+```\n+## Maximum capacity\n+The maximum capacity of a QR Code varies according to the content encoded and the error recovery level. The maximum capacity is 2,953 bytes, 4,296 alphanumeric characters, 7,089 numeric digits, or a combination of these.\n+\n+## Borderless QR Codes\n+\n+To aid QR Code reading software, QR codes have a built in whitespace border.\n+\n+If you know what you're doing, and don't want a border, see https://gist.github.com/skip2/7e3d8a82f5317df9be437f8ec8ec0b7d for how to do it. It's still recommended you include a border manually.\n+\n+## Links\n+\n+- [http://en.wikipedia.org/wiki/QR_code](http://en.wikipedia.org/wiki/QR_code)\n+- [ISO/IEC 18004:2006](http://www.iso.org/iso/catalogue_detail.htm?csnumber=43655) - Main QR Code specification (approx CHF 198,00)<br>\n+- [https://github.com/qpliu/qrencode-go/](https://github.com/qpliu/qrencode-go/) - alternative Go QR encoding library based on [ZXing](https://github.com/zxing/zxing)"
    },
    {
      "sha": "fba3bf4d18239bdb245fe3f6f0cb0a0363b698d6",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/bitset/bitset.go",
      "status": "added",
      "additions": 273,
      "deletions": 0,
      "changes": 273,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/bitset/bitset.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/bitset/bitset.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/bitset/bitset.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,273 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+// Package bitset implements an append only bit array.\n+//\n+// To create a Bitset and append some bits:\n+//\t                                  // Bitset Contents\n+//\tb := bitset.New()                 // {}\n+//\tb.AppendBools(true, true, false)  // {1, 1, 0}\n+//\tb.AppendBools(true)               // {1, 1, 0, 1}\n+//\tb.AppendValue(0x02, 4)            // {1, 1, 0, 1, 0, 0, 1, 0}\n+//\n+// To read values:\n+//\n+//\tlen := b.Len()                    // 8\n+//\tv := b.At(0)                      // 1\n+//\tv = b.At(1)                       // 1\n+//\tv = b.At(2)                       // 0\n+//\tv = b.At(8)                       // 0\n+package bitset\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+)\n+\n+const (\n+\tb0 = false\n+\tb1 = true\n+)\n+\n+// Bitset stores an array of bits.\n+type Bitset struct {\n+\t// The number of bits stored.\n+\tnumBits int\n+\n+\t// Storage for individual bits.\n+\tbits []byte\n+}\n+\n+// New returns an initialised Bitset with optional initial bits v.\n+func New(v ...bool) *Bitset {\n+\tb := &Bitset{numBits: 0, bits: make([]byte, 0)}\n+\tb.AppendBools(v...)\n+\n+\treturn b\n+}\n+\n+// Clone returns a copy.\n+func Clone(from *Bitset) *Bitset {\n+\treturn &Bitset{numBits: from.numBits, bits: from.bits[:]}\n+}\n+\n+// Substr returns a substring, consisting of the bits from indexes start to end.\n+func (b *Bitset) Substr(start int, end int) *Bitset {\n+\tif start > end || end > b.numBits {\n+\t\tlog.Panicf(\"Out of range start=%d end=%d numBits=%d\", start, end, b.numBits)\n+\t}\n+\n+\tresult := New()\n+\tresult.ensureCapacity(end - start)\n+\n+\tfor i := start; i < end; i++ {\n+\t\tif b.At(i) {\n+\t\t\tresult.bits[result.numBits/8] |= 0x80 >> uint(result.numBits%8)\n+\t\t}\n+\t\tresult.numBits++\n+\t}\n+\n+\treturn result\n+}\n+\n+// NewFromBase2String constructs and returns a Bitset from a string. The string\n+// consists of '1', '0' or ' ' characters, e.g. \"1010 0101\". The '1' and '0'\n+// characters represent true/false bits respectively, and ' ' characters are\n+// ignored.\n+//\n+// The function panics if the input string contains other characters.\n+func NewFromBase2String(b2string string) *Bitset {\n+\tb := &Bitset{numBits: 0, bits: make([]byte, 0)}\n+\n+\tfor _, c := range b2string {\n+\t\tswitch c {\n+\t\tcase '1':\n+\t\t\tb.AppendBools(true)\n+\t\tcase '0':\n+\t\t\tb.AppendBools(false)\n+\t\tcase ' ':\n+\t\tdefault:\n+\t\t\tlog.Panicf(\"Invalid char %c in NewFromBase2String\", c)\n+\t\t}\n+\t}\n+\n+\treturn b\n+}\n+\n+// AppendBytes appends a list of whole bytes.\n+func (b *Bitset) AppendBytes(data []byte) {\n+\tfor _, d := range data {\n+\t\tb.AppendByte(d, 8)\n+\t}\n+}\n+\n+// AppendByte appends the numBits least significant bits from value.\n+func (b *Bitset) AppendByte(value byte, numBits int) {\n+\tb.ensureCapacity(numBits)\n+\n+\tif numBits > 8 {\n+\t\tlog.Panicf(\"numBits %d out of range 0-8\", numBits)\n+\t}\n+\n+\tfor i := numBits - 1; i >= 0; i-- {\n+\t\tif value&(1<<uint(i)) != 0 {\n+\t\t\tb.bits[b.numBits/8] |= 0x80 >> uint(b.numBits%8)\n+\t\t}\n+\n+\t\tb.numBits++\n+\t}\n+}\n+\n+// AppendUint32 appends the numBits least significant bits from value.\n+func (b *Bitset) AppendUint32(value uint32, numBits int) {\n+\tb.ensureCapacity(numBits)\n+\n+\tif numBits > 32 {\n+\t\tlog.Panicf(\"numBits %d out of range 0-32\", numBits)\n+\t}\n+\n+\tfor i := numBits - 1; i >= 0; i-- {\n+\t\tif value&(1<<uint(i)) != 0 {\n+\t\t\tb.bits[b.numBits/8] |= 0x80 >> uint(b.numBits%8)\n+\t\t}\n+\n+\t\tb.numBits++\n+\t}\n+}\n+\n+// ensureCapacity ensures the Bitset can store an additional |numBits|.\n+//\n+// The underlying array is expanded if necessary. To prevent frequent\n+// reallocation, expanding the underlying array at least doubles its capacity.\n+func (b *Bitset) ensureCapacity(numBits int) {\n+\tnumBits += b.numBits\n+\n+\tnewNumBytes := numBits / 8\n+\tif numBits%8 != 0 {\n+\t\tnewNumBytes++\n+\t}\n+\n+\tif len(b.bits) >= newNumBytes {\n+\t\treturn\n+\t}\n+\n+\tb.bits = append(b.bits, make([]byte, newNumBytes+2*len(b.bits))...)\n+}\n+\n+// Append bits copied from |other|.\n+//\n+// The new length is b.Len() + other.Len().\n+func (b *Bitset) Append(other *Bitset) {\n+\tb.ensureCapacity(other.numBits)\n+\n+\tfor i := 0; i < other.numBits; i++ {\n+\t\tif other.At(i) {\n+\t\t\tb.bits[b.numBits/8] |= 0x80 >> uint(b.numBits%8)\n+\t\t}\n+\t\tb.numBits++\n+\t}\n+}\n+\n+// AppendBools appends bits to the Bitset.\n+func (b *Bitset) AppendBools(bits ...bool) {\n+\tb.ensureCapacity(len(bits))\n+\n+\tfor _, v := range bits {\n+\t\tif v {\n+\t\t\tb.bits[b.numBits/8] |= 0x80 >> uint(b.numBits%8)\n+\t\t}\n+\t\tb.numBits++\n+\t}\n+}\n+\n+// AppendNumBools appends num bits of value value.\n+func (b *Bitset) AppendNumBools(num int, value bool) {\n+\tfor i := 0; i < num; i++ {\n+\t\tb.AppendBools(value)\n+\t}\n+}\n+\n+// String returns a human readable representation of the Bitset's contents.\n+func (b *Bitset) String() string {\n+\tvar bitString string\n+\tfor i := 0; i < b.numBits; i++ {\n+\t\tif (i % 8) == 0 {\n+\t\t\tbitString += \" \"\n+\t\t}\n+\n+\t\tif (b.bits[i/8] & (0x80 >> byte(i%8))) != 0 {\n+\t\t\tbitString += \"1\"\n+\t\t} else {\n+\t\t\tbitString += \"0\"\n+\t\t}\n+\t}\n+\n+\treturn fmt.Sprintf(\"numBits=%d, bits=%s\", b.numBits, bitString)\n+}\n+\n+// Len returns the length of the Bitset in bits.\n+func (b *Bitset) Len() int {\n+\treturn b.numBits\n+}\n+\n+// Bits returns the contents of the Bitset.\n+func (b *Bitset) Bits() []bool {\n+\tresult := make([]bool, b.numBits)\n+\n+\tvar i int\n+\tfor i = 0; i < b.numBits; i++ {\n+\t\tresult[i] = (b.bits[i/8] & (0x80 >> byte(i%8))) != 0\n+\t}\n+\n+\treturn result\n+}\n+\n+// At returns the value of the bit at |index|.\n+func (b *Bitset) At(index int) bool {\n+\tif index >= b.numBits {\n+\t\tlog.Panicf(\"Index %d out of range\", index)\n+\t}\n+\n+\treturn (b.bits[index/8] & (0x80 >> byte(index%8))) != 0\n+}\n+\n+// Equals returns true if the Bitset equals other.\n+func (b *Bitset) Equals(other *Bitset) bool {\n+\tif b.numBits != other.numBits {\n+\t\treturn false\n+\t}\n+\n+\tif !bytes.Equal(b.bits[0:b.numBits/8], other.bits[0:b.numBits/8]) {\n+\t\treturn false\n+\t}\n+\n+\tfor i := 8 * (b.numBits / 8); i < b.numBits; i++ {\n+\t\ta := (b.bits[i/8] & (0x80 >> byte(i%8)))\n+\t\tb := (other.bits[i/8] & (0x80 >> byte(i%8)))\n+\n+\t\tif a != b {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+// ByteAt returns a byte consisting of upto 8 bits starting at index.\n+func (b *Bitset) ByteAt(index int) byte {\n+\tif index < 0 || index >= b.numBits {\n+\t\tlog.Panicf(\"Index %d out of range\", index)\n+\t}\n+\n+\tvar result byte\n+\n+\tfor i := index; i < index+8 && i < b.numBits; i++ {\n+\t\tresult <<= 1\n+\t\tif b.At(i) {\n+\t\t\tresult |= 1\n+\t\t}\n+\t}\n+\n+\treturn result\n+}"
    },
    {
      "sha": "6a809cfeb202ee54ad04d0bc61f1822d17fbba88",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/encoder.go",
      "status": "added",
      "additions": 486,
      "deletions": 0,
      "changes": 486,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/encoder.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/encoder.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/encoder.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,486 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+package qrcode\n+\n+import (\n+\t\"errors\"\n+\t\"log\"\n+\n+\tbitset \"github.com/skip2/go-qrcode/bitset\"\n+)\n+\n+// Data encoding.\n+//\n+// The main data portion of a QR Code consists of one or more segments of data.\n+// A segment consists of:\n+//\n+// - The segment Data Mode: numeric, alphanumeric, or byte.\n+// - The length of segment in bits.\n+// - Encoded data.\n+//\n+// For example, the string \"123ZZ#!#!\" may be represented as:\n+//\n+// [numeric, 3, \"123\"] [alphanumeric, 2, \"ZZ\"] [byte, 4, \"#!#!\"]\n+//\n+// Multiple data modes exist to minimise the size of encoded data. For example,\n+// 8-bit bytes require 8 bits to encode each, but base 10 numeric data can be\n+// encoded at a higher density of 3 numbers (e.g. 123) per 10 bits.\n+//\n+// Some data can be represented in multiple modes. Numeric data can be\n+// represented in all three modes, whereas alphanumeric data (e.g. 'A') can be\n+// represented in alphanumeric and byte mode.\n+//\n+// Starting a new segment (to use a different Data Mode) has a cost, the bits to\n+// state the new segment Data Mode and length. To minimise each QR Code's symbol\n+// size, an optimisation routine coalesces segment types where possible, to\n+// reduce the encoded data length.\n+//\n+// There are several other data modes available (e.g. Kanji mode) which are not\n+// implemented here.\n+\n+// A segment encoding mode.\n+type dataMode uint8\n+\n+const (\n+\t// Each dataMode is a subset of the subsequent dataMode:\n+\t// dataModeNone < dataModeNumeric < dataModeAlphanumeric < dataModeByte\n+\t//\n+\t// This ordering is important for determining which data modes a character can\n+\t// be encoded with. E.g. 'E' can be encoded in both dataModeAlphanumeric and\n+\t// dataModeByte.\n+\tdataModeNone dataMode = 1 << iota\n+\tdataModeNumeric\n+\tdataModeAlphanumeric\n+\tdataModeByte\n+)\n+\n+// dataModeString returns d as a short printable string.\n+func dataModeString(d dataMode) string {\n+\tswitch d {\n+\tcase dataModeNone:\n+\t\treturn \"none\"\n+\tcase dataModeNumeric:\n+\t\treturn \"numeric\"\n+\tcase dataModeAlphanumeric:\n+\t\treturn \"alphanumeric\"\n+\tcase dataModeByte:\n+\t\treturn \"byte\"\n+\t}\n+\n+\treturn \"unknown\"\n+}\n+\n+type dataEncoderType uint8\n+\n+const (\n+\tdataEncoderType1To9 dataEncoderType = iota\n+\tdataEncoderType10To26\n+\tdataEncoderType27To40\n+)\n+\n+// segment is a single segment of data.\n+type segment struct {\n+\t// Data Mode (e.g. numeric).\n+\tdataMode dataMode\n+\n+\t// segment data (e.g. \"abc\").\n+\tdata []byte\n+}\n+\n+// A dataEncoder encodes data for a particular QR Code version.\n+type dataEncoder struct {\n+\t// Minimum & maximum versions supported.\n+\tminVersion int\n+\tmaxVersion int\n+\n+\t// Mode indicator bit sequences.\n+\tnumericModeIndicator      *bitset.Bitset\n+\talphanumericModeIndicator *bitset.Bitset\n+\tbyteModeIndicator         *bitset.Bitset\n+\n+\t// Character count lengths.\n+\tnumNumericCharCountBits      int\n+\tnumAlphanumericCharCountBits int\n+\tnumByteCharCountBits         int\n+\n+\t// The raw input data.\n+\tdata []byte\n+\n+\t// The data classified into unoptimised segments.\n+\tactual []segment\n+\n+\t// The data classified into optimised segments.\n+\toptimised []segment\n+}\n+\n+// newDataEncoder constructs a dataEncoder.\n+func newDataEncoder(t dataEncoderType) *dataEncoder {\n+\td := &dataEncoder{}\n+\n+\tswitch t {\n+\tcase dataEncoderType1To9:\n+\t\td = &dataEncoder{\n+\t\t\tminVersion:                   1,\n+\t\t\tmaxVersion:                   9,\n+\t\t\tnumericModeIndicator:         bitset.New(b0, b0, b0, b1),\n+\t\t\talphanumericModeIndicator:    bitset.New(b0, b0, b1, b0),\n+\t\t\tbyteModeIndicator:            bitset.New(b0, b1, b0, b0),\n+\t\t\tnumNumericCharCountBits:      10,\n+\t\t\tnumAlphanumericCharCountBits: 9,\n+\t\t\tnumByteCharCountBits:         8,\n+\t\t}\n+\tcase dataEncoderType10To26:\n+\t\td = &dataEncoder{\n+\t\t\tminVersion:                   10,\n+\t\t\tmaxVersion:                   26,\n+\t\t\tnumericModeIndicator:         bitset.New(b0, b0, b0, b1),\n+\t\t\talphanumericModeIndicator:    bitset.New(b0, b0, b1, b0),\n+\t\t\tbyteModeIndicator:            bitset.New(b0, b1, b0, b0),\n+\t\t\tnumNumericCharCountBits:      12,\n+\t\t\tnumAlphanumericCharCountBits: 11,\n+\t\t\tnumByteCharCountBits:         16,\n+\t\t}\n+\tcase dataEncoderType27To40:\n+\t\td = &dataEncoder{\n+\t\t\tminVersion:                   27,\n+\t\t\tmaxVersion:                   40,\n+\t\t\tnumericModeIndicator:         bitset.New(b0, b0, b0, b1),\n+\t\t\talphanumericModeIndicator:    bitset.New(b0, b0, b1, b0),\n+\t\t\tbyteModeIndicator:            bitset.New(b0, b1, b0, b0),\n+\t\t\tnumNumericCharCountBits:      14,\n+\t\t\tnumAlphanumericCharCountBits: 13,\n+\t\t\tnumByteCharCountBits:         16,\n+\t\t}\n+\tdefault:\n+\t\tlog.Panic(\"Unknown dataEncoderType\")\n+\t}\n+\n+\treturn d\n+}\n+\n+// encode data as one or more segments and return the encoded data.\n+//\n+// The returned data does not include the terminator bit sequence.\n+func (d *dataEncoder) encode(data []byte) (*bitset.Bitset, error) {\n+\td.data = data\n+\td.actual = nil\n+\td.optimised = nil\n+\n+\tif len(data) == 0 {\n+\t\treturn nil, errors.New(\"no data to encode\")\n+\t}\n+\n+\t// Classify data into unoptimised segments.\n+\thighestRequiredMode := d.classifyDataModes()\n+\n+\t// Optimise segments.\n+\terr := d.optimiseDataModes()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Check if a single byte encoded segment would be more efficient.\n+\toptimizedLength := 0\n+\tfor _, s := range d.optimised {\n+\t\tlength, err := d.encodedLength(s.dataMode, len(s.data))\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\toptimizedLength += length\n+\t}\n+\n+\tsingleByteSegmentLength, err := d.encodedLength(highestRequiredMode, len(d.data))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif singleByteSegmentLength <= optimizedLength {\n+\t\td.optimised = []segment{segment{dataMode: highestRequiredMode, data: d.data}}\n+\t}\n+\n+\t// Encode data.\n+\tencoded := bitset.New()\n+\tfor _, s := range d.optimised {\n+\t\td.encodeDataRaw(s.data, s.dataMode, encoded)\n+\t}\n+\n+\treturn encoded, nil\n+}\n+\n+// classifyDataModes classifies the raw data into unoptimised segments.\n+// e.g. \"123ZZ#!#!\" =>\n+// [numeric, 3, \"123\"] [alphanumeric, 2, \"ZZ\"] [byte, 4, \"#!#!\"].\n+//\n+// Returns the highest data mode needed to encode the data. e.g. for a mixed\n+// numeric/alphanumeric input, the highest is alphanumeric.\n+//\n+// dataModeNone < dataModeNumeric < dataModeAlphanumeric < dataModeByte\n+func (d *dataEncoder) classifyDataModes() dataMode {\n+\tvar start int\n+\tmode := dataModeNone\n+\thighestRequiredMode := mode\n+\n+\tfor i, v := range d.data {\n+\t\tnewMode := dataModeNone\n+\t\tswitch {\n+\t\tcase v >= 0x30 && v <= 0x39:\n+\t\t\tnewMode = dataModeNumeric\n+\t\tcase v == 0x20 || v == 0x24 || v == 0x25 || v == 0x2a || v == 0x2b || v ==\n+\t\t\t0x2d || v == 0x2e || v == 0x2f || v == 0x3a || (v >= 0x41 && v <= 0x5a):\n+\t\t\tnewMode = dataModeAlphanumeric\n+\t\tdefault:\n+\t\t\tnewMode = dataModeByte\n+\t\t}\n+\n+\t\tif newMode != mode {\n+\t\t\tif i > 0 {\n+\t\t\t\td.actual = append(d.actual, segment{dataMode: mode, data: d.data[start:i]})\n+\n+\t\t\t\tstart = i\n+\t\t\t}\n+\n+\t\t\tmode = newMode\n+\t\t}\n+\n+\t\tif newMode > highestRequiredMode {\n+\t\t\thighestRequiredMode = newMode\n+\t\t}\n+\t}\n+\n+\td.actual = append(d.actual, segment{dataMode: mode, data: d.data[start:len(d.data)]})\n+\n+\treturn highestRequiredMode\n+}\n+\n+// optimiseDataModes optimises the list of segments to reduce the overall output\n+// encoded data length.\n+//\n+// The algorithm coalesces adjacent segments. segments are only coalesced when\n+// the Data Modes are compatible, and when the coalesced segment has a shorter\n+// encoded length than separate segments.\n+//\n+// Multiple segments may be coalesced. For example a string of alternating\n+// alphanumeric/numeric segments ANANANANA can be optimised to just A.\n+func (d *dataEncoder) optimiseDataModes() error {\n+\tfor i := 0; i < len(d.actual); {\n+\t\tmode := d.actual[i].dataMode\n+\t\tnumChars := len(d.actual[i].data)\n+\n+\t\tj := i + 1\n+\t\tfor j < len(d.actual) {\n+\t\t\tnextNumChars := len(d.actual[j].data)\n+\t\t\tnextMode := d.actual[j].dataMode\n+\n+\t\t\tif nextMode > mode {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tcoalescedLength, err := d.encodedLength(mode, numChars+nextNumChars)\n+\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\tseperateLength1, err := d.encodedLength(mode, numChars)\n+\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\tseperateLength2, err := d.encodedLength(nextMode, nextNumChars)\n+\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\tif coalescedLength < seperateLength1+seperateLength2 {\n+\t\t\t\tj++\n+\t\t\t\tnumChars += nextNumChars\n+\t\t\t} else {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\toptimised := segment{dataMode: mode,\n+\t\t\tdata: make([]byte, 0, numChars)}\n+\n+\t\tfor k := i; k < j; k++ {\n+\t\t\toptimised.data = append(optimised.data, d.actual[k].data...)\n+\t\t}\n+\n+\t\td.optimised = append(d.optimised, optimised)\n+\n+\t\ti = j\n+\t}\n+\n+\treturn nil\n+}\n+\n+// encodeDataRaw encodes data in dataMode. The encoded data is appended to\n+// encoded.\n+func (d *dataEncoder) encodeDataRaw(data []byte, dataMode dataMode, encoded *bitset.Bitset) {\n+\tmodeIndicator := d.modeIndicator(dataMode)\n+\tcharCountBits := d.charCountBits(dataMode)\n+\n+\t// Append mode indicator.\n+\tencoded.Append(modeIndicator)\n+\n+\t// Append character count.\n+\tencoded.AppendUint32(uint32(len(data)), charCountBits)\n+\n+\t// Append data.\n+\tswitch dataMode {\n+\tcase dataModeNumeric:\n+\t\tfor i := 0; i < len(data); i += 3 {\n+\t\t\tcharsRemaining := len(data) - i\n+\n+\t\t\tvar value uint32\n+\t\t\tbitsUsed := 1\n+\n+\t\t\tfor j := 0; j < charsRemaining && j < 3; j++ {\n+\t\t\t\tvalue *= 10\n+\t\t\t\tvalue += uint32(data[i+j] - 0x30)\n+\t\t\t\tbitsUsed += 3\n+\t\t\t}\n+\t\t\tencoded.AppendUint32(value, bitsUsed)\n+\t\t}\n+\tcase dataModeAlphanumeric:\n+\t\tfor i := 0; i < len(data); i += 2 {\n+\t\t\tcharsRemaining := len(data) - i\n+\n+\t\t\tvar value uint32\n+\t\t\tfor j := 0; j < charsRemaining && j < 2; j++ {\n+\t\t\t\tvalue *= 45\n+\t\t\t\tvalue += encodeAlphanumericCharacter(data[i+j])\n+\t\t\t}\n+\n+\t\t\tbitsUsed := 6\n+\t\t\tif charsRemaining > 1 {\n+\t\t\t\tbitsUsed = 11\n+\t\t\t}\n+\n+\t\t\tencoded.AppendUint32(value, bitsUsed)\n+\t\t}\n+\tcase dataModeByte:\n+\t\tfor _, b := range data {\n+\t\t\tencoded.AppendByte(b, 8)\n+\t\t}\n+\t}\n+}\n+\n+// modeIndicator returns the segment header bits for a segment of type dataMode.\n+func (d *dataEncoder) modeIndicator(dataMode dataMode) *bitset.Bitset {\n+\tswitch dataMode {\n+\tcase dataModeNumeric:\n+\t\treturn d.numericModeIndicator\n+\tcase dataModeAlphanumeric:\n+\t\treturn d.alphanumericModeIndicator\n+\tcase dataModeByte:\n+\t\treturn d.byteModeIndicator\n+\tdefault:\n+\t\tlog.Panic(\"Unknown data mode\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+// charCountBits returns the number of bits used to encode the length of a data\n+// segment of type dataMode.\n+func (d *dataEncoder) charCountBits(dataMode dataMode) int {\n+\tswitch dataMode {\n+\tcase dataModeNumeric:\n+\t\treturn d.numNumericCharCountBits\n+\tcase dataModeAlphanumeric:\n+\t\treturn d.numAlphanumericCharCountBits\n+\tcase dataModeByte:\n+\t\treturn d.numByteCharCountBits\n+\tdefault:\n+\t\tlog.Panic(\"Unknown data mode\")\n+\t}\n+\n+\treturn 0\n+}\n+\n+// encodedLength returns the number of bits required to encode n symbols in\n+// dataMode.\n+//\n+// The number of bits required is affected by:\n+//\t- QR code type - Mode Indicator length.\n+//\t- Data mode - number of bits used to represent data length.\n+//\t- Data mode - how the data is encoded.\n+//\t- Number of symbols encoded.\n+//\n+// An error is returned if the mode is not supported, or the length requested is\n+// too long to be represented.\n+func (d *dataEncoder) encodedLength(dataMode dataMode, n int) (int, error) {\n+\tmodeIndicator := d.modeIndicator(dataMode)\n+\tcharCountBits := d.charCountBits(dataMode)\n+\n+\tif modeIndicator == nil {\n+\t\treturn 0, errors.New(\"mode not supported\")\n+\t}\n+\n+\tmaxLength := (1 << uint8(charCountBits)) - 1\n+\n+\tif n > maxLength {\n+\t\treturn 0, errors.New(\"length too long to be represented\")\n+\t}\n+\n+\tlength := modeIndicator.Len() + charCountBits\n+\n+\tswitch dataMode {\n+\tcase dataModeNumeric:\n+\t\tlength += 10 * (n / 3)\n+\n+\t\tif n%3 != 0 {\n+\t\t\tlength += 1 + 3*(n%3)\n+\t\t}\n+\tcase dataModeAlphanumeric:\n+\t\tlength += 11 * (n / 2)\n+\t\tlength += 6 * (n % 2)\n+\tcase dataModeByte:\n+\t\tlength += 8 * n\n+\t}\n+\n+\treturn length, nil\n+}\n+\n+// encodeAlphanumericChar returns the QR Code encoded value of v.\n+//\n+// v must be a QR Code defined alphanumeric character: 0-9, A-Z, SP, $%*+-./ or\n+// :. The characters are mapped to values in the range 0-44 respectively.\n+func encodeAlphanumericCharacter(v byte) uint32 {\n+\tc := uint32(v)\n+\n+\tswitch {\n+\tcase c >= '0' && c <= '9':\n+\t\t// 0-9 encoded as 0-9.\n+\t\treturn c - '0'\n+\tcase c >= 'A' && c <= 'Z':\n+\t\t// A-Z encoded as 10-35.\n+\t\treturn c - 'A' + 10\n+\tcase c == ' ':\n+\t\treturn 36\n+\tcase c == '$':\n+\t\treturn 37\n+\tcase c == '%':\n+\t\treturn 38\n+\tcase c == '*':\n+\t\treturn 39\n+\tcase c == '+':\n+\t\treturn 40\n+\tcase c == '-':\n+\t\treturn 41\n+\tcase c == '.':\n+\t\treturn 42\n+\tcase c == '/':\n+\t\treturn 43\n+\tcase c == ':':\n+\t\treturn 44\n+\tdefault:\n+\t\tlog.Panicf(\"encodeAlphanumericCharacter() with non alphanumeric char %v.\", v)\n+\t}\n+\n+\treturn 0\n+}"
    },
    {
      "sha": "a915813d2d2a6b6a967d30d1bf771248498fe645",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/go.mod",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/go.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/go.mod?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,3 @@\n+module github.com/skip2/go-qrcode\n+\n+go 1.13"
    },
    {
      "sha": "d0541bcb9709ac3005438383d5c5189e5b2e1a2b",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/qrcode.go",
      "status": "added",
      "additions": 608,
      "deletions": 0,
      "changes": 608,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/qrcode.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/qrcode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/qrcode.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,608 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+/*\n+Package qrcode implements a QR Code encoder.\n+\n+A QR Code is a matrix (two-dimensional) barcode. Arbitrary content may be\n+encoded.\n+\n+A QR Code contains error recovery information to aid reading damaged or\n+obscured codes. There are four levels of error recovery: qrcode.{Low, Medium,\n+High, Highest}. QR Codes with a higher recovery level are more robust to damage,\n+at the cost of being physically larger.\n+\n+Three functions cover most use cases:\n+\n+- Create a PNG image:\n+\n+\tvar png []byte\n+\tpng, err := qrcode.Encode(\"https://example.org\", qrcode.Medium, 256)\n+\n+- Create a PNG image and write to a file:\n+\n+\terr := qrcode.WriteFile(\"https://example.org\", qrcode.Medium, 256, \"qr.png\")\n+\n+- Create a PNG image with custom colors and write to file:\n+\n+\terr := qrcode.WriteColorFile(\"https://example.org\", qrcode.Medium, 256, color.Black, color.White, \"qr.png\")\n+\n+All examples use the qrcode.Medium error Recovery Level and create a fixed\n+256x256px size QR Code. The last function creates a white on black instead of black\n+on white QR Code.\n+\n+To generate a variable sized image instead, specify a negative size (in place of\n+the 256 above), such as -4 or -5. Larger negative numbers create larger images:\n+A size of -5 sets each module (QR Code \"pixel\") to be 5px wide/high.\n+\n+- Create a PNG image (variable size, with minimum white padding) and write to a file:\n+\n+\terr := qrcode.WriteFile(\"https://example.org\", qrcode.Medium, -5, \"qr.png\")\n+\n+The maximum capacity of a QR Code varies according to the content encoded and\n+the error recovery level. The maximum capacity is 2,953 bytes, 4,296\n+alphanumeric characters, 7,089 numeric digits, or a combination of these.\n+\n+This package implements a subset of QR Code 2005, as defined in ISO/IEC\n+18004:2006.\n+*/\n+package qrcode\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"image\"\n+\t\"image/color\"\n+\t\"image/png\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\n+\tbitset \"github.com/skip2/go-qrcode/bitset\"\n+\treedsolomon \"github.com/skip2/go-qrcode/reedsolomon\"\n+)\n+\n+// Encode a QR Code and return a raw PNG image.\n+//\n+// size is both the image width and height in pixels. If size is too small then\n+// a larger image is silently returned. Negative values for size cause a\n+// variable sized image to be returned: See the documentation for Image().\n+//\n+// To serve over HTTP, remember to send a Content-Type: image/png header.\n+func Encode(content string, level RecoveryLevel, size int) ([]byte, error) {\n+\tvar q *QRCode\n+\n+\tq, err := New(content, level)\n+\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn q.PNG(size)\n+}\n+\n+// WriteFile encodes, then writes a QR Code to the given filename in PNG format.\n+//\n+// size is both the image width and height in pixels. If size is too small then\n+// a larger image is silently written. Negative values for size cause a variable\n+// sized image to be written: See the documentation for Image().\n+func WriteFile(content string, level RecoveryLevel, size int, filename string) error {\n+\tvar q *QRCode\n+\n+\tq, err := New(content, level)\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn q.WriteFile(size, filename)\n+}\n+\n+// WriteColorFile encodes, then writes a QR Code to the given filename in PNG format.\n+// With WriteColorFile you can also specify the colors you want to use.\n+//\n+// size is both the image width and height in pixels. If size is too small then\n+// a larger image is silently written. Negative values for size cause a variable\n+// sized image to be written: See the documentation for Image().\n+func WriteColorFile(content string, level RecoveryLevel, size int, background,\n+\tforeground color.Color, filename string) error {\n+\n+\tvar q *QRCode\n+\n+\tq, err := New(content, level)\n+\n+\tq.BackgroundColor = background\n+\tq.ForegroundColor = foreground\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn q.WriteFile(size, filename)\n+}\n+\n+// A QRCode represents a valid encoded QRCode.\n+type QRCode struct {\n+\t// Original content encoded.\n+\tContent string\n+\n+\t// QR Code type.\n+\tLevel         RecoveryLevel\n+\tVersionNumber int\n+\n+\t// User settable drawing options.\n+\tForegroundColor color.Color\n+\tBackgroundColor color.Color\n+\n+\t// Disable the QR Code border.\n+\tDisableBorder bool\n+\n+\tencoder *dataEncoder\n+\tversion qrCodeVersion\n+\n+\tdata   *bitset.Bitset\n+\tsymbol *symbol\n+\tmask   int\n+}\n+\n+// New constructs a QRCode.\n+//\n+//\tvar q *qrcode.QRCode\n+//\tq, err := qrcode.New(\"my content\", qrcode.Medium)\n+//\n+// An error occurs if the content is too long.\n+func New(content string, level RecoveryLevel) (*QRCode, error) {\n+\tencoders := []dataEncoderType{dataEncoderType1To9, dataEncoderType10To26,\n+\t\tdataEncoderType27To40}\n+\n+\tvar encoder *dataEncoder\n+\tvar encoded *bitset.Bitset\n+\tvar chosenVersion *qrCodeVersion\n+\tvar err error\n+\n+\tfor _, t := range encoders {\n+\t\tencoder = newDataEncoder(t)\n+\t\tencoded, err = encoder.encode([]byte(content))\n+\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tchosenVersion = chooseQRCodeVersion(level, encoder, encoded.Len())\n+\n+\t\tif chosenVersion != nil {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif err != nil {\n+\t\treturn nil, err\n+\t} else if chosenVersion == nil {\n+\t\treturn nil, errors.New(\"content too long to encode\")\n+\t}\n+\n+\tq := &QRCode{\n+\t\tContent: content,\n+\n+\t\tLevel:         level,\n+\t\tVersionNumber: chosenVersion.version,\n+\n+\t\tForegroundColor: color.Black,\n+\t\tBackgroundColor: color.White,\n+\n+\t\tencoder: encoder,\n+\t\tdata:    encoded,\n+\t\tversion: *chosenVersion,\n+\t}\n+\n+\treturn q, nil\n+}\n+\n+// NewWithForcedVersion constructs a QRCode of a specific version.\n+//\n+//\tvar q *qrcode.QRCode\n+//\tq, err := qrcode.NewWithForcedVersion(\"my content\", 25, qrcode.Medium)\n+//\n+// An error occurs in case of invalid version.\n+func NewWithForcedVersion(content string, version int, level RecoveryLevel) (*QRCode, error) {\n+\tvar encoder *dataEncoder\n+\n+\tswitch {\n+\tcase version >= 1 && version <= 9:\n+\t\tencoder = newDataEncoder(dataEncoderType1To9)\n+\tcase version >= 10 && version <= 26:\n+\t\tencoder = newDataEncoder(dataEncoderType10To26)\n+\tcase version >= 27 && version <= 40:\n+\t\tencoder = newDataEncoder(dataEncoderType27To40)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"Invalid version %d (expected 1-40 inclusive)\", version)\n+\t}\n+\n+\tvar encoded *bitset.Bitset\n+\tencoded, err := encoder.encode([]byte(content))\n+\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tchosenVersion := getQRCodeVersion(level, version)\n+\n+\tif chosenVersion == nil {\n+\t\treturn nil, errors.New(\"cannot find QR Code version\")\n+\t}\n+\n+\tif encoded.Len() > chosenVersion.numDataBits() {\n+\t\treturn nil, fmt.Errorf(\"Cannot encode QR code: content too large for fixed size QR Code version %d (encoded length is %d bits, maximum length is %d bits)\",\n+\t\t\tversion,\n+\t\t\tencoded.Len(),\n+\t\t\tchosenVersion.numDataBits())\n+\t}\n+\n+\tq := &QRCode{\n+\t\tContent: content,\n+\n+\t\tLevel:         level,\n+\t\tVersionNumber: chosenVersion.version,\n+\n+\t\tForegroundColor: color.Black,\n+\t\tBackgroundColor: color.White,\n+\n+\t\tencoder: encoder,\n+\t\tdata:    encoded,\n+\t\tversion: *chosenVersion,\n+\t}\n+\n+\treturn q, nil\n+}\n+\n+// Bitmap returns the QR Code as a 2D array of 1-bit pixels.\n+//\n+// bitmap[y][x] is true if the pixel at (x, y) is set.\n+//\n+// The bitmap includes the required \"quiet zone\" around the QR Code to aid\n+// decoding.\n+func (q *QRCode) Bitmap() [][]bool {\n+\t// Build QR code.\n+\tq.encode()\n+\n+\treturn q.symbol.bitmap()\n+}\n+\n+// Image returns the QR Code as an image.Image.\n+//\n+// A positive size sets a fixed image width and height (e.g. 256 yields an\n+// 256x256px image).\n+//\n+// Depending on the amount of data encoded, fixed size images can have different\n+// amounts of padding (white space around the QR Code). As an alternative, a\n+// variable sized image can be generated instead:\n+//\n+// A negative size causes a variable sized image to be returned. The image\n+// returned is the minimum size required for the QR Code. Choose a larger\n+// negative number to increase the scale of the image. e.g. a size of -5 causes\n+// each module (QR Code \"pixel\") to be 5px in size.\n+func (q *QRCode) Image(size int) image.Image {\n+\t// Build QR code.\n+\tq.encode()\n+\n+\t// Minimum pixels (both width and height) required.\n+\trealSize := q.symbol.size\n+\n+\t// Variable size support.\n+\tif size < 0 {\n+\t\tsize = size * -1 * realSize\n+\t}\n+\n+\t// Actual pixels available to draw the symbol. Automatically increase the\n+\t// image size if it's not large enough.\n+\tif size < realSize {\n+\t\tsize = realSize\n+\t}\n+\n+\t// Output image.\n+\trect := image.Rectangle{Min: image.Point{0, 0}, Max: image.Point{size, size}}\n+\n+\t// Saves a few bytes to have them in this order\n+\tp := color.Palette([]color.Color{q.BackgroundColor, q.ForegroundColor})\n+\timg := image.NewPaletted(rect, p)\n+\tfgClr := uint8(img.Palette.Index(q.ForegroundColor))\n+\n+\t// QR code bitmap.\n+\tbitmap := q.symbol.bitmap()\n+\n+\t// Map each image pixel to the nearest QR code module.\n+\tmodulesPerPixel := float64(realSize) / float64(size)\n+\tfor y := 0; y < size; y++ {\n+\t\ty2 := int(float64(y) * modulesPerPixel)\n+\t\tfor x := 0; x < size; x++ {\n+\t\t\tx2 := int(float64(x) * modulesPerPixel)\n+\n+\t\t\tv := bitmap[y2][x2]\n+\n+\t\t\tif v {\n+\t\t\t\tpos := img.PixOffset(x, y)\n+\t\t\t\timg.Pix[pos] = fgClr\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn img\n+}\n+\n+// PNG returns the QR Code as a PNG image.\n+//\n+// size is both the image width and height in pixels. If size is too small then\n+// a larger image is silently returned. Negative values for size cause a\n+// variable sized image to be returned: See the documentation for Image().\n+func (q *QRCode) PNG(size int) ([]byte, error) {\n+\timg := q.Image(size)\n+\n+\tencoder := png.Encoder{CompressionLevel: png.BestCompression}\n+\n+\tvar b bytes.Buffer\n+\terr := encoder.Encode(&b, img)\n+\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn b.Bytes(), nil\n+}\n+\n+// Write writes the QR Code as a PNG image to io.Writer.\n+//\n+// size is both the image width and height in pixels. If size is too small then\n+// a larger image is silently written. Negative values for size cause a\n+// variable sized image to be written: See the documentation for Image().\n+func (q *QRCode) Write(size int, out io.Writer) error {\n+\tvar png []byte\n+\n+\tpng, err := q.PNG(size)\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t_, err = out.Write(png)\n+\treturn err\n+}\n+\n+// WriteFile writes the QR Code as a PNG image to the specified file.\n+//\n+// size is both the image width and height in pixels. If size is too small then\n+// a larger image is silently written. Negative values for size cause a\n+// variable sized image to be written: See the documentation for Image().\n+func (q *QRCode) WriteFile(size int, filename string) error {\n+\tvar png []byte\n+\n+\tpng, err := q.PNG(size)\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn ioutil.WriteFile(filename, png, os.FileMode(0644))\n+}\n+\n+// encode completes the steps required to encode the QR Code. These include\n+// adding the terminator bits and padding, splitting the data into blocks and\n+// applying the error correction, and selecting the best data mask.\n+func (q *QRCode) encode() {\n+\tnumTerminatorBits := q.version.numTerminatorBitsRequired(q.data.Len())\n+\n+\tq.addTerminatorBits(numTerminatorBits)\n+\tq.addPadding()\n+\n+\tencoded := q.encodeBlocks()\n+\n+\tconst numMasks int = 8\n+\tpenalty := 0\n+\n+\tfor mask := 0; mask < numMasks; mask++ {\n+\t\tvar s *symbol\n+\t\tvar err error\n+\n+\t\ts, err = buildRegularSymbol(q.version, mask, encoded, !q.DisableBorder)\n+\n+\t\tif err != nil {\n+\t\t\tlog.Panic(err.Error())\n+\t\t}\n+\n+\t\tnumEmptyModules := s.numEmptyModules()\n+\t\tif numEmptyModules != 0 {\n+\t\t\tlog.Panicf(\"bug: numEmptyModules is %d (expected 0) (version=%d)\",\n+\t\t\t\tnumEmptyModules, q.VersionNumber)\n+\t\t}\n+\n+\t\tp := s.penaltyScore()\n+\n+\t\t//log.Printf(\"mask=%d p=%3d p1=%3d p2=%3d p3=%3d p4=%d\\n\", mask, p, s.penalty1(), s.penalty2(), s.penalty3(), s.penalty4())\n+\n+\t\tif q.symbol == nil || p < penalty {\n+\t\t\tq.symbol = s\n+\t\t\tq.mask = mask\n+\t\t\tpenalty = p\n+\t\t}\n+\t}\n+}\n+\n+// addTerminatorBits adds final terminator bits to the encoded data.\n+//\n+// The number of terminator bits required is determined when the QR Code version\n+// is chosen (which itself depends on the length of the data encoded). The\n+// terminator bits are thus added after the QR Code version\n+// is chosen, rather than at the data encoding stage.\n+func (q *QRCode) addTerminatorBits(numTerminatorBits int) {\n+\tq.data.AppendNumBools(numTerminatorBits, false)\n+}\n+\n+// encodeBlocks takes the completed (terminated & padded) encoded data, splits\n+// the data into blocks (as specified by the QR Code version), applies error\n+// correction to each block, then interleaves the blocks together.\n+//\n+// The QR Code's final data sequence is returned.\n+func (q *QRCode) encodeBlocks() *bitset.Bitset {\n+\t// Split into blocks.\n+\ttype dataBlock struct {\n+\t\tdata          *bitset.Bitset\n+\t\tecStartOffset int\n+\t}\n+\n+\tblock := make([]dataBlock, q.version.numBlocks())\n+\n+\tstart := 0\n+\tend := 0\n+\tblockID := 0\n+\n+\tfor _, b := range q.version.block {\n+\t\tfor j := 0; j < b.numBlocks; j++ {\n+\t\t\tstart = end\n+\t\t\tend = start + b.numDataCodewords*8\n+\n+\t\t\t// Apply error correction to each block.\n+\t\t\tnumErrorCodewords := b.numCodewords - b.numDataCodewords\n+\t\t\tblock[blockID].data = reedsolomon.Encode(q.data.Substr(start, end), numErrorCodewords)\n+\t\t\tblock[blockID].ecStartOffset = end - start\n+\n+\t\t\tblockID++\n+\t\t}\n+\t}\n+\n+\t// Interleave the blocks.\n+\n+\tresult := bitset.New()\n+\n+\t// Combine data blocks.\n+\tworking := true\n+\tfor i := 0; working; i += 8 {\n+\t\tworking = false\n+\n+\t\tfor j, b := range block {\n+\t\t\tif i >= block[j].ecStartOffset {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tresult.Append(b.data.Substr(i, i+8))\n+\n+\t\t\tworking = true\n+\t\t}\n+\t}\n+\n+\t// Combine error correction blocks.\n+\tworking = true\n+\tfor i := 0; working; i += 8 {\n+\t\tworking = false\n+\n+\t\tfor j, b := range block {\n+\t\t\toffset := i + block[j].ecStartOffset\n+\t\t\tif offset >= block[j].data.Len() {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tresult.Append(b.data.Substr(offset, offset+8))\n+\n+\t\t\tworking = true\n+\t\t}\n+\t}\n+\n+\t// Append remainder bits.\n+\tresult.AppendNumBools(q.version.numRemainderBits, false)\n+\n+\treturn result\n+}\n+\n+// max returns the maximum of a and b.\n+func max(a int, b int) int {\n+\tif a > b {\n+\t\treturn a\n+\t}\n+\n+\treturn b\n+}\n+\n+// addPadding pads the encoded data upto the full length required.\n+func (q *QRCode) addPadding() {\n+\tnumDataBits := q.version.numDataBits()\n+\n+\tif q.data.Len() == numDataBits {\n+\t\treturn\n+\t}\n+\n+\t// Pad to the nearest codeword boundary.\n+\tq.data.AppendNumBools(q.version.numBitsToPadToCodeword(q.data.Len()), false)\n+\n+\t// Pad codewords 0b11101100 and 0b00010001.\n+\tpadding := [2]*bitset.Bitset{\n+\t\tbitset.New(true, true, true, false, true, true, false, false),\n+\t\tbitset.New(false, false, false, true, false, false, false, true),\n+\t}\n+\n+\t// Insert pad codewords alternately.\n+\ti := 0\n+\tfor numDataBits-q.data.Len() >= 8 {\n+\t\tq.data.Append(padding[i])\n+\n+\t\ti = 1 - i // Alternate between 0 and 1.\n+\t}\n+\n+\tif q.data.Len() != numDataBits {\n+\t\tlog.Panicf(\"BUG: got len %d, expected %d\", q.data.Len(), numDataBits)\n+\t}\n+}\n+\n+// ToString produces a multi-line string that forms a QR-code image.\n+func (q *QRCode) ToString(inverseColor bool) string {\n+\tbits := q.Bitmap()\n+\tvar buf bytes.Buffer\n+\tfor y := range bits {\n+\t\tfor x := range bits[y] {\n+\t\t\tif bits[y][x] != inverseColor {\n+\t\t\t\tbuf.WriteString(\"  \")\n+\t\t\t} else {\n+\t\t\t\tbuf.WriteString(\"██\")\n+\t\t\t}\n+\t\t}\n+\t\tbuf.WriteString(\"\\n\")\n+\t}\n+\treturn buf.String()\n+}\n+\n+// ToSmallString produces a multi-line string that forms a QR-code image, a\n+// factor two smaller in x and y then ToString.\n+func (q *QRCode) ToSmallString(inverseColor bool) string {\n+\tbits := q.Bitmap()\n+\tvar buf bytes.Buffer\n+\t// if there is an odd number of rows, the last one needs special treatment\n+\tfor y := 0; y < len(bits)-1; y += 2 {\n+\t\tfor x := range bits[y] {\n+\t\t\tif bits[y][x] == bits[y+1][x] {\n+\t\t\t\tif bits[y][x] != inverseColor {\n+\t\t\t\t\tbuf.WriteString(\" \")\n+\t\t\t\t} else {\n+\t\t\t\t\tbuf.WriteString(\"█\")\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif bits[y][x] != inverseColor {\n+\t\t\t\t\tbuf.WriteString(\"▄\")\n+\t\t\t\t} else {\n+\t\t\t\t\tbuf.WriteString(\"▀\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tbuf.WriteString(\"\\n\")\n+\t}\n+\t// special treatment for the last row if odd\n+\tif len(bits)%2 == 1 {\n+\t\ty := len(bits) - 1\n+\t\tfor x := range bits[y] {\n+\t\t\tif bits[y][x] != inverseColor {\n+\t\t\t\tbuf.WriteString(\" \")\n+\t\t\t} else {\n+\t\t\t\tbuf.WriteString(\"▀\")\n+\t\t\t}\n+\t\t}\n+\t\tbuf.WriteString(\"\\n\")\n+\t}\n+\treturn buf.String()\n+}"
    },
    {
      "sha": "6a7003f7d96ef7ab3f3b64ff1365491d611d0ed7",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf2_8.go",
      "status": "added",
      "additions": 387,
      "deletions": 0,
      "changes": 387,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf2_8.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf2_8.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf2_8.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,387 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+package reedsolomon\n+\n+// Addition, subtraction, multiplication, and division in GF(2^8).\n+// Operations are performed modulo x^8 + x^4 + x^3 + x^2 + 1.\n+\n+// http://en.wikipedia.org/wiki/Finite_field_arithmetic\n+\n+import \"log\"\n+\n+const (\n+\tgfZero = gfElement(0)\n+\tgfOne  = gfElement(1)\n+)\n+\n+var (\n+\tgfExpTable = [256]gfElement{\n+\t\t/*   0 -   9 */ 1, 2, 4, 8, 16, 32, 64, 128, 29, 58,\n+\t\t/*  10 -  19 */ 116, 232, 205, 135, 19, 38, 76, 152, 45, 90,\n+\t\t/*  20 -  29 */ 180, 117, 234, 201, 143, 3, 6, 12, 24, 48,\n+\t\t/*  30 -  39 */ 96, 192, 157, 39, 78, 156, 37, 74, 148, 53,\n+\t\t/*  40 -  49 */ 106, 212, 181, 119, 238, 193, 159, 35, 70, 140,\n+\t\t/*  50 -  59 */ 5, 10, 20, 40, 80, 160, 93, 186, 105, 210,\n+\t\t/*  60 -  69 */ 185, 111, 222, 161, 95, 190, 97, 194, 153, 47,\n+\t\t/*  70 -  79 */ 94, 188, 101, 202, 137, 15, 30, 60, 120, 240,\n+\t\t/*  80 -  89 */ 253, 231, 211, 187, 107, 214, 177, 127, 254, 225,\n+\t\t/*  90 -  99 */ 223, 163, 91, 182, 113, 226, 217, 175, 67, 134,\n+\t\t/* 100 - 109 */ 17, 34, 68, 136, 13, 26, 52, 104, 208, 189,\n+\t\t/* 110 - 119 */ 103, 206, 129, 31, 62, 124, 248, 237, 199, 147,\n+\t\t/* 120 - 129 */ 59, 118, 236, 197, 151, 51, 102, 204, 133, 23,\n+\t\t/* 130 - 139 */ 46, 92, 184, 109, 218, 169, 79, 158, 33, 66,\n+\t\t/* 140 - 149 */ 132, 21, 42, 84, 168, 77, 154, 41, 82, 164,\n+\t\t/* 150 - 159 */ 85, 170, 73, 146, 57, 114, 228, 213, 183, 115,\n+\t\t/* 160 - 169 */ 230, 209, 191, 99, 198, 145, 63, 126, 252, 229,\n+\t\t/* 170 - 179 */ 215, 179, 123, 246, 241, 255, 227, 219, 171, 75,\n+\t\t/* 180 - 189 */ 150, 49, 98, 196, 149, 55, 110, 220, 165, 87,\n+\t\t/* 190 - 199 */ 174, 65, 130, 25, 50, 100, 200, 141, 7, 14,\n+\t\t/* 200 - 209 */ 28, 56, 112, 224, 221, 167, 83, 166, 81, 162,\n+\t\t/* 210 - 219 */ 89, 178, 121, 242, 249, 239, 195, 155, 43, 86,\n+\t\t/* 220 - 229 */ 172, 69, 138, 9, 18, 36, 72, 144, 61, 122,\n+\t\t/* 230 - 239 */ 244, 245, 247, 243, 251, 235, 203, 139, 11, 22,\n+\t\t/* 240 - 249 */ 44, 88, 176, 125, 250, 233, 207, 131, 27, 54,\n+\t\t/* 250 - 255 */ 108, 216, 173, 71, 142, 1}\n+\n+\tgfLogTable = [256]int{\n+\t\t/*   0 -   9 */ -1, 0, 1, 25, 2, 50, 26, 198, 3, 223,\n+\t\t/*  10 -  19 */ 51, 238, 27, 104, 199, 75, 4, 100, 224, 14,\n+\t\t/*  20 -  29 */ 52, 141, 239, 129, 28, 193, 105, 248, 200, 8,\n+\t\t/*  30 -  39 */ 76, 113, 5, 138, 101, 47, 225, 36, 15, 33,\n+\t\t/*  40 -  49 */ 53, 147, 142, 218, 240, 18, 130, 69, 29, 181,\n+\t\t/*  50 -  59 */ 194, 125, 106, 39, 249, 185, 201, 154, 9, 120,\n+\t\t/*  60 -  69 */ 77, 228, 114, 166, 6, 191, 139, 98, 102, 221,\n+\t\t/*  70 -  79 */ 48, 253, 226, 152, 37, 179, 16, 145, 34, 136,\n+\t\t/*  80 -  89 */ 54, 208, 148, 206, 143, 150, 219, 189, 241, 210,\n+\t\t/*  90 -  99 */ 19, 92, 131, 56, 70, 64, 30, 66, 182, 163,\n+\t\t/* 100 - 109 */ 195, 72, 126, 110, 107, 58, 40, 84, 250, 133,\n+\t\t/* 110 - 119 */ 186, 61, 202, 94, 155, 159, 10, 21, 121, 43,\n+\t\t/* 120 - 129 */ 78, 212, 229, 172, 115, 243, 167, 87, 7, 112,\n+\t\t/* 130 - 139 */ 192, 247, 140, 128, 99, 13, 103, 74, 222, 237,\n+\t\t/* 140 - 149 */ 49, 197, 254, 24, 227, 165, 153, 119, 38, 184,\n+\t\t/* 150 - 159 */ 180, 124, 17, 68, 146, 217, 35, 32, 137, 46,\n+\t\t/* 160 - 169 */ 55, 63, 209, 91, 149, 188, 207, 205, 144, 135,\n+\t\t/* 170 - 179 */ 151, 178, 220, 252, 190, 97, 242, 86, 211, 171,\n+\t\t/* 180 - 189 */ 20, 42, 93, 158, 132, 60, 57, 83, 71, 109,\n+\t\t/* 190 - 199 */ 65, 162, 31, 45, 67, 216, 183, 123, 164, 118,\n+\t\t/* 200 - 209 */ 196, 23, 73, 236, 127, 12, 111, 246, 108, 161,\n+\t\t/* 210 - 219 */ 59, 82, 41, 157, 85, 170, 251, 96, 134, 177,\n+\t\t/* 220 - 229 */ 187, 204, 62, 90, 203, 89, 95, 176, 156, 169,\n+\t\t/* 230 - 239 */ 160, 81, 11, 245, 22, 235, 122, 117, 44, 215,\n+\t\t/* 240 - 249 */ 79, 174, 213, 233, 230, 231, 173, 232, 116, 214,\n+\t\t/* 250 - 255 */ 244, 234, 168, 80, 88, 175}\n+)\n+\n+// gfElement is an element in GF(2^8).\n+type gfElement uint8\n+\n+// newGFElement creates and returns a new gfElement.\n+func newGFElement(data byte) gfElement {\n+\treturn gfElement(data)\n+}\n+\n+// gfAdd returns a + b.\n+func gfAdd(a, b gfElement) gfElement {\n+\treturn a ^ b\n+}\n+\n+// gfSub returns a - b.\n+//\n+// Note addition is equivalent to subtraction in GF(2).\n+func gfSub(a, b gfElement) gfElement {\n+\treturn a ^ b\n+}\n+\n+// gfMultiply returns a * b.\n+func gfMultiply(a, b gfElement) gfElement {\n+\tif a == gfZero || b == gfZero {\n+\t\treturn gfZero\n+\t}\n+\n+\treturn gfExpTable[(gfLogTable[a]+gfLogTable[b])%255]\n+}\n+\n+// gfDivide returns a / b.\n+//\n+// Divide by zero results in a panic.\n+func gfDivide(a, b gfElement) gfElement {\n+\tif a == gfZero {\n+\t\treturn gfZero\n+\t} else if b == gfZero {\n+\t\tlog.Panicln(\"Divide by zero\")\n+\t}\n+\n+\treturn gfMultiply(a, gfInverse(b))\n+}\n+\n+// gfInverse returns the multiplicative inverse of a, a^-1.\n+//\n+// a * a^-1 = 1\n+func gfInverse(a gfElement) gfElement {\n+\tif a == gfZero {\n+\t\tlog.Panicln(\"No multiplicative inverse of 0\")\n+\t}\n+\n+\treturn gfExpTable[255-gfLogTable[a]]\n+}\n+\n+// a^i   | bits      | polynomial                                   | decimal\n+// --------------------------------------------------------------------------\n+// 0     | 000000000 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 0\n+// a^0   | 000000001 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 1\n+// a^1   | 000000010 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 2\n+// a^2   | 000000100 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 4\n+// a^3   | 000001000 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 8\n+// a^4   | 000010000 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 16\n+// a^5   | 000100000 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 32\n+// a^6   | 001000000 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 64\n+// a^7   | 010000000 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 128\n+// a^8   | 000011101 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 29\n+// a^9   | 000111010 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 58\n+// a^10  | 001110100 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 116\n+// a^11  | 011101000 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 232\n+// a^12  | 011001101 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 205\n+// a^13  | 010000111 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 135\n+// a^14  | 000010011 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 19\n+// a^15  | 000100110 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 38\n+// a^16  | 001001100 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 76\n+// a^17  | 010011000 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 152\n+// a^18  | 000101101 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 45\n+// a^19  | 001011010 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 90\n+// a^20  | 010110100 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 180\n+// a^21  | 001110101 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 117\n+// a^22  | 011101010 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 234\n+// a^23  | 011001001 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 201\n+// a^24  | 010001111 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 143\n+// a^25  | 000000011 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 3\n+// a^26  | 000000110 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 6\n+// a^27  | 000001100 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 12\n+// a^28  | 000011000 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 24\n+// a^29  | 000110000 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 48\n+// a^30  | 001100000 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 96\n+// a^31  | 011000000 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 192\n+// a^32  | 010011101 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 157\n+// a^33  | 000100111 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 39\n+// a^34  | 001001110 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 78\n+// a^35  | 010011100 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 156\n+// a^36  | 000100101 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 37\n+// a^37  | 001001010 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 74\n+// a^38  | 010010100 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 148\n+// a^39  | 000110101 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 53\n+// a^40  | 001101010 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 106\n+// a^41  | 011010100 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 212\n+// a^42  | 010110101 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 181\n+// a^43  | 001110111 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 119\n+// a^44  | 011101110 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 238\n+// a^45  | 011000001 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 193\n+// a^46  | 010011111 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 159\n+// a^47  | 000100011 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 35\n+// a^48  | 001000110 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 70\n+// a^49  | 010001100 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 140\n+// a^50  | 000000101 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 5\n+// a^51  | 000001010 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 10\n+// a^52  | 000010100 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 20\n+// a^53  | 000101000 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 40\n+// a^54  | 001010000 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 80\n+// a^55  | 010100000 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 160\n+// a^56  | 001011101 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 93\n+// a^57  | 010111010 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 186\n+// a^58  | 001101001 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 105\n+// a^59  | 011010010 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 210\n+// a^60  | 010111001 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 185\n+// a^61  | 001101111 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 111\n+// a^62  | 011011110 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 222\n+// a^63  | 010100001 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 161\n+// a^64  | 001011111 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 95\n+// a^65  | 010111110 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 190\n+// a^66  | 001100001 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 97\n+// a^67  | 011000010 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 194\n+// a^68  | 010011001 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 153\n+// a^69  | 000101111 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 47\n+// a^70  | 001011110 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 94\n+// a^71  | 010111100 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 188\n+// a^72  | 001100101 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 101\n+// a^73  | 011001010 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 202\n+// a^74  | 010001001 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 137\n+// a^75  | 000001111 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 15\n+// a^76  | 000011110 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 30\n+// a^77  | 000111100 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 60\n+// a^78  | 001111000 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 120\n+// a^79  | 011110000 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 240\n+// a^80  | 011111101 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 253\n+// a^81  | 011100111 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 231\n+// a^82  | 011010011 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 211\n+// a^83  | 010111011 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 187\n+// a^84  | 001101011 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 107\n+// a^85  | 011010110 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 214\n+// a^86  | 010110001 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 177\n+// a^87  | 001111111 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 127\n+// a^88  | 011111110 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 254\n+// a^89  | 011100001 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 225\n+// a^90  | 011011111 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 223\n+// a^91  | 010100011 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 163\n+// a^92  | 001011011 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 91\n+// a^93  | 010110110 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 182\n+// a^94  | 001110001 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 113\n+// a^95  | 011100010 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 226\n+// a^96  | 011011001 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 217\n+// a^97  | 010101111 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 175\n+// a^98  | 001000011 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 67\n+// a^99  | 010000110 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 134\n+// a^100 | 000010001 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 17\n+// a^101 | 000100010 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 34\n+// a^102 | 001000100 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 68\n+// a^103 | 010001000 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 136\n+// a^104 | 000001101 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 13\n+// a^105 | 000011010 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 26\n+// a^106 | 000110100 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 52\n+// a^107 | 001101000 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 104\n+// a^108 | 011010000 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 208\n+// a^109 | 010111101 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 189\n+// a^110 | 001100111 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 103\n+// a^111 | 011001110 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 206\n+// a^112 | 010000001 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 129\n+// a^113 | 000011111 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 31\n+// a^114 | 000111110 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 62\n+// a^115 | 001111100 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 124\n+// a^116 | 011111000 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 248\n+// a^117 | 011101101 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 237\n+// a^118 | 011000111 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 199\n+// a^119 | 010010011 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 147\n+// a^120 | 000111011 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 59\n+// a^121 | 001110110 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 118\n+// a^122 | 011101100 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 236\n+// a^123 | 011000101 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 197\n+// a^124 | 010010111 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 151\n+// a^125 | 000110011 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 51\n+// a^126 | 001100110 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 102\n+// a^127 | 011001100 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 204\n+// a^128 | 010000101 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 133\n+// a^129 | 000010111 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 23\n+// a^130 | 000101110 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 46\n+// a^131 | 001011100 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 92\n+// a^132 | 010111000 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 184\n+// a^133 | 001101101 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 109\n+// a^134 | 011011010 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 218\n+// a^135 | 010101001 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 169\n+// a^136 | 001001111 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 79\n+// a^137 | 010011110 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 158\n+// a^138 | 000100001 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 33\n+// a^139 | 001000010 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 66\n+// a^140 | 010000100 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 132\n+// a^141 | 000010101 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 21\n+// a^142 | 000101010 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 42\n+// a^143 | 001010100 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 84\n+// a^144 | 010101000 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 168\n+// a^145 | 001001101 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 77\n+// a^146 | 010011010 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 154\n+// a^147 | 000101001 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 41\n+// a^148 | 001010010 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 82\n+// a^149 | 010100100 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 164\n+// a^150 | 001010101 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 85\n+// a^151 | 010101010 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 170\n+// a^152 | 001001001 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 73\n+// a^153 | 010010010 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 146\n+// a^154 | 000111001 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 57\n+// a^155 | 001110010 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 114\n+// a^156 | 011100100 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 228\n+// a^157 | 011010101 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 213\n+// a^158 | 010110111 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 183\n+// a^159 | 001110011 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 115\n+// a^160 | 011100110 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 230\n+// a^161 | 011010001 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 209\n+// a^162 | 010111111 | 0x^8 1x^7 0x^6 1x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 191\n+// a^163 | 001100011 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 99\n+// a^164 | 011000110 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 198\n+// a^165 | 010010001 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 145\n+// a^166 | 000111111 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 63\n+// a^167 | 001111110 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 1x^2 1x^1 0x^0 | 126\n+// a^168 | 011111100 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 252\n+// a^169 | 011100101 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 229\n+// a^170 | 011010111 | 0x^8 1x^7 1x^6 0x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 215\n+// a^171 | 010110011 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 179\n+// a^172 | 001111011 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 123\n+// a^173 | 011110110 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 246\n+// a^174 | 011110001 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 241\n+// a^175 | 011111111 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 1x^2 1x^1 1x^0 | 255\n+// a^176 | 011100011 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 227\n+// a^177 | 011011011 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 219\n+// a^178 | 010101011 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 171\n+// a^179 | 001001011 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 75\n+// a^180 | 010010110 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 150\n+// a^181 | 000110001 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 49\n+// a^182 | 001100010 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 98\n+// a^183 | 011000100 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 196\n+// a^184 | 010010101 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 149\n+// a^185 | 000110111 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 55\n+// a^186 | 001101110 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 110\n+// a^187 | 011011100 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 220\n+// a^188 | 010100101 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 165\n+// a^189 | 001010111 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 87\n+// a^190 | 010101110 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 174\n+// a^191 | 001000001 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 65\n+// a^192 | 010000010 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 130\n+// a^193 | 000011001 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 25\n+// a^194 | 000110010 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 50\n+// a^195 | 001100100 | 0x^8 0x^7 1x^6 1x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 100\n+// a^196 | 011001000 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 200\n+// a^197 | 010001101 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 141\n+// a^198 | 000000111 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 7\n+// a^199 | 000001110 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 14\n+// a^200 | 000011100 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 1x^2 0x^1 0x^0 | 28\n+// a^201 | 000111000 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 56\n+// a^202 | 001110000 | 0x^8 0x^7 1x^6 1x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 112\n+// a^203 | 011100000 | 0x^8 1x^7 1x^6 1x^5 0x^4 0x^3 0x^2 0x^1 0x^0 | 224\n+// a^204 | 011011101 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 221\n+// a^205 | 010100111 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 167\n+// a^206 | 001010011 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 83\n+// a^207 | 010100110 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 1x^2 1x^1 0x^0 | 166\n+// a^208 | 001010001 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 0x^2 0x^1 1x^0 | 81\n+// a^209 | 010100010 | 0x^8 1x^7 0x^6 1x^5 0x^4 0x^3 0x^2 1x^1 0x^0 | 162\n+// a^210 | 001011001 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 89\n+// a^211 | 010110010 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 178\n+// a^212 | 001111001 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 121\n+// a^213 | 011110010 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 242\n+// a^214 | 011111001 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 0x^2 0x^1 1x^0 | 249\n+// a^215 | 011101111 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 239\n+// a^216 | 011000011 | 0x^8 1x^7 1x^6 0x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 195\n+// a^217 | 010011011 | 0x^8 1x^7 0x^6 0x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 155\n+// a^218 | 000101011 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 43\n+// a^219 | 001010110 | 0x^8 0x^7 1x^6 0x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 86\n+// a^220 | 010101100 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 172\n+// a^221 | 001000101 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 1x^2 0x^1 1x^0 | 69\n+// a^222 | 010001010 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 0x^2 1x^1 0x^0 | 138\n+// a^223 | 000001001 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 9\n+// a^224 | 000010010 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 0x^2 1x^1 0x^0 | 18\n+// a^225 | 000100100 | 0x^8 0x^7 0x^6 1x^5 0x^4 0x^3 1x^2 0x^1 0x^0 | 36\n+// a^226 | 001001000 | 0x^8 0x^7 1x^6 0x^5 0x^4 1x^3 0x^2 0x^1 0x^0 | 72\n+// a^227 | 010010000 | 0x^8 1x^7 0x^6 0x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 144\n+// a^228 | 000111101 | 0x^8 0x^7 0x^6 1x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 61\n+// a^229 | 001111010 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 122\n+// a^230 | 011110100 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 1x^2 0x^1 0x^0 | 244\n+// a^231 | 011110101 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 1x^2 0x^1 1x^0 | 245\n+// a^232 | 011110111 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 1x^2 1x^1 1x^0 | 247\n+// a^233 | 011110011 | 0x^8 1x^7 1x^6 1x^5 1x^4 0x^3 0x^2 1x^1 1x^0 | 243\n+// a^234 | 011111011 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 251\n+// a^235 | 011101011 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 235\n+// a^236 | 011001011 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 203\n+// a^237 | 010001011 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 139\n+// a^238 | 000001011 | 0x^8 0x^7 0x^6 0x^5 0x^4 1x^3 0x^2 1x^1 1x^0 | 11\n+// a^239 | 000010110 | 0x^8 0x^7 0x^6 0x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 22\n+// a^240 | 000101100 | 0x^8 0x^7 0x^6 1x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 44\n+// a^241 | 001011000 | 0x^8 0x^7 1x^6 0x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 88\n+// a^242 | 010110000 | 0x^8 1x^7 0x^6 1x^5 1x^4 0x^3 0x^2 0x^1 0x^0 | 176\n+// a^243 | 001111101 | 0x^8 0x^7 1x^6 1x^5 1x^4 1x^3 1x^2 0x^1 1x^0 | 125\n+// a^244 | 011111010 | 0x^8 1x^7 1x^6 1x^5 1x^4 1x^3 0x^2 1x^1 0x^0 | 250\n+// a^245 | 011101001 | 0x^8 1x^7 1x^6 1x^5 0x^4 1x^3 0x^2 0x^1 1x^0 | 233\n+// a^246 | 011001111 | 0x^8 1x^7 1x^6 0x^5 0x^4 1x^3 1x^2 1x^1 1x^0 | 207\n+// a^247 | 010000011 | 0x^8 1x^7 0x^6 0x^5 0x^4 0x^3 0x^2 1x^1 1x^0 | 131\n+// a^248 | 000011011 | 0x^8 0x^7 0x^6 0x^5 1x^4 1x^3 0x^2 1x^1 1x^0 | 27\n+// a^249 | 000110110 | 0x^8 0x^7 0x^6 1x^5 1x^4 0x^3 1x^2 1x^1 0x^0 | 54\n+// a^250 | 001101100 | 0x^8 0x^7 1x^6 1x^5 0x^4 1x^3 1x^2 0x^1 0x^0 | 108\n+// a^251 | 011011000 | 0x^8 1x^7 1x^6 0x^5 1x^4 1x^3 0x^2 0x^1 0x^0 | 216\n+// a^252 | 010101101 | 0x^8 1x^7 0x^6 1x^5 0x^4 1x^3 1x^2 0x^1 1x^0 | 173\n+// a^253 | 001000111 | 0x^8 0x^7 1x^6 0x^5 0x^4 0x^3 1x^2 1x^1 1x^0 | 71\n+// a^254 | 010001110 | 0x^8 1x^7 0x^6 0x^5 0x^4 1x^3 1x^2 1x^1 0x^0 | 142\n+// a^255 | 000000001 | 0x^8 0x^7 0x^6 0x^5 0x^4 0x^3 0x^2 0x^1 1x^0 | 1"
    },
    {
      "sha": "962f545468a2b8ae1304c3fffee756a03b2be914",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf_poly.go",
      "status": "added",
      "additions": 216,
      "deletions": 0,
      "changes": 216,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf_poly.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf_poly.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/gf_poly.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,216 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+package reedsolomon\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\n+\tbitset \"github.com/skip2/go-qrcode/bitset\"\n+)\n+\n+// gfPoly is a polynomial over GF(2^8).\n+type gfPoly struct {\n+\t// The ith value is the coefficient of the ith degree of x.\n+\t// term[0]*(x^0) + term[1]*(x^1) + term[2]*(x^2) ...\n+\tterm []gfElement\n+}\n+\n+// newGFPolyFromData returns |data| as a polynomial over GF(2^8).\n+//\n+// Each data byte becomes the coefficient of an x term.\n+//\n+// For an n byte input the polynomial is:\n+// data[n-1]*(x^n-1) + data[n-2]*(x^n-2) ... + data[0]*(x^0).\n+func newGFPolyFromData(data *bitset.Bitset) gfPoly {\n+\tnumTotalBytes := data.Len() / 8\n+\tif data.Len()%8 != 0 {\n+\t\tnumTotalBytes++\n+\t}\n+\n+\tresult := gfPoly{term: make([]gfElement, numTotalBytes)}\n+\n+\ti := numTotalBytes - 1\n+\tfor j := 0; j < data.Len(); j += 8 {\n+\t\tresult.term[i] = gfElement(data.ByteAt(j))\n+\t\ti--\n+\t}\n+\n+\treturn result\n+}\n+\n+// newGFPolyMonomial returns term*(x^degree).\n+func newGFPolyMonomial(term gfElement, degree int) gfPoly {\n+\tif term == gfZero {\n+\t\treturn gfPoly{}\n+\t}\n+\n+\tresult := gfPoly{term: make([]gfElement, degree+1)}\n+\tresult.term[degree] = term\n+\n+\treturn result\n+}\n+\n+func (e gfPoly) data(numTerms int) []byte {\n+\tresult := make([]byte, numTerms)\n+\n+\ti := numTerms - len(e.term)\n+\tfor j := len(e.term) - 1; j >= 0; j-- {\n+\t\tresult[i] = byte(e.term[j])\n+\t\ti++\n+\t}\n+\n+\treturn result\n+}\n+\n+// numTerms returns the number of\n+func (e gfPoly) numTerms() int {\n+\treturn len(e.term)\n+}\n+\n+// gfPolyMultiply returns a * b.\n+func gfPolyMultiply(a, b gfPoly) gfPoly {\n+\tnumATerms := a.numTerms()\n+\tnumBTerms := b.numTerms()\n+\n+\tresult := gfPoly{term: make([]gfElement, numATerms+numBTerms)}\n+\n+\tfor i := 0; i < numATerms; i++ {\n+\t\tfor j := 0; j < numBTerms; j++ {\n+\t\t\tif a.term[i] != 0 && b.term[j] != 0 {\n+\t\t\t\tmonomial := gfPoly{term: make([]gfElement, i+j+1)}\n+\t\t\t\tmonomial.term[i+j] = gfMultiply(a.term[i], b.term[j])\n+\n+\t\t\t\tresult = gfPolyAdd(result, monomial)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn result.normalised()\n+}\n+\n+// gfPolyRemainder return the remainder of numerator / denominator.\n+func gfPolyRemainder(numerator, denominator gfPoly) gfPoly {\n+\tif denominator.equals(gfPoly{}) {\n+\t\tlog.Panicln(\"Remainder by zero\")\n+\t}\n+\n+\tremainder := numerator\n+\n+\tfor remainder.numTerms() >= denominator.numTerms() {\n+\t\tdegree := remainder.numTerms() - denominator.numTerms()\n+\t\tcoefficient := gfDivide(remainder.term[remainder.numTerms()-1],\n+\t\t\tdenominator.term[denominator.numTerms()-1])\n+\n+\t\tdivisor := gfPolyMultiply(denominator,\n+\t\t\tnewGFPolyMonomial(coefficient, degree))\n+\n+\t\tremainder = gfPolyAdd(remainder, divisor)\n+\t}\n+\n+\treturn remainder.normalised()\n+}\n+\n+// gfPolyAdd returns a + b.\n+func gfPolyAdd(a, b gfPoly) gfPoly {\n+\tnumATerms := a.numTerms()\n+\tnumBTerms := b.numTerms()\n+\n+\tnumTerms := numATerms\n+\tif numBTerms > numTerms {\n+\t\tnumTerms = numBTerms\n+\t}\n+\n+\tresult := gfPoly{term: make([]gfElement, numTerms)}\n+\n+\tfor i := 0; i < numTerms; i++ {\n+\t\tswitch {\n+\t\tcase numATerms > i && numBTerms > i:\n+\t\t\tresult.term[i] = gfAdd(a.term[i], b.term[i])\n+\t\tcase numATerms > i:\n+\t\t\tresult.term[i] = a.term[i]\n+\t\tdefault:\n+\t\t\tresult.term[i] = b.term[i]\n+\t\t}\n+\t}\n+\n+\treturn result.normalised()\n+}\n+\n+func (e gfPoly) normalised() gfPoly {\n+\tnumTerms := e.numTerms()\n+\tmaxNonzeroTerm := numTerms - 1\n+\n+\tfor i := numTerms - 1; i >= 0; i-- {\n+\t\tif e.term[i] != 0 {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tmaxNonzeroTerm = i - 1\n+\t}\n+\n+\tif maxNonzeroTerm < 0 {\n+\t\treturn gfPoly{}\n+\t} else if maxNonzeroTerm < numTerms-1 {\n+\t\te.term = e.term[0 : maxNonzeroTerm+1]\n+\t}\n+\n+\treturn e\n+}\n+\n+func (e gfPoly) string(useIndexForm bool) string {\n+\tvar str string\n+\tnumTerms := e.numTerms()\n+\n+\tfor i := numTerms - 1; i >= 0; i-- {\n+\t\tif e.term[i] > 0 {\n+\t\t\tif len(str) > 0 {\n+\t\t\t\tstr += \" + \"\n+\t\t\t}\n+\n+\t\t\tif !useIndexForm {\n+\t\t\t\tstr += fmt.Sprintf(\"%dx^%d\", e.term[i], i)\n+\t\t\t} else {\n+\t\t\t\tstr += fmt.Sprintf(\"a^%dx^%d\", gfLogTable[e.term[i]], i)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif len(str) == 0 {\n+\t\tstr = \"0\"\n+\t}\n+\n+\treturn str\n+}\n+\n+// equals returns true if e == other.\n+func (e gfPoly) equals(other gfPoly) bool {\n+\tvar minecPoly *gfPoly\n+\tvar maxecPoly *gfPoly\n+\n+\tif e.numTerms() > other.numTerms() {\n+\t\tminecPoly = &other\n+\t\tmaxecPoly = &e\n+\t} else {\n+\t\tminecPoly = &e\n+\t\tmaxecPoly = &other\n+\t}\n+\n+\tnumMinTerms := minecPoly.numTerms()\n+\tnumMaxTerms := maxecPoly.numTerms()\n+\n+\tfor i := 0; i < numMinTerms; i++ {\n+\t\tif e.term[i] != other.term[i] {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tfor i := numMinTerms; i < numMaxTerms; i++ {\n+\t\tif maxecPoly.term[i] != 0 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\treturn true\n+}"
    },
    {
      "sha": "561697b4b4755e3cd99da3da0e3406843d17c169",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/reedsolomon/reed_solomon.go",
      "status": "added",
      "additions": 73,
      "deletions": 0,
      "changes": 73,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/reed_solomon.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/reed_solomon.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/reedsolomon/reed_solomon.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,73 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+// Package reedsolomon provides error correction encoding for QR Code 2005.\n+//\n+// QR Code 2005 uses a Reed-Solomon error correcting code to detect and correct\n+// errors encountered during decoding.\n+//\n+// The generated RS codes are systematic, and consist of the input data with\n+// error correction bytes appended.\n+package reedsolomon\n+\n+import (\n+\t\"log\"\n+\n+\tbitset \"github.com/skip2/go-qrcode/bitset\"\n+)\n+\n+// Encode data for QR Code 2005 using the appropriate Reed-Solomon code.\n+//\n+// numECBytes is the number of error correction bytes to append, and is\n+// determined by the target QR Code's version and error correction level.\n+//\n+// ISO/IEC 18004 table 9 specifies the numECBytes required. e.g. a 1-L code has\n+// numECBytes=7.\n+func Encode(data *bitset.Bitset, numECBytes int) *bitset.Bitset {\n+\t// Create a polynomial representing |data|.\n+\t//\n+\t// The bytes are interpreted as the sequence of coefficients of a polynomial.\n+\t// The last byte's value becomes the x^0 coefficient, the second to last\n+\t// becomes the x^1 coefficient and so on.\n+\tecpoly := newGFPolyFromData(data)\n+\tecpoly = gfPolyMultiply(ecpoly, newGFPolyMonomial(gfOne, numECBytes))\n+\n+\t// Pick the generator polynomial.\n+\tgenerator := rsGeneratorPoly(numECBytes)\n+\n+\t// Generate the error correction bytes.\n+\tremainder := gfPolyRemainder(ecpoly, generator)\n+\n+\t// Combine the data & error correcting bytes.\n+\t// The mathematically correct answer is:\n+\t//\n+\t//\tresult := gfPolyAdd(ecpoly, remainder).\n+\t//\n+\t// The encoding used by QR Code 2005 is slightly different this result: To\n+\t// preserve the original |data| bit sequence exactly, the data and remainder\n+\t// are combined manually below. This ensures any most significant zero bits\n+\t// are preserved (and not optimised away).\n+\tresult := bitset.Clone(data)\n+\tresult.AppendBytes(remainder.data(numECBytes))\n+\n+\treturn result\n+}\n+\n+// rsGeneratorPoly returns the Reed-Solomon generator polynomial with |degree|.\n+//\n+// The generator polynomial is calculated as:\n+// (x + a^0)(x + a^1)...(x + a^degree-1)\n+func rsGeneratorPoly(degree int) gfPoly {\n+\tif degree < 2 {\n+\t\tlog.Panic(\"degree < 2\")\n+\t}\n+\n+\tgenerator := gfPoly{term: []gfElement{1}}\n+\n+\tfor i := 0; i < degree; i++ {\n+\t\tnextPoly := gfPoly{term: []gfElement{gfExpTable[i], 1}}\n+\t\tgenerator = gfPolyMultiply(generator, nextPoly)\n+\t}\n+\n+\treturn generator\n+}"
    },
    {
      "sha": "51eb148d2d5857d738569466ed9222577567166d",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/regular_symbol.go",
      "status": "added",
      "additions": 315,
      "deletions": 0,
      "changes": 315,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/regular_symbol.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/regular_symbol.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/regular_symbol.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,315 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+package qrcode\n+\n+import (\n+\tbitset \"github.com/skip2/go-qrcode/bitset\"\n+)\n+\n+type regularSymbol struct {\n+\tversion qrCodeVersion\n+\tmask    int\n+\n+\tdata *bitset.Bitset\n+\n+\tsymbol *symbol\n+\tsize   int\n+}\n+\n+// Abbreviated true/false.\n+const (\n+\tb0 = false\n+\tb1 = true\n+)\n+\n+var (\n+\talignmentPatternCenter = [][]int{\n+\t\t{}, // Version 0 doesn't exist.\n+\t\t{}, // Version 1 doesn't use alignment patterns.\n+\t\t{6, 18},\n+\t\t{6, 22},\n+\t\t{6, 26},\n+\t\t{6, 30},\n+\t\t{6, 34},\n+\t\t{6, 22, 38},\n+\t\t{6, 24, 42},\n+\t\t{6, 26, 46},\n+\t\t{6, 28, 50},\n+\t\t{6, 30, 54},\n+\t\t{6, 32, 58},\n+\t\t{6, 34, 62},\n+\t\t{6, 26, 46, 66},\n+\t\t{6, 26, 48, 70},\n+\t\t{6, 26, 50, 74},\n+\t\t{6, 30, 54, 78},\n+\t\t{6, 30, 56, 82},\n+\t\t{6, 30, 58, 86},\n+\t\t{6, 34, 62, 90},\n+\t\t{6, 28, 50, 72, 94},\n+\t\t{6, 26, 50, 74, 98},\n+\t\t{6, 30, 54, 78, 102},\n+\t\t{6, 28, 54, 80, 106},\n+\t\t{6, 32, 58, 84, 110},\n+\t\t{6, 30, 58, 86, 114},\n+\t\t{6, 34, 62, 90, 118},\n+\t\t{6, 26, 50, 74, 98, 122},\n+\t\t{6, 30, 54, 78, 102, 126},\n+\t\t{6, 26, 52, 78, 104, 130},\n+\t\t{6, 30, 56, 82, 108, 134},\n+\t\t{6, 34, 60, 86, 112, 138},\n+\t\t{6, 30, 58, 86, 114, 142},\n+\t\t{6, 34, 62, 90, 118, 146},\n+\t\t{6, 30, 54, 78, 102, 126, 150},\n+\t\t{6, 24, 50, 76, 102, 128, 154},\n+\t\t{6, 28, 54, 80, 106, 132, 158},\n+\t\t{6, 32, 58, 84, 110, 136, 162},\n+\t\t{6, 26, 54, 82, 110, 138, 166},\n+\t\t{6, 30, 58, 86, 114, 142, 170},\n+\t}\n+\n+\tfinderPattern = [][]bool{\n+\t\t{b1, b1, b1, b1, b1, b1, b1},\n+\t\t{b1, b0, b0, b0, b0, b0, b1},\n+\t\t{b1, b0, b1, b1, b1, b0, b1},\n+\t\t{b1, b0, b1, b1, b1, b0, b1},\n+\t\t{b1, b0, b1, b1, b1, b0, b1},\n+\t\t{b1, b0, b0, b0, b0, b0, b1},\n+\t\t{b1, b1, b1, b1, b1, b1, b1},\n+\t}\n+\n+\tfinderPatternSize = 7\n+\n+\tfinderPatternHorizontalBorder = [][]bool{\n+\t\t{b0, b0, b0, b0, b0, b0, b0, b0},\n+\t}\n+\n+\tfinderPatternVerticalBorder = [][]bool{\n+\t\t{b0},\n+\t\t{b0},\n+\t\t{b0},\n+\t\t{b0},\n+\t\t{b0},\n+\t\t{b0},\n+\t\t{b0},\n+\t\t{b0},\n+\t}\n+\n+\talignmentPattern = [][]bool{\n+\t\t{b1, b1, b1, b1, b1},\n+\t\t{b1, b0, b0, b0, b1},\n+\t\t{b1, b0, b1, b0, b1},\n+\t\t{b1, b0, b0, b0, b1},\n+\t\t{b1, b1, b1, b1, b1},\n+\t}\n+)\n+\n+func buildRegularSymbol(version qrCodeVersion, mask int,\n+\tdata *bitset.Bitset, includeQuietZone bool) (*symbol, error) {\n+\n+\tquietZoneSize := 0\n+\tif includeQuietZone {\n+\t\tquietZoneSize = version.quietZoneSize()\n+\t}\n+\n+\tm := &regularSymbol{\n+\t\tversion: version,\n+\t\tmask:    mask,\n+\t\tdata:    data,\n+\n+\t\tsymbol: newSymbol(version.symbolSize(), quietZoneSize),\n+\t\tsize:   version.symbolSize(),\n+\t}\n+\n+\tm.addFinderPatterns()\n+\tm.addAlignmentPatterns()\n+\tm.addTimingPatterns()\n+\tm.addFormatInfo()\n+\tm.addVersionInfo()\n+\n+\tok, err := m.addData()\n+\tif !ok {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn m.symbol, nil\n+}\n+\n+func (m *regularSymbol) addFinderPatterns() {\n+\tfpSize := finderPatternSize\n+\tfp := finderPattern\n+\tfpHBorder := finderPatternHorizontalBorder\n+\tfpVBorder := finderPatternVerticalBorder\n+\n+\t// Top left Finder Pattern.\n+\tm.symbol.set2dPattern(0, 0, fp)\n+\tm.symbol.set2dPattern(0, fpSize, fpHBorder)\n+\tm.symbol.set2dPattern(fpSize, 0, fpVBorder)\n+\n+\t// Top right Finder Pattern.\n+\tm.symbol.set2dPattern(m.size-fpSize, 0, fp)\n+\tm.symbol.set2dPattern(m.size-fpSize-1, fpSize, fpHBorder)\n+\tm.symbol.set2dPattern(m.size-fpSize-1, 0, fpVBorder)\n+\n+\t// Bottom left Finder Pattern.\n+\tm.symbol.set2dPattern(0, m.size-fpSize, fp)\n+\tm.symbol.set2dPattern(0, m.size-fpSize-1, fpHBorder)\n+\tm.symbol.set2dPattern(fpSize, m.size-fpSize-1, fpVBorder)\n+}\n+\n+func (m *regularSymbol) addAlignmentPatterns() {\n+\tfor _, x := range alignmentPatternCenter[m.version.version] {\n+\t\tfor _, y := range alignmentPatternCenter[m.version.version] {\n+\t\t\tif !m.symbol.empty(x, y) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tm.symbol.set2dPattern(x-2, y-2, alignmentPattern)\n+\t\t}\n+\t}\n+}\n+\n+func (m *regularSymbol) addTimingPatterns() {\n+\tvalue := true\n+\n+\tfor i := finderPatternSize + 1; i < m.size-finderPatternSize; i++ {\n+\t\tm.symbol.set(i, finderPatternSize-1, value)\n+\t\tm.symbol.set(finderPatternSize-1, i, value)\n+\n+\t\tvalue = !value\n+\t}\n+}\n+\n+func (m *regularSymbol) addFormatInfo() {\n+\tfpSize := finderPatternSize\n+\tl := formatInfoLengthBits - 1\n+\n+\tf := m.version.formatInfo(m.mask)\n+\n+\t// Bits 0-7, under the top right finder pattern.\n+\tfor i := 0; i <= 7; i++ {\n+\t\tm.symbol.set(m.size-i-1, fpSize+1, f.At(l-i))\n+\t}\n+\n+\t// Bits 0-5, right of the top left finder pattern.\n+\tfor i := 0; i <= 5; i++ {\n+\t\tm.symbol.set(fpSize+1, i, f.At(l-i))\n+\t}\n+\n+\t// Bits 6-8 on the corner of the top left finder pattern.\n+\tm.symbol.set(fpSize+1, fpSize, f.At(l-6))\n+\tm.symbol.set(fpSize+1, fpSize+1, f.At(l-7))\n+\tm.symbol.set(fpSize, fpSize+1, f.At(l-8))\n+\n+\t// Bits 9-14 on the underside of the top left finder pattern.\n+\tfor i := 9; i <= 14; i++ {\n+\t\tm.symbol.set(14-i, fpSize+1, f.At(l-i))\n+\t}\n+\n+\t// Bits 8-14 on the right side of the bottom left finder pattern.\n+\tfor i := 8; i <= 14; i++ {\n+\t\tm.symbol.set(fpSize+1, m.size-fpSize+i-8, f.At(l-i))\n+\t}\n+\n+\t// Always dark symbol.\n+\tm.symbol.set(fpSize+1, m.size-fpSize-1, true)\n+}\n+\n+func (m *regularSymbol) addVersionInfo() {\n+\tfpSize := finderPatternSize\n+\n+\tv := m.version.versionInfo()\n+\tl := versionInfoLengthBits - 1\n+\n+\tif v == nil {\n+\t\treturn\n+\t}\n+\n+\tfor i := 0; i < v.Len(); i++ {\n+\t\t// Above the bottom left finder pattern.\n+\t\tm.symbol.set(i/3, m.size-fpSize-4+i%3, v.At(l-i))\n+\n+\t\t// Left of the top right finder pattern.\n+\t\tm.symbol.set(m.size-fpSize-4+i%3, i/3, v.At(l-i))\n+\t}\n+}\n+\n+type direction uint8\n+\n+const (\n+\tup direction = iota\n+\tdown\n+)\n+\n+func (m *regularSymbol) addData() (bool, error) {\n+\txOffset := 1\n+\tdir := up\n+\n+\tx := m.size - 2\n+\ty := m.size - 1\n+\n+\tfor i := 0; i < m.data.Len(); i++ {\n+\t\tvar mask bool\n+\t\tswitch m.mask {\n+\t\tcase 0:\n+\t\t\tmask = (y+x+xOffset)%2 == 0\n+\t\tcase 1:\n+\t\t\tmask = y%2 == 0\n+\t\tcase 2:\n+\t\t\tmask = (x+xOffset)%3 == 0\n+\t\tcase 3:\n+\t\t\tmask = (y+x+xOffset)%3 == 0\n+\t\tcase 4:\n+\t\t\tmask = (y/2+(x+xOffset)/3)%2 == 0\n+\t\tcase 5:\n+\t\t\tmask = (y*(x+xOffset))%2+(y*(x+xOffset))%3 == 0\n+\t\tcase 6:\n+\t\t\tmask = ((y*(x+xOffset))%2+((y*(x+xOffset))%3))%2 == 0\n+\t\tcase 7:\n+\t\t\tmask = ((y+x+xOffset)%2+((y*(x+xOffset))%3))%2 == 0\n+\t\t}\n+\n+\t\t// != is equivalent to XOR.\n+\t\tm.symbol.set(x+xOffset, y, mask != m.data.At(i))\n+\n+\t\tif i == m.data.Len()-1 {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\t// Find next free bit in the symbol.\n+\t\tfor {\n+\t\t\tif xOffset == 1 {\n+\t\t\t\txOffset = 0\n+\t\t\t} else {\n+\t\t\t\txOffset = 1\n+\n+\t\t\t\tif dir == up {\n+\t\t\t\t\tif y > 0 {\n+\t\t\t\t\t\ty--\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdir = down\n+\t\t\t\t\t\tx -= 2\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif y < m.size-1 {\n+\t\t\t\t\t\ty++\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tdir = up\n+\t\t\t\t\t\tx -= 2\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Skip over the vertical timing pattern entirely.\n+\t\t\tif x == 5 {\n+\t\t\t\tx--\n+\t\t\t}\n+\n+\t\t\tif m.symbol.empty(x+xOffset, y) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn true, nil\n+}"
    },
    {
      "sha": "0cb1327c8ac0a9a0dd3c1f4aae4e66d687b0dfb9",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/symbol.go",
      "status": "added",
      "additions": 309,
      "deletions": 0,
      "changes": 309,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/symbol.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/symbol.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/symbol.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -0,0 +1,309 @@\n+// go-qrcode\n+// Copyright 2014 Tom Harwood\n+\n+package qrcode\n+\n+// symbol is a 2D array of bits representing a QR Code symbol.\n+//\n+// A symbol consists of size*size modules, with each module normally drawn as a\n+// black or white square. The symbol also has a border of quietZoneSize modules.\n+//\n+// A (fictional) size=2, quietZoneSize=1 QR Code looks like:\n+//\n+// +----+\n+// |    |\n+// | ab |\n+// | cd |\n+// |    |\n+// +----+\n+//\n+// For ease of implementation, the functions to set/get bits ignore the border,\n+// so (0,0)=a, (0,1)=b, (1,0)=c, and (1,1)=d. The entire symbol (including the\n+// border) is returned by bitmap().\n+//\n+type symbol struct {\n+\t// Value of module at [y][x]. True is set.\n+\tmodule [][]bool\n+\n+\t// True if the module at [y][x] is used (to either true or false).\n+\t// Used to identify unused modules.\n+\tisUsed [][]bool\n+\n+\t// Combined width/height of the symbol and quiet zones.\n+\t//\n+\t// size = symbolSize + 2*quietZoneSize.\n+\tsize int\n+\n+\t// Width/height of the symbol only.\n+\tsymbolSize int\n+\n+\t// Width/height of a single quiet zone.\n+\tquietZoneSize int\n+}\n+\n+// newSymbol constructs a symbol of size size*size, with a border of\n+// quietZoneSize.\n+func newSymbol(size int, quietZoneSize int) *symbol {\n+\tvar m symbol\n+\n+\tm.module = make([][]bool, size+2*quietZoneSize)\n+\tm.isUsed = make([][]bool, size+2*quietZoneSize)\n+\n+\tfor i := range m.module {\n+\t\tm.module[i] = make([]bool, size+2*quietZoneSize)\n+\t\tm.isUsed[i] = make([]bool, size+2*quietZoneSize)\n+\t}\n+\n+\tm.size = size + 2*quietZoneSize\n+\tm.symbolSize = size\n+\tm.quietZoneSize = quietZoneSize\n+\n+\treturn &m\n+}\n+\n+// get returns the module value at (x, y).\n+func (m *symbol) get(x int, y int) (v bool) {\n+\tv = m.module[y+m.quietZoneSize][x+m.quietZoneSize]\n+\treturn\n+}\n+\n+// empty returns true if the module at (x, y) has not been set (to either true\n+// or false).\n+func (m *symbol) empty(x int, y int) bool {\n+\treturn !m.isUsed[y+m.quietZoneSize][x+m.quietZoneSize]\n+}\n+\n+// numEmptyModules returns the number of empty modules.\n+//\n+// Initially numEmptyModules is symbolSize * symbolSize. After every module has\n+// been set (to either true or false), the number of empty modules is zero.\n+func (m *symbol) numEmptyModules() int {\n+\tvar count int\n+\tfor y := 0; y < m.symbolSize; y++ {\n+\t\tfor x := 0; x < m.symbolSize; x++ {\n+\t\t\tif !m.isUsed[y+m.quietZoneSize][x+m.quietZoneSize] {\n+\t\t\t\tcount++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn count\n+}\n+\n+// set sets the module at (x, y) to v.\n+func (m *symbol) set(x int, y int, v bool) {\n+\tm.module[y+m.quietZoneSize][x+m.quietZoneSize] = v\n+\tm.isUsed[y+m.quietZoneSize][x+m.quietZoneSize] = true\n+}\n+\n+// set2dPattern sets a 2D array of modules, starting at (x, y).\n+func (m *symbol) set2dPattern(x int, y int, v [][]bool) {\n+\tfor j, row := range v {\n+\t\tfor i, value := range row {\n+\t\t\tm.set(x+i, y+j, value)\n+\t\t}\n+\t}\n+}\n+\n+// bitmap returns the entire symbol, including the quiet zone.\n+func (m *symbol) bitmap() [][]bool {\n+\tmodule := make([][]bool, len(m.module))\n+\n+\tfor i := range m.module {\n+\t\tmodule[i] = m.module[i][:]\n+\t}\n+\n+\treturn module\n+}\n+\n+// string returns a pictorial representation of the symbol, suitable for\n+// printing in a TTY.\n+func (m *symbol) string() string {\n+\tvar result string\n+\n+\tfor _, row := range m.module {\n+\t\tfor _, value := range row {\n+\t\t\tswitch value {\n+\t\t\tcase true:\n+\t\t\t\tresult += \"  \"\n+\t\t\tcase false:\n+\t\t\t\t// Unicode 'FULL BLOCK' (U+2588).\n+\t\t\t\tresult += \"██\"\n+\t\t\t}\n+\t\t}\n+\t\tresult += \"\\n\"\n+\t}\n+\n+\treturn result\n+}\n+\n+// Constants used to weight penalty calculations. Specified by ISO/IEC\n+// 18004:2006.\n+const (\n+\tpenaltyWeight1 = 3\n+\tpenaltyWeight2 = 3\n+\tpenaltyWeight3 = 40\n+\tpenaltyWeight4 = 10\n+)\n+\n+// penaltyScore returns the penalty score of the symbol. The penalty score\n+// consists of the sum of the four individual penalty types.\n+func (m *symbol) penaltyScore() int {\n+\treturn m.penalty1() + m.penalty2() + m.penalty3() + m.penalty4()\n+}\n+\n+// penalty1 returns the penalty score for \"adjacent modules in row/column with\n+// same colour\".\n+//\n+// The numbers of adjacent matching modules and scores are:\n+// 0-5: score = 0\n+// 6+ : score = penaltyWeight1 + (numAdjacentModules - 5)\n+func (m *symbol) penalty1() int {\n+\tpenalty := 0\n+\n+\tfor x := 0; x < m.symbolSize; x++ {\n+\t\tlastValue := m.get(x, 0)\n+\t\tcount := 1\n+\n+\t\tfor y := 1; y < m.symbolSize; y++ {\n+\t\t\tv := m.get(x, y)\n+\n+\t\t\tif v != lastValue {\n+\t\t\t\tcount = 1\n+\t\t\t\tlastValue = v\n+\t\t\t} else {\n+\t\t\t\tcount++\n+\t\t\t\tif count == 6 {\n+\t\t\t\t\tpenalty += penaltyWeight1 + 1\n+\t\t\t\t} else if count > 6 {\n+\t\t\t\t\tpenalty++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor y := 0; y < m.symbolSize; y++ {\n+\t\tlastValue := m.get(0, y)\n+\t\tcount := 1\n+\n+\t\tfor x := 1; x < m.symbolSize; x++ {\n+\t\t\tv := m.get(x, y)\n+\n+\t\t\tif v != lastValue {\n+\t\t\t\tcount = 1\n+\t\t\t\tlastValue = v\n+\t\t\t} else {\n+\t\t\t\tcount++\n+\t\t\t\tif count == 6 {\n+\t\t\t\t\tpenalty += penaltyWeight1 + 1\n+\t\t\t\t} else if count > 6 {\n+\t\t\t\t\tpenalty++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn penalty\n+}\n+\n+// penalty2 returns the penalty score for \"block of modules in the same colour\".\n+//\n+// m*n: score = penaltyWeight2 * (m-1) * (n-1).\n+func (m *symbol) penalty2() int {\n+\tpenalty := 0\n+\n+\tfor y := 1; y < m.symbolSize; y++ {\n+\t\tfor x := 1; x < m.symbolSize; x++ {\n+\t\t\ttopLeft := m.get(x-1, y-1)\n+\t\t\tabove := m.get(x, y-1)\n+\t\t\tleft := m.get(x-1, y)\n+\t\t\tcurrent := m.get(x, y)\n+\n+\t\t\tif current == left && current == above && current == topLeft {\n+\t\t\t\tpenalty++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn penalty * penaltyWeight2\n+}\n+\n+// penalty3 returns the penalty score for \"1:1:3:1:1 ratio\n+// (dark:light:dark:light:dark) pattern in row/column, preceded or followed by\n+// light area 4 modules wide\".\n+//\n+// Existence of the pattern scores penaltyWeight3.\n+func (m *symbol) penalty3() int {\n+\tpenalty := 0\n+\n+\tfor y := 0; y < m.symbolSize; y++ {\n+\t\tvar bitBuffer int16 = 0x00\n+\n+\t\tfor x := 0; x < m.symbolSize; x++ {\n+\t\t\tbitBuffer <<= 1\n+\t\t\tif v := m.get(x, y); v {\n+\t\t\t\tbitBuffer |= 1\n+\t\t\t}\n+\n+\t\t\tswitch bitBuffer & 0x7ff {\n+\t\t\t// 0b000 0101 1101 or 0b10111010000\n+\t\t\t// 0x05d           or 0x5d0\n+\t\t\tcase 0x05d, 0x5d0:\n+\t\t\t\tpenalty += penaltyWeight3\n+\t\t\t\tbitBuffer = 0xFF\n+\t\t\tdefault:\n+\t\t\t\tif x == m.symbolSize-1 && (bitBuffer&0x7f) == 0x5d {\n+\t\t\t\t\tpenalty += penaltyWeight3\n+\t\t\t\t\tbitBuffer = 0xFF\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor x := 0; x < m.symbolSize; x++ {\n+\t\tvar bitBuffer int16 = 0x00\n+\n+\t\tfor y := 0; y < m.symbolSize; y++ {\n+\t\t\tbitBuffer <<= 1\n+\t\t\tif v := m.get(x, y); v {\n+\t\t\t\tbitBuffer |= 1\n+\t\t\t}\n+\n+\t\t\tswitch bitBuffer & 0x7ff {\n+\t\t\t// 0b000 0101 1101 or 0b10111010000\n+\t\t\t// 0x05d           or 0x5d0\n+\t\t\tcase 0x05d, 0x5d0:\n+\t\t\t\tpenalty += penaltyWeight3\n+\t\t\t\tbitBuffer = 0xFF\n+\t\t\tdefault:\n+\t\t\t\tif y == m.symbolSize-1 && (bitBuffer&0x7f) == 0x5d {\n+\t\t\t\t\tpenalty += penaltyWeight3\n+\t\t\t\t\tbitBuffer = 0xFF\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn penalty\n+}\n+\n+// penalty4 returns the penalty score...\n+func (m *symbol) penalty4() int {\n+\tnumModules := m.symbolSize * m.symbolSize\n+\tnumDarkModules := 0\n+\n+\tfor x := 0; x < m.symbolSize; x++ {\n+\t\tfor y := 0; y < m.symbolSize; y++ {\n+\t\t\tif v := m.get(x, y); v {\n+\t\t\t\tnumDarkModules++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tnumDarkModuleDeviation := numModules/2 - numDarkModules\n+\tif numDarkModuleDeviation < 0 {\n+\t\tnumDarkModuleDeviation *= -1\n+\t}\n+\n+\treturn penaltyWeight4 * (numDarkModuleDeviation / (numModules / 20))\n+}"
    },
    {
      "sha": "738cf3d36e544834d4001f4bf88fb51fbad03988",
      "filename": "backend/vendor/github.com/skip2/go-qrcode/version.go",
      "status": "added",
      "additions": 3050,
      "deletions": 0,
      "changes": 3050,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/version.go",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/github.com/skip2/go-qrcode/version.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/skip2/go-qrcode/version.go?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b"
    },
    {
      "sha": "03816bb011ec1a90b280efe94ea757a57e06cf81",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/modules.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/603decabf6c44df7d331356e1f1c2d44b2239f3b/backend/vendor/modules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/modules.txt?ref=603decabf6c44df7d331356e1f1c2d44b2239f3b",
      "patch": "@@ -177,6 +177,11 @@ github.com/rs/xid\n # github.com/russross/blackfriday/v2 v2.1.0\n ## explicit\n github.com/russross/blackfriday/v2\n+# github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e\n+## explicit\n+github.com/skip2/go-qrcode\n+github.com/skip2/go-qrcode/bitset\n+github.com/skip2/go-qrcode/reedsolomon\n # github.com/slack-go/slack v0.10.1\n ## explicit\n github.com/slack-go/slack"
    }
  ]
}

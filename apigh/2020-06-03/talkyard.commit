{
  "sha": "c255d7230a48049f17f4d4117a53b541125977f0",
  "node_id": "MDY6Q29tbWl0MTA1NjMzMjI6YzI1NWQ3MjMwYTQ4MDQ5ZjE3ZjRkNDExN2E1M2I1NDExMjU5NzdmMA==",
  "commit": {
    "author": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2020-05-21T12:59:16Z"
    },
    "committer": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2020-05-23T07:50:35Z"
    },
    "message": "Make listing posts work, via /-/v0/list.",
    "tree": {
      "sha": "a26f9943ef96a60d2bb35f014eb3c8c5db4c242b",
      "url": "https://api.github.com/repos/debiki/talkyard/git/trees/a26f9943ef96a60d2bb35f014eb3c8c5db4c242b"
    },
    "url": "https://api.github.com/repos/debiki/talkyard/git/commits/c255d7230a48049f17f4d4117a53b541125977f0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/debiki/talkyard/commits/c255d7230a48049f17f4d4117a53b541125977f0",
  "html_url": "https://github.com/debiki/talkyard/commit/c255d7230a48049f17f4d4117a53b541125977f0",
  "comments_url": "https://api.github.com/repos/debiki/talkyard/commits/c255d7230a48049f17f4d4117a53b541125977f0/comments",
  "author": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9d4bf33e53b54562ff8bccc44dccd36b506b82cb",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/9d4bf33e53b54562ff8bccc44dccd36b506b82cb",
      "html_url": "https://github.com/debiki/talkyard/commit/9d4bf33e53b54562ff8bccc44dccd36b506b82cb"
    }
  ],
  "stats": {
    "total": 938,
    "additions": 793,
    "deletions": 145
  },
  "files": [
    {
      "sha": "09098c28e682f6c651378dc85ad3c3c9072dbc61",
      "filename": "app/controllers/ApiV0Controller.scala",
      "status": "modified",
      "additions": 16,
      "deletions": 4,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/controllers/ApiV0Controller.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/controllers/ApiV0Controller.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/controllers/ApiV0Controller.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -229,13 +229,17 @@ class ApiV0Controller @Inject()(cc: ControllerComponents, edContext: EdContext,\n       case \"feed\" | EmbeddedCommentsFeedPath =>\n         val onlyEmbeddedComments = apiEndpoint == EmbeddedCommentsFeedPath\n         /*\n-        https://server.address/-/v0/recent-posts.rss\n+        https://server.address/-/v0/recent-posts.rss  — No! Explosion of endpoints. Instead:\n+\n         https://server.address/-/v0/feed?\n-            type=atom&\n+            type=atom&   — no, *always only* support Atom\n             include=replies,chatMessages,topics&\n             limit=10&\n             minLikeVotes=1&\n-            path=/some/category/or/page\n+            path=/some/category/or/page  — no\n+            category=extid:category_id  — yes\n+\n+        Look at the List API — use the same  findWhat  and  lookWhere  ?\n \n         Just going to:  https://www.talkyard.io/-/feed  = includes all new posts, type Atom, limit 10 maybe.\n \n@@ -245,9 +249,17 @@ class ApiV0Controller @Inject()(cc: ControllerComponents, edContext: EdContext,\n           /directory*.atom  = new topics, and (?) use:\n             dao.listPagePaths(\n               Utils.parsePathRanges(pageReq.pagePath.folder, pageReq.request.queryString,\n+\n+         Also:\n+             Get inspired by, + what can make sense to implement:\n+             https://developer.github.com/v3/activity/feeds/\n+             (but use Auth header Bearer tokens, not query params).\n          */\n-        val atomXml = dao.getAtomFeedXml(onlyEmbeddedComments = onlyEmbeddedComments)\n+\n+        val atomXml = dao.getAtomFeedXml(\n+              request, onlyEmbeddedComments = onlyEmbeddedComments)\n         OkXml(atomXml, \"application/atom+xml; charset=UTF-8\")\n+\n       case _ =>\n         throwForbidden(\"TyEAPIGET404\", s\"No such API endpoint: $apiEndpoint\")\n     }"
    },
    {
      "sha": "8ab4d1a5ee7d7ae5f3716dfa47de128d4eda6cf5",
      "filename": "app/controllers/UserController.scala",
      "status": "modified",
      "additions": 14,
      "deletions": 20,
      "changes": 34,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/controllers/UserController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/controllers/UserController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/controllers/UserController.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -21,7 +21,7 @@ import com.debiki.core._\n import com.debiki.core.Prelude._\n import com.debiki.core.Participant.{MinUsernameLength, isGuestId}\n import debiki._\n-import debiki.dao.{ReadMoreResult, SiteDao}\n+import debiki.dao.{LoadPostsResult, ReadMoreResult, SiteDao}\n import debiki.EdHttp._\n import ed.server.http._\n import java.{util => ju}\n@@ -293,30 +293,24 @@ class UserController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     // And if !all, and > 100 posts, add a load-more button.\n     val limit = all ? 9999 | 100\n \n-    // ----- Dupl code [4AKB2F0]\n-    val postsInclForbidden = dao.readOnlyTransaction { tx =>\n-      tx.loadPostsSkipTitles(limit = limit, OrderBy.MostRecentFirst, byUserId = Some(authorId))\n-    }\n-    val pageIdsInclForbidden = postsInclForbidden.map(_.pageId).toSet\n-    val pageMetaById = dao.getPageMetasAsMap(pageIdsInclForbidden)\n-\n-    val posts = for {\n-      post <- postsInclForbidden\n-      pageMeta <- pageMetaById.get(post.pageId)\n-      if dao.maySeePostUseCache(post, pageMeta, requester,\n-        maySeeUnlistedPages = requesterIsStaffOrAuthor)._1.may\n-    } yield post\n-\n-    val pageIds = posts.map(_.pageId).distinct\n-    val pageStuffById = dao.getPageStuffById(pageIds)\n-    // ----- /Dupl code\n+    val LoadPostsResult(postsOneMaySee, pageStuffById) =\n+          dao.loadPostsMaySeeByQuery(\n+                requester, OrderBy.MostRecentFirst, limit = limit,\n+                // One probably wants to see one's own not-yet-approved posts.\n+                inclUnapprovedPosts = requesterIsStaffOrAuthor,\n+                inclTitles = false, onlyEmbComments = false,\n+                inclUnlistedPagePosts = requesterIsStaffOrAuthor,\n+                writtenById = Some(authorId))\n+\n+    val posts = postsOneMaySee\n     val tagsByPostId = dao.readOnlyTransaction(_.loadTagsByPostId(posts.map(_.id)))\n \n     val postsJson = posts flatMap { post =>\n-      val pageMeta = pageMetaById.get(post.pageId) getOrDie \"EdE2KW07E\"\n+      val pageStuff = pageStuffById.get(post.pageId) getOrDie \"EdE2KW07E\"\n+      val pageMeta = pageStuff.pageMeta\n       val tags = tagsByPostId.getOrElse(post.id, Set.empty)\n       var postJson = dao.jsonMaker.postToJsonOutsidePage(post, pageMeta.pageType,\n-        showHidden = true, includeUnapproved = requesterIsStaffOrAuthor, tags)\n+            showHidden = true, includeUnapproved = requesterIsStaffOrAuthor, tags)\n \n       pageStuffById.get(post.pageId) map { pageStuff =>\n         postJson += \"pageId\" -> JsString(post.pageId)"
    },
    {
      "sha": "15bb2aff17ef417e170a4135b93d6058fe3a726a",
      "filename": "app/debiki/dao/FeedsDao.scala",
      "status": "modified",
      "additions": 47,
      "deletions": 36,
      "changes": 83,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/debiki/dao/FeedsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/debiki/dao/FeedsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/FeedsDao.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -19,7 +19,9 @@ package debiki.dao\n \n import com.debiki.core._\n import com.debiki.core.Prelude._\n-import debiki.EdHttp.throwNotFound\n+import debiki.EdHttp.{throwForbiddenIf, throwNotFound}\n+import debiki.RateLimits\n+import ed.server.http.ApiRequest\n \n \n /** Generates and caches Atom feeds for recent comments or recent topics.\n@@ -29,59 +31,68 @@ trait FeedsDao {\n \n \n   memCache.onPageCreated { sitePageId =>\n-    memCache.remove(siteFeedKey)\n-    memCache.remove(commentsFeedKey)\n+    emptyFeedsCache()\n   }\n \n   memCache.onPageSaved { sitePageId =>\n-    memCache.remove(siteFeedKey)\n-    memCache.remove(commentsFeedKey)\n+    emptyFeedsCache()\n   }\n \n-\n-  def getAtomFeedXml(onlyEmbeddedComments: Boolean): xml.Node = {\n-    val key = onlyEmbeddedComments ? commentsFeedKey | siteFeedKey\n-    memCache.lookup[xml.Node](\n-      key,\n-      orCacheAndReturn = {\n-        Some(loadAtomFeedXml(onlyEmbeddedComments = onlyEmbeddedComments))\n-      }) getOrDie \"TyE5KBR7JQ0\"\n+  private def emptyFeedsCache(): Unit = {   // (CACHHHEE)\n+    memCache.remove(siteFeedKey(SysbotUserId))\n+    memCache.remove(siteFeedKey(NoUserId))\n+    memCache.remove(commentsFeedKey(SysbotUserId))\n+    memCache.remove(commentsFeedKey(NoUserId))\n   }\n \n+  def getAtomFeedXml(request: ApiRequest[_], onlyEmbeddedComments: Boolean)\n+        : xml.Node = {\n+    import request.{requester => anyRequester}\n \n-  def loadAtomFeedXml(onlyEmbeddedComments: Boolean): xml.Node = {\n-    // ----- Dupl code [4AKB2F0]\n-    val postsInclForbidden = readOnlyTransaction { tx =>\n-      if (onlyEmbeddedComments) {\n-        tx.loadEmbeddedCommentsApprovedNotDeleted(limit = 25, OrderBy.MostRecentFirst)\n-      }\n-      else {\n-        tx.loadPostsSkipTitles(limit = 25, OrderBy.MostRecentFirst, byUserId = None)\n-      }\n+    // Cache only the Sysbot user's requests (for now at least),\n+    // So won't need to add complicated clear-cache code now.  (CACHHHEE)\n+    if (anyRequester.exists(_.id != SysbotUserId)) {\n+      self.context.rateLimiter.rateLimit(RateLimits.ExpensiveGetRequest, request)\n+      return loadAtomFeedXml(anyRequester, onlyEmbComments = onlyEmbeddedComments)\n     }\n-    val pageIdsInclForbidden = postsInclForbidden.map(_.pageId).toSet\n-    val pageMetaById = getPageMetasAsMap(pageIdsInclForbidden)\n-    val postsOneMaySee = for {\n-      post <- postsInclForbidden\n-      pageMeta <- pageMetaById.get(post.pageId)\n-      if maySeePostUseCache(\n-        post, pageMeta, ppt = None, maySeeUnlistedPages = onlyEmbeddedComments)._1.may\n-    } yield post\n-    val pageIds = postsOneMaySee.map(_.pageId).distinct\n-    val pageStuffById = getPageStuffById(pageIds)\n-    // ----- /Dupl code\n+\n+    // This'll be NoUserId or SysbotUserId, see above.\n+    val pptId = anyRequester.map(requester => {\n+      if (requester.isAuthenticated) requester.id\n+      else NoUserId\n+    }) getOrElse NoUserId\n+\n+    dieIf(pptId != NoUserId && pptId != SysbotUserId, \"TyE502RKSEH5\") // (CACHHHEE)\n+\n+    val key = onlyEmbeddedComments ? commentsFeedKey(pptId) | siteFeedKey(pptId)\n+\n+    memCache.lookup[xml.Node](key, orCacheAndReturn = Some {\n+      loadAtomFeedXml(anyRequester, onlyEmbComments = onlyEmbeddedComments)\n+    }) getOrDie \"TyE5KBR7JQ0\"\n+  }\n+\n+\n+  def loadAtomFeedXml(anyRequester: Option[Participant], onlyEmbComments: Boolean)\n+        : xml.Node = {\n+    val LoadPostsResult(postsOneMaySee, pageStuffById) =\n+          loadPostsMaySeeByQuery(\n+                anyRequester, OrderBy.MostRecentFirst, limit = 25,\n+                inclUnapprovedPosts = false, inclTitles = false,\n+                onlyEmbComments = onlyEmbComments,\n+                inclUnlistedPagePosts = onlyEmbComments,\n+                writtenById = None)\n \n     if (postsOneMaySee.isEmpty)\n       throwNotFound(\"TyE0FEEDPOSTS\", \"No posts found, or they are private\")\n \n     val origin = theSiteOrigin()\n     debiki.AtomFeedXml.renderFeed(origin, postsOneMaySee, pageStuffById,\n-      isForEmbeddedComments = onlyEmbeddedComments)\n+          isForEmbeddedComments = onlyEmbComments)\n   }\n \n \n-  private def siteFeedKey = MemCacheKey(siteId, \"FeedKey\")\n-  private def commentsFeedKey = MemCacheKey(siteId, \"CmtsFeedKey\")\n+  private def siteFeedKey(pptId: UserId) = MemCacheKey(siteId, s\"$pptId|FeedKey\")\n+  private def commentsFeedKey(pptId: UserId) = MemCacheKey(siteId, s\"$pptId|CmtsFeedKey\")\n \n }\n "
    },
    {
      "sha": "eef7ad7a55955b31d484549cb293ece342e94e13",
      "filename": "app/debiki/dao/PageStuffDao.scala",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/debiki/dao/PageStuffDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/debiki/dao/PageStuffDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/PageStuffDao.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -108,7 +108,7 @@ trait PageStuffDao {\n \n     // Load titles and bodies for all pages. (Because in forum topic lists, we show excerpts\n     // of pinned topics, and the start of other topics.)\n-    val titlesAndBodies = transaction.loadPosts(pageIds flatMap { pageId =>\n+    val titlesAndBodies = transaction.loadPostsByNrs(pageIds flatMap { pageId =>\n       Seq(PagePostNr(pageId, TitleNr), PagePostNr(pageId, BodyNr))\n     })\n "
    },
    {
      "sha": "3e5bce79beb24d33675606be1ee4cbe9b17d89d6",
      "filename": "app/debiki/dao/PostsDao.scala",
      "status": "modified",
      "additions": 62,
      "deletions": 4,
      "changes": 66,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/debiki/dao/PostsDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/debiki/dao/PostsDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/PostsDao.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -43,6 +43,11 @@ case class InsertPostResult(storePatchJson: JsObject, post: Post, reviewTask: Op\n \n case class ChangePostStatusResult(answerGotDeleted: Boolean)\n \n+case class LoadPostsResult(\n+  posts: immutable.Seq[Post],\n+  pageStuffById: Map[PageId, PageStuff])\n+\n+\n \n /** Loads and saves pages and page parts (e.g. posts and patches).\n   *\n@@ -2017,11 +2022,14 @@ trait PostsDao {\n       // will get hidden here, because we loaded only the most recent ones, above.\n       // — However, new users are rate limited, so not super likely to happen.\n \n-      // Censor the user's posts.\n+      // Find the user's posts — we'll hide them.\n+      // (The whole page gets hidden by hidePostsOnPage() below, if all posts get hidden.)\n       val postToMaybeHide =\n         if (user.isMember) {\n-          tx.loadPostsSkipTitles(limit = numThings, OrderBy.MostRecentFirst, byUserId = Some(userId))\n-              .filter(!_.isBodyHidden)\n+          tx.loadPostsByQuery(limit = numThings, OrderBy.MostRecentFirst,\n+                byUserId = Some(userId), includeTitlePosts = false,\n+                inclUnapprovedPosts = true, inclUnlistedPagePosts_unimpl = true)\n+                .filter(!_.isBodyHidden)\n         }\n         else {\n           tx.loadPostsByUniqueId(guestPostIds).values.filter(!_.isBodyHidden)\n@@ -2161,7 +2169,7 @@ trait PostsDao {\n   def loadPostsAllOrError(pageId: PageId, postNrs: Iterable[PostNr])\n         : immutable.Seq[Post] Or One[PostNr] =\n     readOnlyTransaction { tx =>\n-      val posts = tx.loadPosts(postNrs.map(PagePostNr(pageId, _)))\n+      val posts = tx.loadPostsByNrs(postNrs.map(PagePostNr(pageId, _)))\n       dieIf(posts.length > postNrs.size, \"EdE2WBR57\")\n       if (posts.length < postNrs.size) {\n         val firstMissing = postNrs.find(nr => !posts.exists(_.nr == nr)) getOrDie \"EdE7UKYWJ2\"\n@@ -2171,6 +2179,56 @@ trait PostsDao {\n     }\n \n \n+  def loadPostsMaySeeByQuery(\n+          requester: Option[Participant], orderBy: OrderBy, limit: Int,\n+          inclTitles: Boolean, onlyEmbComments: Boolean, inclUnapprovedPosts: Boolean,\n+          inclUnlistedPagePosts: Boolean,\n+          writtenById: Option[UserId]): LoadPostsResult = {\n+\n+    unimplementedIf(orderBy != OrderBy.MostRecentFirst,\n+          \"Only most recent first supported [TyE403RKTJ]\")\n+\n+    val postsInclForbidden = readOnlyTransaction { tx =>\n+      if (onlyEmbComments) {\n+        dieIf(inclTitles, \"TyE503RKDP5\", \"Emb cmts have no titles\")\n+        dieIf(inclUnapprovedPosts, \"TyE503KUTRT\", \"Emb cmts + unapproved\")\n+        dieIf(writtenById.isDefined, \"TyE703RKT3M\", \"Emb cmts + writtenBy unimpl\")\n+        // Embedded discussions are typically unlisted, so strangers\n+        // cannot super easily list all discussions over at the Talkyard site\n+        // (but via the Atom feed, it's ok to list the most recent comments).\n+        dieIf(!inclUnlistedPagePosts, \"TyE520ATJ3\", \"Emb cmts + *no* unlisted\")\n+\n+        tx.loadEmbeddedCommentsApprovedNotDeleted(limit = limit, orderBy)\n+      }\n+      else {\n+        tx.loadPostsByQuery(\n+              limit = limit, orderBy, byUserId = writtenById,\n+              includeTitlePosts = inclTitles, inclUnapprovedPosts = inclUnapprovedPosts,\n+              // inclUnlistedPagePosts_unimpl here has no effect, not implemented,\n+              // but there's a filter below in the for { ... }.\n+              inclUnlistedPagePosts_unimpl = inclUnlistedPagePosts)\n+      }\n+    }\n+\n+    val pageIdsInclForbidden = postsInclForbidden.map(_.pageId).toSet\n+    val pageMetaById = getPageMetasAsMap(pageIdsInclForbidden)\n+\n+    val postsOneMaySee = for {\n+      post <- postsInclForbidden\n+      pageMeta <- pageMetaById.get(post.pageId)\n+      maySee = maySeePostUseCache(\n+            post, pageMeta, ppt = requester, maySeeUnlistedPages = inclUnlistedPagePosts)\n+      if  maySee._1.may\n+    }\n+      yield post\n+\n+    val pageIds = postsOneMaySee.map(_.pageId).distinct\n+    val pageStuffById = getPageStuffById(pageIds) ; COULD_OPTIMIZE // reuse pageMetaById\n+\n+    LoadPostsResult(postsOneMaySee, pageStuffById)\n+  }\n+\n+\n   private def updateVoteCounts(post: Post, tx: SiteTransaction): Unit = {\n     dieIf(post.nr < PageParts.BodyNr, \"TyE4WKAB02\")\n     val actions = tx.loadActionsDoneToPost(post.pageId, postNr = post.nr)"
    },
    {
      "sha": "471d8a5438c67442eabae9f2366df144b8a28c84",
      "filename": "app/ed/server/http/PlainApiActions.scala",
      "status": "modified",
      "additions": 17,
      "deletions": 8,
      "changes": 25,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/ed/server/http/PlainApiActions.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/ed/server/http/PlainApiActions.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/ed/server/http/PlainApiActions.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -421,21 +421,30 @@ class PlainApiActions(\n \n         // ViewPageController has allow-anyone = true.\n         val isXhr = isAjax(request)\n-        def goToHomepageOrIfXhrThen(block: => Unit): Unit = {\n-          if (isXhr) block\n+        val isInternalApi = isXhr\n+        def isPublicApi = request.path.startsWith(\"/-/v0/\")\n+        def isApiReq = isInternalApi || isPublicApi\n+\n+        def goToHomepageOrIfApiReqThen(block: => Unit): Unit = {\n+          if (isApiReq) block\n           else throwTemporaryRedirect(\"/\")  ;COULD // throwLoginAsTo but undef error [5KUP02]\n         }\n-        val siteSettings = dao.getWholeSiteSettings()\n \n-        if (!anyUser.exists(_.isApprovedOrStaff) && siteSettings.userMustBeApproved)\n-          goToHomepageOrIfXhrThen(throwForbidden(\"DwE4HKG5\", \"Not approved\"))\n+        val siteSettings = dao.getWholeSiteSettings()\n \n         if (!anyUser.exists(_.isAuthenticated) && siteSettings.userMustBeAuthenticated)\n-          goToHomepageOrIfXhrThen(throwForbidden(\"DwE6JGY2\", \"Not authenticated\"))\n+          goToHomepageOrIfApiReqThen(throwForbidden(\n+                \"TyE0AUTHN_\", s\"Not authenticated. ${\n+                      if (isPublicApi) \"Please include Basic Auth credentials\"\n+                      else \"You need to be logged in\" }\"))\n+\n+        if (!anyUser.exists(_.isApprovedOrStaff) && siteSettings.userMustBeApproved)\n+          goToHomepageOrIfApiReqThen(throwForbidden(\n+                \"TyE0APPRVD\", \"Your user account has not yet been approved\"))\n \n-        if (anyUser.exists(_.isGuest) && !siteSettings.isGuestLoginAllowed && isXhr)\n+        if (anyUser.exists(_.isGuest) && !siteSettings.isGuestLoginAllowed && isApiReq)\n           throwForbidden(\"DwE7JYK4\", o\"\"\"Guest access has been disabled, but you're logged in\n-            as a guest. Please sign up with a real account instead\"\"\")\n+                as guest. Please sign up with a real account instead\"\"\")\n       }\n \n       val apiRequest = ApiRequest[A]("
    },
    {
      "sha": "b500b886c5392d4619350ccc52686f9f68a2d09c",
      "filename": "app/talkyard/server/api/ListController.scala",
      "status": "modified",
      "additions": 58,
      "deletions": 27,
      "changes": 85,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/talkyard/server/api/ListController.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/talkyard/server/api/ListController.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/talkyard/server/api/ListController.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -22,7 +22,7 @@ import debiki.RateLimits\n import ed.server.http._\n import debiki.EdHttp._\n import Prelude._\n-import debiki.dao.{PageStuff, SiteDao}\n+import debiki.dao.{LoadPostsResult, PageStuff, SiteDao}\n import ed.server.{EdContext, EdController}\n import javax.inject.Inject\n import play.api.libs.json.{JsObject, JsValue, Json}\n@@ -44,14 +44,17 @@ class ListController @Inject()(cc: ControllerComponents, edContext: EdContext)\n \n \n   def listThingsPubApiImpl(request: JsonPostRequest): Result = {\n-    import request.{body, dao}\n+    import request.{body, dao, requester}\n \n     val pretty = (body \\ \"pretty\").asOpt[Boolean].getOrElse(false)\n     val listQueryJson = (body \\ \"listQuery\").as[JsObject]\n \n     val findWhat = (listQueryJson \\ \"findWhat\").as[String]\n-    throwUnimplementedIf(findWhat != \"Pages\",\n-      \"TyE3056KTM7\", \"'findWhat' must be 'pages' right now\")\n+    val Pages = \"Pages\"\n+    val Posts = \"Posts\"\n+\n+    throwUnimplementedIf(findWhat != Pages && findWhat != Posts,\n+      \"TyE3056KTM7\", \"'findWhat' must be 'Pages' or 'Posts' right now\")\n \n     val lookWhere = (listQueryJson \\ \"lookWhere\").asOpt[JsObject]\n \n@@ -62,34 +65,62 @@ class ListController @Inject()(cc: ControllerComponents, edContext: EdContext)\n     throwUnimplementedIf(lookInWhichCategories.size >= 2,\n       \"TyE205KDT53\", \"Currently at most one lookWhere.inCategories can be specified\")\n \n-    val categoryRef = lookInWhichCategories.headOption getOrElse {\n-      throwNotImplemented(\n-        \"TyE205KDT56\", \"Currently lookWhere.inCategories needs to be one category\")\n-    }\n+    val anyCategoryRef = lookInWhichCategories.headOption\n \n-    val parsedCatRef = com.debiki.core.parseRef(\n-          categoryRef, allowParticipantRef = false) getOrIfBad { problem =>\n-      throwForbidden(\"TyE603KSJL3\", s\"Bad category ref: $problem\")\n-    }\n+    def nothingFound = ThingsFoundJson.makePagesFoundListResponse(Nil, dao, pretty)\n \n-    val category = dao.getCategoryByParsedRef(parsedCatRef) getOrElse {\n-      // Don't return any Not Found — that could help an attacker figure\n-      // out which hidden categories exist. Instead:\n-      return ThingsFoundJson.makePagesFoundListResponse(Nil, dao, pretty)\n+    val anyCategory: Option[Category] = anyCategoryRef map { catRef =>\n+      val parsedRef = parseRef(catRef, allowParticipantRef = false) getOrIfBad { problem =>\n+        throwForbidden(\"TyE603KSJL3\", s\"Bad category ref: $problem\")\n+      }\n+      dao.getCategoryByParsedRef(parsedRef) getOrElse {\n+        // Don't return any Not Found — that could help an attacker figure\n+        // out which hidden categories exist. Instead:\n+        return nothingFound\n+      }\n     }\n \n-    // Public API, no authentication needed.\n-    val authzCtx = dao.getForumPublicAuthzContext()\n-    val pageQuery = PageQuery(\n-      // Score and bump time, if nothing else specified. [TyT025WKRGJ]\n-      PageOrderOffset.ByScoreAndBumpTime(offset = None, TopTopicsPeriod.Week),\n-      PageFilter(PageFilterType.AllTopics, includeDeleted = false),\n-      includeAboutCategoryPages = false)\n-\n-    val topics = dao.listMaySeeTopicsInclPinned(category.id, pageQuery,\n-      includeDescendantCategories = true, authzCtx, limit = 12)\n+    val catOrRootCat = anyCategory getOrElse {\n+      val rootCats = dao.getRootCategories()\n+      throwUnimplementedIf(rootCats.length >= 2, \"TyE0450WKTD\")  // [subcats]\n+      rootCats.headOption getOrElse {\n+        return nothingFound\n+      }\n+    }\n \n-    ThingsFoundJson.makePagesFoundListResponse(topics, dao, pretty)\n+    val authzCtx = dao.getForumAuthzContext(requester)\n+\n+    findWhat match {\n+      case Pages =>\n+        val pageQuery = PageQuery(\n+              // Score and bump time, if nothing else specified. [TyT025WKRGJ]\n+              PageOrderOffset.ByScoreAndBumpTime(offset = None, TopTopicsPeriod.Week),\n+              PageFilter(PageFilterType.AllTopics, includeDeleted = false),\n+              includeAboutCategoryPages = false)\n+\n+        val topics = dao.listMaySeeTopicsInclPinned(catOrRootCat.id, pageQuery,\n+              includeDescendantCategories = true, authzCtx, limit = 12)\n+\n+        ThingsFoundJson.makePagesFoundListResponse(topics, dao, pretty)\n+\n+      case Posts =>\n+        val result: LoadPostsResult = dao.loadPostsMaySeeByQuery(\n+              requester, OrderBy.MostRecentFirst, limit = 25,\n+              // API consumers probably want only approved posts. [4946RKTT2]\n+              inclUnapprovedPosts = false,\n+              // But they do want unlisted post, probably? Only if is staff.\n+              inclUnlistedPagePosts = requester.map(_.isStaff) is true,\n+              // Or maybe not include title posts? The fact that titles are posts, is an\n+              // implementation detail? Not impossible this'll change, and there'll\n+              // be a posts3 title field, instead. [DONTLISTTTL]\n+              inclTitles = true, onlyEmbComments = false,\n+              writtenById = None)\n+\n+        PostsListFoundJson.makePostsListFoundResponse(result, dao, pretty)\n+\n+      case _ =>\n+        die(\"TyE502AKTUDT5\", s\"findWhat: $findWhat\")\n+    }\n   }\n \n }"
    },
    {
      "sha": "d949b4e97ff4b74911c012fc405cd9113dcee44d",
      "filename": "app/talkyard/server/api/PostsListFoundJson.scala",
      "status": "added",
      "additions": 113,
      "deletions": 0,
      "changes": 113,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/talkyard/server/api/PostsListFoundJson.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/talkyard/server/api/PostsListFoundJson.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/talkyard/server/api/PostsListFoundJson.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2020 Kaj Magnus Lindberg\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as\n+ * published by the Free Software Foundation, either version 3 of the\n+ * License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package talkyard.server.api\n+\n+import com.debiki.core._\n+import controllers.OkApiJson\n+import Prelude._\n+import debiki.dao.{LoadPostsResult, PageStuff, SiteDao}\n+import play.api.libs.json._\n+import play.api.mvc.Result\n+import talkyard.server.JsX._\n+\n+\n+\n+object PostsListFoundJson {\n+\n+\n+  def makePostsListFoundResponse(postsFound: LoadPostsResult, dao: SiteDao,\n+          pretty: Boolean): Result = {\n+    makePostsFoundResponseImpl(\n+          Some(postsFound), anySearchResults = None, dao, pretty = pretty)\n+  }\n+\n+\n+  type PostsSearchResult = AnyRef // ??\n+\n+  /*\n+  def makePagesFoundSearchResponse(searchResults: Seq[PostsSearchResult], dao: SiteDao,\n+          pretty: Boolean): Result = {\n+    makePostsFoundResponseImpl(\n+          anyPagePathsMetas = Nil, searchResults, dao, pretty = pretty)\n+  } */\n+\n+\n+  private def makePostsFoundResponseImpl(\n+      anyPostsFound: Option[LoadPostsResult], anySearchResults: Option[_],\n+      dao: SiteDao, pretty: Boolean): Result = {\n+\n+    dieIf(anyPostsFound.nonEmpty && anySearchResults.nonEmpty, \"TyE60WKTH5\")\n+\n+    val LoadPostsResult(postsFound: Seq[Post], pageStuffById: Map[PageId, PageStuff]) =\n+          anyPostsFound getOrDie \"TyE405RKDD\"\n+\n+    // --- Load authors\n+\n+    val authorIds = postsFound.map(_.createdById).toSet\n+    val authorsById: Map[UserId, Participant] = dao.getParticipantsAsMap(authorIds)\n+\n+    // --- Site origin   dupl code [603RKDJL5]\n+\n+    val siteIdsOrigins = dao.theSiteIdsOrigins()\n+    val avatarUrlPrefix =\n+          siteIdsOrigins.uploadsOrigin +\n+          ed.server.UploadsUrlBasePath + siteIdsOrigins.pubId + '/'\n+\n+    // --- The result\n+\n+    val jsPostsFound: Seq[JsObject] = for {\n+      post <- postsFound\n+      pageStuff <- pageStuffById.get(post.pageId)\n+    }\n+    yield {\n+      JsPostListFound(post, pageStuff, authorsById, avatarUrlPrefix = avatarUrlPrefix)\n+    }\n+\n+    // Typescript: SearchQueryResults, and ListQueryResults\n+    OkApiJson(Json.obj(\n+      \"origin\" -> siteIdsOrigins.siteOrigin,\n+      \"thingsFound\" -> jsPostsFound), pretty)\n+  }\n+\n+\n+  def JsPostListFound(post: Post, pageStuff: PageStuff, ppsById: Map[UserId, Participant],\n+          avatarUrlPrefix: String): JsObject = {\n+\n+    val anyAuthor = ppsById.get(post.createdById)\n+\n+    // Currently always approved. [4946RKTT2]\n+    val approvedHtmlSanitized = post.approvedHtmlSanitized.getOrDie(\n+          \"TyE603RKDL4\", s\"Post not approved: ${post.id}\")\n+\n+    Json.obj(  // Typescript: PostListed\n+      \"id\" -> JsNumber(post.id),\n+      \"nr\" -> JsNumber(post.nr),\n+      \"parentNr\" -> JsNumberOrNull(post.parentNr),\n+      \"pageId\" -> JsString(post.pageId),\n+      \"pageTitle\" -> pageStuff.title,\n+      \"isPageTitle\" -> JsBoolean(post.nr == PageParts.TitleNr),\n+      \"isPageBody\" -> JsBoolean(post.nr == PageParts.BodyNr),\n+      // COULD use the page's actual path (folder + slug).\n+      \"urlPath\" -> JsString(s\"/-${post.pageId}#post-${post.nr}\"),\n+      \"author\" -> ThingsFoundJson.JsParticipantFoundOrNull(anyAuthor, avatarUrlPrefix),\n+      \"approvedHtmlSanitized\" -> JsString(approvedHtmlSanitized))\n+  }\n+\n+}\n+\n+"
    },
    {
      "sha": "cb9b0b6ccf26f3aff59c67024d47789fe0c4fad4",
      "filename": "app/talkyard/server/api/ThingsFoundJson.scala",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/app/talkyard/server/api/ThingsFoundJson.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/app/talkyard/server/api/ThingsFoundJson.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/talkyard/server/api/ThingsFoundJson.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -29,7 +29,7 @@ import talkyard.server.JsX._\n \n \n \n-object ThingsFoundJson {\n+object ThingsFoundJson {  RENAME // to  PagesFoundJson ?\n \n \n   def makePagesFoundListResponse(topics: Seq[PagePathAndMeta], dao: SiteDao,\n@@ -108,7 +108,7 @@ object ThingsFoundJson {\n \n     val authorsById = dao.getParticipantsAsMap(allAuthorIds)\n \n-    // --- Site origin\n+    // --- Site origin   dupl code [603RKDJL5]\n \n     val siteIdsOrigins = dao.theSiteIdsOrigins()\n     val avatarUrlPrefix ="
    },
    {
      "sha": "4bf10ad212f362b7da861c25954dd1eb01cc355a",
      "filename": "docs/e2e-tests-map.txt",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/docs/e2e-tests-map.txt",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/docs/e2e-tests-map.txt",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/docs/e2e-tests-map.txt?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -953,9 +953,16 @@ api:\n           - TyT05RKVJF68\n   list topics:\n             - api-list-query-for-topics.test.ts  TyT603AKSL25\n+  list posts:\n+            - api-list-query-for-posts.test.ts  TyT503RKDGF\n+  list restricted stuff via api secret:\n+            - api-list-query-for-posts.test.ts  TyT702KRJGF57\n   search,\n   full text search:\n             - api-search-full-text.test.ts   TyT70ADNEFTD36\n+  atom feed:\n+            - TESTS_MISSING\n+  rss feed: No, there're only Atom feeds.\n \n \n import,"
    },
    {
      "sha": "f1577c7096839db004734d64f8b82ae0e29458c6",
      "filename": "modules/ed-core/src/main/scala/com/debiki/core/SiteTransaction.scala",
      "status": "modified",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/modules/ed-core/src/main/scala/com/debiki/core/SiteTransaction.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/modules/ed-core/src/main/scala/com/debiki/core/SiteTransaction.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/modules/ed-core/src/main/scala/com/debiki/core/SiteTransaction.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -84,17 +84,17 @@ trait SiteTransaction {\n     loadPost(pageId, postNr).getOrElse(throw PostNotFoundException(pageId, postNr))\n \n   def loadTitleAndOrigPost(pageId: PageId): Seq[Post] =\n-    loadPosts(Seq(PagePostNr(pageId, PageParts.TitleNr), PagePostNr(pageId, PageParts.BodyNr)))\n+    loadPostsByNrs(Seq(PagePostNr(pageId, PageParts.TitleNr), PagePostNr(pageId, PageParts.BodyNr)))\n \n   def loadTitle(pageId: PageId): Option[Post] =\n-    loadPosts(Seq(PagePostNr(pageId, PageParts.TitleNr))).headOption\n+    loadPostsByNrs(Seq(PagePostNr(pageId, PageParts.TitleNr))).headOption\n \n   def loadOrigPost(pageId: PageId): Option[Post] =\n-    loadPosts(Seq(PagePostNr(pageId, PageParts.BodyNr))).headOption\n+    loadPostsByNrs(Seq(PagePostNr(pageId, PageParts.BodyNr))).headOption\n \n   def loadOrigPostAndLatestPosts(pageId: PageId, limit: Int): Seq[Post]\n   def loadPostsOnPage(pageId: PageId, siteId: Option[SiteId] = None): immutable.Seq[Post]\n-  def loadPosts(pagePostNrs: Iterable[PagePostNr]): immutable.Seq[Post]  // RENAME to loadPostsByPageIdPostNrs\n+  def loadPostsByNrs(pagePostNrs: Iterable[PagePostNr]): immutable.Seq[Post]  // RENAME to loadPostsByPageIdPostNrs\n   def loadPostsByUniqueId(postIds: Iterable[PostId]): immutable.Map[PostId, Post]\n   def loadPostsByExtIdAsMap(extImpIds: Iterable[ExtId]): immutable.Map[ExtId, Post]\n \n@@ -117,11 +117,17 @@ trait SiteTransaction {\n   def loadApprovedOrigPostAndRepliesByPage(pageIds: Iterable[PageId]): Map[PageId, immutable.Seq[Post]]\n \n   def loadPostsToReview(): immutable.Seq[Post]\n-  def loadPostsSkipTitles(limit: Int, orderBy: OrderBy, byUserId: Option[UserId]): immutable.Seq[Post]\n+\n+  // Later all these params can be a ListPostsQuery instead.\n+  // Also, these params:  includeDeleted,  includeHidden.\n+  def loadPostsByQuery(limit: Int, orderBy: OrderBy, byUserId: Option[UserId],\n+        includeTitlePosts: Boolean, inclUnapprovedPosts: Boolean,\n+        inclUnlistedPagePosts_unimpl: Boolean): immutable.Seq[Post]\n+\n   def loadEmbeddedCommentsApprovedNotDeleted(limit: Int, orderBy: OrderBy): immutable.Seq[Post]\n \n   def loadTitlesPreferApproved(pageIds: Iterable[PageId]): Map[PageId, String] = {\n-    val titlePosts = loadPosts(pageIds.map(PagePostNr(_, PageParts.TitleNr)))\n+    val titlePosts = loadPostsByNrs(pageIds.map(PagePostNr(_, PageParts.TitleNr)))\n     Map(titlePosts.map(post => {\n       post.pageId -> post.approvedSource.getOrElse(post.currentSource)\n     }): _*)"
    },
    {
      "sha": "342c359ec7be5ebf73afedf8af4e3dbfbe721b45",
      "filename": "modules/ty-dao-rdb/src/main/scala/com/debiki/dao/rdb/PostsSiteDaoMixin.scala",
      "status": "modified",
      "additions": 19,
      "deletions": 6,
      "changes": 25,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/modules/ty-dao-rdb/src/main/scala/com/debiki/dao/rdb/PostsSiteDaoMixin.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/modules/ty-dao-rdb/src/main/scala/com/debiki/dao/rdb/PostsSiteDaoMixin.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/modules/ty-dao-rdb/src/main/scala/com/debiki/dao/rdb/PostsSiteDaoMixin.scala?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -104,7 +104,7 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n   }\n \n \n-  def loadPosts(pagePostNrs: Iterable[PagePostNr]): immutable.Seq[Post] = {\n+  def loadPostsByNrs(pagePostNrs: Iterable[PagePostNr]): immutable.Seq[Post] = {\n     if (pagePostNrs.isEmpty)\n       return Nil\n \n@@ -236,8 +236,9 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n   } */\n \n \n-  def loadPostsSkipTitles(limit: Int, orderBy: OrderBy, byUserId: Option[UserId])\n-        : immutable.Seq[Post] = {\n+  def loadPostsByQuery(limit: Int, orderBy: OrderBy, byUserId: Option[UserId],\n+        includeTitlePosts: Boolean, includeUnapproved: Boolean,\n+        inclUnlistedPagePosts_unimpl: Boolean): immutable.Seq[Post] = {\n     dieIf(orderBy != OrderBy.MostRecentFirst, \"EdE1DRJ7Y\", \"Unimpl\")\n \n     val values = ArrayBuffer[AnyRef](siteId.asAnyRef)\n@@ -249,10 +250,22 @@ trait PostsSiteDaoMixin extends SiteTransaction {\n         \"and created_by_id = ?\"\n     }\n \n+    val andNotTitle = includeTitlePosts ? \"\" | s\"and post_nr <> $TitleNr\"\n+    val andSomeVersionApproved = includeUnapproved ?\n+          \"\" | \"and approved_at is not null\"\n+\n+    // This'll require a join w pages3 and categories3.\n+    val andPageNotUnlisted_unimpl = !inclUnlistedPagePosts_unimpl ? \"\" | \"\"\n+\n     val query = s\"\"\"\n-      select * from posts3 where site_id = ? $andAuthorEq and post_nr <> $TitleNr\n-      order by created_at desc limit $limit\n-      \"\"\"\n+          select * from posts3\n+          where site_id = ?\n+              $andAuthorEq\n+              $andNotTitle\n+              $andSomeVersionApproved\n+              $andPageNotUnlisted_unimpl\n+          order by created_at desc limit $limit \"\"\"\n+\n     runQueryFindMany(query, values.toList, rs => {\n       readPost(rs)\n     })"
    },
    {
      "sha": "9941f527b125684b7fb9b156821e9a12b389a3e4",
      "filename": "s/run-e2e-tests.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/s/run-e2e-tests.sh",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/s/run-e2e-tests.sh",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/s/run-e2e-tests.sh?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -426,6 +426,7 @@ function runAllE2eTests {\n \n   $r s/wdio --only api-search-full-text $args\n   $r s/wdio --only api-list-query-for-topics $args\n+  $r s/wdio --only api-list-query-for-posts $args\n \n   # wip:\n   # settings-allow-local-signup"
    },
    {
      "sha": "969b3b4c82a37b3733d75deb533afd7849c0781e",
      "filename": "tests/e2e/pub-api.ts",
      "status": "modified",
      "additions": 29,
      "deletions": 5,
      "changes": 34,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/pub-api.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/pub-api.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/pub-api.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -73,6 +73,8 @@ interface Participant_ {\n type FindWhat =\n   'Pages' |\n \n+  'Posts' |\n+\n   // Users and groups (not guests).\n   'Members' |\n \n@@ -152,7 +154,8 @@ interface LookWhere {\n // What you get back\n // -------------------------\n \n-type ThingFound = PageFound | ParticipantFound | TagFound | CategoryFound;\n+type ThingFound = PageFound | PageListed | PostListed\n+                  | ParticipantFound | TagFound | CategoryFound;\n \n \n \n@@ -187,33 +190,54 @@ interface GroupFound extends MemberFound {\n \n \n \n-interface PageFound {\n+interface PageFoundOrListed {\n   pageId: PageId;\n   title: string;\n   // Prefix with the origin (included in the response) to get the full URL.\n   urlPath: string;\n   excerpt?: string;\n   author?: ParticipantFound;\n   categoriesMainFirst?: CategoryFound[];\n-  postsFound?: PostFound[];\n }\n \n+interface PageFound extends PageFoundOrListed {\n+  postsFound: PostFound[];\n+}\n+\n+type PageListed = PageFoundOrListed;\n+\n \n-interface PostFound {\n+\n+interface PostFoundOrListed {\n   isPageTitle?: boolean;\n   isPageBody?: boolean;\n   author?: ParticipantFound;\n+}\n+\n+interface PostFound extends PostFoundOrListed {\n   // With <mark> tags and html escapes, like:\n   //   [\"When you want to <mark>climb</mark> a tall\n   //    &amp; exciting <mark>tree</tree> then\",\n   //   ... ].\n   htmlWithMarks: string[];\n }\n \n+interface PostListed extends PostFoundOrListed {\n+  id: number;\n+  nr: number;\n+  parentNr?: number;\n+  pageId: PageId;\n+  pageTitle: string;\n+  urlPath: string;\n+  approvedHtmlSanitized?: string;\n+}\n+\n+\n \n type TagFound = Unimplemented;\n \n \n+\n interface CategoryFound {\n   categoryId: CategoryId;\n   name: string;\n@@ -246,7 +270,7 @@ interface ListQuery {\n   // E.g. username prefix.\n   exactPrefix?: string;\n   findWhat: FindWhat,\n-  lookWhere: LookWhere;\n+  lookWhere?: LookWhere;\n }\n \n type ListQueryApiResponse<T extends ThingFound> = ApiResponse<ListQueryResults<T>>;"
    },
    {
      "sha": "618752f0664342fdda9aa86d2f82aaa5213f74d9",
      "filename": "tests/e2e/specs/api-list-query-for-posts.test.ts",
      "status": "added",
      "additions": 324,
      "deletions": 0,
      "changes": 324,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/specs/api-list-query-for-posts.test.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/specs/api-list-query-for-posts.test.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/specs/api-list-query-for-posts.test.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -0,0 +1,324 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert = require('../utils/ty-assert');\n+// import fs = require('fs');  EMBCMTS\n+import server = require('../utils/server');\n+import utils = require('../utils/utils');\n+import settings = require('../utils/settings');\n+import { buildSite } from '../utils/site-builder';\n+import { TyE2eTestBrowser } from '../utils/pages-for';\n+import lad = require('../utils/log-and-die');\n+import c = require('../test-constants');\n+\n+\n+let owen: Member;\n+let owensBrowser: TyE2eTestBrowser;\n+let maria: Member;\n+let mariasBrowser: TyE2eTestBrowser;\n+\n+let siteIdAddress: IdAddress;\n+let siteId;\n+\n+let forum: EmptyTestForum;\n+const forumTitle = 'List posts via API E2E test';\n+\n+const pageAaaId = 'pageAaaId';\n+const pageAaaTitle = 'pageAaaTitle';\n+const pageAaaBody = 'pageAaaBody';\n+let pageAaaJustAdded: PageJustAdded | U;\n+\n+const pageBbbId = 'pageBbbId';\n+const pageBbbTitle = 'pageBbbTitle';\n+const pageBbbBody = 'pageBbbBody';\n+let pageBbbJustAdded: PageJustAdded | U;\n+\n+const mariasReplyOne = 'mariasReplyOne';\n+\n+const apiSecret: TestApiSecret = {\n+  nr: 1,\n+  userId: c.SysbotUserId,\n+  createdAt: c.MinUnixMillis,\n+  deletedAt: undefined,\n+  isDeleted: false,\n+  secretKey: 'publicE2eTestSecretKeyAbc123',\n+};\n+\n+\n+describe(\"api-list-query-for-posts.test.ts  TyT503RKDGF\", () => {\n+\n+  it(\"import a site\", () => {\n+    const builder = buildSite();\n+    forum = builder.addEmptyForum({\n+      title: forumTitle,\n+      members: ['michael', 'maria', 'owen'],\n+    });\n+\n+    pageAaaJustAdded = builder.addPage({\n+      id: pageAaaId,\n+      createdAtMs: c.JanOne2020HalfPastFive + 10*1000,\n+      folder: '/',\n+      showId: false,\n+      slug: 'page-aaa',\n+      role: c.TestPageRole.Discussion,\n+      title: pageAaaTitle,\n+      body: pageAaaBody,\n+      categoryId: forum.categories.categoryA.id,\n+      authorId: forum.members.maria.id,\n+    });\n+\n+    pageBbbJustAdded = builder.addPage({\n+      id: 'pageBbbId',\n+      createdAtMs: c.JanOne2020HalfPastFive + 30*1000,\n+      folder: '/',\n+      showId: false,\n+      slug: 'page-zzz',\n+      role: c.TestPageRole.Discussion,\n+      title: pageBbbTitle,\n+      body: pageBbbBody,\n+      categoryId: forum.categories.categoryA.id,\n+      authorId: forum.members.michael.id,\n+    });\n+\n+    // Enable API.\n+    builder.settings({ enableApi: true });\n+    builder.getSite().apiSecrets = [apiSecret];\n+\n+    assert.refEq(builder.getSite(), forum.siteData);\n+    siteIdAddress = server.importSiteData(forum.siteData);\n+    siteId = siteIdAddress.id;\n+    server.skipRateLimits(siteId);\n+  });\n+\n+  it(\"initialize people\", () => {\n+    const richBrowserA = new TyE2eTestBrowser(oneWdioBrowser);\n+    owen = forum.members.owen;\n+    maria = forum.members.maria;\n+    mariasBrowser = richBrowserA;\n+    owensBrowser = richBrowserA;\n+  });\n+\n+\n+  it(\"Maria goes to the forum, logs in\", () => {\n+    mariasBrowser.go2(siteIdAddress.origin);\n+    // Log in, so can post a post, later below.\n+    mariasBrowser.complex.loginWithPasswordViaTopbar(maria);\n+  });\n+\n+\n+  // ----- List Query: Newest posts first\n+\n+\n+  function listPostsImpl(what?: 'Fail' | TestApiSecret): ListQueryResults<PostListed> | string {\n+    return server.apiV0.listQuery<PostListed>({\n+      origin: siteIdAddress.origin,\n+      listQuery: {\n+        findWhat: 'Posts',\n+      },\n+      sortOrder: 'NewestFirst',\n+    }, {\n+      fail: what === 'Fail',\n+      apiRequesterId: (what as TestApiSecret)?.userId,\n+      apiSecret: (what as TestApiSecret)?.secretKey,\n+    })\n+  }\n+\n+  function listPosts(apiSecret?: TestApiSecret): ListQueryResults<PostListed> {\n+    return listPostsImpl(apiSecret) as ListQueryResults<PostListed>;\n+  }\n+\n+  function listPostsButFail(): string {\n+    return listPostsImpl('Fail') as string;\n+  }\n+\n+  let response: ListQueryResults<PostListed>;\n+  let posts: PostListed[];\n+\n+\n+  it(\"Maria lists posts\", () => {\n+    response = listPosts();\n+    posts = response.thingsFound;\n+  });\n+\n+  const eight = 8;\n+\n+  it(`She finds ${eight} posts`, () => {\n+    // Page Aaa and Bbb title and body: 2 + 2, +\n+    // CategoryA about page title and body: 2,  +\n+    // Forum title and intro text:  2  =  8\n+    // Or maybe excl titles by default? [DONTLISTTTL]\n+    assert.eq(posts.length, eight, `Response:\\n`, response);\n+  });\n+\n+\n+\n+  it(\"The first post is the most recently added page: Bbb, the body text\", () => {\n+    assert.eq(posts[0].approvedHtmlSanitized, `<p>${pageBbbBody}</p>`);\n+    assert.eq(posts[0].pageId, pageBbbId);\n+    assert.eq(posts[0].pageTitle, pageBbbTitle);\n+  });\n+\n+  it(\"The 2nd is Bbb's title\", () => {\n+    assert.includes(posts[1].approvedHtmlSanitized, pageBbbTitle);\n+    assert.eq(posts[1].pageId, pageBbbId);\n+    assert.eq(posts[1].pageTitle, pageBbbTitle);  // hmm a bit weird [DONTLISTTTL]\n+  });\n+\n+  let pageAaaBodyPost: PostListed | U;\n+\n+  it(\"The 3rd is Aaa's body\", () => {\n+    assert.includes(posts[2].approvedHtmlSanitized, pageAaaBody);\n+    assert.eq(posts[2].pageId, pageAaaId);\n+    assert.eq(posts[2].pageTitle, pageAaaTitle);  // hmm a bit weird [DONTLISTTTL]\n+    pageAaaBodyPost = posts[2];\n+  });\n+\n+  it(\"The 4th is Aaa's title\", () => {\n+    assert.includes(posts[3].approvedHtmlSanitized, pageAaaTitle);\n+    assert.eq(posts[3].pageTitle, pageAaaTitle);  // hmm a bit weird [DONTLISTTTL]\n+    assert.eq(posts[3].pageId, pageAaaId);\n+  });\n+\n+  /*\n+  it(\"All of them are in Category A\", () => {\n+    const catName = forum.categories.categoryA.name;\n+    assert.eq(posts[0].categoriesMainFirst?.[0]?.name, catName);\n+    assert.eq(posts[1].categoriesMainFirst?.[0]?.name, catName);\n+    assert.eq(posts[2].categoriesMainFirst?.[0]?.name, catName);\n+  }); */\n+\n+  it(\"The author names are correct\", () => {\n+    assert.eq(posts[0].author?.username, forum.members.michael.username);\n+    assert.eq(posts[1].author?.username, forum.members.michael.username);\n+    assert.eq(posts[2].author?.username, maria.username);\n+    assert.eq(posts[3].author?.username, maria.username);\n+  });\n+\n+  it(\"Maria opens page Aaa\", () => {\n+    mariasBrowser.go2(pageAaaBodyPost.urlPath);\n+  });\n+\n+  it(\"The title, body and reply are all there\", () => {\n+    mariasBrowser.topic.waitForPostAssertTextMatches(c.TitleNr, pageAaaTitle);\n+    mariasBrowser.topic.waitForPostAssertTextMatches(c.BodyNr, pageAaaBody);\n+  });\n+\n+\n+  // ----- New replies\n+\n+\n+  it(\"Maria replies\", () => {\n+    mariasBrowser.complex.replyToOrigPost(mariasReplyOne);\n+    mariasBrowser.topic.waitUntilPostTextMatches(c.FirstReplyNr, mariasReplyOne);\n+  });\n+\n+  it(\"Maria again lists posts\", () => {\n+    response = listPosts();\n+    posts = response.thingsFound;\n+  });\n+\n+  it(`She finds ${eight + 1} posts`, () => {\n+    assert.eq(posts.length, eight + 1, `Response:\\n`, response);\n+  });\n+\n+  it(`Her mmost recent reply first, and the other ${eight} follows`, () => {\n+    checkAllPosts(eight + 1);\n+  });\n+\n+\n+  function checkAllPosts(howMany: number) {\n+    if (howMany === eight + 1) {\n+      assert.includes(posts[0].approvedHtmlSanitized, mariasReplyOne);\n+      assert.includes(posts[1].approvedHtmlSanitized, pageBbbBody);\n+      assert.includes(posts[2].approvedHtmlSanitized, pageBbbTitle);\n+      assert.includes(posts[3].approvedHtmlSanitized, pageAaaBody);\n+      assert.includes(posts[4].approvedHtmlSanitized, pageAaaTitle);\n+      assert.includes(posts[5].approvedHtmlSanitized, forum.categories.categoryA.aboutPage.body);\n+      assert.includes(posts[6].approvedHtmlSanitized, forum.categories.categoryA.name);\n+      assert.includes(posts[7].approvedHtmlSanitized, \"intro text\");\n+      assert.includes(posts[8].approvedHtmlSanitized, forumTitle);\n+    }\n+    else if (howMany === 2) {\n+      assert.includes(posts[0].approvedHtmlSanitized, \"intro text\");\n+      assert.includes(posts[1].approvedHtmlSanitized, forumTitle);\n+    }\n+    else {\n+      lad.die('TyE30679084K');\n+    }\n+  }\n+\n+  // ----- Private topics stay private   TyT502RKDJ46\n+\n+\n+  it(\"Owen logs in\", () => {\n+    mariasBrowser.topbar.clickLogout();\n+    owensBrowser.complex.loginWithPasswordViaTopbar(owen);\n+  });\n+\n+\n+  it(\"Owen goes to category A\", () => {\n+    owensBrowser.topbar.clickHome();\n+    owensBrowser.forumTopicList.switchToCategory(forum.categories.categoryA.name);\n+  });\n+  it(\"... eits security settings\", () => {\n+    owensBrowser.forumButtons.clickEditCategory();\n+    owensBrowser.categoryDialog.openSecurityTab();\n+  });\n+  it(\"... makes it restricted: removes the Everyone group  TyT69WKTEJG4\", () => {\n+    owensBrowser.categoryDialog.securityTab.removeGroup(c.EveryoneId);\n+    // ?? owensBrowser.categoryDialog.securityTab.addGroup(c.EveryoneFullName);\n+  });\n+  it(\"... saves\", () => {\n+    owensBrowser.categoryDialog.submit();\n+  });\n+\n+\n+  it(\"Maria lists pages again\", () => {\n+    response = listPosts();\n+    posts = response.thingsFound;\n+  });\n+\n+  it(\"... now finds only the forum title and intro posts\", () => {\n+    assert.eq(posts.length, 2, `Response:\\n`, response);\n+  });\n+\n+  it(\"... they look correct: the forum title, and intro text\", () => {\n+    checkAllPosts(2);\n+  });\n+\n+\n+  it(\"Owen makes the forum Login-Required\", () => {\n+    owensBrowser.adminArea.settings.login.goHere();\n+    owensBrowser.adminArea.settings.login.setLoginRequired(true);\n+    owensBrowser.adminArea.settings.clickSaveAll();\n+  });\n+\n+  let errorText: string | U;\n+\n+  it(\"Maria lists pages again\", () => {\n+    errorText = listPostsButFail();\n+  });\n+\n+  it(\"... now gets an error about not being logged in\", () => {\n+    assert.includes(errorText, 'TyE0AUTHN_');\n+  });\n+\n+\n+  // ----- List private things via API secret   TyT702KRJGF57\n+\n+\n+  it(\"However, Sysbot can list all posts\", () => {\n+    response = listPosts(apiSecret);\n+    posts = response.thingsFound;\n+  });\n+\n+  it(`... finds all ${eight + 1} posts`, () => {\n+    assert.eq(posts.length, 9, `Response:\\n`, response);\n+  });\n+\n+  it(\"... they look fine\", () => {\n+    checkAllPosts(eight + 1);\n+  });\n+\n+});\n+"
    },
    {
      "sha": "a5c1ae858ce721ec989a9353cefeceec152aa94b",
      "filename": "tests/e2e/specs/api-list-query-for-topics.test.ts",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/specs/api-list-query-for-topics.test.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/specs/api-list-query-for-topics.test.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/specs/api-list-query-for-topics.test.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -137,26 +137,26 @@ describe(\"api-list-query-for-topics.test.ts  TyT603AKSL25\", () => {\n \n   // Since no Like votes, the most recently active topics should be listed first.\n \n-  let response: SearchQueryResults<PageFound>;\n+  let response: ListQueryResults<PageListed>;\n \n   it(\"Maria lists pages in the Specific category\", () => {\n-    response = server.apiV0.listQuery<PageFound>({\n+    response = server.apiV0.listQuery<PageListed>({\n       origin: siteIdAddress.origin,\n       listQuery: {\n         findWhat: 'Pages',\n         lookWhere: { inCategories: [`extid:${specificCatExtId}`] },\n       },\n-    });\n+    }) as ListQueryResults<PageListed>;\n   });\n \n   it(\"She finds three pages\", () => {\n     assert.eq(response.thingsFound.length, 3);\n   });\n \n \n-  let pageOneFound: PageFound;\n-  let pageTwoFound: PageFound;\n-  let pageThreeFound: PageFound;\n+  let pageOneFound: PageListed;\n+  let pageTwoFound: PageListed;\n+  let pageThreeFound: PageListed;\n \n   it(\"The first page is the most recently added page: Zzz  [TyT025WKRGJ]\", () => {\n     pageOneFound = response.thingsFound[0];\n@@ -212,13 +212,13 @@ describe(\"api-list-query-for-topics.test.ts  TyT603AKSL25\", () => {\n   });\n \n   it(\"Maria again lists pages in the Specific category\", () => {\n-    response = server.apiV0.listQuery<PageFound>({\n+    response = server.apiV0.listQuery<PageListed>({\n       origin: siteIdAddress.origin,\n       listQuery: {\n         findWhat: 'Pages',\n         lookWhere: { inCategories: [`extid:${specificCatExtId}`] },\n       },\n-    });\n+    }) as ListQueryResults<PageListed>;\n   });\n \n   it(\"She again finds three pages\", () => {\n@@ -245,13 +245,13 @@ describe(\"api-list-query-for-topics.test.ts  TyT603AKSL25\", () => {\n \n \n   function listStaffPages() {\n-    return server.apiV0.listQuery<PageFound>({\n+    return server.apiV0.listQuery<PageListed>({\n       origin: siteIdAddress.origin,\n       listQuery: {\n         findWhat: 'Pages',\n         lookWhere: { inCategories: [`extid:${staffCatExtId}`] },\n       },\n-    });\n+    }) as ListQueryResults<PageListed>;\n   }\n \n   it(\"Maria tries to list pages in the Staff category\", () => {"
    },
    {
      "sha": "6d57cf94427fe7c638670aa3baad178b7f7917fe",
      "filename": "tests/e2e/specs/login-expire-idle-after.2browsers.test.ts",
      "status": "modified",
      "additions": 16,
      "deletions": 6,
      "changes": 22,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/specs/login-expire-idle-after.2browsers.test.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/specs/login-expire-idle-after.2browsers.test.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/specs/login-expire-idle-after.2browsers.test.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -118,28 +118,31 @@ describe(\"expire-idle-session  TyT7RBKTJ25\", () => {\n     owensBrowser.adminArea.settings.login.setExpireIdleAfterMinutes(2000);\n   });\n \n-  it(\"... saves, again\", () => {\n-    owensBrowser.adminArea.settings.clickSaveAll();\n+  it(\"... tries to save\", () => {\n+    owensBrowser.adminArea.settings.clickSaveAll({ willFail: true });\n   });\n \n   it(\"... but his session also expired\", () => {\n     owensBrowser.serverErrorDialog.waitForNotLoggedInAsAdminError();\n     owensBrowser.serverErrorDialog.close();\n   });\n \n-  it(\"He tries to save, still doesn't work, of course\", () => {\n-    owensBrowser.adminArea.settings.clickSaveAll();\n+  it(\"... He tries once more, still doesn't work, of course\", () => {\n+    owensBrowser.adminArea.settings.clickSaveAll({ willFail: true });\n     owensBrowser.serverErrorDialog.waitForNotLoggedInAsAdminError();\n     owensBrowser.serverErrorDialog.close();\n   });\n \n-  it(\"... he logs in again\", () => {\n+  it(\"Owen logs in again\", () => {\n     owensBrowser.refresh();\n     owensBrowser.loginDialog.loginWithPassword(owen);\n   });\n \n-  it(\"... and now he can configure 2000 minutes expiration time\", () => {\n+  it(\"... again configures 2000 minutes expiration time\", () => {\n     owensBrowser.adminArea.settings.login.setExpireIdleAfterMinutes(2000);\n+  });\n+\n+  it(\"... and saves, works now\", () => {\n     owensBrowser.adminArea.settings.clickSaveAll();\n   });\n \n@@ -152,5 +155,12 @@ describe(\"expire-idle-session  TyT7RBKTJ25\", () => {\n     mariasBrowser.topic.waitForPostAssertTextMatches(c.FirstReplyNr + 2, \"Maybe I'll stay\");\n   });\n \n+  it(\"And Owen can keep changing the expiration time\", () => {\n+    owensBrowser.adminArea.settings.login.setExpireIdleAfterMinutes(2098);\n+    // This wouldn't work, if session expired — there'd be a modal error dialog:\n+    owensBrowser.adminArea.settings.clickSaveAll();\n+    owensBrowser.adminArea.settings.login.setExpireIdleAfterMinutes(2099);\n+  });\n+\n });\n "
    },
    {
      "sha": "7e3166c08d7d202b9034b9b6221b755e0f05c651",
      "filename": "tests/e2e/utils/pages-for.ts",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/utils/pages-for.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/utils/pages-for.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/utils/pages-for.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -3906,6 +3906,11 @@ export class TyE2eTestBrowser {\n               '.esDropModal_content .esExplDrp_entry', toGroupName);\n         },\n \n+        removeGroup: (groupId: UserId) => {\n+          this.waitAndClick(`.s_PoP-Grp-${groupId} .s_PoP_Dl`);\n+          this.waitUntilGone(`.s_PoP-Grp-${groupId}`);\n+        },\n+\n         addGroup: (groupName: string) => {\n           this.waitAndClick('.s_CD_Sec_AddB');\n           this.waitAndClick('.s_PoP-Select-Grp .e_SelGrpB');\n@@ -6017,10 +6022,13 @@ export class TyE2eTestBrowser {\n         this.$$('.esAdminArea .dw-main-nav > li').length,\n \n       settings: {\n-        clickSaveAll: () => {\n+        clickSaveAll: (ps: { willFail?: boolean } = {}) => {\n           this.scrollToBottom();\n           this.waitAndClick('.esA_SaveBar_SaveAllB');\n           this.waitUntilLoadingOverlayGone();\n+          if (!ps.willFail) {\n+            this.waitUntilGone('.esA_SaveBar_SaveAllB');\n+          }\n         },\n \n         clickLegalNavLink: () => {"
    },
    {
      "sha": "335a9b00ed388a456e7bc82d5be3bf30de9664b3",
      "filename": "tests/e2e/utils/server.ts",
      "status": "modified",
      "additions": 13,
      "deletions": 4,
      "changes": 17,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/utils/server.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/utils/server.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/utils/server.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -70,7 +70,10 @@ function initOrExit(theSettings) {\n function postOrDie(url, data, opts: { apiRequesterId?: number, apiSecret?: string,\n       retryIfXsrfTokenExpired?: boolean, fail?: boolean } = {})\n       : { statusCode: number, headers, bodyText: string, bodyJson: () => any } {\n+\n   dieIf(!settings.e2eTestPassword, \"No E2E test password specified [EsE2WKG4]\");\n+  dieIf(!!opts.apiRequesterId !== !!opts.apiSecret,\n+        \"API user id or secret missing [TyE450KST]\");\n \n   const passwordParam =\n       (url.indexOf('?') === -1 ? '?' : '&') + 'e2eTestPassword=' + settings.e2eTestPassword;\n@@ -511,15 +514,21 @@ function fullTextSearch<T extends ThingFound>(ps: { origin: string, queryText: s\n }\n \n \n-function listQuery<T extends ThingFound>(ps: {\n-      origin: string, listQuery: ListQuery, sortOrder?: SortOrder })\n-      :  ListQueryResults<T> {\n+function listQuery<T extends ThingFound>(\n+      ps: { origin: string, listQuery: ListQuery, sortOrder?: SortOrder },\n+      postPs: { fail?: boolean, apiRequesterId?: UserId, apiSecret?: string } = {})\n+      : ListQueryResults<T> | string {\n   const url = ps.origin + '/-/v0/list';\n   const requestBody: ListQueryApiRequest = {\n     listQuery: ps.listQuery,\n     pretty: true,\n   };\n-  const responseObj = postOrDie(url, requestBody);\n+\n+  const responseObj = postOrDie(url, requestBody, postPs);\n+\n+  if (postPs.fail)\n+    return responseObj.bodyText;\n+\n   const responseBody = responseObj.bodyJson() as ListQueryApiResponse<T>;\n   const result = responseObj.statusCode === 200 && !isApiErrorResponse(responseBody)\n       ? responseBody"
    },
    {
      "sha": "33a3620e577c3e86cb01cb172d99fd5df6ebbeb1",
      "filename": "tests/e2e/utils/ty-assert.ts",
      "status": "modified",
      "additions": 21,
      "deletions": 2,
      "changes": 23,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/utils/ty-assert.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/utils/ty-assert.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/utils/ty-assert.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -6,11 +6,28 @@ interface TyAssert {\n }\n \n \n+function toPrettyString(sth): string {\n+  if (_.isObject(sth)) return JSON.stringify(sth, undefined, 2);\n+  return `${sth}`;\n+}\n+\n+\n const tyAssert: any = {   // : any = works around:\n               // error TS2775: Assertions require every name in the call target\n               // to be declared with an explicit type annotation.\n   ...assert,\n \n+  ok: (test, message: string, sth?) => {\n+    const wholeMessage = message + (sth ? toPrettyString(sth) : '');\n+    assert.ok(test, wholeMessage);\n+  },\n+\n+\n+  fail: (message: string, sth?) => {\n+    const wholeMessage = message + (sth ? toPrettyString(sth) : '');\n+    assert.fail(wholeMessage);\n+  },\n+\n   // Maybe might as well always use this one, instead of  strictEqual  sometimes?\n   // Could do that change later — but start with deepEq as a separate fn.\n   deepEq: assert.deepStrictEqual,\n@@ -26,7 +43,7 @@ const tyAssert: any = {   // : any = works around:\n       `    should not be:  ${JSON.stringify(wrongValue)}\\n`);\n   },\n \n-  eq: (actual, expected, message?) => {\n+  eq: (actual, expected, message?: string, detailsObj?) => {\n     // Show the two values on two lines, aligned, so one sees at a glance\n     // what's wrong.\n     let wholeMessage = '\\n\\n' +\n@@ -36,7 +53,9 @@ const tyAssert: any = {   // : any = works around:\n     if (message) {\n       wholeMessage +=\n           `  Details:\\n` +\n-          `    ${message}\\n`;\n+          `    ${toPrettyString(message) +\n+                    (detailsObj ? toPrettyString(detailsObj) : '')\n+                }\\n`;\n     }\n     assert.strictEqual(actual, expected, wholeMessage);\n   },"
    },
    {
      "sha": "156dc10b0b6d309f7d671d6adacfafce09581294",
      "filename": "tests/e2e/wdio.conf.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/debiki/talkyard/blob/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/wdio.conf.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/c255d7230a48049f17f4d4117a53b541125977f0/tests/e2e/wdio.conf.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/wdio.conf.ts?ref=c255d7230a48049f17f4d4117a53b541125977f0",
      "patch": "@@ -269,15 +269,14 @@ const config: WebdriverIO.Config = {\n         logPath: 'logs',\n         installArgs: {\n           drivers: {\n-            // 81.0.4044.92\n-            chrome: { version: '81.0.4044.69' },\n+            chrome: { version: '83.0.4103.39' },\n             // Minimum Firefox version >= 60\n             firefox: { version: '0.26.0' }\n           }\n         },\n         args: {\n           drivers: {\n-            chrome: { version: '81.0.4044.69' },\n+            chrome: { version: '83.0.4103.39' },\n             firefox: { version: '0.26.0' }\n           }\n         }}])),"
    }
  ]
}

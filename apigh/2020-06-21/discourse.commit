{
  "sha": "1f053173a45fb6fa544219e8c023fde07052c823",
  "node_id": "MDY6Q29tbWl0NzU2OTU3ODoxZjA1MzE3M2E0NWZiNmZhNTQ0MjE5ZThjMDIzZmRlMDcwNTJjODIz",
  "commit": {
    "author": {
      "name": "Gerhard Schlager",
      "email": "mail@gerhard-schlager.at",
      "date": "2020-06-21T10:12:42Z"
    },
    "committer": {
      "name": "Gerhard Schlager",
      "email": "mail@gerhard-schlager.at",
      "date": "2020-06-21T10:12:42Z"
    },
    "message": "FEATURE: Import script for jForum",
    "tree": {
      "sha": "692e4e146e22dd7d725207345099c135a2db4f40",
      "url": "https://api.github.com/repos/discourse/discourse/git/trees/692e4e146e22dd7d725207345099c135a2db4f40"
    },
    "url": "https://api.github.com/repos/discourse/discourse/git/commits/1f053173a45fb6fa544219e8c023fde07052c823",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/discourse/discourse/commits/1f053173a45fb6fa544219e8c023fde07052c823",
  "html_url": "https://github.com/discourse/discourse/commit/1f053173a45fb6fa544219e8c023fde07052c823",
  "comments_url": "https://api.github.com/repos/discourse/discourse/commits/1f053173a45fb6fa544219e8c023fde07052c823/comments",
  "author": {
    "login": "gschlager",
    "id": 473736,
    "node_id": "MDQ6VXNlcjQ3MzczNg==",
    "avatar_url": "https://avatars3.githubusercontent.com/u/473736?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gschlager",
    "html_url": "https://github.com/gschlager",
    "followers_url": "https://api.github.com/users/gschlager/followers",
    "following_url": "https://api.github.com/users/gschlager/following{/other_user}",
    "gists_url": "https://api.github.com/users/gschlager/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gschlager/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gschlager/subscriptions",
    "organizations_url": "https://api.github.com/users/gschlager/orgs",
    "repos_url": "https://api.github.com/users/gschlager/repos",
    "events_url": "https://api.github.com/users/gschlager/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gschlager/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "gschlager",
    "id": 473736,
    "node_id": "MDQ6VXNlcjQ3MzczNg==",
    "avatar_url": "https://avatars3.githubusercontent.com/u/473736?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gschlager",
    "html_url": "https://github.com/gschlager",
    "followers_url": "https://api.github.com/users/gschlager/followers",
    "following_url": "https://api.github.com/users/gschlager/following{/other_user}",
    "gists_url": "https://api.github.com/users/gschlager/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gschlager/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gschlager/subscriptions",
    "organizations_url": "https://api.github.com/users/gschlager/orgs",
    "repos_url": "https://api.github.com/users/gschlager/repos",
    "events_url": "https://api.github.com/users/gschlager/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gschlager/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "390dc5c7a99c9d717f58fea238537a00075ba107",
      "url": "https://api.github.com/repos/discourse/discourse/commits/390dc5c7a99c9d717f58fea238537a00075ba107",
      "html_url": "https://github.com/discourse/discourse/commit/390dc5c7a99c9d717f58fea238537a00075ba107"
    }
  ],
  "stats": {
    "total": 619,
    "additions": 619,
    "deletions": 0
  },
  "files": [
    {
      "sha": "1f52412c593926a2b7d11ce2f66a3d0f85c03bc3",
      "filename": "script/import_scripts/jforum.rb",
      "status": "added",
      "additions": 586,
      "deletions": 0,
      "changes": 586,
      "blob_url": "https://github.com/discourse/discourse/blob/1f053173a45fb6fa544219e8c023fde07052c823/script/import_scripts/jforum.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/1f053173a45fb6fa544219e8c023fde07052c823/script/import_scripts/jforum.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/script/import_scripts/jforum.rb?ref=1f053173a45fb6fa544219e8c023fde07052c823",
      "patch": "@@ -0,0 +1,586 @@\n+# frozen_string_literal: true\n+\n+require \"mysql2\"\n+require_relative 'base'\n+\n+class ImportScripts::JForum < ImportScripts::Base\n+  BATCH_SIZE = 1000\n+  REMOTE_AVATAR_REGEX ||= /\\Ahttps?:\\/\\//i\n+\n+  def initialize\n+    super\n+\n+    @settings = YAML.load(File.read(ARGV.first), symbolize_names: true)\n+\n+    @database_client = Mysql2::Client.new(\n+      host: @settings[:database][:host],\n+      port: @settings[:database][:port],\n+      username: @settings[:database][:username],\n+      password: @settings[:database][:password],\n+      database: @settings[:database][:schema],\n+      reconnect: true\n+    )\n+  end\n+\n+  def execute\n+    import_users\n+\n+    if @settings[:import_categories_as_tags]\n+      import_tags\n+    else\n+      import_categories\n+    end\n+\n+    import_posts\n+    import_likes\n+    import_category_subscriptions\n+    import_topic_subscriptions\n+    mark_topics_as_solved\n+  end\n+\n+  def import_users\n+    puts '', 'creating users'\n+    total_count = count(\"SELECT COUNT(1) AS count FROM jforum_users\")\n+    last_user_id = 0\n+\n+    custom_fields_query = user_custom_fields_query\n+\n+    batches do |offset|\n+      rows, last_user_id = query(<<~SQL, :user_id)\n+        SELECT user_id, username, user_lastvisit, user_regdate, user_email, user_from, user_active,\n+               user_avatar, COALESCE(user_realname, CONCAT(first_name, ' ', last_name)) AS name\n+               #{custom_fields_query}\n+        FROM jforum_users\n+        WHERE user_id > #{last_user_id}\n+        ORDER BY user_id\n+        LIMIT #{BATCH_SIZE}\n+      SQL\n+      break if rows.size < 1\n+\n+      next if all_records_exist?(:users, rows.map { |row| row[:user_id] })\n+\n+      create_users(rows, total: total_count, offset: offset) do |row|\n+        {\n+          id: row[:user_id],\n+          email: row[:user_email]&.strip,\n+          name: row[:name],\n+          created_at: row[:user_regdate],\n+          last_seen_at: row[:user_lastvisit],\n+          active: row[:user_active] == 1,\n+          location: row[:user_from],\n+          custom_fields: user_custom_fields(row),\n+          post_create_action: proc do |user|\n+            import_avatar(user, row[:user_avatar])\n+          end\n+        }\n+      end\n+    end\n+  end\n+\n+  def user_custom_fields_query\n+    return \"\" if @settings[:custom_fields].blank?\n+\n+    columns = []\n+    @settings[:custom_fields].map do |field|\n+      columns << (field[:alias] ? \"#{field[:column]} AS #{field[:alias]}\" : field[:column])\n+    end\n+    \", #{columns.join(', ')}\"\n+  end\n+\n+  def user_fields\n+    @user_fields ||= begin\n+      Hash[UserField.all.map { |field| [field.name, field] }]\n+    end\n+  end\n+\n+  def user_custom_fields(row)\n+    return nil if @settings[:custom_fields].blank?\n+\n+    custom_fields = {}\n+\n+    @settings[:custom_fields].map do |field|\n+      column = field[:alias] || field[:column]\n+      value = row[column.to_sym]\n+      user_field = user_fields[field[:name]]\n+\n+      case user_field.field_type\n+      when \"confirm\"\n+        value = value == 1 ? true : nil\n+      when \"dropdown\"\n+        value = user_field.user_field_options.find { |option| option.value == value } ? value : nil\n+      end\n+\n+      custom_fields[\"user_field_#{user_field.id}\"] = value if value.present?\n+    end\n+\n+    custom_fields\n+  end\n+\n+  def import_avatar(user, avatar_source)\n+    return if avatar_source.blank?\n+\n+    path = File.join(@settings[:avatar_directory], avatar_source)\n+\n+    if File.file?(path)\n+      @uploader.create_avatar(user, path)\n+    elsif avatar_source.match?(REMOTE_AVATAR_REGEX)\n+      UserAvatar.import_url_for_user(avatar_source, user) rescue nil\n+    end\n+  end\n+\n+  def import_tags\n+    puts \"\", \"creating tags\"\n+\n+    @tags_by_import_forum_id = {}\n+\n+    SiteSetting.tagging_enabled = true\n+    SiteSetting.max_tag_length = 100\n+    SiteSetting.max_tags_per_topic = 10\n+    SiteSetting.force_lowercase_tags = false\n+\n+    additional_tags = Array.wrap(@settings[:additional_tags])\n+\n+    rows = query(<<~SQL)\n+      SELECT c.categories_id, c.title AS category_name, f.forum_id, f.forum_name\n+      FROM jforum_forums f\n+        JOIN jforum_categories c ON f.categories_id = c.categories_id\n+      WHERE EXISTS (\n+        SELECT 1\n+        FROM jforum_posts p\n+        WHERE p.forum_id = f.forum_id\n+      )\n+    SQL\n+\n+    rows.each do |row|\n+      tag_names = [row[:category_name], row[:forum_name]]\n+\n+      additional_tags.each do |additional_tag|\n+        if additional_tag[:old_category_name].match?(row[:category_name])\n+          tag_names += additional_tag[:tag_names]\n+        end\n+      end\n+\n+      tag_names.map! { |t| t.parameterize(preserve_case: true) }\n+\n+      tag_names.each_with_index do |tag_name, index|\n+        tag = create_tag(tag_name)\n+        next if tag.blank?\n+\n+        case index\n+        when 0\n+          url = File.join(@settings[:permalink_prefix], \"forums/list/#{row[:categories_id]}.page\")\n+          Permalink.create(url: url, tag_id: tag.id) unless Permalink.find_by(url: url)\n+        when 1\n+          url = File.join(@settings[:permalink_prefix], \"forums/show/#{row[:forum_id]}.page\")\n+          Permalink.create(url: url, tag_id: tag.id) unless Permalink.find_by(url: url)\n+        end\n+      end\n+\n+      @tags_by_import_forum_id[row[:forum_id]] = tag_names.uniq\n+    end\n+\n+    category_mappings = Array.wrap(@settings[:category_mappings])\n+\n+    if category_mappings.blank?\n+      rows.each do |row|\n+        category_mappings.each do |mapping|\n+          if mapping[:old_category_name].match?(row[:category_name])\n+            @lookup.add_category(row[:forum_id], Category.find(mapping[:category_id]))\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  def create_tag(tag_name)\n+    tag = Tag.find_by_name(tag_name)\n+\n+    if tag\n+      # update if the case is different\n+      tag.update!(name: tag_name) if tag.name != tag_name\n+      nil\n+    else\n+      Tag.create!(name: tag_name)\n+    end\n+  end\n+\n+  def import_categories\n+    puts \"\", \"creating categories\"\n+\n+    rows = query(<<~SQL)\n+      SELECT categories_id, title, display_order\n+      FROM jforum_categories\n+      ORDER BY display_order\n+    SQL\n+\n+    create_categories(rows) do |row|\n+      {\n+        id: \"C#{row[:categories_id]}\",\n+        name: row[:title],\n+        position: row[:display_order],\n+        post_create_action: proc do |category|\n+          url = File.join(@settings[:permalink_prefix], \"forums/list/#{row[:categories_id]}.page\")\n+          Permalink.create(url: url, category_id: category.id) unless Permalink.find_by(url: url)\n+        end\n+      }\n+    end\n+\n+    rows = query(<<~SQL)\n+      SELECT forum_id, categories_id, forum_name, forum_desc, forum_order\n+      FROM jforum_categories\n+      ORDER BY categories_id, forum_order\n+    SQL\n+\n+    create_categories(rows) do |row|\n+      {\n+        id: row[:forum_id],\n+        name: row[:forum_name],\n+        description: row[:forum_desc],\n+        position: row[:forum_order],\n+        parent_category_id: @lookup.category_id_from_imported_category_id(\"C#{row[:categories_id]}\"),\n+        post_create_action: proc do |category|\n+          url = File.join(@settings[:permalink_prefix], \"forums/show/#{row[:forum_id]}.page\")\n+          Permalink.create(url: url, category_id: category.id) unless Permalink.find_by(url: url)\n+        end\n+      }\n+    end\n+  end\n+\n+  def import_posts\n+    puts '', 'creating topics and posts'\n+    total_count = count(\"SELECT COUNT(1) AS count FROM jforum_posts\")\n+    last_post_id = 0\n+\n+    batches do |offset|\n+      rows, last_post_id = query(<<~SQL, :post_id)\n+        SELECT p.post_id, p.topic_id, p.user_id, t.topic_title, pt.post_text, p.post_time, t.topic_status,\n+               t.topic_type, t.topic_views, p.poster_ip, p.forum_id, t.topic_acceptedanswer_post_id,\n+               EXISTS (SELECT 1 FROM jforum_attach a WHERE a.post_id = p.post_id) AS has_attachments,\n+               COALESCE(\n+                 (SELECT x.post_id FROM jforum_posts x WHERE x.post_id = t.topic_first_post_id),\n+                 (SELECT MIN(x.post_id) FROM jforum_posts x WHERE x.topic_id = t.topic_id)\n+               ) AS topic_first_post_id\n+        FROM jforum_posts p\n+            JOIN jforum_topics t ON p.topic_id = t.topic_id\n+            LEFT OUTER JOIN jforum_posts_text pt ON p.post_id = pt.post_id\n+        WHERE p.post_id > #{last_post_id}\n+        ORDER BY p.post_id\n+        LIMIT #{BATCH_SIZE}\n+      SQL\n+      break if rows.size < 1\n+\n+      next if all_records_exist?(:posts, rows.map { |row| row[:post_id] })\n+\n+      create_posts(rows, total: total_count, offset: offset) do |row|\n+        user_id = @lookup.user_id_from_imported_user_id(row[:user_id]) || Discourse::SYSTEM_USER_ID\n+        is_first_post = row[:post_id] == row[:topic_first_post_id]\n+        post_text = fix_bbcodes(row[:post_text])\n+\n+        if row[:has_attachments] > 0\n+          attachments = import_attachments(row[:post_id], user_id)\n+          post_text << \"\\n\" << attachments.join(\"\\n\")\n+        end\n+\n+        mapped = {\n+          id: row[:post_id],\n+          user_id: user_id,\n+          created_at: row[:post_time],\n+          raw: post_text,\n+          import_topic_id: row[:topic_id]\n+        }\n+\n+        if row[:topic_acceptedanswer_post_id] == row[:post_id]\n+          mapped[:custom_fields] = { is_accepted_answer: \"true\" }\n+        end\n+\n+        if is_first_post\n+          map_first_post(row, mapped)\n+        else\n+          map_other_post(row, mapped)\n+        end\n+      end\n+    end\n+  end\n+\n+  def map_first_post(row, mapped)\n+    mapped[:title] = CGI.unescapeHTML(row[:topic_title]).strip[0...255]\n+    mapped[:views] = row[:topic_views]\n+    mapped[:post_create_action] = proc do |post|\n+      url = File.join(@settings[:permalink_prefix], \"posts/list/#{row[:topic_id]}.page\")\n+      Permalink.create(url: url, topic_id: post.topic.id) unless Permalink.find_by(url: url)\n+\n+      TopicViewItem.add(post.topic_id, row[:poster_ip], post.user_id, post.created_at, true)\n+    end\n+\n+    mapped[:tags] = @tags_by_import_forum_id[row[:forum_id]] if @settings[:import_categories_as_tags]\n+    mapped[:category] = @lookup.category_id_from_imported_category_id(row[:forum_id])\n+\n+    mapped\n+  end\n+\n+  def map_other_post(row, mapped)\n+    parent = @lookup.topic_lookup_from_imported_post_id(row[:topic_first_post_id])\n+\n+    if parent.blank?\n+      puts \"Parent post #{row[:topic_first_post_id]} doesn't exist. Skipping #{row[:post_id]}: #{row[:topic_title][0..40]}\"\n+      return nil\n+    end\n+\n+    mapped[:topic_id] = parent[:topic_id]\n+    mapped[:post_create_action] = proc do |post|\n+      TopicViewItem.add(post.topic_id, row[:poster_ip], post.user_id, post.created_at, true)\n+    end\n+\n+    mapped\n+  end\n+\n+  def import_attachments(post_id, user_id)\n+    rows = query(<<~SQL)\n+      SELECT d.physical_filename, d.real_filename\n+      FROM jforum_attach a\n+        JOIN jforum_attach_desc d USING (attach_id)\n+      WHERE a.post_id = #{post_id}\n+      ORDER BY a.attach_id\n+    SQL\n+    return nil if rows.size < 1\n+\n+    attachments = []\n+\n+    rows.each do |row|\n+      path = File.join(@settings[:attachment_directory], row[:physical_filename])\n+      filename = CGI.unescapeHTML(row[:real_filename])\n+      upload = @uploader.create_upload(user_id, path, filename)\n+\n+      if upload.nil? || !upload.persisted?\n+        puts \"Failed to upload #{path}\"\n+        puts upload.errors.inspect if upload\n+      else\n+        attachments << @uploader.html_for_upload(upload, filename)\n+      end\n+    end\n+\n+    attachments\n+  end\n+\n+  def mark_topics_as_solved\n+    puts \"\", \"Marking topics as solved...\"\n+\n+    DB.exec <<~SQL\n+      INSERT INTO topic_custom_fields (name, value, topic_id, created_at, updated_at)\n+      SELECT 'accepted_answer_post_id', pcf.post_id, p.topic_id, p.created_at, p.created_at\n+        FROM post_custom_fields pcf\n+        JOIN posts p ON p.id = pcf.post_id\n+       WHERE pcf.name = 'is_accepted_answer' AND pcf.value = 'true'\n+         AND NOT EXISTS (\n+           SELECT 1\n+           FROM topic_custom_fields x\n+           WHERE x.topic_id = p.topic_id AND x.name = 'accepted_answer_post_id'\n+         )\n+    SQL\n+  end\n+\n+  def import_likes\n+    puts \"\", \"Importing likes...\"\n+    total_count = count(<<~SQL)\n+      SELECT COUNT(1) AS count\n+      FROM jforum_karma k\n+      WHERE k.points >= 2\n+        AND EXISTS (SELECT 1 FROM jforum_posts p WHERE k.post_id = p.post_id)\n+        AND EXISTS (SELECT 1 FROM jforum_users u WHERE k.from_user_id = u.user_id)\n+    SQL\n+    current_index = 0\n+    last_post_id = 0\n+    last_user_id = 0\n+\n+    batches do |_|\n+      rows, last_post_id, last_user_id = query(<<~SQL, :post_id, :from_user_id)\n+        SELECT k.post_id, k.from_user_id, k.rate_date\n+        FROM jforum_karma k\n+        WHERE k.points >= 2 AND ((k.post_id = #{last_post_id} AND k.from_user_id > #{last_user_id}) OR k.post_id > #{last_post_id})\n+          AND EXISTS (SELECT 1 FROM jforum_posts p WHERE k.post_id = p.post_id)\n+          AND EXISTS (SELECT 1 FROM jforum_users u WHERE k.from_user_id = u.user_id) \n+        ORDER BY k.post_id, k.from_user_id\n+        LIMIT #{BATCH_SIZE}\n+      SQL\n+      break if rows.size < 1\n+\n+      rows.each do |row|\n+        created_by = User.find_by(id: @lookup.user_id_from_imported_user_id(row[:from_user_id]))\n+        post = Post.find_by(id: @lookup.post_id_from_imported_post_id(row[:post_id]))\n+\n+        if created_by && post\n+          PostActionCreator.create(created_by, post, :like, created_at: row[:rate_date])\n+        end\n+\n+        current_index += 1\n+        print_status(current_index, total_count, get_start_time(\"likes\"))\n+      end\n+    end\n+  end\n+\n+  def import_category_subscriptions\n+    puts \"\", \"Importing category subscriptions...\"\n+    total_count = count(<<~SQL)\n+      SELECT COUNT(1) AS count\n+      FROM (\n+               SELECT forum_id, user_id\n+               FROM jforum_forums_watch\n+               UNION\n+               SELECT forum_id, user_id\n+               FROM jforum_digest_forums\n+           ) x\n+      WHERE EXISTS (SELECT 1 FROM jforum_forums f WHERE x.forum_id = f.forum_id)\n+    SQL\n+    current_index = 0\n+    last_forum_id = 0\n+    last_user_id = 0\n+\n+    batches do |_|\n+      rows, last_forum_id, last_user_id = query(<<~SQL, :forum_id, :user_id)\n+        SELECT x.forum_id, x.user_id\n+        FROM jforum_forums_watch x\n+        WHERE ((x.forum_id = #{last_forum_id} AND x.user_id > #{last_user_id}) OR x.forum_id > #{last_forum_id})\n+          AND EXISTS (SELECT 1 FROM jforum_forums f WHERE x.forum_id = f.forum_id)\n+        UNION\n+        SELECT forum_id, user_id\n+        FROM jforum_digest_forums x\n+        WHERE ((x.forum_id = #{last_forum_id} AND x.user_id > #{last_user_id}) OR x.forum_id > #{last_forum_id})\n+          AND EXISTS (SELECT 1 FROM jforum_forums f WHERE x.forum_id = f.forum_id)\n+        ORDER BY forum_id, user_id\n+        LIMIT #{BATCH_SIZE}\n+      SQL\n+      break if rows.size < 1\n+\n+      tags = Tag.all.pluck(:name, :id).to_h\n+\n+      rows.each do |row|\n+        user_id = @lookup.user_id_from_imported_user_id(row[:user_id])\n+\n+        if @settings[:import_categories_as_tags]\n+          tag_names = @tags_by_import_forum_id[row[:forum_id]]\n+          tag_ids = tag_names ? tag_names.map { |name| tags[name] } : nil\n+\n+          if user_id && tag_ids.present?\n+            tag_ids.each do |tag_id|\n+              TagUser.change(user_id, tag_id, TagUser.notification_levels[:watching])\n+            end\n+          end\n+        else\n+          user = User.find_by(id: user_id)\n+          category_id = @lookup.category_id_from_imported_category_id(row[:forum_id])\n+\n+          if user && category_id\n+            CategoryUser.set_notification_level_for_category(user, NotificationLevels.all[:watching], category_id)\n+          end\n+        end\n+\n+        current_index += 1\n+        print_status(current_index, total_count, get_start_time(\"category_subscriptions\"))\n+      end\n+    end\n+  end\n+\n+  def import_topic_subscriptions\n+    puts \"\", \"Importing topic subscriptions...\"\n+    total_count = count(<<~SQL)\n+      SELECT COUNT(1) AS count\n+      FROM jforum_topics_watch x\n+      WHERE EXISTS (SELECT 1 FROM jforum_topics t WHERE x.topic_id = t.topic_id)\n+    SQL\n+    current_index = 0\n+    last_topic_id = 0\n+    last_user_id = 0\n+\n+    batches do |_|\n+      rows, last_topic_id, last_user_id = query(<<~SQL, :topic_id, :user_id)\n+        SELECT x.topic_id, x.user_id,\n+          COALESCE(\n+            (SELECT x.post_id FROM jforum_posts x WHERE x.post_id = t.topic_first_post_id),\n+            (SELECT MIN(x.post_id) FROM jforum_posts x WHERE x.topic_id = t.topic_id)\n+          ) AS topic_first_post_id\n+        FROM jforum_topics_watch x\n+          JOIN jforum_topics t ON x.topic_id = t.topic_id\n+        WHERE ((x.topic_id = #{last_topic_id} AND x.user_id > #{last_user_id}) OR x.topic_id > #{last_topic_id})\n+        ORDER BY topic_id, user_id\n+        LIMIT #{BATCH_SIZE}\n+      SQL\n+      break if rows.size < 1\n+\n+      rows.each do |row|\n+        user_id = @lookup.user_id_from_imported_user_id(row[:user_id])\n+        topic = @lookup.topic_lookup_from_imported_post_id(row[:topic_first_post_id])\n+\n+        if user_id && topic\n+          TopicUser.change(user_id, topic[:topic_id], notification_level: NotificationLevels.all[:watching])\n+        end\n+\n+        current_index += 1\n+        print_status(current_index, total_count, get_start_time(\"topic_subscriptions\"))\n+      end\n+    end\n+  end\n+\n+  def fix_bbcodes(text)\n+    return text if text.blank?\n+\n+    text = text.dup\n+    text.gsub!(/\\r\\n/, \"\\n\")\n+\n+    fix_bbcode_tag!(tag: \"quote\", text: text)\n+    fix_bbcode_tag!(tag: \"code\", text: text)\n+    fix_bbcode_tag!(tag: \"list\", text: text)\n+    fix_bbcode_tag!(tag: \"center\", text: text)\n+    fix_bbcode_tag!(tag: \"right\", text: text)\n+    fix_bbcode_tag!(tag: \"left\", text: text)\n+\n+    fix_inline_bbcode!(tag: \"i\", text: text)\n+    fix_inline_bbcode!(tag: \"b\", text: text)\n+    fix_inline_bbcode!(tag: \"s\", text: text)\n+    fix_inline_bbcode!(tag: \"u\", text: text)\n+    fix_inline_bbcode!(tag: \"size\", text: text)\n+    fix_inline_bbcode!(tag: \"font\", text: text)\n+    fix_inline_bbcode!(tag: \"color\", text: text)\n+\n+    text\n+  end\n+\n+  def fix_bbcode_tag!(tag:, text:)\n+    text.gsub!(/\\s+(\\[#{tag}\\].*?\\[\\/#{tag}\\])/im, '\\1')\n+\n+    text.gsub!(/(\\[#{tag}.*?\\])(?!$)/i) { \"#{$1}\\n\" }\n+    text.gsub!(/((?<!^)\\[#{tag}.*?\\])/i) { \"\\n#{$1}\" }\n+\n+    text.gsub!(/(\\[\\/#{tag}\\])(?!$)/i) { \"#{$1}\\n\" }\n+    text.gsub!(/((?<!^)\\[\\/#{tag}\\])/i) { \"\\n#{$1}\" }\n+  end\n+\n+  def fix_inline_bbcode!(tag:, text:)\n+    text.gsub!(/\\[(#{tag}.*?)\\](.*?)\\[\\/#{tag}\\]/im) do\n+      beginning_tag = $1\n+      content = $2.gsub(/(\\n{2,})/) { \"[/#{tag}]#{$1}[#{beginning_tag}]\" }\n+      \"[#{beginning_tag}]#{content}[/#{tag}]\"\n+    end\n+  end\n+\n+  def batches\n+    super(BATCH_SIZE)\n+  end\n+\n+  def query(sql, *last_columns)\n+    rows = @database_client.query(sql, cache_rows: true, symbolize_keys: true)\n+    return rows if last_columns.length == 0\n+\n+    result = [rows]\n+    last_row = rows.to_a.last\n+\n+    last_columns.each { |column| result.push(last_row ? last_row[column] : nil) }\n+    result\n+  end\n+\n+  # Executes a database query and returns the value of the 'count' column.\n+  def count(sql)\n+    query(sql).first[:count]\n+  end\n+end\n+\n+ImportScripts::JForum.new.perform"
    },
    {
      "sha": "5eca85c3fc56cb6ad9225c78730ca279f7ba8f5b",
      "filename": "script/import_scripts/settings/jforum.yml",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/discourse/discourse/blob/1f053173a45fb6fa544219e8c023fde07052c823/script/import_scripts/settings/jforum.yml",
      "raw_url": "https://github.com/discourse/discourse/raw/1f053173a45fb6fa544219e8c023fde07052c823/script/import_scripts/settings/jforum.yml",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/script/import_scripts/settings/jforum.yml?ref=1f053173a45fb6fa544219e8c023fde07052c823",
      "patch": "@@ -0,0 +1,33 @@\n+database:\n+  host: localhost\n+  port: 3306\n+  username: root\n+  password: password\n+  schema: db_name\n+\n+avatar_directory: /shared/import/avatar\n+attachment_directory: /shared/import/upload\n+\n+# folder name of old forum in URL\n+permalink_prefix: foo\n+\n+import_categories_as_tags: true\n+\n+additional_tags:\n+  - old_category_name: !ruby/regexp '/something/'\n+    tag_names:\n+      - \"Foo\"\n+      - \"Bar\"\n+\n+category_mappings:\n+  - old_category_name: !ruby/regexp '/HIDDEN/'\n+    category_id: 23\n+\n+custom_fields:\n+  - name: \"State\"\n+    column: \"state_porvince\"\n+  - name: \"Country\"\n+    column: \"user_from\"\n+  - name: \"Company\"\n+    column: \"company_name\"\n+    alias: \"company\""
    }
  ]
}

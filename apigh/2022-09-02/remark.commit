{
  "sha": "9ad3be2e97c658337a8e05edd744a5863607cf97",
  "node_id": "C_kwDOBtgov9oAKDlhZDNiZTJlOTdjNjU4MzM3YThlMDVlZGQ3NDRhNTg2MzYwN2NmOTc",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2022-08-26T21:05:28Z"
    },
    "committer": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2022-08-26T21:35:57Z"
    },
    "message": "bump go modules, make auth dev hostname customisable\n\nAfter this commit, dev auth would start working with the `REMARK_URL`\nhostname instead of the previously hardcoded 127.0.0.1.\n\nBreaks development setup where `REMARK_URL` was set\nto a non-standard value and dev auth was running on 127.0.0.1\nand working, as, after that change, it would stop working.",
    "tree": {
      "sha": "20f4e5460a06b5bedd9b0bb6a26ce17b4fd7e7ee",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/20f4e5460a06b5bedd9b0bb6a26ce17b4fd7e7ee"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/9ad3be2e97c658337a8e05edd744a5863607cf97",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/9ad3be2e97c658337a8e05edd744a5863607cf97",
  "html_url": "https://github.com/umputun/remark42/commit/9ad3be2e97c658337a8e05edd744a5863607cf97",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/9ad3be2e97c658337a8e05edd744a5863607cf97/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "url": "https://api.github.com/repos/umputun/remark42/commits/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "html_url": "https://github.com/umputun/remark42/commit/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5"
    }
  ],
  "stats": {
    "total": 19565,
    "additions": 12629,
    "deletions": 6936
  },
  "files": [
    {
      "sha": "eedaec9fe8449c89437ca6f65977a85fec54efef",
      "filename": "backend/_example/memory_store/go.mod",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2F_example%2Fmemory_store%2Fgo.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2F_example%2Fmemory_store%2Fgo.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F_example%2Fmemory_store%2Fgo.mod?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -13,6 +13,7 @@ require (\n require (\n \tgithub.com/Depado/bfchroma/v2 v2.0.0 // indirect\n \tgithub.com/PuerkitoBio/goquery v1.8.0 // indirect\n+\tgithub.com/ajg/form v1.5.1 // indirect\n \tgithub.com/alecthomas/chroma/v2 v2.2.0 // indirect\n \tgithub.com/andybalholm/cascadia v1.3.1 // indirect\n \tgithub.com/aymerick/douceur v0.2.0 // indirect\n@@ -21,7 +22,7 @@ require (\n \tgithub.com/didip/tollbooth_chi v0.0.0-20220719025231-d662a7f6928f // indirect\n \tgithub.com/dlclark/regexp2 v1.4.0 // indirect\n \tgithub.com/go-chi/chi/v5 v5.0.7 // indirect\n-\tgithub.com/go-chi/render v1.0.1 // indirect\n+\tgithub.com/go-chi/render v1.0.2 // indirect\n \tgithub.com/go-pkgz/expirable-cache v0.1.0 // indirect\n \tgithub.com/go-pkgz/rest v1.15.6 // indirect\n \tgithub.com/gorilla/css v1.0.0 // indirect"
    },
    {
      "sha": "0ff34f5662a3deb9ffa34207f24672fa795ad7b7",
      "filename": "backend/_example/memory_store/go.sum",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2F_example%2Fmemory_store%2Fgo.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2F_example%2Fmemory_store%2Fgo.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F_example%2Fmemory_store%2Fgo.sum?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -2,6 +2,8 @@ github.com/Depado/bfchroma/v2 v2.0.0 h1:IRpN9BPkNwEpR6w1ectIcNWOuhDSLx+8f1pn83fz\n github.com/Depado/bfchroma/v2 v2.0.0/go.mod h1:wFwW/Pw8Tnd0irzgO9Zxtxgzp3aPS8qBWlyadxujxmw=\n github.com/PuerkitoBio/goquery v1.8.0 h1:PJTF7AmFCFKk1N6V6jmKfrNH9tV5pNE6lZMkG0gta/U=\n github.com/PuerkitoBio/goquery v1.8.0/go.mod h1:ypIiRMtY7COPGk+I/YbZLbxsxn9g5ejnI2HSMtkjZvI=\n+github.com/ajg/form v1.5.1 h1:t9c7v8JUKu/XxOGBU0yjNpaMloxGEJhUkqFRq0ibGeU=\n+github.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=\n github.com/alecthomas/chroma/v2 v2.2.0 h1:Aten8jfQwUqEdadVFFjNyjx7HTexhKP0XuqBG67mRDY=\n github.com/alecthomas/chroma/v2 v2.2.0/go.mod h1:vf4zrexSH54oEjJ7EdB65tGNHmH3pGZmVkgTP5RHvAs=\n github.com/alecthomas/repr v0.0.0-20220113201626-b1b626ac65ae h1:zzGwJfFlFGD94CyyYwCJeSuD32Gj9GTaSi5y9hoVzdY=\n@@ -20,8 +22,9 @@ github.com/dlclark/regexp2 v1.4.0 h1:F1rxgk7p4uKjwIQxBs9oAXe5CqrXlCduYEJvrF4u93E\n github.com/dlclark/regexp2 v1.4.0/go.mod h1:2pZnwuY/m+8K6iRw6wQdMtk+rH5tNGR1i55kozfMjCc=\n github.com/go-chi/chi/v5 v5.0.7 h1:rDTPXLDHGATaeHvVlLcR4Qe0zftYethFucbjVQ1PxU8=\n github.com/go-chi/chi/v5 v5.0.7/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=\n-github.com/go-chi/render v1.0.1 h1:4/5tis2cKaNdnv9zFLfXzcquC9HbeZgCnxGnKrltBS8=\n github.com/go-chi/render v1.0.1/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n+github.com/go-chi/render v1.0.2 h1:4ER/udB0+fMWB2Jlf15RV3F4A2FDuYi/9f+lFttR/Lg=\n+github.com/go-chi/render v1.0.2/go.mod h1:/gr3hVkmYR0YlEy3LxCuVRFzEu9Ruok+gFqbIofjao0=\n github.com/go-pkgz/expirable-cache v0.1.0 h1:3bw0m8vlTK8qlwz5KXuygNBTkiKRTPrAGXU0Ej2AC1g=\n github.com/go-pkgz/expirable-cache v0.1.0/go.mod h1:GTrEl0X+q0mPNqN6dtcQXksACnzCBQ5k/k1SwXJsZKs=\n github.com/go-pkgz/jrpc v0.3.0 h1:Fls38KqPsHzvp0FWfivr6cGnncC+iFBodHBqvUPY+0U="
    },
    {
      "sha": "c61e3e9335af32fe944e1395844beffe2c48ac27",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fapp%2Fcmd%2Fserver.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fapp%2Fcmd%2Fserver.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -865,7 +865,11 @@ func (s *ServerCommand) addAuthProviders(authenticator *auth.Service) error {\n \n \tif s.Auth.Dev {\n \t\tlog.Print(\"[INFO] dev access enabled\")\n-\t\tauthenticator.AddProvider(\"dev\", \"\", \"\")\n+\t\tu, errURL := url.Parse(s.RemarkURL)\n+\t\tif errURL != nil {\n+\t\t\treturn fmt.Errorf(\"can't parse Remark42 URL: %w\", errURL)\n+\t\t}\n+\t\tauthenticator.AddDevProvider(u.Hostname(), 8084)\n \t\tprovidersCount++\n \t}\n "
    },
    {
      "sha": "b6b402f7897598c20636e4e9cdcff5e14f1963ff",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 8,
      "deletions": 5,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fgo.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fgo.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fgo.mod?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -10,10 +10,10 @@ require (\n \tgithub.com/didip/tollbooth_chi v0.0.0-20220719025231-d662a7f6928f\n \tgithub.com/go-chi/chi/v5 v5.0.7\n \tgithub.com/go-chi/cors v1.2.1\n-\tgithub.com/go-chi/render v1.0.1\n-\tgithub.com/go-pkgz/auth v1.19.1-0.20220624002401-8b91a0eee69a\n+\tgithub.com/go-chi/render v1.0.2\n+\tgithub.com/go-pkgz/auth v1.19.1\n \tgithub.com/go-pkgz/jrpc v0.3.0\n-\tgithub.com/go-pkgz/lcw v0.8.1\n+\tgithub.com/go-pkgz/lcw v1.0.1\n \tgithub.com/go-pkgz/lgr v0.10.4\n \tgithub.com/go-pkgz/notify v0.1.1\n \tgithub.com/go-pkgz/repeater v1.1.3\n@@ -24,7 +24,7 @@ require (\n \tgithub.com/gorilla/feeds v1.1.1\n \tgithub.com/hashicorp/go-multierror v1.1.1\n \tgithub.com/jessevdk/go-flags v1.5.0\n-\tgithub.com/kyokomi/emoji/v2 v2.2.9\n+\tgithub.com/kyokomi/emoji/v2 v2.2.10\n \tgithub.com/microcosm-cc/bluemonday v1.0.19\n \tgithub.com/rs/xid v1.4.0\n \tgithub.com/russross/blackfriday/v2 v2.1.0\n@@ -39,15 +39,18 @@ require (\n \n require (\n \tcloud.google.com/go/compute v1.6.1 // indirect\n+\tgithub.com/ajg/form v1.5.1 // indirect\n \tgithub.com/andybalholm/cascadia v1.3.1 // indirect\n \tgithub.com/aymerick/douceur v0.2.0 // indirect\n+\tgithub.com/cespare/xxhash/v2 v2.1.2 // indirect\n \tgithub.com/davecgh/go-spew v1.1.1 // indirect\n \tgithub.com/dghubble/oauth1 v0.7.1 // indirect\n+\tgithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect\n \tgithub.com/dlclark/regexp2 v1.4.0 // indirect\n \tgithub.com/go-oauth2/oauth2/v4 v4.4.3 // indirect\n \tgithub.com/go-pkgz/email v0.3.0 // indirect\n \tgithub.com/go-pkgz/expirable-cache v0.1.0 // indirect\n-\tgithub.com/go-redis/redis/v7 v7.4.1 // indirect\n+\tgithub.com/go-redis/redis/v8 v8.11.5 // indirect\n \tgithub.com/go-stack/stack v1.8.1 // indirect\n \tgithub.com/golang/protobuf v1.5.2 // indirect\n \tgithub.com/golang/snappy v0.0.4 // indirect"
    },
    {
      "sha": "8dda2ec837c17791ebeb38ddb8fc34b9dd652a0e",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 37,
      "deletions": 27,
      "changes": 64,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fgo.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fgo.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fgo.sum?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -65,10 +65,10 @@ github.com/alecthomas/chroma/v2 v2.2.0 h1:Aten8jfQwUqEdadVFFjNyjx7HTexhKP0XuqBG6\n github.com/alecthomas/chroma/v2 v2.2.0/go.mod h1:vf4zrexSH54oEjJ7EdB65tGNHmH3pGZmVkgTP5RHvAs=\n github.com/alecthomas/repr v0.0.0-20220113201626-b1b626ac65ae h1:zzGwJfFlFGD94CyyYwCJeSuD32Gj9GTaSi5y9hoVzdY=\n github.com/alecthomas/repr v0.0.0-20220113201626-b1b626ac65ae/go.mod h1:2kn6fqh/zIyPLmm3ugklbEi5hg5wS435eygvNfaDQL8=\n-github.com/alicebob/gopher-json v0.0.0-20180125190556-5a6b3ba71ee6 h1:45bxf7AZMwWcqkLzDAQugVEwedisr5nRJ1r+7LYnv0U=\n-github.com/alicebob/gopher-json v0.0.0-20180125190556-5a6b3ba71ee6/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\n-github.com/alicebob/miniredis/v2 v2.11.4 h1:GsuyeunTx7EllZBU3/6Ji3dhMQZDpC9rLf1luJ+6M5M=\n-github.com/alicebob/miniredis/v2 v2.11.4/go.mod h1:VL3UDEfAH59bSa7MuHMuFToxkqyHh69s/WUbYlOAuyg=\n+github.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a h1:HbKu58rmZpUGpz5+4FfNmIU+FmZg2P3Xaj2v2bfNWmk=\n+github.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\n+github.com/alicebob/miniredis/v2 v2.22.0 h1:lIHHiSkEyS1MkKHCHzN+0mWrA4YdbGdimE5iZ2sHSzo=\n+github.com/alicebob/miniredis/v2 v2.22.0/go.mod h1:XNqvJdQJv5mSuVMc0ynneafpnL/zv52acZ6kqeS0t88=\n github.com/andybalholm/brotli v1.0.0 h1:7UCwP93aiSfvWpapti8g88vVVGp2qqtGyePsSuDafo4=\n github.com/andybalholm/brotli v1.0.0/go.mod h1:loMXtMfwqflxFJPmdbJO0a3KNoPuLBgiu3qAvBg8x/Y=\n github.com/andybalholm/cascadia v1.3.1 h1:nhxRkql1kdYCc8Snf7D5/D3spOX+dBgjA6u8x004T2c=\n@@ -77,8 +77,11 @@ github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kd\n github.com/aymerick/douceur v0.2.0 h1:Mv+mAeH1Q+n9Fr+oyamOlAkUNPWPlA8PPGR0QAaYuPk=\n github.com/aymerick/douceur v0.2.0/go.mod h1:wlT5vV2O3h55X9m7iVYN0TBM0NH/MmbLnd30/FjWUq4=\n github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\n+github.com/cespare/xxhash v1.1.0 h1:a6HrQnmkObjyL+Gs60czilIUGqrzKutQD6XZog3p+ko=\n github.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\n github.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\n+github.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=\n+github.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\n github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\n github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\n github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\n@@ -96,6 +99,8 @@ github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c\n github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n github.com/dghubble/oauth1 v0.7.1 h1:JjbOVSVVkms9A4h/sTQy5Jb2nFuAAVb2qVYgenJPyrE=\n github.com/dghubble/oauth1 v0.7.1/go.mod h1:0eEzON0UY/OLACQrmnjgJjmvCGXzjBCsZqL1kWDXtF0=\n+github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=\n+github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=\n github.com/didip/tollbooth/v7 v7.0.0 h1:XmyyNwZpz9j61PwR4A894MmmYO5zBF9xjgVi2n1fiQI=\n github.com/didip/tollbooth/v7 v7.0.0/go.mod h1:VZhDSGl5bDSPj4wPsih3PFa4Uh9Ghv8hgacaTm5PRT4=\n github.com/didip/tollbooth_chi v0.0.0-20220719025231-d662a7f6928f h1:jtKwihcLmUC9BAhoJ9adCUqdSSZcOdH2KL7mPTUm2aw=\n@@ -124,23 +129,24 @@ github.com/go-chi/chi/v5 v5.0.7 h1:rDTPXLDHGATaeHvVlLcR4Qe0zftYethFucbjVQ1PxU8=\n github.com/go-chi/chi/v5 v5.0.7/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=\n github.com/go-chi/cors v1.2.1 h1:xEC8UT3Rlp2QuWNEr4Fs/c2EAGVKBwy/1vHx3bppil4=\n github.com/go-chi/cors v1.2.1/go.mod h1:sSbTewc+6wYHBBCW7ytsFSn836hqM7JxpglAy2Vzc58=\n-github.com/go-chi/render v1.0.1 h1:4/5tis2cKaNdnv9zFLfXzcquC9HbeZgCnxGnKrltBS8=\n github.com/go-chi/render v1.0.1/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n+github.com/go-chi/render v1.0.2 h1:4ER/udB0+fMWB2Jlf15RV3F4A2FDuYi/9f+lFttR/Lg=\n+github.com/go-chi/render v1.0.2/go.mod h1:/gr3hVkmYR0YlEy3LxCuVRFzEu9Ruok+gFqbIofjao0=\n github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\n github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\n github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\n github.com/go-oauth2/oauth2/v4 v4.4.3 h1:IiU3iAK5NEeZ4mUf5HV9tN7iNlx4AGUkIJ5M1C4ARxY=\n github.com/go-oauth2/oauth2/v4 v4.4.3/go.mod h1:NR9Hugz5/Qe2OGxoPBhsTRNjnm/amC+z9+XTwt63rhs=\n-github.com/go-pkgz/auth v1.19.1-0.20220624002401-8b91a0eee69a h1:gp0mLtawviHOwmrd6E60yxA+9GAKtpBjI1WCc/4oyAE=\n-github.com/go-pkgz/auth v1.19.1-0.20220624002401-8b91a0eee69a/go.mod h1:ncL+ePcAf9A7lCKKDAQ6aIs4MTz/Q/g5XIhRx5hap6E=\n+github.com/go-pkgz/auth v1.19.1 h1:yoxQvx6cBYJPHvMryJw+vj+/1QpjPSKERBfPL/mPGT0=\n+github.com/go-pkgz/auth v1.19.1/go.mod h1:Uex9UlbhlHamrkO14f69BuZX5n5x1CSzIxZb/En+VPw=\n github.com/go-pkgz/email v0.3.0 h1:89FbVF6trHkdn2VVoXlBfZHkdYQ1vLmQ54OhdosaFtc=\n github.com/go-pkgz/email v0.3.0/go.mod h1:TpnmSLkQW3FyICit2hn7WIhCUDrhCX6btzz5wS3wHRI=\n github.com/go-pkgz/expirable-cache v0.1.0 h1:3bw0m8vlTK8qlwz5KXuygNBTkiKRTPrAGXU0Ej2AC1g=\n github.com/go-pkgz/expirable-cache v0.1.0/go.mod h1:GTrEl0X+q0mPNqN6dtcQXksACnzCBQ5k/k1SwXJsZKs=\n github.com/go-pkgz/jrpc v0.3.0 h1:Fls38KqPsHzvp0FWfivr6cGnncC+iFBodHBqvUPY+0U=\n github.com/go-pkgz/jrpc v0.3.0/go.mod h1:MFtKs75JESiSqVicsQkgN2iDFFuCd3gVT1/vKiwRi00=\n-github.com/go-pkgz/lcw v0.8.1 h1:Bpt2yYTE1J8hIhz8tjdm1WPOgH13eo5iTNsXyop7cMQ=\n-github.com/go-pkgz/lcw v0.8.1/go.mod h1:Xw0/ZfApATgbjVPYRZO4XHdWyxAjErDWDWJ7TLlw1Vc=\n+github.com/go-pkgz/lcw v1.0.1 h1:svYC6LIyzRaHF3TwJ8GCS+2RkJreBfaFjoeS+UYwJBc=\n+github.com/go-pkgz/lcw v1.0.1/go.mod h1:CPJJzunpmGToOtD0Ga82TV152eL69sYEIIPcy9fbxlU=\n github.com/go-pkgz/lgr v0.10.4 h1:l7qyFjqEZgwRgaQQSEp6tve4A3OU80VrfzpvtEX8ngw=\n github.com/go-pkgz/lgr v0.10.4/go.mod h1:CD0s1z6EFpIUplV067gitF77tn25JItzwHNKAPqeCF0=\n github.com/go-pkgz/notify v0.1.1 h1:0EaPnBD/IX8EBVAmKnEHNesyH3rD1v6w0MBLRCwrTUI=\n@@ -152,13 +158,13 @@ github.com/go-pkgz/rest v1.15.6 h1:8RgOuY/c00CD0el8KdmscOCgDH+ML0ZsK2qa1Rcxal4=\n github.com/go-pkgz/rest v1.15.6/go.mod h1:KUWAqbDteYGS/CiXftomQsKjtEOifXsJ36Ka0skYbmk=\n github.com/go-pkgz/syncs v1.2.0 h1:aiizQFILlMZ4KtRNaYLcDffRbUQZH9fclsgr5KybWyY=\n github.com/go-pkgz/syncs v1.2.0/go.mod h1:fjThZdM2FkC/oSeiqBTOZOtHpbrCh4HuHbipB5qZJJM=\n-github.com/go-redis/redis/v7 v7.4.0/go.mod h1:JDNMw23GTyLNC4GZu9njt15ctBQVn7xjRfnwdHj/Dcg=\n-github.com/go-redis/redis/v7 v7.4.1 h1:PASvf36gyUpr2zdOUS/9Zqc80GbM+9BDyiJSJDDOrTI=\n-github.com/go-redis/redis/v7 v7.4.1/go.mod h1:JDNMw23GTyLNC4GZu9njt15ctBQVn7xjRfnwdHj/Dcg=\n+github.com/go-redis/redis/v8 v8.11.5 h1:AcZZR7igkdvfVmQTPnu9WE37LRrO/YrBH5zWyjDC0oI=\n+github.com/go-redis/redis/v8 v8.11.5/go.mod h1:gREzHqY1hg6oD9ngVRbLStwAWKhA0FEgq8Jd4h5lpwo=\n github.com/go-session/session v3.1.2+incompatible/go.mod h1:8B3iivBQjrz/JtC68Np2T1yBBLxTan3mn/3OM0CyRt0=\n github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\n github.com/go-stack/stack v1.8.1 h1:ntEHSVwIt7PNXNpgPmVfMrNhLtgjlmnZha2kOpuRiDw=\n github.com/go-stack/stack v1.8.1/go.mod h1:dcoOX6HbPZSZptuspn9bctJ+N/CnF5gGygcUP3XYfe4=\n+github.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=\n github.com/go-test/deep v1.0.4 h1:u2CU3YKy9I2pmu9pX0eq50wCgjfGIt539SqR7FbHiho=\n github.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\n github.com/golang-jwt/jwt v3.2.1+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=\n@@ -199,7 +205,6 @@ github.com/golang/snappy v0.0.1/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEW\n github.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\n github.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=\n github.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\n-github.com/gomodule/redigo v1.7.1-0.20190322064113-39e2c31b7ca3/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=\n github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\n github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\n github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\n@@ -233,6 +238,7 @@ github.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLe\n github.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n github.com/google/pprof v0.0.0-20210122040257-d980be63207e/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n github.com/google/pprof v0.0.0-20210226084205-cbba55b83ad5/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n+github.com/google/pprof v0.0.0-20210407192527-94a9f03dee38/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n github.com/google/pprof v0.0.0-20210601050228-01bbb1931b22/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n github.com/google/pprof v0.0.0-20210609004039-a478d1d731e9/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n github.com/google/pprof v0.0.0-20210720184732-4bb14d4b1be1/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\n@@ -259,7 +265,6 @@ github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFb\n github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n github.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=\n github.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n-github.com/hashicorp/go-multierror v1.1.0/go.mod h1:spPvp8C1qA32ftKqdAHm4hHTbPw+vmowP0z+KUhOZdA=\n github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=\n github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=\n github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n@@ -288,8 +293,8 @@ github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORN\n github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\n github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\n github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\n-github.com/kyokomi/emoji/v2 v2.2.9 h1:UWYkjplPZ4rMPvLxc+/e12/xTqoRcn55oUySkpZ554g=\n-github.com/kyokomi/emoji/v2 v2.2.9/go.mod h1:JUcn42DTdsXJo1SWanHh4HKDEyPaR5CqkmoirZZP9qE=\n+github.com/kyokomi/emoji/v2 v2.2.10 h1:1z5eMVcxFifsmEoNpdeq4UahbcicgQ4FEHuzrCVwmiI=\n+github.com/kyokomi/emoji/v2 v2.2.10/go.mod h1:JUcn42DTdsXJo1SWanHh4HKDEyPaR5CqkmoirZZP9qE=\n github.com/mattn/go-colorable v0.1.7/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\n github.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\n github.com/microcosm-cc/bluemonday v1.0.18/go.mod h1:Z0r70sCuXHig8YpBzCc5eGHAap2K7e/u082ZUpDRRqM=\n@@ -300,17 +305,21 @@ github.com/moul/http2curl v1.0.0 h1:dRMWoAtb+ePxMlLkrCbAqh4TlPHXvoGUSQ323/9Zahs=\n github.com/moul/http2curl v1.0.0/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\n github.com/nullrocks/identicon v0.0.0-20180626043057-7875f45b0022 h1:Ys0rDzh8s4UMlGaDa1UTA0sfKgvF0hQZzTYX8ktjiDc=\n github.com/nullrocks/identicon v0.0.0-20180626043057-7875f45b0022/go.mod h1:x4NsS+uc7ecH/Cbm9xKQ6XzmJM57rWTkjywjfB2yQ18=\n-github.com/nxadm/tail v1.4.4 h1:DQuhQpB1tVlglWS2hLQ5OV6B5r8aGxSrPc5Qo6uTN78=\n github.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\n+github.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=\n+github.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=\n github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\n-github.com/onsi/ginkgo v1.10.1/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\n github.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\n-github.com/onsi/ginkgo v1.13.0 h1:M76yO2HkZASFjXL0HSoZJ1AYEmQxNJmY41Jx1zNUq1Y=\n github.com/onsi/ginkgo v1.13.0/go.mod h1:+REjRxOmWfHCjfv9TTWB1jD1Frx4XydAD3zm1lskyM0=\n-github.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\n+github.com/onsi/ginkgo v1.16.4/go.mod h1:dX+/inL/fNMqNlz0e9LfyB9TswhZpCVdJM/Z6Vvnwo0=\n+github.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=\n+github.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=\n+github.com/onsi/ginkgo/v2 v2.0.0/go.mod h1:vw5CSIxN1JObi/U8gcbwft7ZxR2dgaR70JSE3/PpL4c=\n github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\n-github.com/onsi/gomega v1.10.1 h1:o0+MgICZLuZ7xjH7Vx6zS/zcu93/BEp1VwkIW1mEXCE=\n github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\n+github.com/onsi/gomega v1.17.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=\n+github.com/onsi/gomega v1.18.1 h1:M1GfJqGRrBrrGGsbxzV5dqM2U2ApXefZCQpkukxYRLE=\n+github.com/onsi/gomega v1.18.1/go.mod h1:0q+aL8jAiMXy9hbwj2mr5GziHiwhAIQpFmmtT5hitRs=\n github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\n github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n@@ -397,8 +406,8 @@ github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9de\n github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\n github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\n github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\n-github.com/yuin/gopher-lua v0.0.0-20191220021717-ab39c6098bdb h1:ZkM6LRnq40pR1Ox0hTHlnpkcOTuFIDQpZ1IN8rKKhX0=\n-github.com/yuin/gopher-lua v0.0.0-20191220021717-ab39c6098bdb/go.mod h1:gqRgreBUhTSL0GeU64rtZ3Uq3wtjOa/TB2YfrtkCbVQ=\n+github.com/yuin/gopher-lua v0.0.0-20210529063254-f4c35e4016d9 h1:k/gmLsJDWwWqbLCur2yWnJzwQEKRcAHXo6seXGuSwWw=\n+github.com/yuin/gopher-lua v0.0.0-20210529063254-f4c35e4016d9/go.mod h1:E1AXubJBdNmFERAOucpDIxNzeGfLzg0mYh+UfMWdChA=\n go.etcd.io/bbolt v1.3.6 h1:/ecaJf0sk1l4l6V4awd65v2C3ILy7MSj+s/x1ADCIMU=\n go.etcd.io/bbolt v1.3.6/go.mod h1:qXsaaIqmgQH0T+OPdb99Bf+PKfBBQVAdyD6TY9G8XM4=\n go.mongodb.org/mongo-driver v1.8.5/go.mod h1:0sQWfOeY63QTntERDJJ/0SuKK0T1uVSgKCuAROlKEPY=\n@@ -476,7 +485,6 @@ golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR\n golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n-golang.org/x/net v0.0.0-20190923162816-aa69164e4478/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n@@ -500,6 +508,7 @@ golang.org/x/net v0.0.0-20210119194325-5f4716e94777/go.mod h1:m0MpNAwzfU5UDzcl9v\n golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\n golang.org/x/net v0.0.0-20210316092652-d523dce5a7f4/go.mod h1:RBQZq4jEuRlivfhVLdyRGr576XBO4/greRjx4P4O3yc=\n golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\n+golang.org/x/net v0.0.0-20210428140749-89ef3d95e781/go.mod h1:OJAsFXCWl8Ukc7SiCT/9KSuxbyM7479/AVlXFRxuMCk=\n golang.org/x/net v0.0.0-20210503060351-7fd8e65b6420/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\n golang.org/x/net v0.0.0-20210614182718-04defd469f4e/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\n golang.org/x/net v0.0.0-20210916014120-12bc252f5db8/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\n@@ -558,7 +567,6 @@ golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7w\n golang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n-golang.org/x/sys v0.0.0-20191010194322-b09406accb47/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n@@ -585,6 +593,7 @@ golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7w\n golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20210220050731-9a76102bfb43/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n golang.org/x/sys v0.0.0-20210305230114-8fe3ee5dd75b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n@@ -674,6 +683,7 @@ golang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82u\n golang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\n golang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\n golang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\n+golang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\n golang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\n golang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=\n golang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\n@@ -855,12 +865,12 @@ gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\n gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\n gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\n gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\n-gopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n-gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=\n gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\n+gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\n+gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\n gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n gopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA="
    },
    {
      "sha": "14608c76fa3a2a2994bfe4b4b77c1ba82e28318f",
      "filename": "backend/vendor/github.com/ajg/form/.travis.yml",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2F.travis.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2F.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2F.travis.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,25 @@\n+## Copyright 2014 Alvaro J. Genial. All rights reserved.\n+## Use of this source code is governed by a BSD-style\n+## license that can be found in the LICENSE file.\n+\n+language: go\n+\n+go:\n+  - tip\n+  - 1.6\n+  - 1.5\n+  - 1.4\n+  - 1.3\n+  # 1.2\n+\n+before_install:\n+  # - go get -v golang.org/x/tools/cmd/cover\n+  # - go get -v golang.org/x/tools/cmd/vet\n+  # - go get -v golang.org/x/lint/golint\n+  - export PATH=$PATH:/home/travis/gopath/bin\n+\n+script:\n+  - go build -v ./...\n+  - go test -v -cover ./...\n+  - go vet ./...\n+  # - golint ."
    },
    {
      "sha": "9190b1655ea807ac7ab18a09562c6dc48aee64d7",
      "filename": "backend/vendor/github.com/ajg/form/LICENSE",
      "status": "added",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FLICENSE?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,27 @@\n+Copyright (c) 2014 Alvaro J. Genial. All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+   * Redistributions of source code must retain the above copyright\n+notice, this list of conditions and the following disclaimer.\n+   * Redistributions in binary form must reproduce the above\n+copyright notice, this list of conditions and the following disclaimer\n+in the documentation and/or other materials provided with the\n+distribution.\n+   * Neither the name of Google Inc. nor the names of its\n+contributors may be used to endorse or promote products derived from\n+this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
    },
    {
      "sha": "ad99be4b1fbb21433b4135602b4a6f212a3fb09d",
      "filename": "backend/vendor/github.com/ajg/form/README.md",
      "status": "added",
      "additions": 247,
      "deletions": 0,
      "changes": 247,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FREADME.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,247 @@\n+form\n+====\n+\n+A Form Encoding & Decoding Package for Go, written by [Alvaro J. Genial](http://alva.ro).\n+\n+[![Build Status](https://travis-ci.org/ajg/form.png?branch=master)](https://travis-ci.org/ajg/form)\n+[![GoDoc](https://godoc.org/github.com/ajg/form?status.png)](https://godoc.org/github.com/ajg/form)\n+\n+Synopsis\n+--------\n+\n+This library is designed to allow seamless, high-fidelity encoding and decoding of arbitrary data in `application/x-www-form-urlencoded` format and as [`url.Values`](http://golang.org/pkg/net/url/#Values). It is intended to be useful primarily in dealing with web forms and URI query strings, both of which natively employ said format.\n+\n+Unsurprisingly, `form` is modeled after other Go [`encoding`](http://golang.org/pkg/encoding/) packages, in particular [`encoding/json`](http://golang.org/pkg/encoding/json/), and follows the same conventions (see below for more.) It aims to automatically handle any kind of concrete Go [data value](#values) (i.e., not functions, channels, etc.) while providing mechanisms for custom behavior.\n+\n+Status\n+------\n+\n+The implementation is in usable shape and is fairly well tested with its accompanying test suite. The API is unlikely to change much, but still may. Lastly, the code has not yet undergone a security review to ensure it is free of vulnerabilities. Please file an issue or send a pull request for fixes & improvements.\n+\n+Dependencies\n+------------\n+\n+The only requirement is [Go 1.2](http://golang.org/doc/go1.2) or later.\n+\n+Usage\n+-----\n+\n+```go\n+import \"github.com/ajg/form\"\n+// or: \"gopkg.in/ajg/form.v1\"\n+```\n+\n+Given a type like the following...\n+\n+```go\n+type User struct {\n+\tName         string            `form:\"name\"`\n+\tEmail        string            `form:\"email\"`\n+\tJoined       time.Time         `form:\"joined,omitempty\"`\n+\tPosts        []int             `form:\"posts\"`\n+\tPreferences  map[string]string `form:\"prefs\"`\n+\tAvatar       []byte            `form:\"avatar\"`\n+\tPasswordHash int64             `form:\"-\"`\n+}\n+```\n+\n+...it is easy to encode data of that type...\n+\n+\n+```go\n+func PostUser(url string, u User) error {\n+\tvar c http.Client\n+\t_, err := c.PostForm(url, form.EncodeToValues(u))\n+\treturn err\n+}\n+```\n+\n+...as well as decode it...\n+\n+\n+```go\n+func Handler(w http.ResponseWriter, r *http.Request) {\n+\tvar u User\n+\n+\td := form.NewDecoder(r.Body)\n+\tif err := d.Decode(&u); err != nil {\n+\t\thttp.Error(w, \"Form could not be decoded\", http.StatusBadRequest)\n+\t\treturn\n+\t}\n+\n+\tfmt.Fprintf(w, \"Decoded: %#v\", u)\n+}\n+```\n+\n+...without having to do any grunt work.\n+\n+Field Tags\n+----------\n+\n+Like other encoding packages, `form` supports the following options for fields:\n+\n+ - `` `form:\"-\"` ``: Causes the field to be ignored during encoding and decoding.\n+ - `` `form:\"<name>\"` ``: Overrides the field's name; useful especially when dealing with external identifiers in camelCase, as are commonly found on the web.\n+ - `` `form:\",omitempty\"` ``: Elides the field during encoding if it is empty (typically meaning equal to the type's zero value.)\n+ - `` `form:\"<name>,omitempty\"` ``: The way to combine the two options above.\n+\n+Values\n+------\n+\n+### Simple Values\n+\n+Values of the following types are all considered simple:\n+\n+ - `bool`\n+ - `int`, `int8`, `int16`, `int32`, `int64`, `rune`\n+ - `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `byte`\n+ - `float32`, `float64`\n+ - `complex64`, `complex128`\n+ - `string`\n+ - `[]byte` (see note)\n+ - [`time.Time`](http://golang.org/pkg/time/#Time)\n+ - [`url.URL`](http://golang.org/pkg/net/url/#URL)\n+ - An alias of any of the above\n+ - A pointer to any of the above\n+\n+### Composite Values\n+\n+A composite value is one that can contain other values. Values of the following kinds...\n+\n+ - Maps\n+ - Slices; except `[]byte` (see note)\n+ - Structs; except [`time.Time`](http://golang.org/pkg/time/#Time) and [`url.URL`](http://golang.org/pkg/net/url/#URL)\n+ - Arrays\n+ - An alias of any of the above\n+ - A pointer to any of the above\n+\n+...are considered composites in general, unless they implement custom marshaling/unmarshaling. Composite values are encoded as a flat mapping of paths to values, where the paths are constructed by joining the parent and child paths with a period (`.`).\n+\n+(Note: a byte slice is treated as a `string` by default because it's more efficient, but can also be decoded as a slice—i.e., with indexes.)\n+\n+### Untyped Values\n+\n+While encouraged, it is not necessary to define a type (e.g. a `struct`) in order to use `form`, since it is able to encode and decode untyped data generically using the following rules:\n+\n+ - Simple values will be treated as a `string`.\n+ - Composite values will be treated as a `map[string]interface{}`, itself able to contain nested values (both scalar and compound) ad infinitum.\n+ - However, if there is a value (of any supported type) already present in a map for a given key, then it will be used when possible, rather than being replaced with a generic value as specified above; this makes it possible to handle partially typed, dynamic or schema-less values.\n+\n+### Zero Values\n+\n+By default, and without custom marshaling, zero values (also known as empty/default values) are encoded as the empty string. To disable this behavior, meaning to keep zero values in their literal form (e.g. `0` for integral types), `Encoder` offers a `KeepZeros` setter method, which will do just that when set to `true`.\n+\n+### Unsupported Values\n+\n+Values of the following kinds aren't supported and, if present, must be ignored.\n+\n+ - Channel\n+ - Function\n+ - Unsafe pointer\n+ - An alias of any of the above\n+ - A pointer to any of the above\n+\n+Custom Marshaling\n+-----------------\n+\n+There is a default (generally lossless) marshaling & unmarshaling scheme for any concrete data value in Go, which is good enough in most cases. However, it is possible to override it and use a custom scheme. For instance, a \"binary\" field could be marshaled more efficiently using [base64](http://golang.org/pkg/encoding/base64/) to prevent it from being percent-escaped during serialization to `application/x-www-form-urlencoded` format.\n+\n+Because `form` provides support for [`encoding.TextMarshaler`](http://golang.org/pkg/encoding/#TextMarshaler) and [`encoding.TextUnmarshaler`](http://golang.org/pkg/encoding/#TextUnmarshaler) it is easy to do that; for instance, like this:\n+\n+```go\n+import \"encoding\"\n+\n+type Binary []byte\n+\n+var (\n+\t_ encoding.TextMarshaler   = &Binary{}\n+\t_ encoding.TextUnmarshaler = &Binary{}\n+)\n+\n+func (b Binary) MarshalText() ([]byte, error) {\n+\treturn []byte(base64.URLEncoding.EncodeToString([]byte(b))), nil\n+}\n+\n+func (b *Binary) UnmarshalText(text []byte) error {\n+\tbs, err := base64.URLEncoding.DecodeString(string(text))\n+\tif err == nil {\n+\t\t*b = Binary(bs)\n+\t}\n+\treturn err\n+}\n+```\n+\n+Now any value with type `Binary` will automatically be encoded using the [URL](http://golang.org/pkg/encoding/base64/#URLEncoding) variant of base64. It is left as an exercise to the reader to improve upon this scheme by eliminating the need for padding (which, besides being superfluous, uses `=`, a character that will end up percent-escaped.)\n+\n+Keys\n+----\n+\n+In theory any value can be a key as long as it has a string representation. However, by default, periods have special meaning to `form`, and thus, under the hood (i.e. in encoded form) they are transparently escaped using a preceding backslash (`\\`). Backslashes within keys, themselves, are also escaped in this manner (e.g. as `\\\\`) in order to permit representing `\\.` itself (as `\\\\\\.`).\n+\n+(Note: it is normally unnecessary to deal with this issue unless keys are being constructed manually—e.g. literally embedded in HTML or in a URI.)\n+\n+The default delimiter and escape characters used for encoding and decoding composite keys can be changed using the `DelimitWith` and `EscapeWith` setter methods of `Encoder` and `Decoder`, respectively. For example...\n+\n+```go\n+package main\n+\n+import (\n+\t\"os\"\n+\n+\t\"github.com/ajg/form\"\n+)\n+\n+func main() {\n+\ttype B struct {\n+\t\tQux string `form:\"qux\"`\n+\t}\n+\ttype A struct {\n+\t\tFooBar B `form:\"foo.bar\"`\n+\t}\n+\ta := A{FooBar: B{\"XYZ\"}}\n+\tos.Stdout.WriteString(\"Default: \")\n+\tform.NewEncoder(os.Stdout).Encode(a)\n+\tos.Stdout.WriteString(\"\\nCustom:  \")\n+\tform.NewEncoder(os.Stdout).DelimitWith('/').Encode(a)\n+\tos.Stdout.WriteString(\"\\n\")\n+}\n+\n+```\n+\n+...will produce...\n+\n+```\n+Default: foo%5C.bar.qux=XYZ\n+Custom:  foo.bar%2Fqux=XYZ\n+```\n+\n+(`%5C` and `%2F` represent `\\` and `/`, respectively.)\n+\n+Limitations\n+-----------\n+\n+ - Circular (self-referential) values are untested.\n+\n+Future Work\n+-----------\n+\n+The following items would be nice to have in the future—though they are not being worked on yet:\n+\n+ - An option to treat all values as if they had been tagged with `omitempty`.\n+ - An option to automatically treat all field names in `camelCase` or `underscore_case`.\n+ - Built-in support for the types in [`math/big`](http://golang.org/pkg/math/big/).\n+ - Built-in support for the types in [`image/color`](http://golang.org/pkg/image/color/).\n+ - Improve encoding/decoding by reading/writing directly from/to the `io.Reader`/`io.Writer` when possible, rather than going through an intermediate representation (i.e. `node`) which requires more memory.\n+\n+(Feel free to implement any of these and then send a pull request.)\n+\n+Related Work\n+------------\n+\n+ - Package [gorilla/schema](https://github.com/gorilla/schema), which only implements decoding.\n+ - Package [google/go-querystring](https://github.com/google/go-querystring), which only implements encoding.\n+\n+License\n+-------\n+\n+This library is distributed under a BSD-style [LICENSE](./LICENSE)."
    },
    {
      "sha": "d3447279813bdf919bc3fa9b802af43575e08ae3",
      "filename": "backend/vendor/github.com/ajg/form/TODO.md",
      "status": "added",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FTODO.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FTODO.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2FTODO.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,4 @@\n+TODO\n+====\n+\n+  - Document IgnoreCase and IgnoreUnknownKeys in README."
    },
    {
      "sha": "dd8bd4f29dc77c282f805bf87672ad4ecc6cb9b1",
      "filename": "backend/vendor/github.com/ajg/form/decode.go",
      "status": "added",
      "additions": 370,
      "deletions": 0,
      "changes": 370,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fdecode.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fdecode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fdecode.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,370 @@\n+// Copyright 2014 Alvaro J. Genial. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package form\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"net/url\"\n+\t\"reflect\"\n+\t\"strconv\"\n+\t\"time\"\n+)\n+\n+// NewDecoder returns a new form Decoder.\n+func NewDecoder(r io.Reader) *Decoder {\n+\treturn &Decoder{r, defaultDelimiter, defaultEscape, false, false}\n+}\n+\n+// Decoder decodes data from a form (application/x-www-form-urlencoded).\n+type Decoder struct {\n+\tr             io.Reader\n+\td             rune\n+\te             rune\n+\tignoreUnknown bool\n+\tignoreCase    bool\n+}\n+\n+// DelimitWith sets r as the delimiter used for composite keys by Decoder d and returns the latter; it is '.' by default.\n+func (d *Decoder) DelimitWith(r rune) *Decoder {\n+\td.d = r\n+\treturn d\n+}\n+\n+// EscapeWith sets r as the escape used for delimiters (and to escape itself) by Decoder d and returns the latter; it is '\\\\' by default.\n+func (d *Decoder) EscapeWith(r rune) *Decoder {\n+\td.e = r\n+\treturn d\n+}\n+\n+// Decode reads in and decodes form-encoded data into dst.\n+func (d Decoder) Decode(dst interface{}) error {\n+\tbs, err := ioutil.ReadAll(d.r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tvs, err := url.ParseQuery(string(bs))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tv := reflect.ValueOf(dst)\n+\treturn d.decodeNode(v, parseValues(d.d, d.e, vs, canIndexOrdinally(v)))\n+}\n+\n+// IgnoreUnknownKeys if set to true it will make the Decoder ignore values\n+// that are not found in the destination object instead of returning an error.\n+func (d *Decoder) IgnoreUnknownKeys(ignoreUnknown bool) {\n+\td.ignoreUnknown = ignoreUnknown\n+}\n+\n+// IgnoreCase if set to true it will make the Decoder try to set values in the\n+// destination object even if the case does not match.\n+func (d *Decoder) IgnoreCase(ignoreCase bool) {\n+\td.ignoreCase = ignoreCase\n+}\n+\n+// DecodeString decodes src into dst.\n+func (d Decoder) DecodeString(dst interface{}, src string) error {\n+\tvs, err := url.ParseQuery(src)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tv := reflect.ValueOf(dst)\n+\treturn d.decodeNode(v, parseValues(d.d, d.e, vs, canIndexOrdinally(v)))\n+}\n+\n+// DecodeValues decodes vs into dst.\n+func (d Decoder) DecodeValues(dst interface{}, vs url.Values) error {\n+\tv := reflect.ValueOf(dst)\n+\treturn d.decodeNode(v, parseValues(d.d, d.e, vs, canIndexOrdinally(v)))\n+}\n+\n+// DecodeString decodes src into dst.\n+func DecodeString(dst interface{}, src string) error {\n+\treturn NewDecoder(nil).DecodeString(dst, src)\n+}\n+\n+// DecodeValues decodes vs into dst.\n+func DecodeValues(dst interface{}, vs url.Values) error {\n+\treturn NewDecoder(nil).DecodeValues(dst, vs)\n+}\n+\n+func (d Decoder) decodeNode(v reflect.Value, n node) (err error) {\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\terr = fmt.Errorf(\"%v\", e)\n+\t\t}\n+\t}()\n+\n+\tif v.Kind() == reflect.Slice {\n+\t\treturn fmt.Errorf(\"could not decode directly into slice; use pointer to slice\")\n+\t}\n+\td.decodeValue(v, n)\n+\treturn nil\n+}\n+\n+func (d Decoder) decodeValue(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\tk := v.Kind()\n+\n+\tif k == reflect.Ptr && v.IsNil() {\n+\t\tv.Set(reflect.New(t.Elem()))\n+\t}\n+\n+\tif unmarshalValue(v, x) {\n+\t\treturn\n+\t}\n+\n+\tempty := isEmpty(x)\n+\n+\tswitch k {\n+\tcase reflect.Ptr:\n+\t\td.decodeValue(v.Elem(), x)\n+\t\treturn\n+\tcase reflect.Interface:\n+\t\tif !v.IsNil() {\n+\t\t\td.decodeValue(v.Elem(), x)\n+\t\t\treturn\n+\n+\t\t} else if empty {\n+\t\t\treturn // Allow nil interfaces only if empty.\n+\t\t} else {\n+\t\t\tpanic(\"form: cannot decode non-empty value into into nil interface\")\n+\t\t}\n+\t}\n+\n+\tif empty {\n+\t\tv.Set(reflect.Zero(t)) // Treat the empty string as the zero value.\n+\t\treturn\n+\t}\n+\n+\tswitch k {\n+\tcase reflect.Struct:\n+\t\tif t.ConvertibleTo(timeType) {\n+\t\t\td.decodeTime(v, x)\n+\t\t} else if t.ConvertibleTo(urlType) {\n+\t\t\td.decodeURL(v, x)\n+\t\t} else {\n+\t\t\td.decodeStruct(v, x)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\td.decodeSlice(v, x)\n+\tcase reflect.Array:\n+\t\td.decodeArray(v, x)\n+\tcase reflect.Map:\n+\t\td.decodeMap(v, x)\n+\tcase reflect.Invalid, reflect.Uintptr, reflect.UnsafePointer, reflect.Chan, reflect.Func:\n+\t\tpanic(t.String() + \" has unsupported kind \" + k.String())\n+\tdefault:\n+\t\td.decodeBasic(v, x)\n+\t}\n+}\n+\n+func (d Decoder) decodeStruct(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\tfor k, c := range getNode(x) {\n+\t\tif f, ok := findField(v, k, d.ignoreCase); !ok && k == \"\" {\n+\t\t\tpanic(getString(x) + \" cannot be decoded as \" + t.String())\n+\t\t} else if !ok {\n+\t\t\tif !d.ignoreUnknown {\n+\t\t\t\tpanic(k + \" doesn't exist in \" + t.String())\n+\t\t\t}\n+\t\t} else if !f.CanSet() {\n+\t\t\tpanic(k + \" cannot be set in \" + t.String())\n+\t\t} else {\n+\t\t\td.decodeValue(f, c)\n+\t\t}\n+\t}\n+}\n+\n+func (d Decoder) decodeMap(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\tif v.IsNil() {\n+\t\tv.Set(reflect.MakeMap(t))\n+\t}\n+\tfor k, c := range getNode(x) {\n+\t\ti := reflect.New(t.Key()).Elem()\n+\t\td.decodeValue(i, k)\n+\n+\t\tw := v.MapIndex(i)\n+\t\tif w.IsValid() { // We have an actual element value to decode into.\n+\t\t\tif w.Kind() == reflect.Interface {\n+\t\t\t\tw = w.Elem()\n+\t\t\t}\n+\t\t\tw = reflect.New(w.Type()).Elem()\n+\t\t} else if t.Elem().Kind() != reflect.Interface { // The map's element type is concrete.\n+\t\t\tw = reflect.New(t.Elem()).Elem()\n+\t\t} else {\n+\t\t\t// The best we can do here is to decode as either a string (for scalars) or a map[string]interface {} (for the rest).\n+\t\t\t// We could try to guess the type based on the string (e.g. true/false => bool) but that'll get ugly fast,\n+\t\t\t// especially if we have to guess the kind (slice vs. array vs. map) and index type (e.g. string, int, etc.)\n+\t\t\tswitch c.(type) {\n+\t\t\tcase node:\n+\t\t\t\tw = reflect.MakeMap(stringMapType)\n+\t\t\tcase string:\n+\t\t\t\tw = reflect.New(stringType).Elem()\n+\t\t\tdefault:\n+\t\t\t\tpanic(\"value is neither node nor string\")\n+\t\t\t}\n+\t\t}\n+\n+\t\td.decodeValue(w, c)\n+\t\tv.SetMapIndex(i, w)\n+\t}\n+}\n+\n+func (d Decoder) decodeArray(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\tfor k, c := range getNode(x) {\n+\t\ti, err := strconv.Atoi(k)\n+\t\tif err != nil {\n+\t\t\tpanic(k + \" is not a valid index for type \" + t.String())\n+\t\t}\n+\t\tif l := v.Len(); i >= l {\n+\t\t\tpanic(\"index is above array size\")\n+\t\t}\n+\t\td.decodeValue(v.Index(i), c)\n+\t}\n+}\n+\n+func (d Decoder) decodeSlice(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t// Allow, but don't require, byte slices to be encoded as a single string.\n+\t\tif s, ok := x.(string); ok {\n+\t\t\tv.SetBytes([]byte(s))\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// NOTE: Implicit indexing is currently done at the parseValues level,\n+\t//       so if if an implicitKey reaches here it will always replace the last.\n+\timplicit := 0\n+\tfor k, c := range getNode(x) {\n+\t\tvar i int\n+\t\tif k == implicitKey {\n+\t\t\ti = implicit\n+\t\t\timplicit++\n+\t\t} else {\n+\t\t\texplicit, err := strconv.Atoi(k)\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(k + \" is not a valid index for type \" + t.String())\n+\t\t\t}\n+\t\t\ti = explicit\n+\t\t\timplicit = explicit + 1\n+\t\t}\n+\t\t// \"Extend\" the slice if it's too short.\n+\t\tif l := v.Len(); i >= l {\n+\t\t\tdelta := i - l + 1\n+\t\t\tv.Set(reflect.AppendSlice(v, reflect.MakeSlice(t, delta, delta)))\n+\t\t}\n+\t\td.decodeValue(v.Index(i), c)\n+\t}\n+}\n+\n+func (d Decoder) decodeBasic(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\tswitch k, s := t.Kind(), getString(x); k {\n+\tcase reflect.Bool:\n+\t\tif b, e := strconv.ParseBool(s); e == nil {\n+\t\t\tv.SetBool(b)\n+\t\t} else {\n+\t\t\tpanic(\"could not parse bool from \" + strconv.Quote(s))\n+\t\t}\n+\tcase reflect.Int,\n+\t\treflect.Int8,\n+\t\treflect.Int16,\n+\t\treflect.Int32,\n+\t\treflect.Int64:\n+\t\tif i, e := strconv.ParseInt(s, 10, 64); e == nil {\n+\t\t\tv.SetInt(i)\n+\t\t} else {\n+\t\t\tpanic(\"could not parse int from \" + strconv.Quote(s))\n+\t\t}\n+\tcase reflect.Uint,\n+\t\treflect.Uint8,\n+\t\treflect.Uint16,\n+\t\treflect.Uint32,\n+\t\treflect.Uint64:\n+\t\tif u, e := strconv.ParseUint(s, 10, 64); e == nil {\n+\t\t\tv.SetUint(u)\n+\t\t} else {\n+\t\t\tpanic(\"could not parse uint from \" + strconv.Quote(s))\n+\t\t}\n+\tcase reflect.Float32,\n+\t\treflect.Float64:\n+\t\tif f, e := strconv.ParseFloat(s, 64); e == nil {\n+\t\t\tv.SetFloat(f)\n+\t\t} else {\n+\t\t\tpanic(\"could not parse float from \" + strconv.Quote(s))\n+\t\t}\n+\tcase reflect.Complex64,\n+\t\treflect.Complex128:\n+\t\tvar c complex128\n+\t\tif n, err := fmt.Sscanf(s, \"%g\", &c); n == 1 && err == nil {\n+\t\t\tv.SetComplex(c)\n+\t\t} else {\n+\t\t\tpanic(\"could not parse complex from \" + strconv.Quote(s))\n+\t\t}\n+\tcase reflect.String:\n+\t\tv.SetString(s)\n+\tdefault:\n+\t\tpanic(t.String() + \" has unsupported kind \" + k.String())\n+\t}\n+}\n+\n+func (d Decoder) decodeTime(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\ts := getString(x)\n+\t// TODO: Find a more efficient way to do this.\n+\tfor _, f := range allowedTimeFormats {\n+\t\tif p, err := time.Parse(f, s); err == nil {\n+\t\t\tv.Set(reflect.ValueOf(p).Convert(v.Type()))\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tpanic(\"cannot decode string `\" + s + \"` as \" + t.String())\n+}\n+\n+func (d Decoder) decodeURL(v reflect.Value, x interface{}) {\n+\tt := v.Type()\n+\ts := getString(x)\n+\tif u, err := url.Parse(s); err == nil {\n+\t\tv.Set(reflect.ValueOf(*u).Convert(v.Type()))\n+\t\treturn\n+\t}\n+\tpanic(\"cannot decode string `\" + s + \"` as \" + t.String())\n+}\n+\n+var allowedTimeFormats = []string{\n+\t\"2006-01-02T15:04:05.999999999Z07:00\",\n+\t\"2006-01-02T15:04:05.999999999Z07\",\n+\t\"2006-01-02T15:04:05.999999999Z\",\n+\t\"2006-01-02T15:04:05.999999999\",\n+\t\"2006-01-02T15:04:05Z07:00\",\n+\t\"2006-01-02T15:04:05Z07\",\n+\t\"2006-01-02T15:04:05Z\",\n+\t\"2006-01-02T15:04:05\",\n+\t\"2006-01-02T15:04Z\",\n+\t\"2006-01-02T15:04\",\n+\t\"2006-01-02T15Z\",\n+\t\"2006-01-02T15\",\n+\t\"2006-01-02\",\n+\t\"2006-01\",\n+\t\"2006\",\n+\t\"15:04:05.999999999Z07:00\",\n+\t\"15:04:05.999999999Z07\",\n+\t\"15:04:05.999999999Z\",\n+\t\"15:04:05.999999999\",\n+\t\"15:04:05Z07:00\",\n+\t\"15:04:05Z07\",\n+\t\"15:04:05Z\",\n+\t\"15:04:05\",\n+\t\"15:04Z\",\n+\t\"15:04\",\n+\t\"15Z\",\n+\t\"15\",\n+}"
    },
    {
      "sha": "57a0d0a571d6df40eb63ba41ef9d3cbdbd6fb513",
      "filename": "backend/vendor/github.com/ajg/form/encode.go",
      "status": "added",
      "additions": 388,
      "deletions": 0,
      "changes": 388,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fencode.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fencode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fencode.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,388 @@\n+// Copyright 2014 Alvaro J. Genial. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package form\n+\n+import (\n+\t\"encoding\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/url\"\n+\t\"reflect\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// NewEncoder returns a new form Encoder.\n+func NewEncoder(w io.Writer) *Encoder {\n+\treturn &Encoder{w, defaultDelimiter, defaultEscape, false}\n+}\n+\n+// Encoder provides a way to encode to a Writer.\n+type Encoder struct {\n+\tw io.Writer\n+\td rune\n+\te rune\n+\tz bool\n+}\n+\n+// DelimitWith sets r as the delimiter used for composite keys by Encoder e and returns the latter; it is '.' by default.\n+func (e *Encoder) DelimitWith(r rune) *Encoder {\n+\te.d = r\n+\treturn e\n+}\n+\n+// EscapeWith sets r as the escape used for delimiters (and to escape itself) by Encoder e and returns the latter; it is '\\\\' by default.\n+func (e *Encoder) EscapeWith(r rune) *Encoder {\n+\te.e = r\n+\treturn e\n+}\n+\n+// KeepZeros sets whether Encoder e should keep zero (default) values in their literal form when encoding, and returns the former; by default zero values are not kept, but are rather encoded as the empty string.\n+func (e *Encoder) KeepZeros(z bool) *Encoder {\n+\te.z = z\n+\treturn e\n+}\n+\n+// Encode encodes dst as form and writes it out using the Encoder's Writer.\n+func (e Encoder) Encode(dst interface{}) error {\n+\tv := reflect.ValueOf(dst)\n+\tn, err := encodeToNode(v, e.z)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\ts := n.values(e.d, e.e).Encode()\n+\tl, err := io.WriteString(e.w, s)\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn err\n+\tcase l != len(s):\n+\t\treturn errors.New(\"could not write data completely\")\n+\t}\n+\treturn nil\n+}\n+\n+// EncodeToString encodes dst as a form and returns it as a string.\n+func EncodeToString(dst interface{}) (string, error) {\n+\tv := reflect.ValueOf(dst)\n+\tn, err := encodeToNode(v, false)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tvs := n.values(defaultDelimiter, defaultEscape)\n+\treturn vs.Encode(), nil\n+}\n+\n+// EncodeToValues encodes dst as a form and returns it as Values.\n+func EncodeToValues(dst interface{}) (url.Values, error) {\n+\tv := reflect.ValueOf(dst)\n+\tn, err := encodeToNode(v, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tvs := n.values(defaultDelimiter, defaultEscape)\n+\treturn vs, nil\n+}\n+\n+func encodeToNode(v reflect.Value, z bool) (n node, err error) {\n+\tdefer func() {\n+\t\tif e := recover(); e != nil {\n+\t\t\terr = fmt.Errorf(\"%v\", e)\n+\t\t}\n+\t}()\n+\treturn getNode(encodeValue(v, z)), nil\n+}\n+\n+func encodeValue(v reflect.Value, z bool) interface{} {\n+\tt := v.Type()\n+\tk := v.Kind()\n+\n+\tif s, ok := marshalValue(v); ok {\n+\t\treturn s\n+\t} else if !z && isEmptyValue(v) {\n+\t\treturn \"\" // Treat the zero value as the empty string.\n+\t}\n+\n+\tswitch k {\n+\tcase reflect.Ptr, reflect.Interface:\n+\t\treturn encodeValue(v.Elem(), z)\n+\tcase reflect.Struct:\n+\t\tif t.ConvertibleTo(timeType) {\n+\t\t\treturn encodeTime(v)\n+\t\t} else if t.ConvertibleTo(urlType) {\n+\t\t\treturn encodeURL(v)\n+\t\t}\n+\t\treturn encodeStruct(v, z)\n+\tcase reflect.Slice:\n+\t\treturn encodeSlice(v, z)\n+\tcase reflect.Array:\n+\t\treturn encodeArray(v, z)\n+\tcase reflect.Map:\n+\t\treturn encodeMap(v, z)\n+\tcase reflect.Invalid, reflect.Uintptr, reflect.UnsafePointer, reflect.Chan, reflect.Func:\n+\t\tpanic(t.String() + \" has unsupported kind \" + t.Kind().String())\n+\tdefault:\n+\t\treturn encodeBasic(v)\n+\t}\n+}\n+\n+func encodeStruct(v reflect.Value, z bool) interface{} {\n+\tt := v.Type()\n+\tn := node{}\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\tf := t.Field(i)\n+\t\tk, oe := fieldInfo(f)\n+\n+\t\tif k == \"-\" {\n+\t\t\tcontinue\n+\t\t} else if fv := v.Field(i); oe && isEmptyValue(fv) {\n+\t\t\tdelete(n, k)\n+\t\t} else {\n+\t\t\tn[k] = encodeValue(fv, z)\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+func encodeMap(v reflect.Value, z bool) interface{} {\n+\tn := node{}\n+\tfor _, i := range v.MapKeys() {\n+\t\tk := getString(encodeValue(i, z))\n+\t\tn[k] = encodeValue(v.MapIndex(i), z)\n+\t}\n+\treturn n\n+}\n+\n+func encodeArray(v reflect.Value, z bool) interface{} {\n+\tn := node{}\n+\tfor i := 0; i < v.Len(); i++ {\n+\t\tn[strconv.Itoa(i)] = encodeValue(v.Index(i), z)\n+\t}\n+\treturn n\n+}\n+\n+func encodeSlice(v reflect.Value, z bool) interface{} {\n+\tt := v.Type()\n+\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\treturn string(v.Bytes()) // Encode byte slices as a single string by default.\n+\t}\n+\tn := node{}\n+\tfor i := 0; i < v.Len(); i++ {\n+\t\tn[strconv.Itoa(i)] = encodeValue(v.Index(i), z)\n+\t}\n+\treturn n\n+}\n+\n+func encodeTime(v reflect.Value) string {\n+\tt := v.Convert(timeType).Interface().(time.Time)\n+\tif t.Year() == 0 && (t.Month() == 0 || t.Month() == 1) && (t.Day() == 0 || t.Day() == 1) {\n+\t\treturn t.Format(\"15:04:05.999999999Z07:00\")\n+\t} else if t.Hour() == 0 && t.Minute() == 0 && t.Second() == 0 && t.Nanosecond() == 0 {\n+\t\treturn t.Format(\"2006-01-02\")\n+\t}\n+\treturn t.Format(\"2006-01-02T15:04:05.999999999Z07:00\")\n+}\n+\n+func encodeURL(v reflect.Value) string {\n+\tu := v.Convert(urlType).Interface().(url.URL)\n+\treturn u.String()\n+}\n+\n+func encodeBasic(v reflect.Value) string {\n+\tt := v.Type()\n+\tswitch k := t.Kind(); k {\n+\tcase reflect.Bool:\n+\t\treturn strconv.FormatBool(v.Bool())\n+\tcase reflect.Int,\n+\t\treflect.Int8,\n+\t\treflect.Int16,\n+\t\treflect.Int32,\n+\t\treflect.Int64:\n+\t\treturn strconv.FormatInt(v.Int(), 10)\n+\tcase reflect.Uint,\n+\t\treflect.Uint8,\n+\t\treflect.Uint16,\n+\t\treflect.Uint32,\n+\t\treflect.Uint64:\n+\t\treturn strconv.FormatUint(v.Uint(), 10)\n+\tcase reflect.Float32:\n+\t\treturn strconv.FormatFloat(v.Float(), 'g', -1, 32)\n+\tcase reflect.Float64:\n+\t\treturn strconv.FormatFloat(v.Float(), 'g', -1, 64)\n+\tcase reflect.Complex64, reflect.Complex128:\n+\t\ts := fmt.Sprintf(\"%g\", v.Complex())\n+\t\treturn strings.TrimSuffix(strings.TrimPrefix(s, \"(\"), \")\")\n+\tcase reflect.String:\n+\t\treturn v.String()\n+\t}\n+\tpanic(t.String() + \" has unsupported kind \" + t.Kind().String())\n+}\n+\n+func isEmptyValue(v reflect.Value) bool {\n+\tswitch t := v.Type(); v.Kind() {\n+\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n+\t\treturn v.Len() == 0\n+\tcase reflect.Bool:\n+\t\treturn !v.Bool()\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn v.Int() == 0\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\treturn v.Uint() == 0\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn v.Float() == 0\n+\tcase reflect.Complex64, reflect.Complex128:\n+\t\treturn v.Complex() == 0\n+\tcase reflect.Interface, reflect.Ptr:\n+\t\treturn v.IsNil()\n+\tcase reflect.Struct:\n+\t\tif t.ConvertibleTo(timeType) {\n+\t\t\treturn v.Convert(timeType).Interface().(time.Time).IsZero()\n+\t\t}\n+\t\treturn reflect.DeepEqual(v, reflect.Zero(t))\n+\t}\n+\treturn false\n+}\n+\n+// canIndexOrdinally returns whether a value contains an ordered sequence of elements.\n+func canIndexOrdinally(v reflect.Value) bool {\n+\tif !v.IsValid() {\n+\t\treturn false\n+\t}\n+\tswitch t := v.Type(); t.Kind() {\n+\tcase reflect.Ptr, reflect.Interface:\n+\t\treturn canIndexOrdinally(v.Elem())\n+\tcase reflect.Slice, reflect.Array:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func fieldInfo(f reflect.StructField) (k string, oe bool) {\n+\tif f.PkgPath != \"\" { // Skip private fields.\n+\t\treturn omittedKey, oe\n+\t}\n+\n+\tk = f.Name\n+\ttag := f.Tag.Get(\"form\")\n+\tif tag == \"\" {\n+\t\treturn k, oe\n+\t}\n+\n+\tps := strings.SplitN(tag, \",\", 2)\n+\tif ps[0] != \"\" {\n+\t\tk = ps[0]\n+\t}\n+\tif len(ps) == 2 {\n+\t\toe = ps[1] == \"omitempty\"\n+\t}\n+\treturn k, oe\n+}\n+\n+func findField(v reflect.Value, n string, ignoreCase bool) (reflect.Value, bool) {\n+\tt := v.Type()\n+\tl := v.NumField()\n+\n+\tvar lowerN string\n+\tcaseInsensitiveMatch := -1\n+\tif ignoreCase {\n+\t\tlowerN = strings.ToLower(n)\n+\t}\n+\n+\t// First try named fields.\n+\tfor i := 0; i < l; i++ {\n+\t\tf := t.Field(i)\n+\t\tk, _ := fieldInfo(f)\n+\t\tif k == omittedKey {\n+\t\t\tcontinue\n+\t\t} else if n == k {\n+\t\t\treturn v.Field(i), true\n+\t\t} else if ignoreCase && lowerN == strings.ToLower(k) {\n+\t\t\tcaseInsensitiveMatch = i\n+\t\t}\n+\t}\n+\n+\t// If no exact match was found try case insensitive match.\n+\tif caseInsensitiveMatch != -1 {\n+\t\treturn v.Field(caseInsensitiveMatch), true\n+\t}\n+\n+\t// Then try anonymous (embedded) fields.\n+\tfor i := 0; i < l; i++ {\n+\t\tf := t.Field(i)\n+\t\tk, _ := fieldInfo(f)\n+\t\tif k == omittedKey || !f.Anonymous { // || k != \"\" ?\n+\t\t\tcontinue\n+\t\t}\n+\t\tfv := v.Field(i)\n+\t\tfk := fv.Kind()\n+\t\tfor fk == reflect.Ptr || fk == reflect.Interface {\n+\t\t\tfv = fv.Elem()\n+\t\t\tfk = fv.Kind()\n+\t\t}\n+\n+\t\tif fk != reflect.Struct {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif ev, ok := findField(fv, n, ignoreCase); ok {\n+\t\t\treturn ev, true\n+\t\t}\n+\t}\n+\n+\treturn reflect.Value{}, false\n+}\n+\n+var (\n+\tstringType    = reflect.TypeOf(string(\"\"))\n+\tstringMapType = reflect.TypeOf(map[string]interface{}{})\n+\ttimeType      = reflect.TypeOf(time.Time{})\n+\ttimePtrType   = reflect.TypeOf(&time.Time{})\n+\turlType       = reflect.TypeOf(url.URL{})\n+)\n+\n+func skipTextMarshalling(t reflect.Type) bool {\n+\t/*// Skip time.Time because its text unmarshaling is overly rigid:\n+\treturn t == timeType || t == timePtrType*/\n+\t// Skip time.Time & convertibles because its text unmarshaling is overly rigid:\n+\treturn t.ConvertibleTo(timeType) || t.ConvertibleTo(timePtrType)\n+}\n+\n+func unmarshalValue(v reflect.Value, x interface{}) bool {\n+\tif skipTextMarshalling(v.Type()) {\n+\t\treturn false\n+\t}\n+\n+\ttu, ok := v.Interface().(encoding.TextUnmarshaler)\n+\tif !ok && !v.CanAddr() {\n+\t\treturn false\n+\t} else if !ok {\n+\t\treturn unmarshalValue(v.Addr(), x)\n+\t}\n+\n+\ts := getString(x)\n+\tif err := tu.UnmarshalText([]byte(s)); err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn true\n+}\n+\n+func marshalValue(v reflect.Value) (string, bool) {\n+\tif skipTextMarshalling(v.Type()) {\n+\t\treturn \"\", false\n+\t}\n+\n+\ttm, ok := v.Interface().(encoding.TextMarshaler)\n+\tif !ok && !v.CanAddr() {\n+\t\treturn \"\", false\n+\t} else if !ok {\n+\t\treturn marshalValue(v.Addr())\n+\t}\n+\n+\tbs, err := tm.MarshalText()\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn string(bs), true\n+}"
    },
    {
      "sha": "4052369cfebc641e7de1638139bb5db019f3c463",
      "filename": "backend/vendor/github.com/ajg/form/form.go",
      "status": "added",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fform.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fform.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fform.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 Alvaro J. Genial. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package form implements encoding and decoding of application/x-www-form-urlencoded data.\n+package form\n+\n+const (\n+\timplicitKey = \"_\"\n+\tomittedKey  = \"-\"\n+\n+\tdefaultDelimiter = '.'\n+\tdefaultEscape    = '\\\\'\n+)"
    },
    {
      "sha": "567aaafde1293a39bec98967aa095c66c0a69ff2",
      "filename": "backend/vendor/github.com/ajg/form/node.go",
      "status": "added",
      "additions": 152,
      "deletions": 0,
      "changes": 152,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fnode.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fnode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fnode.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2014 Alvaro J. Genial. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package form\n+\n+import (\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+type node map[string]interface{}\n+\n+func (n node) values(d, e rune) url.Values {\n+\tvs := url.Values{}\n+\tn.merge(d, e, \"\", &vs)\n+\treturn vs\n+}\n+\n+func (n node) merge(d, e rune, p string, vs *url.Values) {\n+\tfor k, x := range n {\n+\t\tswitch y := x.(type) {\n+\t\tcase string:\n+\t\t\tvs.Add(p+escape(d, e, k), y)\n+\t\tcase node:\n+\t\t\ty.merge(d, e, p+escape(d, e, k)+string(d), vs)\n+\t\tdefault:\n+\t\t\tpanic(\"value is neither string nor node\")\n+\t\t}\n+\t}\n+}\n+\n+// TODO: Add tests for implicit indexing.\n+func parseValues(d, e rune, vs url.Values, canIndexFirstLevelOrdinally bool) node {\n+\t// NOTE: Because of the flattening of potentially multiple strings to one key, implicit indexing works:\n+\t//    i. At the first level;   e.g. Foo.Bar=A&Foo.Bar=B     becomes 0.Foo.Bar=A&1.Foo.Bar=B\n+\t//   ii. At the last level;    e.g. Foo.Bar._=A&Foo.Bar._=B becomes Foo.Bar.0=A&Foo.Bar.1=B\n+\t// TODO: At in-between levels; e.g. Foo._.Bar=A&Foo._.Bar=B becomes Foo.0.Bar=A&Foo.1.Bar=B\n+\t//       (This last one requires that there only be one placeholder in order for it to be unambiguous.)\n+\n+\tm := map[string]string{}\n+\tfor k, ss := range vs {\n+\t\tindexLastLevelOrdinally := strings.HasSuffix(k, string(d)+implicitKey)\n+\n+\t\tfor i, s := range ss {\n+\t\t\tif canIndexFirstLevelOrdinally {\n+\t\t\t\tk = strconv.Itoa(i) + string(d) + k\n+\t\t\t} else if indexLastLevelOrdinally {\n+\t\t\t\tk = strings.TrimSuffix(k, implicitKey) + strconv.Itoa(i)\n+\t\t\t}\n+\n+\t\t\tm[k] = s\n+\t\t}\n+\t}\n+\n+\tn := node{}\n+\tfor k, s := range m {\n+\t\tn = n.split(d, e, k, s)\n+\t}\n+\treturn n\n+}\n+\n+func splitPath(d, e rune, path string) (k, rest string) {\n+\tesc := false\n+\tfor i, r := range path {\n+\t\tswitch {\n+\t\tcase !esc && r == e:\n+\t\t\tesc = true\n+\t\tcase !esc && r == d:\n+\t\t\treturn unescape(d, e, path[:i]), path[i+1:]\n+\t\tdefault:\n+\t\t\tesc = false\n+\t\t}\n+\t}\n+\treturn unescape(d, e, path), \"\"\n+}\n+\n+func (n node) split(d, e rune, path, s string) node {\n+\tk, rest := splitPath(d, e, path)\n+\tif rest == \"\" {\n+\t\treturn add(n, k, s)\n+\t}\n+\tif _, ok := n[k]; !ok {\n+\t\tn[k] = node{}\n+\t}\n+\n+\tc := getNode(n[k])\n+\tn[k] = c.split(d, e, rest, s)\n+\treturn n\n+}\n+\n+func add(n node, k, s string) node {\n+\tif n == nil {\n+\t\treturn node{k: s}\n+\t}\n+\n+\tif _, ok := n[k]; ok {\n+\t\tpanic(\"key \" + k + \" already set\")\n+\t}\n+\n+\tn[k] = s\n+\treturn n\n+}\n+\n+func isEmpty(x interface{}) bool {\n+\tswitch y := x.(type) {\n+\tcase string:\n+\t\treturn y == \"\"\n+\tcase node:\n+\t\tif s, ok := y[\"\"].(string); ok {\n+\t\t\treturn s == \"\"\n+\t\t}\n+\t\treturn false\n+\t}\n+\tpanic(\"value is neither string nor node\")\n+}\n+\n+func getNode(x interface{}) node {\n+\tswitch y := x.(type) {\n+\tcase string:\n+\t\treturn node{\"\": y}\n+\tcase node:\n+\t\treturn y\n+\t}\n+\tpanic(\"value is neither string nor node\")\n+}\n+\n+func getString(x interface{}) string {\n+\tswitch y := x.(type) {\n+\tcase string:\n+\t\treturn y\n+\tcase node:\n+\t\tif s, ok := y[\"\"].(string); ok {\n+\t\t\treturn s\n+\t\t}\n+\t\treturn \"\"\n+\t}\n+\tpanic(\"value is neither string nor node\")\n+}\n+\n+func escape(d, e rune, s string) string {\n+\ts = strings.Replace(s, string(e), string(e)+string(e), -1) // Escape the escape    (\\ => \\\\)\n+\ts = strings.Replace(s, string(d), string(e)+string(d), -1) // Escape the delimiter (. => \\.)\n+\treturn s\n+}\n+\n+func unescape(d, e rune, s string) string {\n+\ts = strings.Replace(s, string(e)+string(d), string(d), -1) // Unescape the delimiter (\\. => .)\n+\ts = strings.Replace(s, string(e)+string(e), string(e), -1) // Unescape the escape    (\\\\ => \\)\n+\treturn s\n+}"
    },
    {
      "sha": "29ce311e38a878dd82d9692ded53eac2afa4d419",
      "filename": "backend/vendor/github.com/ajg/form/pre-commit.sh",
      "status": "added",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fpre-commit.sh",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fpre-commit.sh",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fajg%2Fform%2Fpre-commit.sh?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash -eu\n+\n+# TODO: Only colorize messages given a suitable terminal.\n+# FIXME: Handle case in which no stash entry is created due to no changes.\n+\n+printf \"\\e[30m=== PRE-COMMIT STARTING ===\\e[m\\n\"\n+git stash save --quiet --keep-index --include-untracked\n+\n+if go build -v ./... && go test -v -cover ./... && go vet ./... && golint . && travis-lint; then\n+  result=$?\n+  printf \"\\e[32m=== PRE-COMMIT SUCCEEDED ===\\e[m\\n\"\n+else\n+  result=$?\n+  printf \"\\e[31m=== PRE-COMMIT FAILED ===\\e[m\\n\"\n+fi\n+\n+git stash pop --quiet\n+exit $result"
    },
    {
      "sha": "24b53065f40b5d7d277a64375956ec19cb2123c5",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/LICENSE.txt",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2FLICENSE.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2FLICENSE.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2FLICENSE.txt?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,22 @@\n+Copyright (c) 2016 Caleb Spare\n+\n+MIT License\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    {
      "sha": "792b4a60b346536061e65b9fbaeeb2475be4e3c1",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/README.md",
      "status": "added",
      "additions": 69,
      "deletions": 0,
      "changes": 69,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2FREADME.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,69 @@\n+# xxhash\n+\n+[![Go Reference](https://pkg.go.dev/badge/github.com/cespare/xxhash/v2.svg)](https://pkg.go.dev/github.com/cespare/xxhash/v2)\n+[![Test](https://github.com/cespare/xxhash/actions/workflows/test.yml/badge.svg)](https://github.com/cespare/xxhash/actions/workflows/test.yml)\n+\n+xxhash is a Go implementation of the 64-bit\n+[xxHash](http://cyan4973.github.io/xxHash/) algorithm, XXH64. This is a\n+high-quality hashing algorithm that is much faster than anything in the Go\n+standard library.\n+\n+This package provides a straightforward API:\n+\n+```\n+func Sum64(b []byte) uint64\n+func Sum64String(s string) uint64\n+type Digest struct{ ... }\n+    func New() *Digest\n+```\n+\n+The `Digest` type implements hash.Hash64. Its key methods are:\n+\n+```\n+func (*Digest) Write([]byte) (int, error)\n+func (*Digest) WriteString(string) (int, error)\n+func (*Digest) Sum64() uint64\n+```\n+\n+This implementation provides a fast pure-Go implementation and an even faster\n+assembly implementation for amd64.\n+\n+## Compatibility\n+\n+This package is in a module and the latest code is in version 2 of the module.\n+You need a version of Go with at least \"minimal module compatibility\" to use\n+github.com/cespare/xxhash/v2:\n+\n+* 1.9.7+ for Go 1.9\n+* 1.10.3+ for Go 1.10\n+* Go 1.11 or later\n+\n+I recommend using the latest release of Go.\n+\n+## Benchmarks\n+\n+Here are some quick benchmarks comparing the pure-Go and assembly\n+implementations of Sum64.\n+\n+| input size | purego | asm |\n+| --- | --- | --- |\n+| 5 B   |  979.66 MB/s |  1291.17 MB/s  |\n+| 100 B | 7475.26 MB/s | 7973.40 MB/s  |\n+| 4 KB  | 17573.46 MB/s | 17602.65 MB/s |\n+| 10 MB | 17131.46 MB/s | 17142.16 MB/s |\n+\n+These numbers were generated on Ubuntu 18.04 with an Intel i7-8700K CPU using\n+the following commands under Go 1.11.2:\n+\n+```\n+$ go test -tags purego -benchtime 10s -bench '/xxhash,direct,bytes'\n+$ go test -benchtime 10s -bench '/xxhash,direct,bytes'\n+```\n+\n+## Projects using this package\n+\n+- [InfluxDB](https://github.com/influxdata/influxdb)\n+- [Prometheus](https://github.com/prometheus/prometheus)\n+- [VictoriaMetrics](https://github.com/VictoriaMetrics/VictoriaMetrics)\n+- [FreeCache](https://github.com/coocood/freecache)\n+- [FastCache](https://github.com/VictoriaMetrics/fastcache)"
    },
    {
      "sha": "15c835d5417c06d14182c50afc7c5b2ca0b45fce",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/xxhash.go",
      "status": "added",
      "additions": 235,
      "deletions": 0,
      "changes": 235,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,235 @@\n+// Package xxhash implements the 64-bit variant of xxHash (XXH64) as described\n+// at http://cyan4973.github.io/xxHash/.\n+package xxhash\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"math/bits\"\n+)\n+\n+const (\n+\tprime1 uint64 = 11400714785074694791\n+\tprime2 uint64 = 14029467366897019727\n+\tprime3 uint64 = 1609587929392839161\n+\tprime4 uint64 = 9650029242287828579\n+\tprime5 uint64 = 2870177450012600261\n+)\n+\n+// NOTE(caleb): I'm using both consts and vars of the primes. Using consts where\n+// possible in the Go code is worth a small (but measurable) performance boost\n+// by avoiding some MOVQs. Vars are needed for the asm and also are useful for\n+// convenience in the Go code in a few places where we need to intentionally\n+// avoid constant arithmetic (e.g., v1 := prime1 + prime2 fails because the\n+// result overflows a uint64).\n+var (\n+\tprime1v = prime1\n+\tprime2v = prime2\n+\tprime3v = prime3\n+\tprime4v = prime4\n+\tprime5v = prime5\n+)\n+\n+// Digest implements hash.Hash64.\n+type Digest struct {\n+\tv1    uint64\n+\tv2    uint64\n+\tv3    uint64\n+\tv4    uint64\n+\ttotal uint64\n+\tmem   [32]byte\n+\tn     int // how much of mem is used\n+}\n+\n+// New creates a new Digest that computes the 64-bit xxHash algorithm.\n+func New() *Digest {\n+\tvar d Digest\n+\td.Reset()\n+\treturn &d\n+}\n+\n+// Reset clears the Digest's state so that it can be reused.\n+func (d *Digest) Reset() {\n+\td.v1 = prime1v + prime2\n+\td.v2 = prime2\n+\td.v3 = 0\n+\td.v4 = -prime1v\n+\td.total = 0\n+\td.n = 0\n+}\n+\n+// Size always returns 8 bytes.\n+func (d *Digest) Size() int { return 8 }\n+\n+// BlockSize always returns 32 bytes.\n+func (d *Digest) BlockSize() int { return 32 }\n+\n+// Write adds more data to d. It always returns len(b), nil.\n+func (d *Digest) Write(b []byte) (n int, err error) {\n+\tn = len(b)\n+\td.total += uint64(n)\n+\n+\tif d.n+n < 32 {\n+\t\t// This new data doesn't even fill the current block.\n+\t\tcopy(d.mem[d.n:], b)\n+\t\td.n += n\n+\t\treturn\n+\t}\n+\n+\tif d.n > 0 {\n+\t\t// Finish off the partial block.\n+\t\tcopy(d.mem[d.n:], b)\n+\t\td.v1 = round(d.v1, u64(d.mem[0:8]))\n+\t\td.v2 = round(d.v2, u64(d.mem[8:16]))\n+\t\td.v3 = round(d.v3, u64(d.mem[16:24]))\n+\t\td.v4 = round(d.v4, u64(d.mem[24:32]))\n+\t\tb = b[32-d.n:]\n+\t\td.n = 0\n+\t}\n+\n+\tif len(b) >= 32 {\n+\t\t// One or more full blocks left.\n+\t\tnw := writeBlocks(d, b)\n+\t\tb = b[nw:]\n+\t}\n+\n+\t// Store any remaining partial block.\n+\tcopy(d.mem[:], b)\n+\td.n = len(b)\n+\n+\treturn\n+}\n+\n+// Sum appends the current hash to b and returns the resulting slice.\n+func (d *Digest) Sum(b []byte) []byte {\n+\ts := d.Sum64()\n+\treturn append(\n+\t\tb,\n+\t\tbyte(s>>56),\n+\t\tbyte(s>>48),\n+\t\tbyte(s>>40),\n+\t\tbyte(s>>32),\n+\t\tbyte(s>>24),\n+\t\tbyte(s>>16),\n+\t\tbyte(s>>8),\n+\t\tbyte(s),\n+\t)\n+}\n+\n+// Sum64 returns the current hash.\n+func (d *Digest) Sum64() uint64 {\n+\tvar h uint64\n+\n+\tif d.total >= 32 {\n+\t\tv1, v2, v3, v4 := d.v1, d.v2, d.v3, d.v4\n+\t\th = rol1(v1) + rol7(v2) + rol12(v3) + rol18(v4)\n+\t\th = mergeRound(h, v1)\n+\t\th = mergeRound(h, v2)\n+\t\th = mergeRound(h, v3)\n+\t\th = mergeRound(h, v4)\n+\t} else {\n+\t\th = d.v3 + prime5\n+\t}\n+\n+\th += d.total\n+\n+\ti, end := 0, d.n\n+\tfor ; i+8 <= end; i += 8 {\n+\t\tk1 := round(0, u64(d.mem[i:i+8]))\n+\t\th ^= k1\n+\t\th = rol27(h)*prime1 + prime4\n+\t}\n+\tif i+4 <= end {\n+\t\th ^= uint64(u32(d.mem[i:i+4])) * prime1\n+\t\th = rol23(h)*prime2 + prime3\n+\t\ti += 4\n+\t}\n+\tfor i < end {\n+\t\th ^= uint64(d.mem[i]) * prime5\n+\t\th = rol11(h) * prime1\n+\t\ti++\n+\t}\n+\n+\th ^= h >> 33\n+\th *= prime2\n+\th ^= h >> 29\n+\th *= prime3\n+\th ^= h >> 32\n+\n+\treturn h\n+}\n+\n+const (\n+\tmagic         = \"xxh\\x06\"\n+\tmarshaledSize = len(magic) + 8*5 + 32\n+)\n+\n+// MarshalBinary implements the encoding.BinaryMarshaler interface.\n+func (d *Digest) MarshalBinary() ([]byte, error) {\n+\tb := make([]byte, 0, marshaledSize)\n+\tb = append(b, magic...)\n+\tb = appendUint64(b, d.v1)\n+\tb = appendUint64(b, d.v2)\n+\tb = appendUint64(b, d.v3)\n+\tb = appendUint64(b, d.v4)\n+\tb = appendUint64(b, d.total)\n+\tb = append(b, d.mem[:d.n]...)\n+\tb = b[:len(b)+len(d.mem)-d.n]\n+\treturn b, nil\n+}\n+\n+// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n+func (d *Digest) UnmarshalBinary(b []byte) error {\n+\tif len(b) < len(magic) || string(b[:len(magic)]) != magic {\n+\t\treturn errors.New(\"xxhash: invalid hash state identifier\")\n+\t}\n+\tif len(b) != marshaledSize {\n+\t\treturn errors.New(\"xxhash: invalid hash state size\")\n+\t}\n+\tb = b[len(magic):]\n+\tb, d.v1 = consumeUint64(b)\n+\tb, d.v2 = consumeUint64(b)\n+\tb, d.v3 = consumeUint64(b)\n+\tb, d.v4 = consumeUint64(b)\n+\tb, d.total = consumeUint64(b)\n+\tcopy(d.mem[:], b)\n+\td.n = int(d.total % uint64(len(d.mem)))\n+\treturn nil\n+}\n+\n+func appendUint64(b []byte, x uint64) []byte {\n+\tvar a [8]byte\n+\tbinary.LittleEndian.PutUint64(a[:], x)\n+\treturn append(b, a[:]...)\n+}\n+\n+func consumeUint64(b []byte) ([]byte, uint64) {\n+\tx := u64(b)\n+\treturn b[8:], x\n+}\n+\n+func u64(b []byte) uint64 { return binary.LittleEndian.Uint64(b) }\n+func u32(b []byte) uint32 { return binary.LittleEndian.Uint32(b) }\n+\n+func round(acc, input uint64) uint64 {\n+\tacc += input * prime2\n+\tacc = rol31(acc)\n+\tacc *= prime1\n+\treturn acc\n+}\n+\n+func mergeRound(acc, val uint64) uint64 {\n+\tval = round(0, val)\n+\tacc ^= val\n+\tacc = acc*prime1 + prime4\n+\treturn acc\n+}\n+\n+func rol1(x uint64) uint64  { return bits.RotateLeft64(x, 1) }\n+func rol7(x uint64) uint64  { return bits.RotateLeft64(x, 7) }\n+func rol11(x uint64) uint64 { return bits.RotateLeft64(x, 11) }\n+func rol12(x uint64) uint64 { return bits.RotateLeft64(x, 12) }\n+func rol18(x uint64) uint64 { return bits.RotateLeft64(x, 18) }\n+func rol23(x uint64) uint64 { return bits.RotateLeft64(x, 23) }\n+func rol27(x uint64) uint64 { return bits.RotateLeft64(x, 27) }\n+func rol31(x uint64) uint64 { return bits.RotateLeft64(x, 31) }"
    },
    {
      "sha": "ad14b807f4d96913a9c77366a61f075b188554cc",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/xxhash_amd64.go",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_amd64.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_amd64.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,13 @@\n+// +build !appengine\n+// +build gc\n+// +build !purego\n+\n+package xxhash\n+\n+// Sum64 computes the 64-bit xxHash digest of b.\n+//\n+//go:noescape\n+func Sum64(b []byte) uint64\n+\n+//go:noescape\n+func writeBlocks(d *Digest, b []byte) int"
    },
    {
      "sha": "be8db5bf796015120afa0748cf1c39f2acf4f576",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/xxhash_amd64.s",
      "status": "added",
      "additions": 215,
      "deletions": 0,
      "changes": 215,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_amd64.s",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_amd64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_amd64.s?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,215 @@\n+// +build !appengine\n+// +build gc\n+// +build !purego\n+\n+#include \"textflag.h\"\n+\n+// Register allocation:\n+// AX\th\n+// SI\tpointer to advance through b\n+// DX\tn\n+// BX\tloop end\n+// R8\tv1, k1\n+// R9\tv2\n+// R10\tv3\n+// R11\tv4\n+// R12\ttmp\n+// R13\tprime1v\n+// R14\tprime2v\n+// DI\tprime4v\n+\n+// round reads from and advances the buffer pointer in SI.\n+// It assumes that R13 has prime1v and R14 has prime2v.\n+#define round(r) \\\n+\tMOVQ  (SI), R12 \\\n+\tADDQ  $8, SI    \\\n+\tIMULQ R14, R12  \\\n+\tADDQ  R12, r    \\\n+\tROLQ  $31, r    \\\n+\tIMULQ R13, r\n+\n+// mergeRound applies a merge round on the two registers acc and val.\n+// It assumes that R13 has prime1v, R14 has prime2v, and DI has prime4v.\n+#define mergeRound(acc, val) \\\n+\tIMULQ R14, val \\\n+\tROLQ  $31, val \\\n+\tIMULQ R13, val \\\n+\tXORQ  val, acc \\\n+\tIMULQ R13, acc \\\n+\tADDQ  DI, acc\n+\n+// func Sum64(b []byte) uint64\n+TEXT ·Sum64(SB), NOSPLIT, $0-32\n+\t// Load fixed primes.\n+\tMOVQ ·prime1v(SB), R13\n+\tMOVQ ·prime2v(SB), R14\n+\tMOVQ ·prime4v(SB), DI\n+\n+\t// Load slice.\n+\tMOVQ b_base+0(FP), SI\n+\tMOVQ b_len+8(FP), DX\n+\tLEAQ (SI)(DX*1), BX\n+\n+\t// The first loop limit will be len(b)-32.\n+\tSUBQ $32, BX\n+\n+\t// Check whether we have at least one block.\n+\tCMPQ DX, $32\n+\tJLT  noBlocks\n+\n+\t// Set up initial state (v1, v2, v3, v4).\n+\tMOVQ R13, R8\n+\tADDQ R14, R8\n+\tMOVQ R14, R9\n+\tXORQ R10, R10\n+\tXORQ R11, R11\n+\tSUBQ R13, R11\n+\n+\t// Loop until SI > BX.\n+blockLoop:\n+\tround(R8)\n+\tround(R9)\n+\tround(R10)\n+\tround(R11)\n+\n+\tCMPQ SI, BX\n+\tJLE  blockLoop\n+\n+\tMOVQ R8, AX\n+\tROLQ $1, AX\n+\tMOVQ R9, R12\n+\tROLQ $7, R12\n+\tADDQ R12, AX\n+\tMOVQ R10, R12\n+\tROLQ $12, R12\n+\tADDQ R12, AX\n+\tMOVQ R11, R12\n+\tROLQ $18, R12\n+\tADDQ R12, AX\n+\n+\tmergeRound(AX, R8)\n+\tmergeRound(AX, R9)\n+\tmergeRound(AX, R10)\n+\tmergeRound(AX, R11)\n+\n+\tJMP afterBlocks\n+\n+noBlocks:\n+\tMOVQ ·prime5v(SB), AX\n+\n+afterBlocks:\n+\tADDQ DX, AX\n+\n+\t// Right now BX has len(b)-32, and we want to loop until SI > len(b)-8.\n+\tADDQ $24, BX\n+\n+\tCMPQ SI, BX\n+\tJG   fourByte\n+\n+wordLoop:\n+\t// Calculate k1.\n+\tMOVQ  (SI), R8\n+\tADDQ  $8, SI\n+\tIMULQ R14, R8\n+\tROLQ  $31, R8\n+\tIMULQ R13, R8\n+\n+\tXORQ  R8, AX\n+\tROLQ  $27, AX\n+\tIMULQ R13, AX\n+\tADDQ  DI, AX\n+\n+\tCMPQ SI, BX\n+\tJLE  wordLoop\n+\n+fourByte:\n+\tADDQ $4, BX\n+\tCMPQ SI, BX\n+\tJG   singles\n+\n+\tMOVL  (SI), R8\n+\tADDQ  $4, SI\n+\tIMULQ R13, R8\n+\tXORQ  R8, AX\n+\n+\tROLQ  $23, AX\n+\tIMULQ R14, AX\n+\tADDQ  ·prime3v(SB), AX\n+\n+singles:\n+\tADDQ $4, BX\n+\tCMPQ SI, BX\n+\tJGE  finalize\n+\n+singlesLoop:\n+\tMOVBQZX (SI), R12\n+\tADDQ    $1, SI\n+\tIMULQ   ·prime5v(SB), R12\n+\tXORQ    R12, AX\n+\n+\tROLQ  $11, AX\n+\tIMULQ R13, AX\n+\n+\tCMPQ SI, BX\n+\tJL   singlesLoop\n+\n+finalize:\n+\tMOVQ  AX, R12\n+\tSHRQ  $33, R12\n+\tXORQ  R12, AX\n+\tIMULQ R14, AX\n+\tMOVQ  AX, R12\n+\tSHRQ  $29, R12\n+\tXORQ  R12, AX\n+\tIMULQ ·prime3v(SB), AX\n+\tMOVQ  AX, R12\n+\tSHRQ  $32, R12\n+\tXORQ  R12, AX\n+\n+\tMOVQ AX, ret+24(FP)\n+\tRET\n+\n+// writeBlocks uses the same registers as above except that it uses AX to store\n+// the d pointer.\n+\n+// func writeBlocks(d *Digest, b []byte) int\n+TEXT ·writeBlocks(SB), NOSPLIT, $0-40\n+\t// Load fixed primes needed for round.\n+\tMOVQ ·prime1v(SB), R13\n+\tMOVQ ·prime2v(SB), R14\n+\n+\t// Load slice.\n+\tMOVQ b_base+8(FP), SI\n+\tMOVQ b_len+16(FP), DX\n+\tLEAQ (SI)(DX*1), BX\n+\tSUBQ $32, BX\n+\n+\t// Load vN from d.\n+\tMOVQ d+0(FP), AX\n+\tMOVQ 0(AX), R8   // v1\n+\tMOVQ 8(AX), R9   // v2\n+\tMOVQ 16(AX), R10 // v3\n+\tMOVQ 24(AX), R11 // v4\n+\n+\t// We don't need to check the loop condition here; this function is\n+\t// always called with at least one block of data to process.\n+blockLoop:\n+\tround(R8)\n+\tround(R9)\n+\tround(R10)\n+\tround(R11)\n+\n+\tCMPQ SI, BX\n+\tJLE  blockLoop\n+\n+\t// Copy vN back to d.\n+\tMOVQ R8, 0(AX)\n+\tMOVQ R9, 8(AX)\n+\tMOVQ R10, 16(AX)\n+\tMOVQ R11, 24(AX)\n+\n+\t// The number of bytes written is SI minus the old base pointer.\n+\tSUBQ b_base+8(FP), SI\n+\tMOVQ SI, ret+32(FP)\n+\n+\tRET"
    },
    {
      "sha": "4a5a821603e5b8d876d07219882c5e127619f1a3",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/xxhash_other.go",
      "status": "added",
      "additions": 76,
      "deletions": 0,
      "changes": 76,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_other.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_other.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_other.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,76 @@\n+// +build !amd64 appengine !gc purego\n+\n+package xxhash\n+\n+// Sum64 computes the 64-bit xxHash digest of b.\n+func Sum64(b []byte) uint64 {\n+\t// A simpler version would be\n+\t//   d := New()\n+\t//   d.Write(b)\n+\t//   return d.Sum64()\n+\t// but this is faster, particularly for small inputs.\n+\n+\tn := len(b)\n+\tvar h uint64\n+\n+\tif n >= 32 {\n+\t\tv1 := prime1v + prime2\n+\t\tv2 := prime2\n+\t\tv3 := uint64(0)\n+\t\tv4 := -prime1v\n+\t\tfor len(b) >= 32 {\n+\t\t\tv1 = round(v1, u64(b[0:8:len(b)]))\n+\t\t\tv2 = round(v2, u64(b[8:16:len(b)]))\n+\t\t\tv3 = round(v3, u64(b[16:24:len(b)]))\n+\t\t\tv4 = round(v4, u64(b[24:32:len(b)]))\n+\t\t\tb = b[32:len(b):len(b)]\n+\t\t}\n+\t\th = rol1(v1) + rol7(v2) + rol12(v3) + rol18(v4)\n+\t\th = mergeRound(h, v1)\n+\t\th = mergeRound(h, v2)\n+\t\th = mergeRound(h, v3)\n+\t\th = mergeRound(h, v4)\n+\t} else {\n+\t\th = prime5\n+\t}\n+\n+\th += uint64(n)\n+\n+\ti, end := 0, len(b)\n+\tfor ; i+8 <= end; i += 8 {\n+\t\tk1 := round(0, u64(b[i:i+8:len(b)]))\n+\t\th ^= k1\n+\t\th = rol27(h)*prime1 + prime4\n+\t}\n+\tif i+4 <= end {\n+\t\th ^= uint64(u32(b[i:i+4:len(b)])) * prime1\n+\t\th = rol23(h)*prime2 + prime3\n+\t\ti += 4\n+\t}\n+\tfor ; i < end; i++ {\n+\t\th ^= uint64(b[i]) * prime5\n+\t\th = rol11(h) * prime1\n+\t}\n+\n+\th ^= h >> 33\n+\th *= prime2\n+\th ^= h >> 29\n+\th *= prime3\n+\th ^= h >> 32\n+\n+\treturn h\n+}\n+\n+func writeBlocks(d *Digest, b []byte) int {\n+\tv1, v2, v3, v4 := d.v1, d.v2, d.v3, d.v4\n+\tn := len(b)\n+\tfor len(b) >= 32 {\n+\t\tv1 = round(v1, u64(b[0:8:len(b)]))\n+\t\tv2 = round(v2, u64(b[8:16:len(b)]))\n+\t\tv3 = round(v3, u64(b[16:24:len(b)]))\n+\t\tv4 = round(v4, u64(b[24:32:len(b)]))\n+\t\tb = b[32:len(b):len(b)]\n+\t}\n+\td.v1, d.v2, d.v3, d.v4 = v1, v2, v3, v4\n+\treturn n - len(b)\n+}"
    },
    {
      "sha": "fc9bea7a31f2b7cb8b9e6724735b4166eba2adc6",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/xxhash_safe.go",
      "status": "added",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_safe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_safe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_safe.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,15 @@\n+// +build appengine\n+\n+// This file contains the safe implementations of otherwise unsafe-using code.\n+\n+package xxhash\n+\n+// Sum64String computes the 64-bit xxHash digest of s.\n+func Sum64String(s string) uint64 {\n+\treturn Sum64([]byte(s))\n+}\n+\n+// WriteString adds more data to d. It always returns len(s), nil.\n+func (d *Digest) WriteString(s string) (n int, err error) {\n+\treturn d.Write([]byte(s))\n+}"
    },
    {
      "sha": "376e0ca2e49745ecb087871d2e27afb4ed2d987d",
      "filename": "backend/vendor/github.com/cespare/xxhash/v2/xxhash_unsafe.go",
      "status": "added",
      "additions": 57,
      "deletions": 0,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_unsafe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_unsafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fcespare%2Fxxhash%2Fv2%2Fxxhash_unsafe.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,57 @@\n+// +build !appengine\n+\n+// This file encapsulates usage of unsafe.\n+// xxhash_safe.go contains the safe implementations.\n+\n+package xxhash\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// In the future it's possible that compiler optimizations will make these\n+// XxxString functions unnecessary by realizing that calls such as\n+// Sum64([]byte(s)) don't need to copy s. See https://golang.org/issue/2205.\n+// If that happens, even if we keep these functions they can be replaced with\n+// the trivial safe code.\n+\n+// NOTE: The usual way of doing an unsafe string-to-[]byte conversion is:\n+//\n+//   var b []byte\n+//   bh := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+//   bh.Data = (*reflect.StringHeader)(unsafe.Pointer(&s)).Data\n+//   bh.Len = len(s)\n+//   bh.Cap = len(s)\n+//\n+// Unfortunately, as of Go 1.15.3 the inliner's cost model assigns a high enough\n+// weight to this sequence of expressions that any function that uses it will\n+// not be inlined. Instead, the functions below use a different unsafe\n+// conversion designed to minimize the inliner weight and allow both to be\n+// inlined. There is also a test (TestInlining) which verifies that these are\n+// inlined.\n+//\n+// See https://github.com/golang/go/issues/42739 for discussion.\n+\n+// Sum64String computes the 64-bit xxHash digest of s.\n+// It may be faster than Sum64([]byte(s)) by avoiding a copy.\n+func Sum64String(s string) uint64 {\n+\tb := *(*[]byte)(unsafe.Pointer(&sliceHeader{s, len(s)}))\n+\treturn Sum64(b)\n+}\n+\n+// WriteString adds more data to d. It always returns len(s), nil.\n+// It may be faster than Write([]byte(s)) by avoiding a copy.\n+func (d *Digest) WriteString(s string) (n int, err error) {\n+\td.Write(*(*[]byte)(unsafe.Pointer(&sliceHeader{s, len(s)})))\n+\t// d.Write always returns len(s), nil.\n+\t// Ignoring the return output and returning these fixed values buys a\n+\t// savings of 6 in the inliner's cost model.\n+\treturn len(s), nil\n+}\n+\n+// sliceHeader is similar to reflect.SliceHeader, but it assumes that the layout\n+// of the first two words is the same as the layout of a string.\n+type sliceHeader struct {\n+\ts   string\n+\tcap int\n+}"
    },
    {
      "sha": "22080f736a41a6fb2287c3f0cf5c5b25345279a4",
      "filename": "backend/vendor/github.com/dgryski/go-rendezvous/LICENSE",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fdgryski%2Fgo-rendezvous%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fdgryski%2Fgo-rendezvous%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fdgryski%2Fgo-rendezvous%2FLICENSE?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,21 @@\n+The MIT License (MIT)\n+\n+Copyright (c) 2017-2020 Damian Gryski <damian@gryski.com>\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
    },
    {
      "sha": "7a6f8203c67810356a413b9f56abf30a0429de59",
      "filename": "backend/vendor/github.com/dgryski/go-rendezvous/rdv.go",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fdgryski%2Fgo-rendezvous%2Frdv.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fdgryski%2Fgo-rendezvous%2Frdv.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fdgryski%2Fgo-rendezvous%2Frdv.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,79 @@\n+package rendezvous\n+\n+type Rendezvous struct {\n+\tnodes map[string]int\n+\tnstr  []string\n+\tnhash []uint64\n+\thash  Hasher\n+}\n+\n+type Hasher func(s string) uint64\n+\n+func New(nodes []string, hash Hasher) *Rendezvous {\n+\tr := &Rendezvous{\n+\t\tnodes: make(map[string]int, len(nodes)),\n+\t\tnstr:  make([]string, len(nodes)),\n+\t\tnhash: make([]uint64, len(nodes)),\n+\t\thash:  hash,\n+\t}\n+\n+\tfor i, n := range nodes {\n+\t\tr.nodes[n] = i\n+\t\tr.nstr[i] = n\n+\t\tr.nhash[i] = hash(n)\n+\t}\n+\n+\treturn r\n+}\n+\n+func (r *Rendezvous) Lookup(k string) string {\n+\t// short-circuit if we're empty\n+\tif len(r.nodes) == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\tkhash := r.hash(k)\n+\n+\tvar midx int\n+\tvar mhash = xorshiftMult64(khash ^ r.nhash[0])\n+\n+\tfor i, nhash := range r.nhash[1:] {\n+\t\tif h := xorshiftMult64(khash ^ nhash); h > mhash {\n+\t\t\tmidx = i + 1\n+\t\t\tmhash = h\n+\t\t}\n+\t}\n+\n+\treturn r.nstr[midx]\n+}\n+\n+func (r *Rendezvous) Add(node string) {\n+\tr.nodes[node] = len(r.nstr)\n+\tr.nstr = append(r.nstr, node)\n+\tr.nhash = append(r.nhash, r.hash(node))\n+}\n+\n+func (r *Rendezvous) Remove(node string) {\n+\t// find index of node to remove\n+\tnidx := r.nodes[node]\n+\n+\t// remove from the slices\n+\tl := len(r.nstr)\n+\tr.nstr[nidx] = r.nstr[l]\n+\tr.nstr = r.nstr[:l]\n+\n+\tr.nhash[nidx] = r.nhash[l]\n+\tr.nhash = r.nhash[:l]\n+\n+\t// update the map\n+\tdelete(r.nodes, node)\n+\tmoved := r.nstr[nidx]\n+\tr.nodes[moved] = nidx\n+}\n+\n+func xorshiftMult64(x uint64) uint64 {\n+\tx ^= x >> 12 // a\n+\tx ^= x << 25 // b\n+\tx ^= x >> 27 // c\n+\treturn x * 2685821657736338717\n+}"
    },
    {
      "sha": "22d0d82f8095e9c0ed572776afb47f9ca293ce00",
      "filename": "backend/vendor/github.com/go-chi/render/.gitignore",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2F.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2F.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2F.gitignore?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1 @@\n+vendor"
    },
    {
      "sha": "a0262045ddcfbdf0f13c744fb175cac19272d661",
      "filename": "backend/vendor/github.com/go-chi/render/.travis.yml",
      "status": "removed",
      "additions": 0,
      "deletions": 15,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2F.travis.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2F.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2F.travis.yml?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,15 +0,0 @@\n-language: go\n-\n-go:\n-  - 1.7.x\n-  - 1.8.x\n-  - tip\n-\n-install:\n-  - go get -u golang.org/x/tools/cmd/goimports\n-\n-script:\n-  - go get -d -t ./...\n-  - go test ./...\n-  - >\n-    goimports -d -e ./ | grep '.*' && { echo; echo \"Aborting due to non-empty goimports output.\"; exit 1; } || :"
    },
    {
      "sha": "4d371538ac89547b1f84ab1e5f03fee4b346b92e",
      "filename": "backend/vendor/github.com/go-chi/render/README.md",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2FREADME.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,5 +1,9 @@\n # render\n \n+![tests](https://github.com/go-chi/render/actions/workflows/test.yml/badge.svg)\n+[![Go Report Card](https://goreportcard.com/badge/github.com/go-chi/render)](https://goreportcard.com/report/github.com/go-chi/render)\n+[![Go Reference](https://pkg.go.dev/badge/github.com/go-chi/render.svg)](https://pkg.go.dev/github.com/go-chi/render)\n+\n The `render` package helps manage HTTP request / response payloads.\n \n Every well-designed, robust and maintainable Web Service / REST API also needs\n@@ -21,4 +25,3 @@ request bodies. Please have a look at the [rest](https://github.com/go-chi/chi/b\n example which uses the latest chi/render sub-pkg.\n \n All feedback is welcome, thank you!\n-"
    },
    {
      "sha": "883b2f84040fc2a686fa45597767e6a59821a5fa",
      "filename": "backend/vendor/github.com/go-chi/render/decoder.go",
      "status": "modified",
      "additions": 16,
      "deletions": 3,
      "changes": 19,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2Fdecoder.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2Fdecoder.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2Fdecoder.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -7,6 +7,8 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net/http\"\n+\n+\t\"github.com/ajg/form\"\n )\n \n // Decode is a package-level variable set to our default Decoder. We do this\n@@ -17,6 +19,8 @@ import (\n // bytes allowed to be read from the request body.\n var Decode = DefaultDecoder\n \n+// DefaultDecoder detects the correct decoder for use on an HTTP request and\n+// marshals into a given interface.\n func DefaultDecoder(r *http.Request, v interface{}) error {\n \tvar err error\n \n@@ -25,20 +29,29 @@ func DefaultDecoder(r *http.Request, v interface{}) error {\n \t\terr = DecodeJSON(r.Body, v)\n \tcase ContentTypeXML:\n \t\terr = DecodeXML(r.Body, v)\n-\t// case ContentTypeForm: // TODO\n+\tcase ContentTypeForm:\n+\t\terr = DecodeForm(r.Body, v)\n \tdefault:\n \t\terr = errors.New(\"render: unable to automatically decode the request content type\")\n \t}\n \n \treturn err\n }\n \n+// DecodeJSON decodes a given reader into an interface using the json decoder.\n func DecodeJSON(r io.Reader, v interface{}) error {\n-\tdefer io.Copy(ioutil.Discard, r)\n+\tdefer io.Copy(ioutil.Discard, r) //nolint:errcheck\n \treturn json.NewDecoder(r).Decode(v)\n }\n \n+// DecodeXML decodes a given reader into an interface using the xml decoder.\n func DecodeXML(r io.Reader, v interface{}) error {\n-\tdefer io.Copy(ioutil.Discard, r)\n+\tdefer io.Copy(ioutil.Discard, r) //nolint:errcheck\n \treturn xml.NewDecoder(r).Decode(v)\n }\n+\n+// DecodeForm decodes a given reader into an interface using the form decoder.\n+func DecodeForm(r io.Reader, v interface{}) error {\n+\tdecoder := form.NewDecoder(r) //nolint:errcheck\n+\treturn decoder.Decode(v)\n+}"
    },
    {
      "sha": "66d6bbff05ac0bc9da8d466ca73178a2b5c006d1",
      "filename": "backend/vendor/github.com/go-chi/render/responder.go",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2Fresponder.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2Fresponder.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-chi%2Frender%2Fresponder.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -66,7 +66,7 @@ func PlainText(w http.ResponseWriter, r *http.Request, v string) {\n \tif status, ok := r.Context().Value(StatusCtxKey).(int); ok {\n \t\tw.WriteHeader(status)\n \t}\n-\tw.Write([]byte(v))\n+\tw.Write([]byte(v)) //nolint:errcheck\n }\n \n // Data writes raw bytes to the response, setting the Content-Type as\n@@ -76,7 +76,7 @@ func Data(w http.ResponseWriter, r *http.Request, v []byte) {\n \tif status, ok := r.Context().Value(StatusCtxKey).(int); ok {\n \t\tw.WriteHeader(status)\n \t}\n-\tw.Write(v)\n+\tw.Write(v) //nolint:errcheck\n }\n \n // HTML writes a string to the response, setting the Content-Type as text/html.\n@@ -85,7 +85,7 @@ func HTML(w http.ResponseWriter, r *http.Request, v string) {\n \tif status, ok := r.Context().Value(StatusCtxKey).(int); ok {\n \t\tw.WriteHeader(status)\n \t}\n-\tw.Write([]byte(v))\n+\tw.Write([]byte(v)) //nolint:errcheck\n }\n \n // JSON marshals 'v' to JSON, automatically escaping HTML and setting the\n@@ -103,7 +103,7 @@ func JSON(w http.ResponseWriter, r *http.Request, v interface{}) {\n \tif status, ok := r.Context().Value(StatusCtxKey).(int); ok {\n \t\tw.WriteHeader(status)\n \t}\n-\tw.Write(buf.Bytes())\n+\tw.Write(buf.Bytes()) //nolint:errcheck\n }\n \n // XML marshals 'v' to JSON, setting the Content-Type as application/xml. It\n@@ -128,15 +128,15 @@ func XML(w http.ResponseWriter, r *http.Request, v interface{}) {\n \t}\n \tif !bytes.Contains(b[:findHeaderUntil], []byte(\"<?xml\")) {\n \t\t// No header found. Print it out first.\n-\t\tw.Write([]byte(xml.Header))\n+\t\tw.Write([]byte(xml.Header)) //nolint:errcheck\n \t}\n \n-\tw.Write(b)\n+\tw.Write(b) //nolint:errcheck\n }\n \n // NoContent returns a HTTP 204 \"No Content\" response.\n func NoContent(w http.ResponseWriter, r *http.Request) {\n-\tw.WriteHeader(204)\n+\tw.WriteHeader(http.StatusNoContent)\n }\n \n func channelEventStream(w http.ResponseWriter, r *http.Request, v interface{}) {\n@@ -153,7 +153,7 @@ func channelEventStream(w http.ResponseWriter, r *http.Request, v interface{}) {\n \t\tw.Header().Set(\"Connection\", \"keep-alive\")\n \t}\n \n-\tw.WriteHeader(200)\n+\tw.WriteHeader(http.StatusOK)\n \n \tctx := r.Context()\n \tfor {\n@@ -162,12 +162,12 @@ func channelEventStream(w http.ResponseWriter, r *http.Request, v interface{}) {\n \t\t\t{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(v)},\n \t\t}); chosen {\n \t\tcase 0: // equivalent to: case <-ctx.Done()\n-\t\t\tw.Write([]byte(\"event: error\\ndata: {\\\"error\\\":\\\"Server Timeout\\\"}\\n\\n\"))\n+\t\t\tw.Write([]byte(\"event: error\\ndata: {\\\"error\\\":\\\"Server Timeout\\\"}\\n\\n\")) //nolint:errcheck\n \t\t\treturn\n \n \t\tdefault: // equivalent to: case v, ok := <-stream\n \t\t\tif !ok {\n-\t\t\t\tw.Write([]byte(\"event: EOF\\n\\n\"))\n+\t\t\t\tw.Write([]byte(\"event: EOF\\n\\n\")) //nolint:errcheck\n \t\t\t\treturn\n \t\t\t}\n \t\t\tv := recv.Interface()\n@@ -184,13 +184,13 @@ func channelEventStream(w http.ResponseWriter, r *http.Request, v interface{}) {\n \n \t\t\tbytes, err := json.Marshal(v)\n \t\t\tif err != nil {\n-\t\t\t\tw.Write([]byte(fmt.Sprintf(\"event: error\\ndata: {\\\"error\\\":\\\"%v\\\"}\\n\\n\", err)))\n+\t\t\t\tw.Write([]byte(fmt.Sprintf(\"event: error\\ndata: {\\\"error\\\":\\\"%v\\\"}\\n\\n\", err))) //nolint:errcheck\n \t\t\t\tif f, ok := w.(http.Flusher); ok {\n \t\t\t\t\tf.Flush()\n \t\t\t\t}\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tw.Write([]byte(fmt.Sprintf(\"event: data\\ndata: %s\\n\\n\", bytes)))\n+\t\t\tw.Write([]byte(fmt.Sprintf(\"event: data\\ndata: %s\\n\\n\", bytes))) //nolint:errcheck\n \t\t\tif f, ok := w.(http.Flusher); ok {\n \t\t\t\tf.Flush()\n \t\t\t}\n@@ -209,7 +209,7 @@ func channelIntoSlice(w http.ResponseWriter, r *http.Request, from interface{})\n \t\t\t{Dir: reflect.SelectRecv, Chan: reflect.ValueOf(from)},\n \t\t}); chosen {\n \t\tcase 0: // equivalent to: case <-ctx.Done()\n-\t\t\thttp.Error(w, \"Server Timeout\", 504)\n+\t\t\thttp.Error(w, \"Server Timeout\", http.StatusGatewayTimeout)\n \t\t\treturn nil\n \n \t\tdefault: // equivalent to: case v, ok := <-stream"
    },
    {
      "sha": "055683569854174bcf87506d3139a5e9c40bd8d6",
      "filename": "backend/vendor/github.com/go-pkgz/auth/auth.go",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fauth.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fauth.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fauth.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -257,15 +257,16 @@ func (s *Service) AddProvider(name, cid, csecret string) {\n \ts.authMiddleware.Providers = s.providers\n }\n \n-// AddDevProvider with a custom port\n-func (s *Service) AddDevProvider(port int) {\n+// AddDevProvider with a custom host and port\n+func (s *Service) AddDevProvider(host string, port int) {\n \tp := provider.Params{\n \t\tURL:         s.opts.URL,\n \t\tJwtService:  s.jwtService,\n \t\tIssuer:      s.issuer,\n \t\tAvatarSaver: s.avatarProxy,\n \t\tL:           s.logger,\n \t\tPort:        port,\n+\t\tHost:        host,\n \t}\n \ts.providers = append(s.providers, provider.NewService(provider.NewDev(p)))\n }"
    },
    {
      "sha": "d9e654f85084785af1e79795a9961c2a26badb8a",
      "filename": "backend/vendor/github.com/go-pkgz/auth/provider/dev_provider.go",
      "status": "modified",
      "additions": 15,
      "deletions": 6,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fprovider%2Fdev_provider.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fprovider%2Fdev_provider.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fprovider%2Fdev_provider.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -16,7 +16,10 @@ import (\n \t\"github.com/go-pkgz/auth/token\"\n )\n \n-const defDevAuthPort = 8084\n+const (\n+\tdefDevAuthPort = 8084\n+\tdefDevAuthHost = \"127.0.0.1\"\n+)\n \n // DevAuthServer is a fake oauth server for development\n // it provides stand-alone server running on its own port and pretending to be the real oauth2. It also provides\n@@ -28,7 +31,6 @@ type DevAuthServer struct {\n \tProvider   Oauth2Handler\n \tAutomatic  bool\n \tGetEmailFn func(string) string\n-\n \tusername   string // unsafe, but fine for dev\n \thttpServer *http.Server\n \tlock       sync.Mutex\n@@ -39,6 +41,10 @@ func (d *DevAuthServer) Run(ctx context.Context) { // nolint (gocyclo)\n \tif d.Provider.Port == 0 {\n \t\td.Provider.Port = defDevAuthPort\n \t}\n+\tif d.Provider.Host == \"\" {\n+\t\td.Provider.Host = defDevAuthHost\n+\t}\n+\n \td.username = \"dev_user\"\n \td.Logf(\"[INFO] run local oauth2 dev server on %d, redirect url=%s\", d.Provider.Port, d.Provider.conf.RedirectURL)\n \td.lock.Lock()\n@@ -93,7 +99,7 @@ func (d *DevAuthServer) Run(ctx context.Context) { // nolint (gocyclo)\n \t\t\t\t}\n \n \t\t\tcase strings.HasPrefix(r.URL.Path, \"/user\"):\n-\t\t\t\tava := fmt.Sprintf(\"http://127.0.0.1:%d/avatar?user=%s\", d.Provider.Port, d.username)\n+\t\t\t\tava := fmt.Sprintf(\"http://%s:%d/avatar?user=%s\", d.Provider.Host, d.Provider.Port, d.username)\n \t\t\t\tres := fmt.Sprintf(`{\n \t\t\t\t\t\"id\": \"%s\",\n \t\t\t\t\t\"name\":\"%s\",\n@@ -165,14 +171,17 @@ func NewDev(p Params) Oauth2Handler {\n \tif p.Port == 0 {\n \t\tp.Port = defDevAuthPort\n \t}\n+\tif p.Host == \"\" {\n+\t\tp.Host = defDevAuthHost\n+\t}\n \toh := initOauth2Handler(p, Oauth2Handler{\n \t\tname: \"dev\",\n \t\tendpoint: oauth2.Endpoint{\n-\t\t\tAuthURL:  fmt.Sprintf(\"http://127.0.0.1:%d/login/oauth/authorize\", p.Port),\n-\t\t\tTokenURL: fmt.Sprintf(\"http://127.0.0.1:%d/login/oauth/access_token\", p.Port),\n+\t\t\tAuthURL:  fmt.Sprintf(\"http://%s:%d/login/oauth/authorize\", p.Host, p.Port),\n+\t\t\tTokenURL: fmt.Sprintf(\"http://%s:%d/login/oauth/access_token\", p.Host, p.Port),\n \t\t},\n \t\tscopes:  []string{\"user:email\"},\n-\t\tinfoURL: fmt.Sprintf(\"http://127.0.0.1:%d/user\", p.Port),\n+\t\tinfoURL: fmt.Sprintf(\"http://%s:%d/user\", p.Host, p.Port),\n \t\tmapUser: func(data UserData, _ []byte) token.User {\n \t\t\tuserInfo := token.User{\n \t\t\t\tID:      data.Value(\"id\"),"
    },
    {
      "sha": "88ed4b6743cb09efd19a2228471bce51fcca1328",
      "filename": "backend/vendor/github.com/go-pkgz/auth/provider/oauth2.go",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fprovider%2Foauth2.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fprovider%2Foauth2.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Fauth%2Fprovider%2Foauth2.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -40,7 +40,8 @@ type Params struct {\n \tIssuer      string\n \tAvatarSaver AvatarSaver\n \n-\tPort int // relevant for providers supporting port customization, for example dev oauth2\n+\tPort int    // relevant for providers supporting port customization, for example dev oauth2\n+\tHost string // relevant for providers supporting host customization, for example dev oauth2\n }\n \n // UserData is type for user information returned from oauth2 providers /info API method"
    },
    {
      "sha": "1a78e9cf1c3941579f7a360f86da35b82457690b",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/.golangci.yml",
      "status": "modified",
      "additions": 2,
      "deletions": 11,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2F.golangci.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,8 +1,6 @@\n linters-settings:\n   govet:\n     check-shadowing: true\n-  golint:\n-    min-confidence: 0\n   gocyclo:\n     min-complexity: 15\n   maligned:\n@@ -25,7 +23,7 @@ linters-settings:\n linters:\n   enable:\n     - megacheck\n-    - golint\n+    - revive\n     - govet\n     - unconvert\n     - megacheck\n@@ -42,7 +40,7 @@ linters:\n     - varcheck\n     - stylecheck\n     - gochecknoinits\n-    - scopelint\n+    - exportloopref\n     - gocritic\n     - nakedret\n     - gosimple\n@@ -55,10 +53,3 @@ run:\n     format: tab\n   skip-dirs:\n     - vendor\n-\n-issues:\n-  exclude-rules:\n-    - text: \"should have a package comment, unless it's in another file for this package\"\n-      linters:\n-        - golint\n-  exclude-use-default: false"
    },
    {
      "sha": "8032b2d6dd58c7a1cc55c97970205eab1c802627",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/README.md",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2FREADME.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,15 +1,17 @@\n # Loading Cache Wrapper [![Build Status](https://github.com/go-pkgz/lcw/workflows/build/badge.svg)](https://github.com/go-pkgz/lcw/actions) [![Coverage Status](https://coveralls.io/repos/github/go-pkgz/lcw/badge.svg?branch=master)](https://coveralls.io/github/go-pkgz/lcw?branch=master) [![godoc](https://godoc.org/github.com/go-pkgz/lcw?status.svg)](https://godoc.org/github.com/go-pkgz/lcw)\n \n-The library adds a thin layer on top of [lru cache](https://github.com/hashicorp/golang-lru) and internal implementation of expirable cache.\n+The library adds a thin layer on top of [lru cache](https://github.com/hashicorp/golang-lru) and internal implementation\n+of expirable cache.\n \n | Cache name     | Constructor           | Defaults          | Description             |\n-| -------------- | --------------------- | ----------------- | ----------------------- |\n+|----------------|-----------------------|-------------------|-------------------------|\n | LruCache       | lcw.NewLruCache       | keys=1000         | LRU cache with limits   |\n | ExpirableCache | lcw.NewExpirableCache | keys=1000, ttl=5m | TTL cache with limits   |\n | RedisCache     | lcw.NewRedisCache     | ttl=5m            | Redis cache with limits |\n | Nop            | lcw.NewNopCache       |                   | Do-nothing cache        |\n \n Main features:\n+\n - LoadingCache (guava style)\n - Limit maximum cache size (in bytes)\n - Limit maximum key size\n@@ -52,25 +54,26 @@ Cache can be created with URIs:\n \n - `mem://lru?max_key_size=10&max_val_size=1024&max_keys=50&max_cache_size=64000` - creates LRU cache with given limits\n - `mem://expirable?ttl=30s&max_key_size=10&max_val_size=1024&max_keys=50&max_cache_size=64000` - create expirable cache\n-- `redis://10.0.0.1:1234?db=16&password=qwerty&network=tcp4&dial_timeout=1s&read_timeout=5s&write_timeout=3s` - create redis cache\n+- `redis://10.0.0.1:1234?db=16&password=qwerty&network=tcp4&dial_timeout=1s&read_timeout=5s&write_timeout=3s` - create\n+  redis cache\n - `nop://` - create Nop cache\n \n ## Scoped cache\n \n `Scache` provides a wrapper on top of all implementations of `LoadingCache` with a number of special features:\n \n-1. Key is not a string, but a composed type made from partition, key-id and list of scopes (tags). \n+1. Key is not a string, but a composed type made from partition, key-id and list of scopes (tags).\n 1. Value type limited to `[]byte`\n 1. Added `Flush` method for scoped/tagged invalidation of multiple records in a given partition\n 1. A simplified interface with Get, Stat, Flush and Close only.\n \n ## Details\n \n - In all cache types other than Redis (e.g. LRU and Expirable at the moment) values are stored as-is which means\n-that mutable values can be changed outside of cache. `ExampleLoadingCache_Mutability` illustrates that.\n+  that mutable values can be changed outside of cache. `ExampleLoadingCache_Mutability` illustrates that.\n - All byte-size limits (MaxCacheSize and MaxValSize) only work for values implementing `lcw.Sizer` interface.\n - Negative limits (max options) rejected\n - `lgr.Value` wraps `interface{}` and should be converted back to the concrete type.\n - The implementation started as a part of [remark42](https://github.com/umputun/remark)\n-and later on moved to [go-pkgz/rest](https://github.com/go-pkgz/rest/tree/master/cache)\n-library and finally generalized to become `lcw`.\n+  and later on moved to [go-pkgz/rest](https://github.com/go-pkgz/rest/tree/master/cache)\n+  library and finally generalized to become `lcw`."
    },
    {
      "sha": "9e961544d205e9622daca482b01d88a129b969e0",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/eventbus/redis.go",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Feventbus%2Fredis.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Feventbus%2Fredis.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Feventbus%2Fredis.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,23 +1,24 @@\n package eventbus\n \n import (\n+\t\"context\"\n+\t\"fmt\"\n \t\"strings\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7\"\n+\t\"github.com/go-redis/redis/v8\"\n \t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/pkg/errors\"\n )\n \n // NewRedisPubSub creates new RedisPubSub with given parameters.\n // Returns an error in case of problems with creating PubSub client for specified channel.\n func NewRedisPubSub(addr, channel string) (*RedisPubSub, error) {\n \tclient := redis.NewClient(&redis.Options{Addr: addr})\n-\tpubSub := client.Subscribe(channel)\n+\tpubSub := client.Subscribe(context.Background(), channel)\n \t// wait for subscription to be created and ignore the message\n-\tif _, err := pubSub.Receive(); err != nil {\n+\tif _, err := pubSub.Receive(context.Background()); err != nil {\n \t\t_ = client.Close()\n-\t\treturn nil, errors.Wrapf(err, \"problem subscribing to channel %s on address %s\", channel, addr)\n+\t\treturn nil, fmt.Errorf(\"problem subscribing to channel %s on address %s: %w\", channel, addr, err)\n \t}\n \treturn &RedisPubSub{client: client, pubSub: pubSub, channel: channel, done: make(chan struct{})}, nil\n }\n@@ -41,7 +42,7 @@ func (m *RedisPubSub) Subscribe(fn func(fromID, key string)) error {\n \t\t\t\treturn\n \t\t\tdefault:\n \t\t\t}\n-\t\t\tmsg, err := pubsub.ReceiveTimeout(time.Second * 10)\n+\t\t\tmsg, err := pubsub.ReceiveTimeout(context.Background(), time.Second*10)\n \t\t\tif err != nil {\n \t\t\t\tcontinue\n \t\t\t}\n@@ -59,14 +60,18 @@ func (m *RedisPubSub) Subscribe(fn func(fromID, key string)) error {\n \n // Publish publishes provided message to channel provided on new RedisPubSub instance creation\n func (m *RedisPubSub) Publish(fromID, key string) error {\n-\treturn m.client.Publish(m.channel, fromID+\"$\"+key).Err()\n+\treturn m.client.Publish(context.Background(), m.channel, fromID+\"$\"+key).Err()\n }\n \n // Close cleans up running goroutines and closes Redis clients\n func (m *RedisPubSub) Close() error {\n \tclose(m.done)\n \terrs := new(multierror.Error)\n-\terrs = multierror.Append(errs, errors.Wrap(m.pubSub.Close(), \"problem closing pubSub client\"))\n-\terrs = multierror.Append(errs, errors.Wrap(m.client.Close(), \"problem closing redis client\"))\n+\tif err := m.pubSub.Close(); err != nil {\n+\t\terrs = multierror.Append(errs, fmt.Errorf(\"problem closing pubSub client: %w\", err))\n+\t}\n+\tif err := m.client.Close(); err != nil {\n+\t\terrs = multierror.Append(errs, fmt.Errorf(\"problem closing redis client: %w\", err))\n+\t}\n \treturn errs.ErrorOrNil()\n }"
    },
    {
      "sha": "513e0c0f375376da7d21988068b7a4ec128b6b5a",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/expirable_cache.go",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fexpirable_cache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fexpirable_cache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fexpirable_cache.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,14 +1,13 @@\n package lcw\n \n import (\n+\t\"fmt\"\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/google/uuid\"\n-\t\"github.com/pkg/errors\"\n-\n \t\"github.com/go-pkgz/lcw/eventbus\"\n \t\"github.com/go-pkgz/lcw/internal/cache\"\n+\t\"github.com/google/uuid\"\n )\n \n // ExpirableCache implements LoadingCache with TTL.\n@@ -34,12 +33,12 @@ func NewExpirableCache(opts ...Option) (*ExpirableCache, error) {\n \n \tfor _, opt := range opts {\n \t\tif err := opt(&res.options); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to set cache option\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n \n \tif err := res.eventBus.Subscribe(res.onBusEvent); err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't subscribe to event bus\")\n+\t\treturn nil, fmt.Errorf(\"can't subscribe to event bus: %w\", err)\n \t}\n \n \tbackend, err := cache.NewLoadingCache(\n@@ -61,7 +60,7 @@ func NewExpirableCache(opts ...Option) (*ExpirableCache, error) {\n \t\t}),\n \t)\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"error creating backend\")\n+\t\treturn nil, fmt.Errorf(\"error creating backend: %w\", err)\n \t}\n \tres.backend = backend\n "
    },
    {
      "sha": "e9a54535b519e543f82b00590cd8d3b62bf7b3b6",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/internal/cache/cache.go",
      "status": "modified",
      "additions": 25,
      "deletions": 26,
      "changes": 51,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Fcache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Fcache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Finternal%2Fcache%2Fcache.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -4,11 +4,10 @@\n package cache\n \n import (\n+\t\"fmt\"\n \t\"sort\"\n \t\"sync\"\n \t\"time\"\n-\n-\t\"github.com/pkg/errors\"\n )\n \n // LoadingCache provides expirable loading cache with LRC eviction.\n@@ -19,7 +18,7 @@ type LoadingCache struct {\n \tdone       chan struct{}\n \tonEvicted  func(key string, value interface{})\n \n-\tsync.Mutex\n+\tmu   sync.Mutex\n \tdata map[string]*cacheItem\n }\n \n@@ -39,7 +38,7 @@ func NewLoadingCache(options ...Option) (*LoadingCache, error) {\n \n \tfor _, opt := range options {\n \t\tif err := opt(&res); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to set cache option\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n \n@@ -54,9 +53,9 @@ func NewLoadingCache(options ...Option) (*LoadingCache, error) {\n \t\t\t\tcase <-done:\n \t\t\t\t\treturn\n \t\t\t\tcase <-ticker.C:\n-\t\t\t\t\tres.Lock()\n+\t\t\t\t\tres.mu.Lock()\n \t\t\t\t\tres.purge(res.maxKeys)\n-\t\t\t\t\tres.Unlock()\n+\t\t\t\t\tres.mu.Unlock()\n \t\t\t\t}\n \t\t\t}\n \t\t}(res.done)\n@@ -66,8 +65,8 @@ func NewLoadingCache(options ...Option) (*LoadingCache, error) {\n \n // Set key\n func (c *LoadingCache) Set(key string, value interface{}) {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \n \tnow := time.Now()\n \tif _, ok := c.data[key]; !ok {\n@@ -86,8 +85,8 @@ func (c *LoadingCache) Set(key string, value interface{}) {\n \n // Get returns the key value\n func (c *LoadingCache) Get(key string) (interface{}, bool) {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \tvalue, ok := c.getValue(key)\n \tif !ok {\n \t\treturn nil, false\n@@ -97,8 +96,8 @@ func (c *LoadingCache) Get(key string) (interface{}, bool) {\n \n // Peek returns the key value (or undefined if not found) without updating the \"recently used\"-ness of the key.\n func (c *LoadingCache) Peek(key string) (interface{}, bool) {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \tvalue, ok := c.getValue(key)\n \tif !ok {\n \t\treturn nil, false\n@@ -108,19 +107,19 @@ func (c *LoadingCache) Peek(key string) (interface{}, bool) {\n \n // Invalidate key (item) from the cache\n func (c *LoadingCache) Invalidate(key string) {\n-\tc.Lock()\n+\tc.mu.Lock()\n \tif value, ok := c.data[key]; ok {\n \t\tdelete(c.data, key)\n \t\tif c.onEvicted != nil {\n \t\t\tc.onEvicted(key, value.data)\n \t\t}\n \t}\n-\tc.Unlock()\n+\tc.mu.Unlock()\n }\n \n // InvalidateFn deletes multiple keys if predicate is true\n func (c *LoadingCache) InvalidateFn(fn func(key string) bool) {\n-\tc.Lock()\n+\tc.mu.Lock()\n \tfor key, value := range c.data {\n \t\tif fn(key) {\n \t\t\tdelete(c.data, key)\n@@ -129,13 +128,13 @@ func (c *LoadingCache) InvalidateFn(fn func(key string) bool) {\n \t\t\t}\n \t\t}\n \t}\n-\tc.Unlock()\n+\tc.mu.Unlock()\n }\n \n // Keys return slice of current keys in the cache\n func (c *LoadingCache) Keys() []string {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \tkeys := make([]string, 0, len(c.data))\n \tfor k := range c.data {\n \t\tkeys = append(keys, k)\n@@ -157,8 +156,8 @@ func (c *LoadingCache) getValue(key string) (interface{}, bool) {\n \n // Purge clears the cache completely.\n func (c *LoadingCache) Purge() {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \tfor k, v := range c.data {\n \t\tdelete(c.data, k)\n \t\tif c.onEvicted != nil {\n@@ -169,23 +168,23 @@ func (c *LoadingCache) Purge() {\n \n // DeleteExpired clears cache of expired items\n func (c *LoadingCache) DeleteExpired() {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \tc.purge(0)\n }\n \n // ItemCount return count of items in cache\n func (c *LoadingCache) ItemCount() int {\n-\tc.Lock()\n+\tc.mu.Lock()\n \tn := len(c.data)\n-\tc.Unlock()\n+\tc.mu.Unlock()\n \treturn n\n }\n \n // Close cleans the cache and destroys running goroutines\n func (c *LoadingCache) Close() {\n-\tc.Lock()\n-\tdefer c.Unlock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n \tclose(c.done)\n }\n "
    },
    {
      "sha": "72b8e57f3c9d3fd99a0fc00b5c682721b855bc6a",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/lru_cache.go",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Flru_cache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Flru_cache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Flru_cache.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,13 +1,12 @@\n package lcw\n \n import (\n+\t\"fmt\"\n \t\"sync/atomic\"\n \n+\t\"github.com/go-pkgz/lcw/eventbus\"\n \t\"github.com/google/uuid\"\n \tlru \"github.com/hashicorp/golang-lru\"\n-\t\"github.com/pkg/errors\"\n-\n-\t\"github.com/go-pkgz/lcw/eventbus\"\n )\n \n // LruCache wraps lru.LruCache with loading cache Get and size limits\n@@ -31,7 +30,7 @@ func NewLruCache(opts ...Option) (*LruCache, error) {\n \t}\n \tfor _, opt := range opts {\n \t\tif err := opt(&res.options); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to set cache option\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n \n@@ -41,7 +40,7 @@ func NewLruCache(opts ...Option) (*LruCache, error) {\n \n func (c *LruCache) init() error {\n \tif err := c.eventBus.Subscribe(c.onBusEvent); err != nil {\n-\t\treturn errors.Wrapf(err, \"can't subscribe to event bus\")\n+\t\treturn fmt.Errorf(\"can't subscribe to event bus: %w\", err)\n \t}\n \n \tonEvicted := func(key interface{}, value interface{}) {\n@@ -58,7 +57,7 @@ func (c *LruCache) init() error {\n \tvar err error\n \t// OnEvicted called automatically for expired and manually deleted\n \tif c.backend, err = lru.NewWithEvict(c.maxKeys, onEvicted); err != nil {\n-\t\treturn errors.Wrap(err, \"failed to make lru cache backend\")\n+\t\treturn fmt.Errorf(\"failed to make lru cache backend: %w\", err)\n \t}\n \n \treturn nil"
    },
    {
      "sha": "01de5667cdf280898b798cfc5a11a94dd998078f",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/options.go",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Foptions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Foptions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Foptions.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,7 +1,7 @@\n package lcw\n \n import (\n-\t\"errors\"\n+\t\"fmt\"\n \t\"time\"\n \n \t\"github.com/go-pkgz/lcw/eventbus\"\n@@ -25,7 +25,7 @@ type Option func(o *options) error\n func MaxValSize(max int) Option {\n \treturn func(o *options) error {\n \t\tif max < 0 {\n-\t\t\treturn errors.New(\"negative max value size\")\n+\t\t\treturn fmt.Errorf(\"negative max value size\")\n \t\t}\n \t\to.maxValueSize = max\n \t\treturn nil\n@@ -37,7 +37,7 @@ func MaxValSize(max int) Option {\n func MaxKeySize(max int) Option {\n \treturn func(o *options) error {\n \t\tif max < 0 {\n-\t\t\treturn errors.New(\"negative max key size\")\n+\t\t\treturn fmt.Errorf(\"negative max key size\")\n \t\t}\n \t\to.maxKeySize = max\n \t\treturn nil\n@@ -49,7 +49,7 @@ func MaxKeySize(max int) Option {\n func MaxKeys(max int) Option {\n \treturn func(o *options) error {\n \t\tif max < 0 {\n-\t\t\treturn errors.New(\"negative max keys\")\n+\t\t\treturn fmt.Errorf(\"negative max keys\")\n \t\t}\n \t\to.maxKeys = max\n \t\treturn nil\n@@ -61,7 +61,7 @@ func MaxKeys(max int) Option {\n func MaxCacheSize(max int64) Option {\n \treturn func(o *options) error {\n \t\tif max < 0 {\n-\t\t\treturn errors.New(\"negative max cache size\")\n+\t\t\treturn fmt.Errorf(\"negative max cache size\")\n \t\t}\n \t\to.maxCacheSize = max\n \t\treturn nil\n@@ -73,7 +73,7 @@ func MaxCacheSize(max int64) Option {\n func TTL(ttl time.Duration) Option {\n \treturn func(o *options) error {\n \t\tif ttl < 0 {\n-\t\t\treturn errors.New(\"negative ttl\")\n+\t\t\treturn fmt.Errorf(\"negative ttl\")\n \t\t}\n \t\to.ttl = ttl\n \t\treturn nil"
    },
    {
      "sha": "5c000e638f3dd0791e6039f045132f1406f99462",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/redis_cache.go",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fredis_cache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fredis_cache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fredis_cache.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,11 +1,12 @@\n package lcw\n \n import (\n+\t\"context\"\n+\t\"fmt\"\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7\"\n-\t\"github.com/pkg/errors\"\n+\t\"github.com/go-redis/redis/v8\"\n )\n \n // RedisValueSizeLimit is maximum allowed value size in Redis\n@@ -27,7 +28,7 @@ func NewRedisCache(backend *redis.Client, opts ...Option) (*RedisCache, error) {\n \t}\n \tfor _, opt := range opts {\n \t\tif err := opt(&res.options); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to set cache option\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to set cache option: %w\", err)\n \t\t}\n \t}\n \n@@ -42,7 +43,7 @@ func NewRedisCache(backend *redis.Client, opts ...Option) (*RedisCache, error) {\n \n // Get gets value by key or load with fn if not found in cache\n func (c *RedisCache) Get(key string, fn func() (interface{}, error)) (data interface{}, err error) {\n-\tv, getErr := c.backend.Get(key).Result()\n+\tv, getErr := c.backend.Get(context.Background(), key).Result()\n \tswitch getErr {\n \t// RedisClient returns nil when find a key in DB\n \tcase nil:\n@@ -65,7 +66,7 @@ func (c *RedisCache) Get(key string, fn func() (interface{}, error)) (data inter\n \t\treturn data, nil\n \t}\n \n-\t_, setErr := c.backend.Set(key, data, c.ttl).Result()\n+\t_, setErr := c.backend.Set(context.Background(), key, data, c.ttl).Result()\n \tif setErr != nil {\n \t\tatomic.AddInt64(&c.Errors, 1)\n \t\treturn data, setErr\n@@ -76,16 +77,16 @@ func (c *RedisCache) Get(key string, fn func() (interface{}, error)) (data inter\n \n // Invalidate removes keys with passed predicate fn, i.e. fn(key) should be true to get evicted\n func (c *RedisCache) Invalidate(fn func(key string) bool) {\n-\tfor _, key := range c.backend.Keys(\"*\").Val() { // Keys() returns copy of cache's key, safe to remove directly\n+\tfor _, key := range c.backend.Keys(context.Background(), \"*\").Val() { // Keys() returns copy of cache's key, safe to remove directly\n \t\tif fn(key) {\n-\t\t\tc.backend.Del(key)\n+\t\t\tc.backend.Del(context.Background(), key)\n \t\t}\n \t}\n }\n \n // Peek returns the key value (or undefined if not found) without updating the \"recently used\"-ness of the key.\n func (c *RedisCache) Peek(key string) (interface{}, bool) {\n-\tret, err := c.backend.Get(key).Result()\n+\tret, err := c.backend.Get(context.Background(), key).Result()\n \tif err != nil {\n \t\treturn nil, false\n \t}\n@@ -94,18 +95,18 @@ func (c *RedisCache) Peek(key string) (interface{}, bool) {\n \n // Purge clears the cache completely.\n func (c *RedisCache) Purge() {\n-\tc.backend.FlushDB()\n+\tc.backend.FlushDB(context.Background())\n \n }\n \n // Delete cache item by key\n func (c *RedisCache) Delete(key string) {\n-\tc.backend.Del(key)\n+\tc.backend.Del(context.Background(), key)\n }\n \n // Keys gets all keys for the cache\n func (c *RedisCache) Keys() (res []string) {\n-\treturn c.backend.Keys(\"*\").Val()\n+\treturn c.backend.Keys(context.Background(), \"*\").Val()\n }\n \n // Stat returns cache statistics\n@@ -129,11 +130,11 @@ func (c *RedisCache) size() int64 {\n }\n \n func (c *RedisCache) keys() int {\n-\treturn int(c.backend.DBSize().Val())\n+\treturn int(c.backend.DBSize(context.Background()).Val())\n }\n \n func (c *RedisCache) allowed(key string, data interface{}) bool {\n-\tif c.maxKeys > 0 && c.backend.DBSize().Val() >= int64(c.maxKeys) {\n+\tif c.maxKeys > 0 && c.backend.DBSize(context.Background()).Val() >= int64(c.maxKeys) {\n \t\treturn false\n \t}\n \tif c.maxKeySize > 0 && len(key) > c.maxKeySize {"
    },
    {
      "sha": "2181b75c1542217b8a59a4d492cc002db3348223",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/scache.go",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fscache.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fscache.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Fscache.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,9 +1,8 @@\n package lcw\n \n import (\n+\t\"fmt\"\n \t\"strings\"\n-\n-\t\"github.com/pkg/errors\"\n )\n \n // Scache wraps LoadingCache with partitions (sub-system), and scopes.\n@@ -111,7 +110,7 @@ func (k Key) String() string {\n func parseKey(keyStr string) (Key, error) {\n \telems := strings.Split(keyStr, \"@@\")\n \tif len(elems) != 3 {\n-\t\treturn Key{}, errors.Errorf(\"can't parse cache key %s, invalid number of segments %d\", keyStr, len(elems))\n+\t\treturn Key{}, fmt.Errorf(\"can't parse cache key %s, invalid number of segments %d\", keyStr, len(elems))\n \t}\n \n \tscopes := strings.Split(elems[2], \"$$\")"
    },
    {
      "sha": "67bfbb74fbe3f6bbbc3689f9276a46d7068269f4",
      "filename": "backend/vendor/github.com/go-pkgz/lcw/url.go",
      "status": "modified",
      "additions": 20,
      "deletions": 17,
      "changes": 37,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Furl.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Furl.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-pkgz%2Flcw%2Furl.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,13 +1,13 @@\n package lcw\n \n import (\n+\t\"fmt\"\n \t\"net/url\"\n \t\"strconv\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7\"\n+\t\"github.com/go-redis/redis/v8\"\n \t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/pkg/errors\"\n )\n \n // New parses uri and makes any of supported caches\n@@ -19,36 +19,39 @@ import (\n func New(uri string) (LoadingCache, error) {\n \tu, err := url.Parse(uri)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"parse cache uri %s\", uri)\n+\t\treturn nil, fmt.Errorf(\"parse cache uri %s: %w\", uri, err)\n \t}\n \n \tquery := u.Query()\n \topts, err := optionsFromQuery(query)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"parse uri options %s\", uri)\n+\t\treturn nil, fmt.Errorf(\"parse uri options %s: %w\", uri, err)\n \t}\n \n \tswitch u.Scheme {\n \tcase \"redis\":\n-\t\tredisOpts, err := redisOptionsFromURL(u)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tredisOpts, e := redisOptionsFromURL(u)\n+\t\tif e != nil {\n+\t\t\treturn nil, e\n+\t\t}\n+\t\tres, e := NewRedisCache(redis.NewClient(redisOpts), opts...)\n+\t\tif e != nil {\n+\t\t\treturn nil, fmt.Errorf(\"make redis for %s: %w\", uri, e)\n \t\t}\n-\t\tres, err := NewRedisCache(redis.NewClient(redisOpts), opts...)\n-\t\treturn res, errors.Wrapf(err, \"make redis for %s\", uri)\n+\t\treturn res, nil\n \tcase \"mem\":\n \t\tswitch u.Hostname() {\n \t\tcase \"lru\":\n \t\t\treturn NewLruCache(opts...)\n \t\tcase \"expirable\":\n \t\t\treturn NewExpirableCache(opts...)\n \t\tdefault:\n-\t\t\treturn nil, errors.Errorf(\"unsupported mem cache type %s\", u.Hostname())\n+\t\t\treturn nil, fmt.Errorf(\"unsupported mem cache type %s\", u.Hostname())\n \t\t}\n \tcase \"nop\":\n \t\treturn NewNopCache(), nil\n \t}\n-\treturn nil, errors.Errorf(\"unsupported cache type %s\", u.Scheme)\n+\treturn nil, fmt.Errorf(\"unsupported cache type %s\", u.Scheme)\n }\n \n func optionsFromQuery(q url.Values) (opts []Option, err error) {\n@@ -57,7 +60,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \tif v := q.Get(\"max_val_size\"); v != \"\" {\n \t\tvv, e := strconv.Atoi(v)\n \t\tif e != nil {\n-\t\t\terrs = multierror.Append(errs, errors.Wrapf(e, \"max_val_size query param %s\", v))\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_val_size query param %s: %w\", v, e))\n \t\t} else {\n \t\t\topts = append(opts, MaxValSize(vv))\n \t\t}\n@@ -66,7 +69,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \tif v := q.Get(\"max_key_size\"); v != \"\" {\n \t\tvv, e := strconv.Atoi(v)\n \t\tif e != nil {\n-\t\t\terrs = multierror.Append(errs, errors.Wrapf(e, \"max_key_size query param %s\", v))\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_key_size query param %s: %w\", v, e))\n \t\t} else {\n \t\t\topts = append(opts, MaxKeySize(vv))\n \t\t}\n@@ -75,7 +78,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \tif v := q.Get(\"max_keys\"); v != \"\" {\n \t\tvv, e := strconv.Atoi(v)\n \t\tif e != nil {\n-\t\t\terrs = multierror.Append(errs, errors.Wrapf(e, \"max_keys query param %s\", v))\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_keys query param %s: %w\", v, e))\n \t\t} else {\n \t\t\topts = append(opts, MaxKeys(vv))\n \t\t}\n@@ -84,7 +87,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \tif v := q.Get(\"max_cache_size\"); v != \"\" {\n \t\tvv, e := strconv.ParseInt(v, 10, 64)\n \t\tif e != nil {\n-\t\t\terrs = multierror.Append(errs, errors.Wrapf(e, \"max_cache_size query param %s\", v))\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"max_cache_size query param %s: %w\", v, e))\n \t\t} else {\n \t\t\topts = append(opts, MaxCacheSize(vv))\n \t\t}\n@@ -93,7 +96,7 @@ func optionsFromQuery(q url.Values) (opts []Option, err error) {\n \tif v := q.Get(\"ttl\"); v != \"\" {\n \t\tvv, e := time.ParseDuration(v)\n \t\tif e != nil {\n-\t\t\terrs = multierror.Append(errs, errors.Wrapf(e, \"ttl query param %s\", v))\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"ttl query param %s: %w\", v, e))\n \t\t} else {\n \t\t\topts = append(opts, TTL(vv))\n \t\t}\n@@ -107,7 +110,7 @@ func redisOptionsFromURL(u *url.URL) (*redis.Options, error) {\n \n \tdb, err := strconv.Atoi(query.Get(\"db\"))\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"db from %s\", u)\n+\t\treturn nil, fmt.Errorf(\"db from %s: %w\", u, err)\n \t}\n \n \tres := &redis.Options{"
    },
    {
      "sha": "912dab1ef392d4513782f31225883fe3d46704f9",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/.golangci.yml",
      "status": "removed",
      "additions": 0,
      "deletions": 15,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2F.golangci.yml?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,15 +0,0 @@\n-run:\n-  concurrency: 8\n-  deadline: 5m\n-  tests: false\n-linters:\n-  enable-all: true\n-  disable:\n-    - funlen\n-    - gochecknoglobals\n-    - gocognit\n-    - goconst\n-    - godox\n-    - gosec\n-    - maligned\n-    - wsl"
    },
    {
      "sha": "3f93932bc8404e0fb165ca8e4c265762145def11",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/.travis.yml",
      "status": "removed",
      "additions": 0,
      "deletions": 22,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2F.travis.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2F.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2F.travis.yml?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,22 +0,0 @@\n-dist: xenial\n-language: go\n-\n-services:\n-  - redis-server\n-\n-go:\n-  - 1.12.x\n-  - 1.13.x\n-  - tip\n-\n-matrix:\n-  allow_failures:\n-    - go: tip\n-\n-env:\n-  - GO111MODULE=on\n-\n-go_import_path: github.com/go-redis/redis\n-\n-before_install:\n-  - curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s -- -b $(go env GOPATH)/bin v1.21.0"
    },
    {
      "sha": "bd4eccff24877280094dadd5342cf21e1442f4db",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/CHANGELOG.md",
      "status": "removed",
      "additions": 0,
      "deletions": 46,
      "changes": 46,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FCHANGELOG.md",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FCHANGELOG.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FCHANGELOG.md?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,46 +0,0 @@\n-# Changelog\n-\n-## v7.2\n-\n-- Existing `HMSet` is renamed to `HSet` and old deprecated `HMSet` is restored for Redis 3 users.\n-\n-## v7.1\n-\n-- Existing `Cmd.String` is renamed to `Cmd.Text`. New `Cmd.String` implements `fmt.Stringer` interface.\n-\n-## v7\n-\n-- *Important*. Tx.Pipeline now returns a non-transactional pipeline. Use Tx.TxPipeline for a transactional pipeline.\n-- WrapProcess is replaced with more convenient AddHook that has access to context.Context.\n-- WithContext now can not be used to create a shallow copy of the client.\n-- New methods ProcessContext, DoContext, and ExecContext.\n-- Client respects Context.Deadline when setting net.Conn deadline.\n-- Client listens on Context.Done while waiting for a connection from the pool and returns an error when context context is cancelled.\n-- Add PubSub.ChannelWithSubscriptions that sends `*Subscription` in addition to `*Message` to allow detecting reconnections.\n-- `time.Time` is now marshalled in RFC3339 format. `rdb.Get(\"foo\").Time()` helper is added to parse the time.\n-- `SetLimiter` is removed and added `Options.Limiter` instead.\n-- `HMSet` is deprecated as of Redis v4.\n-\n-## v6.15\n-\n-- Cluster and Ring pipelines process commands for each node in its own goroutine.\n-\n-## 6.14\n-\n-- Added Options.MinIdleConns.\n-- Added Options.MaxConnAge.\n-- PoolStats.FreeConns is renamed to PoolStats.IdleConns.\n-- Add Client.Do to simplify creating custom commands.\n-- Add Cmd.String, Cmd.Int, Cmd.Int64, Cmd.Uint64, Cmd.Float64, and Cmd.Bool helpers.\n-- Lower memory usage.\n-\n-## v6.13\n-\n-- Ring got new options called `HashReplicas` and `Hash`. It is recommended to set `HashReplicas = 1000` for better keys distribution between shards.\n-- Cluster client was optimized to use much less memory when reloading cluster state.\n-- PubSub.ReceiveMessage is re-worked to not use ReceiveTimeout so it does not lose data when timeout occurres. In most cases it is recommended to use PubSub.Channel instead.\n-- Dialer.KeepAlive is set to 5 minutes by default.\n-\n-## v6.12\n-\n-- ClusterClient got new option called `ClusterSlots` which allows to build cluster of normal Redis Servers that don't have cluster mode enabled. See https://godoc.org/github.com/go-redis/redis#example-NewClusterClient--ManualSetup"
    },
    {
      "sha": "86609c6e07c9435ad0352dba40aa86098284af51",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/Makefile",
      "status": "removed",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FMakefile",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FMakefile",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FMakefile?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,20 +0,0 @@\n-all: testdeps\n-\tgo test ./...\n-\tgo test ./... -short -race\n-\tgo test ./... -run=NONE -bench=. -benchmem\n-\tenv GOOS=linux GOARCH=386 go test ./...\n-\tgolangci-lint run\n-\n-testdeps: testdata/redis/src/redis-server\n-\n-bench: testdeps\n-\tgo test ./... -test.run=NONE -test.bench=. -test.benchmem\n-\n-.PHONY: all test testdeps bench\n-\n-testdata/redis:\n-\tmkdir -p $@\n-\twget -qO- http://download.redis.io/redis-stable.tar.gz | tar xvz --strip-components=1 -C $@\n-\n-testdata/redis/src/redis-server: testdata/redis\n-\tcd $< && make all"
    },
    {
      "sha": "0fbb506ead192183d131ada8ff3f9dcd1a5033dc",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/README.md",
      "status": "removed",
      "additions": 0,
      "deletions": 128,
      "changes": 128,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2FREADME.md?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,128 +0,0 @@\n-# Redis client for Golang\n-\n-[![Build Status](https://travis-ci.org/go-redis/redis.png?branch=master)](https://travis-ci.org/go-redis/redis)\n-[![GoDoc](https://godoc.org/github.com/go-redis/redis?status.svg)](https://godoc.org/github.com/go-redis/redis)\n-[![Airbrake](https://img.shields.io/badge/kudos-airbrake.io-orange.svg)](https://airbrake.io)\n-\n-Supports:\n-\n-- Redis 3 commands except QUIT, MONITOR, SLOWLOG and SYNC.\n-- Automatic connection pooling with [circuit breaker](https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern) support.\n-- [Pub/Sub](https://godoc.org/github.com/go-redis/redis#PubSub).\n-- [Transactions](https://godoc.org/github.com/go-redis/redis#example-Client-TxPipeline).\n-- [Pipeline](https://godoc.org/github.com/go-redis/redis#example-Client-Pipeline) and [TxPipeline](https://godoc.org/github.com/go-redis/redis#example-Client-TxPipeline).\n-- [Scripting](https://godoc.org/github.com/go-redis/redis#Script).\n-- [Timeouts](https://godoc.org/github.com/go-redis/redis#Options).\n-- [Redis Sentinel](https://godoc.org/github.com/go-redis/redis#NewFailoverClient).\n-- [Redis Cluster](https://godoc.org/github.com/go-redis/redis#NewClusterClient).\n-- [Cluster of Redis Servers](https://godoc.org/github.com/go-redis/redis#example-NewClusterClient--ManualSetup) without using cluster mode and Redis Sentinel.\n-- [Ring](https://godoc.org/github.com/go-redis/redis#NewRing).\n-- [Instrumentation](https://godoc.org/github.com/go-redis/redis#ex-package--Instrumentation).\n-- [Cache friendly](https://github.com/go-redis/cache).\n-- [Rate limiting](https://github.com/go-redis/redis_rate).\n-- [Distributed Locks](https://github.com/bsm/redislock).\n-\n-API docs: https://godoc.org/github.com/go-redis/redis.\n-Examples: https://godoc.org/github.com/go-redis/redis#pkg-examples.\n-\n-## Installation\n-\n-go-redis requires a Go version with [Modules](https://github.com/golang/go/wiki/Modules) support and uses import versioning. So please make sure to initialize a Go module before installing go-redis:\n-\n-``` shell\n-go mod init github.com/my/repo\n-go get github.com/go-redis/redis/v7\n-```\n-\n-Import:\n-\n-``` go\n-import \"github.com/go-redis/redis/v7\"\n-```\n-\n-## Quickstart\n-\n-``` go\n-func ExampleNewClient() {\n-\tclient := redis.NewClient(&redis.Options{\n-\t\tAddr:     \"localhost:6379\",\n-\t\tPassword: \"\", // no password set\n-\t\tDB:       0,  // use default DB\n-\t})\n-\n-\tpong, err := client.Ping().Result()\n-\tfmt.Println(pong, err)\n-\t// Output: PONG <nil>\n-}\n-\n-func ExampleClient() {\n-\tclient := redis.NewClient(&redis.Options{\n-\t\tAddr:     \"localhost:6379\",\n-\t\tPassword: \"\", // no password set\n-\t\tDB:       0,  // use default DB\n-\t})\n-\terr := client.Set(\"key\", \"value\", 0).Err()\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\n-\tval, err := client.Get(\"key\").Result()\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\tfmt.Println(\"key\", val)\n-\n-\tval2, err := client.Get(\"key2\").Result()\n-\tif err == redis.Nil {\n-\t\tfmt.Println(\"key2 does not exist\")\n-\t} else if err != nil {\n-\t\tpanic(err)\n-\t} else {\n-\t\tfmt.Println(\"key2\", val2)\n-\t}\n-\t// Output: key value\n-\t// key2 does not exist\n-}\n-```\n-\n-## Howto\n-\n-Please go through [examples](https://godoc.org/github.com/go-redis/redis#pkg-examples) to get an idea how to use this package.\n-\n-## Look and feel\n-\n-Some corner cases:\n-\n-``` go\n-// SET key value EX 10 NX\n-set, err := client.SetNX(\"key\", \"value\", 10*time.Second).Result()\n-\n-// SORT list LIMIT 0 2 ASC\n-vals, err := client.Sort(\"list\", &redis.Sort{Offset: 0, Count: 2, Order: \"ASC\"}).Result()\n-\n-// ZRANGEBYSCORE zset -inf +inf WITHSCORES LIMIT 0 2\n-vals, err := client.ZRangeByScoreWithScores(\"zset\", &redis.ZRangeBy{\n-\tMin: \"-inf\",\n-\tMax: \"+inf\",\n-\tOffset: 0,\n-\tCount: 2,\n-}).Result()\n-\n-// ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3 AGGREGATE SUM\n-vals, err := client.ZInterStore(\"out\", &redis.ZStore{\n-\tKeys: []string{\"zset1\", \"zset2\"},\n-\tWeights: []int64{2, 3}\n-}).Result()\n-\n-// EVAL \"return {KEYS[1],ARGV[1]}\" 1 \"key\" \"hello\"\n-vals, err := client.Eval(\"return {KEYS[1],ARGV[1]}\", []string{\"key\"}, \"hello\").Result()\n-\n-// custom command\n-res, err := client.Do(\"set\", \"key\", \"value\").Result()\n-```\n-\n-## See also\n-\n-- [Golang PostgreSQL ORM](https://github.com/go-pg/pg)\n-- [Golang msgpack](https://github.com/vmihailenco/msgpack)\n-- [Golang message task queue](https://github.com/vmihailenco/taskq)"
    },
    {
      "sha": "c9b9b9de24756fc90b8e39afb286b71c8a71c9b6",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/cluster_commands.go",
      "status": "removed",
      "additions": 0,
      "deletions": 22,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcluster_commands.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcluster_commands.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcluster_commands.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,22 +0,0 @@\n-package redis\n-\n-import \"sync/atomic\"\n-\n-func (c *ClusterClient) DBSize() *IntCmd {\n-\tcmd := NewIntCmd(\"dbsize\")\n-\tvar size int64\n-\terr := c.ForEachMaster(func(master *Client) error {\n-\t\tn, err := master.DBSize().Result()\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tatomic.AddInt64(&size, n)\n-\t\treturn nil\n-\t})\n-\tif err != nil {\n-\t\tcmd.SetErr(err)\n-\t\treturn cmd\n-\t}\n-\tcmd.val = size\n-\treturn cmd\n-}"
    },
    {
      "sha": "dd7fe4a91e05b797365840d3b03c47ebdc284ebe",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/command.go",
      "status": "removed",
      "additions": 0,
      "deletions": 2064,
      "changes": 2064,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcommand.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcommand.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcommand.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,2064 +0,0 @@\n-package redis\n-\n-import (\n-\t\"fmt\"\n-\t\"net\"\n-\t\"strconv\"\n-\t\"strings\"\n-\t\"time\"\n-\n-\t\"github.com/go-redis/redis/v7/internal\"\n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n-\t\"github.com/go-redis/redis/v7/internal/util\"\n-)\n-\n-type Cmder interface {\n-\tName() string\n-\tArgs() []interface{}\n-\tString() string\n-\tstringArg(int) string\n-\n-\treadTimeout() *time.Duration\n-\treadReply(rd *proto.Reader) error\n-\n-\tSetErr(error)\n-\tErr() error\n-}\n-\n-func setCmdsErr(cmds []Cmder, e error) {\n-\tfor _, cmd := range cmds {\n-\t\tif cmd.Err() == nil {\n-\t\t\tcmd.SetErr(e)\n-\t\t}\n-\t}\n-}\n-\n-func cmdsFirstErr(cmds []Cmder) error {\n-\tfor _, cmd := range cmds {\n-\t\tif err := cmd.Err(); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func writeCmds(wr *proto.Writer, cmds []Cmder) error {\n-\tfor _, cmd := range cmds {\n-\t\tif err := writeCmd(wr, cmd); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func writeCmd(wr *proto.Writer, cmd Cmder) error {\n-\treturn wr.WriteArgs(cmd.Args())\n-}\n-\n-func cmdString(cmd Cmder, val interface{}) string {\n-\tss := make([]string, 0, len(cmd.Args()))\n-\tfor _, arg := range cmd.Args() {\n-\t\tss = append(ss, fmt.Sprint(arg))\n-\t}\n-\ts := strings.Join(ss, \" \")\n-\tif err := cmd.Err(); err != nil {\n-\t\treturn s + \": \" + err.Error()\n-\t}\n-\tif val != nil {\n-\t\tswitch vv := val.(type) {\n-\t\tcase []byte:\n-\t\t\treturn s + \": \" + string(vv)\n-\t\tdefault:\n-\t\t\treturn s + \": \" + fmt.Sprint(val)\n-\t\t}\n-\t}\n-\treturn s\n-}\n-\n-func cmdFirstKeyPos(cmd Cmder, info *CommandInfo) int {\n-\tswitch cmd.Name() {\n-\tcase \"eval\", \"evalsha\":\n-\t\tif cmd.stringArg(2) != \"0\" {\n-\t\t\treturn 3\n-\t\t}\n-\n-\t\treturn 0\n-\tcase \"publish\":\n-\t\treturn 1\n-\t}\n-\tif info == nil {\n-\t\treturn 0\n-\t}\n-\treturn int(info.FirstKeyPos)\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type baseCmd struct {\n-\targs []interface{}\n-\terr  error\n-\n-\t_readTimeout *time.Duration\n-}\n-\n-var _ Cmder = (*Cmd)(nil)\n-\n-func (cmd *baseCmd) Name() string {\n-\tif len(cmd.args) == 0 {\n-\t\treturn \"\"\n-\t}\n-\t// Cmd name must be lower cased.\n-\treturn internal.ToLower(cmd.stringArg(0))\n-}\n-\n-func (cmd *baseCmd) Args() []interface{} {\n-\treturn cmd.args\n-}\n-\n-func (cmd *baseCmd) stringArg(pos int) string {\n-\tif pos < 0 || pos >= len(cmd.args) {\n-\t\treturn \"\"\n-\t}\n-\ts, _ := cmd.args[pos].(string)\n-\treturn s\n-}\n-\n-func (cmd *baseCmd) SetErr(e error) {\n-\tcmd.err = e\n-}\n-\n-func (cmd *baseCmd) Err() error {\n-\treturn cmd.err\n-}\n-\n-func (cmd *baseCmd) readTimeout() *time.Duration {\n-\treturn cmd._readTimeout\n-}\n-\n-func (cmd *baseCmd) setReadTimeout(d time.Duration) {\n-\tcmd._readTimeout = &d\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type Cmd struct {\n-\tbaseCmd\n-\n-\tval interface{}\n-}\n-\n-func NewCmd(args ...interface{}) *Cmd {\n-\treturn &Cmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *Cmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *Cmd) Val() interface{} {\n-\treturn cmd.val\n-}\n-\n-func (cmd *Cmd) Result() (interface{}, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *Cmd) Text() (string, error) {\n-\tif cmd.err != nil {\n-\t\treturn \"\", cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase string:\n-\t\treturn val, nil\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for String\", val)\n-\t\treturn \"\", err\n-\t}\n-}\n-\n-func (cmd *Cmd) Int() (int, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase int64:\n-\t\treturn int(val), nil\n-\tcase string:\n-\t\treturn strconv.Atoi(val)\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Int\", val)\n-\t\treturn 0, err\n-\t}\n-}\n-\n-func (cmd *Cmd) Int64() (int64, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase int64:\n-\t\treturn val, nil\n-\tcase string:\n-\t\treturn strconv.ParseInt(val, 10, 64)\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Int64\", val)\n-\t\treturn 0, err\n-\t}\n-}\n-\n-func (cmd *Cmd) Uint64() (uint64, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase int64:\n-\t\treturn uint64(val), nil\n-\tcase string:\n-\t\treturn strconv.ParseUint(val, 10, 64)\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Uint64\", val)\n-\t\treturn 0, err\n-\t}\n-}\n-\n-func (cmd *Cmd) Float32() (float32, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase int64:\n-\t\treturn float32(val), nil\n-\tcase string:\n-\t\tf, err := strconv.ParseFloat(val, 32)\n-\t\tif err != nil {\n-\t\t\treturn 0, err\n-\t\t}\n-\t\treturn float32(f), nil\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Float32\", val)\n-\t\treturn 0, err\n-\t}\n-}\n-\n-func (cmd *Cmd) Float64() (float64, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase int64:\n-\t\treturn float64(val), nil\n-\tcase string:\n-\t\treturn strconv.ParseFloat(val, 64)\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Float64\", val)\n-\t\treturn 0, err\n-\t}\n-}\n-\n-func (cmd *Cmd) Bool() (bool, error) {\n-\tif cmd.err != nil {\n-\t\treturn false, cmd.err\n-\t}\n-\tswitch val := cmd.val.(type) {\n-\tcase int64:\n-\t\treturn val != 0, nil\n-\tcase string:\n-\t\treturn strconv.ParseBool(val)\n-\tdefault:\n-\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Bool\", val)\n-\t\treturn false, err\n-\t}\n-}\n-\n-func (cmd *Cmd) readReply(rd *proto.Reader) error {\n-\tcmd.val, cmd.err = rd.ReadReply(sliceParser)\n-\treturn cmd.err\n-}\n-\n-// Implements proto.MultiBulkParse\n-func sliceParser(rd *proto.Reader, n int64) (interface{}, error) {\n-\tvals := make([]interface{}, n)\n-\tfor i := 0; i < len(vals); i++ {\n-\t\tv, err := rd.ReadReply(sliceParser)\n-\t\tif err != nil {\n-\t\t\tif err == Nil {\n-\t\t\t\tvals[i] = nil\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif err, ok := err.(proto.RedisError); ok {\n-\t\t\t\tvals[i] = err\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tvals[i] = v\n-\t}\n-\treturn vals, nil\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type SliceCmd struct {\n-\tbaseCmd\n-\n-\tval []interface{}\n-}\n-\n-var _ Cmder = (*SliceCmd)(nil)\n-\n-func NewSliceCmd(args ...interface{}) *SliceCmd {\n-\treturn &SliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *SliceCmd) Val() []interface{} {\n-\treturn cmd.val\n-}\n-\n-func (cmd *SliceCmd) Result() ([]interface{}, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *SliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *SliceCmd) readReply(rd *proto.Reader) error {\n-\tvar v interface{}\n-\tv, cmd.err = rd.ReadArrayReply(sliceParser)\n-\tif cmd.err != nil {\n-\t\treturn cmd.err\n-\t}\n-\tcmd.val = v.([]interface{})\n-\treturn nil\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type StatusCmd struct {\n-\tbaseCmd\n-\n-\tval string\n-}\n-\n-var _ Cmder = (*StatusCmd)(nil)\n-\n-func NewStatusCmd(args ...interface{}) *StatusCmd {\n-\treturn &StatusCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *StatusCmd) Val() string {\n-\treturn cmd.val\n-}\n-\n-func (cmd *StatusCmd) Result() (string, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *StatusCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *StatusCmd) readReply(rd *proto.Reader) error {\n-\tcmd.val, cmd.err = rd.ReadString()\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type IntCmd struct {\n-\tbaseCmd\n-\n-\tval int64\n-}\n-\n-var _ Cmder = (*IntCmd)(nil)\n-\n-func NewIntCmd(args ...interface{}) *IntCmd {\n-\treturn &IntCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *IntCmd) Val() int64 {\n-\treturn cmd.val\n-}\n-\n-func (cmd *IntCmd) Result() (int64, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *IntCmd) Uint64() (uint64, error) {\n-\treturn uint64(cmd.val), cmd.err\n-}\n-\n-func (cmd *IntCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *IntCmd) readReply(rd *proto.Reader) error {\n-\tcmd.val, cmd.err = rd.ReadIntReply()\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type IntSliceCmd struct {\n-\tbaseCmd\n-\n-\tval []int64\n-}\n-\n-var _ Cmder = (*IntSliceCmd)(nil)\n-\n-func NewIntSliceCmd(args ...interface{}) *IntSliceCmd {\n-\treturn &IntSliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *IntSliceCmd) Val() []int64 {\n-\treturn cmd.val\n-}\n-\n-func (cmd *IntSliceCmd) Result() ([]int64, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *IntSliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *IntSliceCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]int64, n)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\tnum, err := rd.ReadIntReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tcmd.val[i] = num\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type DurationCmd struct {\n-\tbaseCmd\n-\n-\tval       time.Duration\n-\tprecision time.Duration\n-}\n-\n-var _ Cmder = (*DurationCmd)(nil)\n-\n-func NewDurationCmd(precision time.Duration, args ...interface{}) *DurationCmd {\n-\treturn &DurationCmd{\n-\t\tbaseCmd:   baseCmd{args: args},\n-\t\tprecision: precision,\n-\t}\n-}\n-\n-func (cmd *DurationCmd) Val() time.Duration {\n-\treturn cmd.val\n-}\n-\n-func (cmd *DurationCmd) Result() (time.Duration, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *DurationCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *DurationCmd) readReply(rd *proto.Reader) error {\n-\tvar n int64\n-\tn, cmd.err = rd.ReadIntReply()\n-\tif cmd.err != nil {\n-\t\treturn cmd.err\n-\t}\n-\tswitch n {\n-\t// -2 if the key does not exist\n-\t// -1 if the key exists but has no associated expire\n-\tcase -2, -1:\n-\t\tcmd.val = time.Duration(n)\n-\tdefault:\n-\t\tcmd.val = time.Duration(n) * cmd.precision\n-\t}\n-\treturn nil\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type TimeCmd struct {\n-\tbaseCmd\n-\n-\tval time.Time\n-}\n-\n-var _ Cmder = (*TimeCmd)(nil)\n-\n-func NewTimeCmd(args ...interface{}) *TimeCmd {\n-\treturn &TimeCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *TimeCmd) Val() time.Time {\n-\treturn cmd.val\n-}\n-\n-func (cmd *TimeCmd) Result() (time.Time, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *TimeCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *TimeCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tif n != 2 {\n-\t\t\treturn nil, fmt.Errorf(\"got %d elements, expected 2\", n)\n-\t\t}\n-\n-\t\tsec, err := rd.ReadInt()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tmicrosec, err := rd.ReadInt()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tcmd.val = time.Unix(sec, microsec*1000)\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type BoolCmd struct {\n-\tbaseCmd\n-\n-\tval bool\n-}\n-\n-var _ Cmder = (*BoolCmd)(nil)\n-\n-func NewBoolCmd(args ...interface{}) *BoolCmd {\n-\treturn &BoolCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *BoolCmd) Val() bool {\n-\treturn cmd.val\n-}\n-\n-func (cmd *BoolCmd) Result() (bool, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *BoolCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *BoolCmd) readReply(rd *proto.Reader) error {\n-\tvar v interface{}\n-\tv, cmd.err = rd.ReadReply(nil)\n-\t// `SET key value NX` returns nil when key already exists. But\n-\t// `SETNX key value` returns bool (0/1). So convert nil to bool.\n-\tif cmd.err == Nil {\n-\t\tcmd.val = false\n-\t\tcmd.err = nil\n-\t\treturn nil\n-\t}\n-\tif cmd.err != nil {\n-\t\treturn cmd.err\n-\t}\n-\tswitch v := v.(type) {\n-\tcase int64:\n-\t\tcmd.val = v == 1\n-\t\treturn nil\n-\tcase string:\n-\t\tcmd.val = v == \"OK\"\n-\t\treturn nil\n-\tdefault:\n-\t\tcmd.err = fmt.Errorf(\"got %T, wanted int64 or string\", v)\n-\t\treturn cmd.err\n-\t}\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type StringCmd struct {\n-\tbaseCmd\n-\n-\tval string\n-}\n-\n-var _ Cmder = (*StringCmd)(nil)\n-\n-func NewStringCmd(args ...interface{}) *StringCmd {\n-\treturn &StringCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *StringCmd) Val() string {\n-\treturn cmd.val\n-}\n-\n-func (cmd *StringCmd) Result() (string, error) {\n-\treturn cmd.Val(), cmd.err\n-}\n-\n-func (cmd *StringCmd) Bytes() ([]byte, error) {\n-\treturn util.StringToBytes(cmd.val), cmd.err\n-}\n-\n-func (cmd *StringCmd) Int() (int, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\treturn strconv.Atoi(cmd.Val())\n-}\n-\n-func (cmd *StringCmd) Int64() (int64, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\treturn strconv.ParseInt(cmd.Val(), 10, 64)\n-}\n-\n-func (cmd *StringCmd) Uint64() (uint64, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\treturn strconv.ParseUint(cmd.Val(), 10, 64)\n-}\n-\n-func (cmd *StringCmd) Float32() (float32, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\tf, err := strconv.ParseFloat(cmd.Val(), 32)\n-\tif err != nil {\n-\t\treturn 0, err\n-\t}\n-\treturn float32(f), nil\n-}\n-\n-func (cmd *StringCmd) Float64() (float64, error) {\n-\tif cmd.err != nil {\n-\t\treturn 0, cmd.err\n-\t}\n-\treturn strconv.ParseFloat(cmd.Val(), 64)\n-}\n-\n-func (cmd *StringCmd) Time() (time.Time, error) {\n-\tif cmd.err != nil {\n-\t\treturn time.Time{}, cmd.err\n-\t}\n-\treturn time.Parse(time.RFC3339Nano, cmd.Val())\n-}\n-\n-func (cmd *StringCmd) Scan(val interface{}) error {\n-\tif cmd.err != nil {\n-\t\treturn cmd.err\n-\t}\n-\treturn proto.Scan([]byte(cmd.val), val)\n-}\n-\n-func (cmd *StringCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *StringCmd) readReply(rd *proto.Reader) error {\n-\tcmd.val, cmd.err = rd.ReadString()\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type FloatCmd struct {\n-\tbaseCmd\n-\n-\tval float64\n-}\n-\n-var _ Cmder = (*FloatCmd)(nil)\n-\n-func NewFloatCmd(args ...interface{}) *FloatCmd {\n-\treturn &FloatCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *FloatCmd) Val() float64 {\n-\treturn cmd.val\n-}\n-\n-func (cmd *FloatCmd) Result() (float64, error) {\n-\treturn cmd.Val(), cmd.Err()\n-}\n-\n-func (cmd *FloatCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *FloatCmd) readReply(rd *proto.Reader) error {\n-\tcmd.val, cmd.err = rd.ReadFloatReply()\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type StringSliceCmd struct {\n-\tbaseCmd\n-\n-\tval []string\n-}\n-\n-var _ Cmder = (*StringSliceCmd)(nil)\n-\n-func NewStringSliceCmd(args ...interface{}) *StringSliceCmd {\n-\treturn &StringSliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *StringSliceCmd) Val() []string {\n-\treturn cmd.val\n-}\n-\n-func (cmd *StringSliceCmd) Result() ([]string, error) {\n-\treturn cmd.Val(), cmd.Err()\n-}\n-\n-func (cmd *StringSliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *StringSliceCmd) ScanSlice(container interface{}) error {\n-\treturn proto.ScanSlice(cmd.Val(), container)\n-}\n-\n-func (cmd *StringSliceCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]string, n)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\tswitch s, err := rd.ReadString(); {\n-\t\t\tcase err == Nil:\n-\t\t\t\tcmd.val[i] = \"\"\n-\t\t\tcase err != nil:\n-\t\t\t\treturn nil, err\n-\t\t\tdefault:\n-\t\t\t\tcmd.val[i] = s\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type BoolSliceCmd struct {\n-\tbaseCmd\n-\n-\tval []bool\n-}\n-\n-var _ Cmder = (*BoolSliceCmd)(nil)\n-\n-func NewBoolSliceCmd(args ...interface{}) *BoolSliceCmd {\n-\treturn &BoolSliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *BoolSliceCmd) Val() []bool {\n-\treturn cmd.val\n-}\n-\n-func (cmd *BoolSliceCmd) Result() ([]bool, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *BoolSliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *BoolSliceCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]bool, n)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\tn, err := rd.ReadIntReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tcmd.val[i] = n == 1\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type StringStringMapCmd struct {\n-\tbaseCmd\n-\n-\tval map[string]string\n-}\n-\n-var _ Cmder = (*StringStringMapCmd)(nil)\n-\n-func NewStringStringMapCmd(args ...interface{}) *StringStringMapCmd {\n-\treturn &StringStringMapCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *StringStringMapCmd) Val() map[string]string {\n-\treturn cmd.val\n-}\n-\n-func (cmd *StringStringMapCmd) Result() (map[string]string, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *StringStringMapCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *StringStringMapCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make(map[string]string, n/2)\n-\t\tfor i := int64(0); i < n; i += 2 {\n-\t\t\tkey, err := rd.ReadString()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tvalue, err := rd.ReadString()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tcmd.val[key] = value\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type StringIntMapCmd struct {\n-\tbaseCmd\n-\n-\tval map[string]int64\n-}\n-\n-var _ Cmder = (*StringIntMapCmd)(nil)\n-\n-func NewStringIntMapCmd(args ...interface{}) *StringIntMapCmd {\n-\treturn &StringIntMapCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *StringIntMapCmd) Val() map[string]int64 {\n-\treturn cmd.val\n-}\n-\n-func (cmd *StringIntMapCmd) Result() (map[string]int64, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *StringIntMapCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *StringIntMapCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make(map[string]int64, n/2)\n-\t\tfor i := int64(0); i < n; i += 2 {\n-\t\t\tkey, err := rd.ReadString()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tn, err := rd.ReadIntReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tcmd.val[key] = n\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type StringStructMapCmd struct {\n-\tbaseCmd\n-\n-\tval map[string]struct{}\n-}\n-\n-var _ Cmder = (*StringStructMapCmd)(nil)\n-\n-func NewStringStructMapCmd(args ...interface{}) *StringStructMapCmd {\n-\treturn &StringStructMapCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *StringStructMapCmd) Val() map[string]struct{} {\n-\treturn cmd.val\n-}\n-\n-func (cmd *StringStructMapCmd) Result() (map[string]struct{}, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *StringStructMapCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *StringStructMapCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make(map[string]struct{}, n)\n-\t\tfor i := int64(0); i < n; i++ {\n-\t\t\tkey, err := rd.ReadString()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tcmd.val[key] = struct{}{}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type XMessage struct {\n-\tID     string\n-\tValues map[string]interface{}\n-}\n-\n-type XMessageSliceCmd struct {\n-\tbaseCmd\n-\n-\tval []XMessage\n-}\n-\n-var _ Cmder = (*XMessageSliceCmd)(nil)\n-\n-func NewXMessageSliceCmd(args ...interface{}) *XMessageSliceCmd {\n-\treturn &XMessageSliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *XMessageSliceCmd) Val() []XMessage {\n-\treturn cmd.val\n-}\n-\n-func (cmd *XMessageSliceCmd) Result() ([]XMessage, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *XMessageSliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *XMessageSliceCmd) readReply(rd *proto.Reader) error {\n-\tvar v interface{}\n-\tv, cmd.err = rd.ReadArrayReply(xMessageSliceParser)\n-\tif cmd.err != nil {\n-\t\treturn cmd.err\n-\t}\n-\tcmd.val = v.([]XMessage)\n-\treturn nil\n-}\n-\n-// Implements proto.MultiBulkParse\n-func xMessageSliceParser(rd *proto.Reader, n int64) (interface{}, error) {\n-\tmsgs := make([]XMessage, n)\n-\tfor i := 0; i < len(msgs); i++ {\n-\t\ti := i\n-\t\t_, err := rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\tid, err := rd.ReadString()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tvar values map[string]interface{}\n-\n-\t\t\tv, err := rd.ReadArrayReply(stringInterfaceMapParser)\n-\t\t\tif err != nil {\n-\t\t\t\tif err != proto.Nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tvalues = v.(map[string]interface{})\n-\t\t\t}\n-\n-\t\t\tmsgs[i] = XMessage{\n-\t\t\t\tID:     id,\n-\t\t\t\tValues: values,\n-\t\t\t}\n-\t\t\treturn nil, nil\n-\t\t})\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\treturn msgs, nil\n-}\n-\n-// Implements proto.MultiBulkParse\n-func stringInterfaceMapParser(rd *proto.Reader, n int64) (interface{}, error) {\n-\tm := make(map[string]interface{}, n/2)\n-\tfor i := int64(0); i < n; i += 2 {\n-\t\tkey, err := rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tvalue, err := rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tm[key] = value\n-\t}\n-\treturn m, nil\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type XStream struct {\n-\tStream   string\n-\tMessages []XMessage\n-}\n-\n-type XStreamSliceCmd struct {\n-\tbaseCmd\n-\n-\tval []XStream\n-}\n-\n-var _ Cmder = (*XStreamSliceCmd)(nil)\n-\n-func NewXStreamSliceCmd(args ...interface{}) *XStreamSliceCmd {\n-\treturn &XStreamSliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *XStreamSliceCmd) Val() []XStream {\n-\treturn cmd.val\n-}\n-\n-func (cmd *XStreamSliceCmd) Result() ([]XStream, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *XStreamSliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *XStreamSliceCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]XStream, n)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\ti := i\n-\t\t\t_, err := rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\t\tif n != 2 {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"got %d, wanted 2\", n)\n-\t\t\t\t}\n-\n-\t\t\t\tstream, err := rd.ReadString()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tv, err := rd.ReadArrayReply(xMessageSliceParser)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tcmd.val[i] = XStream{\n-\t\t\t\t\tStream:   stream,\n-\t\t\t\t\tMessages: v.([]XMessage),\n-\t\t\t\t}\n-\t\t\t\treturn nil, nil\n-\t\t\t})\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type XPending struct {\n-\tCount     int64\n-\tLower     string\n-\tHigher    string\n-\tConsumers map[string]int64\n-}\n-\n-type XPendingCmd struct {\n-\tbaseCmd\n-\tval *XPending\n-}\n-\n-var _ Cmder = (*XPendingCmd)(nil)\n-\n-func NewXPendingCmd(args ...interface{}) *XPendingCmd {\n-\treturn &XPendingCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *XPendingCmd) Val() *XPending {\n-\treturn cmd.val\n-}\n-\n-func (cmd *XPendingCmd) Result() (*XPending, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *XPendingCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *XPendingCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tif n != 4 {\n-\t\t\treturn nil, fmt.Errorf(\"got %d, wanted 4\", n)\n-\t\t}\n-\n-\t\tcount, err := rd.ReadIntReply()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tlower, err := rd.ReadString()\n-\t\tif err != nil && err != Nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\thigher, err := rd.ReadString()\n-\t\tif err != nil && err != Nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tcmd.val = &XPending{\n-\t\t\tCount:  count,\n-\t\t\tLower:  lower,\n-\t\t\tHigher: higher,\n-\t\t}\n-\t\t_, err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\tfor i := int64(0); i < n; i++ {\n-\t\t\t\t_, err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\t\t\tif n != 2 {\n-\t\t\t\t\t\treturn nil, fmt.Errorf(\"got %d, wanted 2\", n)\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tconsumerName, err := rd.ReadString()\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn nil, err\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tconsumerPending, err := rd.ReadInt()\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn nil, err\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tif cmd.val.Consumers == nil {\n-\t\t\t\t\t\tcmd.val.Consumers = make(map[string]int64)\n-\t\t\t\t\t}\n-\t\t\t\t\tcmd.val.Consumers[consumerName] = consumerPending\n-\n-\t\t\t\t\treturn nil, nil\n-\t\t\t\t})\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn nil, nil\n-\t\t})\n-\t\tif err != nil && err != Nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type XPendingExt struct {\n-\tID         string\n-\tConsumer   string\n-\tIdle       time.Duration\n-\tRetryCount int64\n-}\n-\n-type XPendingExtCmd struct {\n-\tbaseCmd\n-\tval []XPendingExt\n-}\n-\n-var _ Cmder = (*XPendingExtCmd)(nil)\n-\n-func NewXPendingExtCmd(args ...interface{}) *XPendingExtCmd {\n-\treturn &XPendingExtCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *XPendingExtCmd) Val() []XPendingExt {\n-\treturn cmd.val\n-}\n-\n-func (cmd *XPendingExtCmd) Result() ([]XPendingExt, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *XPendingExtCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *XPendingExtCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]XPendingExt, 0, n)\n-\t\tfor i := int64(0); i < n; i++ {\n-\t\t\t_, err := rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\t\tif n != 4 {\n-\t\t\t\t\treturn nil, fmt.Errorf(\"got %d, wanted 4\", n)\n-\t\t\t\t}\n-\n-\t\t\t\tid, err := rd.ReadString()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tconsumer, err := rd.ReadString()\n-\t\t\t\tif err != nil && err != Nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tidle, err := rd.ReadIntReply()\n-\t\t\t\tif err != nil && err != Nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tretryCount, err := rd.ReadIntReply()\n-\t\t\t\tif err != nil && err != Nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tcmd.val = append(cmd.val, XPendingExt{\n-\t\t\t\t\tID:         id,\n-\t\t\t\t\tConsumer:   consumer,\n-\t\t\t\t\tIdle:       time.Duration(idle) * time.Millisecond,\n-\t\t\t\t\tRetryCount: retryCount,\n-\t\t\t\t})\n-\t\t\t\treturn nil, nil\n-\t\t\t})\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type XInfoGroupsCmd struct {\n-\tbaseCmd\n-\tval []XInfoGroups\n-}\n-\n-type XInfoGroups struct {\n-\tName            string\n-\tConsumers       int64\n-\tPending         int64\n-\tLastDeliveredID string\n-}\n-\n-var _ Cmder = (*XInfoGroupsCmd)(nil)\n-\n-func NewXInfoGroupsCmd(stream string) *XInfoGroupsCmd {\n-\treturn &XInfoGroupsCmd{\n-\t\tbaseCmd: baseCmd{args: []interface{}{\"xinfo\", \"groups\", stream}},\n-\t}\n-}\n-\n-func (cmd *XInfoGroupsCmd) Val() []XInfoGroups {\n-\treturn cmd.val\n-}\n-\n-func (cmd *XInfoGroupsCmd) Result() ([]XInfoGroups, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *XInfoGroupsCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *XInfoGroupsCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(\n-\t\tfunc(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\tfor i := int64(0); i < n; i++ {\n-\t\t\t\tv, err := rd.ReadReply(xGroupInfoParser)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\tcmd.val = append(cmd.val, v.(XInfoGroups))\n-\t\t\t}\n-\t\t\treturn nil, nil\n-\t\t})\n-\treturn nil\n-}\n-\n-func xGroupInfoParser(rd *proto.Reader, n int64) (interface{}, error) {\n-\tif n != 8 {\n-\t\treturn nil, fmt.Errorf(\"redis: got %d elements in XINFO GROUPS reply,\"+\n-\t\t\t\"wanted 8\", n)\n-\t}\n-\tvar (\n-\t\terr error\n-\t\tgrp XInfoGroups\n-\t\tkey string\n-\t\tval string\n-\t)\n-\n-\tfor i := 0; i < 4; i++ {\n-\t\tkey, err = rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tval, err = rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tswitch key {\n-\t\tcase \"name\":\n-\t\t\tgrp.Name = val\n-\t\tcase \"consumers\":\n-\t\t\tgrp.Consumers, err = strconv.ParseInt(val, 0, 64)\n-\t\tcase \"pending\":\n-\t\t\tgrp.Pending, err = strconv.ParseInt(val, 0, 64)\n-\t\tcase \"last-delivered-id\":\n-\t\t\tgrp.LastDeliveredID = val\n-\t\tdefault:\n-\t\t\treturn nil, fmt.Errorf(\"redis: unexpected content %s \"+\n-\t\t\t\t\"in XINFO GROUPS reply\", key)\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\treturn grp, err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type ZSliceCmd struct {\n-\tbaseCmd\n-\n-\tval []Z\n-}\n-\n-var _ Cmder = (*ZSliceCmd)(nil)\n-\n-func NewZSliceCmd(args ...interface{}) *ZSliceCmd {\n-\treturn &ZSliceCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *ZSliceCmd) Val() []Z {\n-\treturn cmd.val\n-}\n-\n-func (cmd *ZSliceCmd) Result() ([]Z, error) {\n-\treturn cmd.val, cmd.err\n-}\n-\n-func (cmd *ZSliceCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *ZSliceCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]Z, n/2)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\tmember, err := rd.ReadString()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tscore, err := rd.ReadFloatReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tcmd.val[i] = Z{\n-\t\t\t\tMember: member,\n-\t\t\t\tScore:  score,\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type ZWithKeyCmd struct {\n-\tbaseCmd\n-\n-\tval *ZWithKey\n-}\n-\n-var _ Cmder = (*ZWithKeyCmd)(nil)\n-\n-func NewZWithKeyCmd(args ...interface{}) *ZWithKeyCmd {\n-\treturn &ZWithKeyCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *ZWithKeyCmd) Val() *ZWithKey {\n-\treturn cmd.val\n-}\n-\n-func (cmd *ZWithKeyCmd) Result() (*ZWithKey, error) {\n-\treturn cmd.Val(), cmd.Err()\n-}\n-\n-func (cmd *ZWithKeyCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *ZWithKeyCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tif n != 3 {\n-\t\t\treturn nil, fmt.Errorf(\"got %d elements, expected 3\", n)\n-\t\t}\n-\n-\t\tcmd.val = &ZWithKey{}\n-\t\tvar err error\n-\n-\t\tcmd.val.Key, err = rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tcmd.val.Member, err = rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\tcmd.val.Score, err = rd.ReadFloatReply()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type ScanCmd struct {\n-\tbaseCmd\n-\n-\tpage   []string\n-\tcursor uint64\n-\n-\tprocess func(cmd Cmder) error\n-}\n-\n-var _ Cmder = (*ScanCmd)(nil)\n-\n-func NewScanCmd(process func(cmd Cmder) error, args ...interface{}) *ScanCmd {\n-\treturn &ScanCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t\tprocess: process,\n-\t}\n-}\n-\n-func (cmd *ScanCmd) Val() (keys []string, cursor uint64) {\n-\treturn cmd.page, cmd.cursor\n-}\n-\n-func (cmd *ScanCmd) Result() (keys []string, cursor uint64, err error) {\n-\treturn cmd.page, cmd.cursor, cmd.err\n-}\n-\n-func (cmd *ScanCmd) String() string {\n-\treturn cmdString(cmd, cmd.page)\n-}\n-\n-func (cmd *ScanCmd) readReply(rd *proto.Reader) error {\n-\tcmd.page, cmd.cursor, cmd.err = rd.ReadScanReply()\n-\treturn cmd.err\n-}\n-\n-// Iterator creates a new ScanIterator.\n-func (cmd *ScanCmd) Iterator() *ScanIterator {\n-\treturn &ScanIterator{\n-\t\tcmd: cmd,\n-\t}\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type ClusterNode struct {\n-\tID   string\n-\tAddr string\n-}\n-\n-type ClusterSlot struct {\n-\tStart int\n-\tEnd   int\n-\tNodes []ClusterNode\n-}\n-\n-type ClusterSlotsCmd struct {\n-\tbaseCmd\n-\n-\tval []ClusterSlot\n-}\n-\n-var _ Cmder = (*ClusterSlotsCmd)(nil)\n-\n-func NewClusterSlotsCmd(args ...interface{}) *ClusterSlotsCmd {\n-\treturn &ClusterSlotsCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *ClusterSlotsCmd) Val() []ClusterSlot {\n-\treturn cmd.val\n-}\n-\n-func (cmd *ClusterSlotsCmd) Result() ([]ClusterSlot, error) {\n-\treturn cmd.Val(), cmd.Err()\n-}\n-\n-func (cmd *ClusterSlotsCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *ClusterSlotsCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]ClusterSlot, n)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\tn, err := rd.ReadArrayLen()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tif n < 2 {\n-\t\t\t\terr := fmt.Errorf(\"redis: got %d elements in cluster info, expected at least 2\", n)\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tstart, err := rd.ReadIntReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tend, err := rd.ReadIntReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\n-\t\t\tnodes := make([]ClusterNode, n-2)\n-\t\t\tfor j := 0; j < len(nodes); j++ {\n-\t\t\t\tn, err := rd.ReadArrayLen()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\tif n != 2 && n != 3 {\n-\t\t\t\t\terr := fmt.Errorf(\"got %d elements in cluster info address, expected 2 or 3\", n)\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tip, err := rd.ReadString()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tport, err := rd.ReadString()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tnodes[j].Addr = net.JoinHostPort(ip, port)\n-\n-\t\t\t\tif n == 3 {\n-\t\t\t\t\tid, err := rd.ReadString()\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn nil, err\n-\t\t\t\t\t}\n-\t\t\t\t\tnodes[j].ID = id\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tcmd.val[i] = ClusterSlot{\n-\t\t\t\tStart: int(start),\n-\t\t\t\tEnd:   int(end),\n-\t\t\t\tNodes: nodes,\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-// GeoLocation is used with GeoAdd to add geospatial location.\n-type GeoLocation struct {\n-\tName                      string\n-\tLongitude, Latitude, Dist float64\n-\tGeoHash                   int64\n-}\n-\n-// GeoRadiusQuery is used with GeoRadius to query geospatial index.\n-type GeoRadiusQuery struct {\n-\tRadius float64\n-\t// Can be m, km, ft, or mi. Default is km.\n-\tUnit        string\n-\tWithCoord   bool\n-\tWithDist    bool\n-\tWithGeoHash bool\n-\tCount       int\n-\t// Can be ASC or DESC. Default is no sort order.\n-\tSort      string\n-\tStore     string\n-\tStoreDist string\n-}\n-\n-type GeoLocationCmd struct {\n-\tbaseCmd\n-\n-\tq         *GeoRadiusQuery\n-\tlocations []GeoLocation\n-}\n-\n-var _ Cmder = (*GeoLocationCmd)(nil)\n-\n-func NewGeoLocationCmd(q *GeoRadiusQuery, args ...interface{}) *GeoLocationCmd {\n-\treturn &GeoLocationCmd{\n-\t\tbaseCmd: baseCmd{args: geoLocationArgs(q, args...)},\n-\t\tq:       q,\n-\t}\n-}\n-\n-func geoLocationArgs(q *GeoRadiusQuery, args ...interface{}) []interface{} {\n-\targs = append(args, q.Radius)\n-\tif q.Unit != \"\" {\n-\t\targs = append(args, q.Unit)\n-\t} else {\n-\t\targs = append(args, \"km\")\n-\t}\n-\tif q.WithCoord {\n-\t\targs = append(args, \"withcoord\")\n-\t}\n-\tif q.WithDist {\n-\t\targs = append(args, \"withdist\")\n-\t}\n-\tif q.WithGeoHash {\n-\t\targs = append(args, \"withhash\")\n-\t}\n-\tif q.Count > 0 {\n-\t\targs = append(args, \"count\", q.Count)\n-\t}\n-\tif q.Sort != \"\" {\n-\t\targs = append(args, q.Sort)\n-\t}\n-\tif q.Store != \"\" {\n-\t\targs = append(args, \"store\")\n-\t\targs = append(args, q.Store)\n-\t}\n-\tif q.StoreDist != \"\" {\n-\t\targs = append(args, \"storedist\")\n-\t\targs = append(args, q.StoreDist)\n-\t}\n-\treturn args\n-}\n-\n-func (cmd *GeoLocationCmd) Val() []GeoLocation {\n-\treturn cmd.locations\n-}\n-\n-func (cmd *GeoLocationCmd) Result() ([]GeoLocation, error) {\n-\treturn cmd.locations, cmd.err\n-}\n-\n-func (cmd *GeoLocationCmd) String() string {\n-\treturn cmdString(cmd, cmd.locations)\n-}\n-\n-func (cmd *GeoLocationCmd) readReply(rd *proto.Reader) error {\n-\tvar v interface{}\n-\tv, cmd.err = rd.ReadArrayReply(newGeoLocationSliceParser(cmd.q))\n-\tif cmd.err != nil {\n-\t\treturn cmd.err\n-\t}\n-\tcmd.locations = v.([]GeoLocation)\n-\treturn nil\n-}\n-\n-func newGeoLocationSliceParser(q *GeoRadiusQuery) proto.MultiBulkParse {\n-\treturn func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tlocs := make([]GeoLocation, 0, n)\n-\t\tfor i := int64(0); i < n; i++ {\n-\t\t\tv, err := rd.ReadReply(newGeoLocationParser(q))\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tswitch vv := v.(type) {\n-\t\t\tcase string:\n-\t\t\t\tlocs = append(locs, GeoLocation{\n-\t\t\t\t\tName: vv,\n-\t\t\t\t})\n-\t\t\tcase *GeoLocation:\n-\t\t\t\t//TODO: avoid copying\n-\t\t\t\tlocs = append(locs, *vv)\n-\t\t\tdefault:\n-\t\t\t\treturn nil, fmt.Errorf(\"got %T, expected string or *GeoLocation\", v)\n-\t\t\t}\n-\t\t}\n-\t\treturn locs, nil\n-\t}\n-}\n-\n-func newGeoLocationParser(q *GeoRadiusQuery) proto.MultiBulkParse {\n-\treturn func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tvar loc GeoLocation\n-\t\tvar err error\n-\n-\t\tloc.Name, err = rd.ReadString()\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif q.WithDist {\n-\t\t\tloc.Dist, err = rd.ReadFloatReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\t\tif q.WithGeoHash {\n-\t\t\tloc.GeoHash, err = rd.ReadIntReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\t\tif q.WithCoord {\n-\t\t\tn, err := rd.ReadArrayLen()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tif n != 2 {\n-\t\t\t\treturn nil, fmt.Errorf(\"got %d coordinates, expected 2\", n)\n-\t\t\t}\n-\n-\t\t\tloc.Longitude, err = rd.ReadFloatReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tloc.Latitude, err = rd.ReadFloatReply()\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn &loc, nil\n-\t}\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type GeoPos struct {\n-\tLongitude, Latitude float64\n-}\n-\n-type GeoPosCmd struct {\n-\tbaseCmd\n-\n-\tval []*GeoPos\n-}\n-\n-var _ Cmder = (*GeoPosCmd)(nil)\n-\n-func NewGeoPosCmd(args ...interface{}) *GeoPosCmd {\n-\treturn &GeoPosCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *GeoPosCmd) Val() []*GeoPos {\n-\treturn cmd.val\n-}\n-\n-func (cmd *GeoPosCmd) Result() ([]*GeoPos, error) {\n-\treturn cmd.Val(), cmd.Err()\n-}\n-\n-func (cmd *GeoPosCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *GeoPosCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make([]*GeoPos, n)\n-\t\tfor i := 0; i < len(cmd.val); i++ {\n-\t\t\ti := i\n-\t\t\t_, err := rd.ReadReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\t\t\tlongitude, err := rd.ReadFloatReply()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tlatitude, err := rd.ReadFloatReply()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\n-\t\t\t\tcmd.val[i] = &GeoPos{\n-\t\t\t\t\tLongitude: longitude,\n-\t\t\t\t\tLatitude:  latitude,\n-\t\t\t\t}\n-\t\t\t\treturn nil, nil\n-\t\t\t})\n-\t\t\tif err != nil {\n-\t\t\t\tif err == Nil {\n-\t\t\t\t\tcmd.val[i] = nil\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type CommandInfo struct {\n-\tName        string\n-\tArity       int8\n-\tFlags       []string\n-\tACLFlags    []string\n-\tFirstKeyPos int8\n-\tLastKeyPos  int8\n-\tStepCount   int8\n-\tReadOnly    bool\n-}\n-\n-type CommandsInfoCmd struct {\n-\tbaseCmd\n-\n-\tval map[string]*CommandInfo\n-}\n-\n-var _ Cmder = (*CommandsInfoCmd)(nil)\n-\n-func NewCommandsInfoCmd(args ...interface{}) *CommandsInfoCmd {\n-\treturn &CommandsInfoCmd{\n-\t\tbaseCmd: baseCmd{args: args},\n-\t}\n-}\n-\n-func (cmd *CommandsInfoCmd) Val() map[string]*CommandInfo {\n-\treturn cmd.val\n-}\n-\n-func (cmd *CommandsInfoCmd) Result() (map[string]*CommandInfo, error) {\n-\treturn cmd.Val(), cmd.Err()\n-}\n-\n-func (cmd *CommandsInfoCmd) String() string {\n-\treturn cmdString(cmd, cmd.val)\n-}\n-\n-func (cmd *CommandsInfoCmd) readReply(rd *proto.Reader) error {\n-\t_, cmd.err = rd.ReadArrayReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.val = make(map[string]*CommandInfo, n)\n-\t\tfor i := int64(0); i < n; i++ {\n-\t\t\tv, err := rd.ReadReply(commandInfoParser)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tvv := v.(*CommandInfo)\n-\t\t\tcmd.val[vv.Name] = vv\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\treturn cmd.err\n-}\n-\n-func commandInfoParser(rd *proto.Reader, n int64) (interface{}, error) {\n-\tconst numArgRedis5 = 6\n-\tconst numArgRedis6 = 7\n-\n-\tswitch n {\n-\tcase numArgRedis5, numArgRedis6:\n-\t\t// continue\n-\tdefault:\n-\t\treturn nil, fmt.Errorf(\"redis: got %d elements in COMMAND reply, wanted 7\", n)\n-\t}\n-\n-\tvar cmd CommandInfo\n-\tvar err error\n-\n-\tcmd.Name, err = rd.ReadString()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tarity, err := rd.ReadIntReply()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tcmd.Arity = int8(arity)\n-\n-\t_, err = rd.ReadReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.Flags = make([]string, n)\n-\t\tfor i := 0; i < len(cmd.Flags); i++ {\n-\t\t\tswitch s, err := rd.ReadString(); {\n-\t\t\tcase err == Nil:\n-\t\t\t\tcmd.Flags[i] = \"\"\n-\t\t\tcase err != nil:\n-\t\t\t\treturn nil, err\n-\t\t\tdefault:\n-\t\t\t\tcmd.Flags[i] = s\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfirstKeyPos, err := rd.ReadIntReply()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tcmd.FirstKeyPos = int8(firstKeyPos)\n-\n-\tlastKeyPos, err := rd.ReadIntReply()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tcmd.LastKeyPos = int8(lastKeyPos)\n-\n-\tstepCount, err := rd.ReadIntReply()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tcmd.StepCount = int8(stepCount)\n-\n-\tfor _, flag := range cmd.Flags {\n-\t\tif flag == \"readonly\" {\n-\t\t\tcmd.ReadOnly = true\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\tif n == numArgRedis5 {\n-\t\treturn &cmd, nil\n-\t}\n-\n-\t_, err = rd.ReadReply(func(rd *proto.Reader, n int64) (interface{}, error) {\n-\t\tcmd.ACLFlags = make([]string, n)\n-\t\tfor i := 0; i < len(cmd.ACLFlags); i++ {\n-\t\t\tswitch s, err := rd.ReadString(); {\n-\t\t\tcase err == Nil:\n-\t\t\t\tcmd.ACLFlags[i] = \"\"\n-\t\t\tcase err != nil:\n-\t\t\t\treturn nil, err\n-\t\t\tdefault:\n-\t\t\t\tcmd.ACLFlags[i] = s\n-\t\t\t}\n-\t\t}\n-\t\treturn nil, nil\n-\t})\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\treturn &cmd, nil\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type cmdsInfoCache struct {\n-\tfn func() (map[string]*CommandInfo, error)\n-\n-\tonce internal.Once\n-\tcmds map[string]*CommandInfo\n-}\n-\n-func newCmdsInfoCache(fn func() (map[string]*CommandInfo, error)) *cmdsInfoCache {\n-\treturn &cmdsInfoCache{\n-\t\tfn: fn,\n-\t}\n-}\n-\n-func (c *cmdsInfoCache) Get() (map[string]*CommandInfo, error) {\n-\terr := c.once.Do(func() error {\n-\t\tcmds, err := c.fn()\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\n-\t\t// Extensions have cmd names in upper case. Convert them to lower case.\n-\t\tfor k, v := range cmds {\n-\t\t\tlower := internal.ToLower(k)\n-\t\t\tif lower != k {\n-\t\t\t\tcmds[lower] = v\n-\t\t\t}\n-\t\t}\n-\n-\t\tc.cmds = cmds\n-\t\treturn nil\n-\t})\n-\treturn c.cmds, err\n-}"
    },
    {
      "sha": "da5ceda13ea206368deee292cbe8861fa2bf55e0",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/commands.go",
      "status": "removed",
      "additions": 0,
      "deletions": 2643,
      "changes": 2643,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcommands.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcommands.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fcommands.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,2643 +0,0 @@\n-package redis\n-\n-import (\n-\t\"errors\"\n-\t\"io\"\n-\t\"time\"\n-\n-\t\"github.com/go-redis/redis/v7/internal\"\n-)\n-\n-func usePrecise(dur time.Duration) bool {\n-\treturn dur < time.Second || dur%time.Second != 0\n-}\n-\n-func formatMs(dur time.Duration) int64 {\n-\tif dur > 0 && dur < time.Millisecond {\n-\t\tinternal.Logger.Printf(\n-\t\t\t\"specified duration is %s, but minimal supported value is %s\",\n-\t\t\tdur, time.Millisecond,\n-\t\t)\n-\t}\n-\treturn int64(dur / time.Millisecond)\n-}\n-\n-func formatSec(dur time.Duration) int64 {\n-\tif dur > 0 && dur < time.Second {\n-\t\tinternal.Logger.Printf(\n-\t\t\t\"specified duration is %s, but minimal supported value is %s\",\n-\t\t\tdur, time.Second,\n-\t\t)\n-\t}\n-\treturn int64(dur / time.Second)\n-}\n-\n-func appendArgs(dst, src []interface{}) []interface{} {\n-\tif len(src) == 1 {\n-\t\tswitch v := src[0].(type) {\n-\t\tcase []string:\n-\t\t\tfor _, s := range v {\n-\t\t\t\tdst = append(dst, s)\n-\t\t\t}\n-\t\t\treturn dst\n-\t\tcase map[string]interface{}:\n-\t\t\tfor k, v := range v {\n-\t\t\t\tdst = append(dst, k, v)\n-\t\t\t}\n-\t\t\treturn dst\n-\t\t}\n-\t}\n-\n-\tdst = append(dst, src...)\n-\treturn dst\n-}\n-\n-type Cmdable interface {\n-\tPipeline() Pipeliner\n-\tPipelined(fn func(Pipeliner) error) ([]Cmder, error)\n-\n-\tTxPipelined(fn func(Pipeliner) error) ([]Cmder, error)\n-\tTxPipeline() Pipeliner\n-\n-\tCommand() *CommandsInfoCmd\n-\tClientGetName() *StringCmd\n-\tEcho(message interface{}) *StringCmd\n-\tPing() *StatusCmd\n-\tQuit() *StatusCmd\n-\tDel(keys ...string) *IntCmd\n-\tUnlink(keys ...string) *IntCmd\n-\tDump(key string) *StringCmd\n-\tExists(keys ...string) *IntCmd\n-\tExpire(key string, expiration time.Duration) *BoolCmd\n-\tExpireAt(key string, tm time.Time) *BoolCmd\n-\tKeys(pattern string) *StringSliceCmd\n-\tMigrate(host, port, key string, db int, timeout time.Duration) *StatusCmd\n-\tMove(key string, db int) *BoolCmd\n-\tObjectRefCount(key string) *IntCmd\n-\tObjectEncoding(key string) *StringCmd\n-\tObjectIdleTime(key string) *DurationCmd\n-\tPersist(key string) *BoolCmd\n-\tPExpire(key string, expiration time.Duration) *BoolCmd\n-\tPExpireAt(key string, tm time.Time) *BoolCmd\n-\tPTTL(key string) *DurationCmd\n-\tRandomKey() *StringCmd\n-\tRename(key, newkey string) *StatusCmd\n-\tRenameNX(key, newkey string) *BoolCmd\n-\tRestore(key string, ttl time.Duration, value string) *StatusCmd\n-\tRestoreReplace(key string, ttl time.Duration, value string) *StatusCmd\n-\tSort(key string, sort *Sort) *StringSliceCmd\n-\tSortStore(key, store string, sort *Sort) *IntCmd\n-\tSortInterfaces(key string, sort *Sort) *SliceCmd\n-\tTouch(keys ...string) *IntCmd\n-\tTTL(key string) *DurationCmd\n-\tType(key string) *StatusCmd\n-\tScan(cursor uint64, match string, count int64) *ScanCmd\n-\tSScan(key string, cursor uint64, match string, count int64) *ScanCmd\n-\tHScan(key string, cursor uint64, match string, count int64) *ScanCmd\n-\tZScan(key string, cursor uint64, match string, count int64) *ScanCmd\n-\tAppend(key, value string) *IntCmd\n-\tBitCount(key string, bitCount *BitCount) *IntCmd\n-\tBitOpAnd(destKey string, keys ...string) *IntCmd\n-\tBitOpOr(destKey string, keys ...string) *IntCmd\n-\tBitOpXor(destKey string, keys ...string) *IntCmd\n-\tBitOpNot(destKey string, key string) *IntCmd\n-\tBitPos(key string, bit int64, pos ...int64) *IntCmd\n-\tBitField(key string, args ...interface{}) *IntSliceCmd\n-\tDecr(key string) *IntCmd\n-\tDecrBy(key string, decrement int64) *IntCmd\n-\tGet(key string) *StringCmd\n-\tGetBit(key string, offset int64) *IntCmd\n-\tGetRange(key string, start, end int64) *StringCmd\n-\tGetSet(key string, value interface{}) *StringCmd\n-\tIncr(key string) *IntCmd\n-\tIncrBy(key string, value int64) *IntCmd\n-\tIncrByFloat(key string, value float64) *FloatCmd\n-\tMGet(keys ...string) *SliceCmd\n-\tMSet(values ...interface{}) *StatusCmd\n-\tMSetNX(values ...interface{}) *BoolCmd\n-\tSet(key string, value interface{}, expiration time.Duration) *StatusCmd\n-\tSetBit(key string, offset int64, value int) *IntCmd\n-\tSetNX(key string, value interface{}, expiration time.Duration) *BoolCmd\n-\tSetXX(key string, value interface{}, expiration time.Duration) *BoolCmd\n-\tSetRange(key string, offset int64, value string) *IntCmd\n-\tStrLen(key string) *IntCmd\n-\tHDel(key string, fields ...string) *IntCmd\n-\tHExists(key, field string) *BoolCmd\n-\tHGet(key, field string) *StringCmd\n-\tHGetAll(key string) *StringStringMapCmd\n-\tHIncrBy(key, field string, incr int64) *IntCmd\n-\tHIncrByFloat(key, field string, incr float64) *FloatCmd\n-\tHKeys(key string) *StringSliceCmd\n-\tHLen(key string) *IntCmd\n-\tHMGet(key string, fields ...string) *SliceCmd\n-\tHSet(key string, values ...interface{}) *IntCmd\n-\tHMSet(key string, values ...interface{}) *BoolCmd\n-\tHSetNX(key, field string, value interface{}) *BoolCmd\n-\tHVals(key string) *StringSliceCmd\n-\tBLPop(timeout time.Duration, keys ...string) *StringSliceCmd\n-\tBRPop(timeout time.Duration, keys ...string) *StringSliceCmd\n-\tBRPopLPush(source, destination string, timeout time.Duration) *StringCmd\n-\tLIndex(key string, index int64) *StringCmd\n-\tLInsert(key, op string, pivot, value interface{}) *IntCmd\n-\tLInsertBefore(key string, pivot, value interface{}) *IntCmd\n-\tLInsertAfter(key string, pivot, value interface{}) *IntCmd\n-\tLLen(key string) *IntCmd\n-\tLPop(key string) *StringCmd\n-\tLPush(key string, values ...interface{}) *IntCmd\n-\tLPushX(key string, values ...interface{}) *IntCmd\n-\tLRange(key string, start, stop int64) *StringSliceCmd\n-\tLRem(key string, count int64, value interface{}) *IntCmd\n-\tLSet(key string, index int64, value interface{}) *StatusCmd\n-\tLTrim(key string, start, stop int64) *StatusCmd\n-\tRPop(key string) *StringCmd\n-\tRPopLPush(source, destination string) *StringCmd\n-\tRPush(key string, values ...interface{}) *IntCmd\n-\tRPushX(key string, values ...interface{}) *IntCmd\n-\tSAdd(key string, members ...interface{}) *IntCmd\n-\tSCard(key string) *IntCmd\n-\tSDiff(keys ...string) *StringSliceCmd\n-\tSDiffStore(destination string, keys ...string) *IntCmd\n-\tSInter(keys ...string) *StringSliceCmd\n-\tSInterStore(destination string, keys ...string) *IntCmd\n-\tSIsMember(key string, member interface{}) *BoolCmd\n-\tSMembers(key string) *StringSliceCmd\n-\tSMembersMap(key string) *StringStructMapCmd\n-\tSMove(source, destination string, member interface{}) *BoolCmd\n-\tSPop(key string) *StringCmd\n-\tSPopN(key string, count int64) *StringSliceCmd\n-\tSRandMember(key string) *StringCmd\n-\tSRandMemberN(key string, count int64) *StringSliceCmd\n-\tSRem(key string, members ...interface{}) *IntCmd\n-\tSUnion(keys ...string) *StringSliceCmd\n-\tSUnionStore(destination string, keys ...string) *IntCmd\n-\tXAdd(a *XAddArgs) *StringCmd\n-\tXDel(stream string, ids ...string) *IntCmd\n-\tXLen(stream string) *IntCmd\n-\tXRange(stream, start, stop string) *XMessageSliceCmd\n-\tXRangeN(stream, start, stop string, count int64) *XMessageSliceCmd\n-\tXRevRange(stream string, start, stop string) *XMessageSliceCmd\n-\tXRevRangeN(stream string, start, stop string, count int64) *XMessageSliceCmd\n-\tXRead(a *XReadArgs) *XStreamSliceCmd\n-\tXReadStreams(streams ...string) *XStreamSliceCmd\n-\tXGroupCreate(stream, group, start string) *StatusCmd\n-\tXGroupCreateMkStream(stream, group, start string) *StatusCmd\n-\tXGroupSetID(stream, group, start string) *StatusCmd\n-\tXGroupDestroy(stream, group string) *IntCmd\n-\tXGroupDelConsumer(stream, group, consumer string) *IntCmd\n-\tXReadGroup(a *XReadGroupArgs) *XStreamSliceCmd\n-\tXAck(stream, group string, ids ...string) *IntCmd\n-\tXPending(stream, group string) *XPendingCmd\n-\tXPendingExt(a *XPendingExtArgs) *XPendingExtCmd\n-\tXClaim(a *XClaimArgs) *XMessageSliceCmd\n-\tXClaimJustID(a *XClaimArgs) *StringSliceCmd\n-\tXTrim(key string, maxLen int64) *IntCmd\n-\tXTrimApprox(key string, maxLen int64) *IntCmd\n-\tXInfoGroups(key string) *XInfoGroupsCmd\n-\tBZPopMax(timeout time.Duration, keys ...string) *ZWithKeyCmd\n-\tBZPopMin(timeout time.Duration, keys ...string) *ZWithKeyCmd\n-\tZAdd(key string, members ...*Z) *IntCmd\n-\tZAddNX(key string, members ...*Z) *IntCmd\n-\tZAddXX(key string, members ...*Z) *IntCmd\n-\tZAddCh(key string, members ...*Z) *IntCmd\n-\tZAddNXCh(key string, members ...*Z) *IntCmd\n-\tZAddXXCh(key string, members ...*Z) *IntCmd\n-\tZIncr(key string, member *Z) *FloatCmd\n-\tZIncrNX(key string, member *Z) *FloatCmd\n-\tZIncrXX(key string, member *Z) *FloatCmd\n-\tZCard(key string) *IntCmd\n-\tZCount(key, min, max string) *IntCmd\n-\tZLexCount(key, min, max string) *IntCmd\n-\tZIncrBy(key string, increment float64, member string) *FloatCmd\n-\tZInterStore(destination string, store *ZStore) *IntCmd\n-\tZPopMax(key string, count ...int64) *ZSliceCmd\n-\tZPopMin(key string, count ...int64) *ZSliceCmd\n-\tZRange(key string, start, stop int64) *StringSliceCmd\n-\tZRangeWithScores(key string, start, stop int64) *ZSliceCmd\n-\tZRangeByScore(key string, opt *ZRangeBy) *StringSliceCmd\n-\tZRangeByLex(key string, opt *ZRangeBy) *StringSliceCmd\n-\tZRangeByScoreWithScores(key string, opt *ZRangeBy) *ZSliceCmd\n-\tZRank(key, member string) *IntCmd\n-\tZRem(key string, members ...interface{}) *IntCmd\n-\tZRemRangeByRank(key string, start, stop int64) *IntCmd\n-\tZRemRangeByScore(key, min, max string) *IntCmd\n-\tZRemRangeByLex(key, min, max string) *IntCmd\n-\tZRevRange(key string, start, stop int64) *StringSliceCmd\n-\tZRevRangeWithScores(key string, start, stop int64) *ZSliceCmd\n-\tZRevRangeByScore(key string, opt *ZRangeBy) *StringSliceCmd\n-\tZRevRangeByLex(key string, opt *ZRangeBy) *StringSliceCmd\n-\tZRevRangeByScoreWithScores(key string, opt *ZRangeBy) *ZSliceCmd\n-\tZRevRank(key, member string) *IntCmd\n-\tZScore(key, member string) *FloatCmd\n-\tZUnionStore(dest string, store *ZStore) *IntCmd\n-\tPFAdd(key string, els ...interface{}) *IntCmd\n-\tPFCount(keys ...string) *IntCmd\n-\tPFMerge(dest string, keys ...string) *StatusCmd\n-\tBgRewriteAOF() *StatusCmd\n-\tBgSave() *StatusCmd\n-\tClientKill(ipPort string) *StatusCmd\n-\tClientKillByFilter(keys ...string) *IntCmd\n-\tClientList() *StringCmd\n-\tClientPause(dur time.Duration) *BoolCmd\n-\tClientID() *IntCmd\n-\tConfigGet(parameter string) *SliceCmd\n-\tConfigResetStat() *StatusCmd\n-\tConfigSet(parameter, value string) *StatusCmd\n-\tConfigRewrite() *StatusCmd\n-\tDBSize() *IntCmd\n-\tFlushAll() *StatusCmd\n-\tFlushAllAsync() *StatusCmd\n-\tFlushDB() *StatusCmd\n-\tFlushDBAsync() *StatusCmd\n-\tInfo(section ...string) *StringCmd\n-\tLastSave() *IntCmd\n-\tSave() *StatusCmd\n-\tShutdown() *StatusCmd\n-\tShutdownSave() *StatusCmd\n-\tShutdownNoSave() *StatusCmd\n-\tSlaveOf(host, port string) *StatusCmd\n-\tTime() *TimeCmd\n-\tEval(script string, keys []string, args ...interface{}) *Cmd\n-\tEvalSha(sha1 string, keys []string, args ...interface{}) *Cmd\n-\tScriptExists(hashes ...string) *BoolSliceCmd\n-\tScriptFlush() *StatusCmd\n-\tScriptKill() *StatusCmd\n-\tScriptLoad(script string) *StringCmd\n-\tDebugObject(key string) *StringCmd\n-\tPublish(channel string, message interface{}) *IntCmd\n-\tPubSubChannels(pattern string) *StringSliceCmd\n-\tPubSubNumSub(channels ...string) *StringIntMapCmd\n-\tPubSubNumPat() *IntCmd\n-\tClusterSlots() *ClusterSlotsCmd\n-\tClusterNodes() *StringCmd\n-\tClusterMeet(host, port string) *StatusCmd\n-\tClusterForget(nodeID string) *StatusCmd\n-\tClusterReplicate(nodeID string) *StatusCmd\n-\tClusterResetSoft() *StatusCmd\n-\tClusterResetHard() *StatusCmd\n-\tClusterInfo() *StringCmd\n-\tClusterKeySlot(key string) *IntCmd\n-\tClusterGetKeysInSlot(slot int, count int) *StringSliceCmd\n-\tClusterCountFailureReports(nodeID string) *IntCmd\n-\tClusterCountKeysInSlot(slot int) *IntCmd\n-\tClusterDelSlots(slots ...int) *StatusCmd\n-\tClusterDelSlotsRange(min, max int) *StatusCmd\n-\tClusterSaveConfig() *StatusCmd\n-\tClusterSlaves(nodeID string) *StringSliceCmd\n-\tClusterFailover() *StatusCmd\n-\tClusterAddSlots(slots ...int) *StatusCmd\n-\tClusterAddSlotsRange(min, max int) *StatusCmd\n-\tGeoAdd(key string, geoLocation ...*GeoLocation) *IntCmd\n-\tGeoPos(key string, members ...string) *GeoPosCmd\n-\tGeoRadius(key string, longitude, latitude float64, query *GeoRadiusQuery) *GeoLocationCmd\n-\tGeoRadiusStore(key string, longitude, latitude float64, query *GeoRadiusQuery) *IntCmd\n-\tGeoRadiusByMember(key, member string, query *GeoRadiusQuery) *GeoLocationCmd\n-\tGeoRadiusByMemberStore(key, member string, query *GeoRadiusQuery) *IntCmd\n-\tGeoDist(key string, member1, member2, unit string) *FloatCmd\n-\tGeoHash(key string, members ...string) *StringSliceCmd\n-\tReadOnly() *StatusCmd\n-\tReadWrite() *StatusCmd\n-\tMemoryUsage(key string, samples ...int) *IntCmd\n-}\n-\n-type StatefulCmdable interface {\n-\tCmdable\n-\tAuth(password string) *StatusCmd\n-\tAuthACL(username, password string) *StatusCmd\n-\tSelect(index int) *StatusCmd\n-\tSwapDB(index1, index2 int) *StatusCmd\n-\tClientSetName(name string) *BoolCmd\n-}\n-\n-var _ Cmdable = (*Client)(nil)\n-var _ Cmdable = (*Tx)(nil)\n-var _ Cmdable = (*Ring)(nil)\n-var _ Cmdable = (*ClusterClient)(nil)\n-\n-type cmdable func(cmd Cmder) error\n-\n-type statefulCmdable func(cmd Cmder) error\n-\n-//------------------------------------------------------------------------------\n-\n-func (c statefulCmdable) Auth(password string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"auth\", password)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Perform an AUTH command, using the given user and pass.\n-// Should be used to authenticate the current connection with one of the connections defined in the ACL list\n-// when connecting to a Redis 6.0 instance, or greater, that is using the Redis ACL system.\n-func (c statefulCmdable) AuthACL(username, password string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"auth\", username, password)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Echo(message interface{}) *StringCmd {\n-\tcmd := NewStringCmd(\"echo\", message)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Ping() *StatusCmd {\n-\tcmd := NewStatusCmd(\"ping\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Wait(numSlaves int, timeout time.Duration) *IntCmd {\n-\tcmd := NewIntCmd(\"wait\", numSlaves, int(timeout/time.Millisecond))\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Quit() *StatusCmd {\n-\tpanic(\"not implemented\")\n-}\n-\n-func (c statefulCmdable) Select(index int) *StatusCmd {\n-\tcmd := NewStatusCmd(\"select\", index)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c statefulCmdable) SwapDB(index1, index2 int) *StatusCmd {\n-\tcmd := NewStatusCmd(\"swapdb\", index1, index2)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) Command() *CommandsInfoCmd {\n-\tcmd := NewCommandsInfoCmd(\"command\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Del(keys ...string) *IntCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"del\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Unlink(keys ...string) *IntCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"unlink\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Dump(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"dump\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Exists(keys ...string) *IntCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"exists\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Expire(key string, expiration time.Duration) *BoolCmd {\n-\tcmd := NewBoolCmd(\"expire\", key, formatSec(expiration))\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ExpireAt(key string, tm time.Time) *BoolCmd {\n-\tcmd := NewBoolCmd(\"expireat\", key, tm.Unix())\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Keys(pattern string) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"keys\", pattern)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Migrate(host, port, key string, db int, timeout time.Duration) *StatusCmd {\n-\tcmd := NewStatusCmd(\n-\t\t\"migrate\",\n-\t\thost,\n-\t\tport,\n-\t\tkey,\n-\t\tdb,\n-\t\tformatMs(timeout),\n-\t)\n-\tcmd.setReadTimeout(timeout)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Move(key string, db int) *BoolCmd {\n-\tcmd := NewBoolCmd(\"move\", key, db)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ObjectRefCount(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"object\", \"refcount\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ObjectEncoding(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"object\", \"encoding\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ObjectIdleTime(key string) *DurationCmd {\n-\tcmd := NewDurationCmd(time.Second, \"object\", \"idletime\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Persist(key string) *BoolCmd {\n-\tcmd := NewBoolCmd(\"persist\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PExpire(key string, expiration time.Duration) *BoolCmd {\n-\tcmd := NewBoolCmd(\"pexpire\", key, formatMs(expiration))\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PExpireAt(key string, tm time.Time) *BoolCmd {\n-\tcmd := NewBoolCmd(\n-\t\t\"pexpireat\",\n-\t\tkey,\n-\t\ttm.UnixNano()/int64(time.Millisecond),\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PTTL(key string) *DurationCmd {\n-\tcmd := NewDurationCmd(time.Millisecond, \"pttl\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RandomKey() *StringCmd {\n-\tcmd := NewStringCmd(\"randomkey\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Rename(key, newkey string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"rename\", key, newkey)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RenameNX(key, newkey string) *BoolCmd {\n-\tcmd := NewBoolCmd(\"renamenx\", key, newkey)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Restore(key string, ttl time.Duration, value string) *StatusCmd {\n-\tcmd := NewStatusCmd(\n-\t\t\"restore\",\n-\t\tkey,\n-\t\tformatMs(ttl),\n-\t\tvalue,\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RestoreReplace(key string, ttl time.Duration, value string) *StatusCmd {\n-\tcmd := NewStatusCmd(\n-\t\t\"restore\",\n-\t\tkey,\n-\t\tformatMs(ttl),\n-\t\tvalue,\n-\t\t\"replace\",\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type Sort struct {\n-\tBy            string\n-\tOffset, Count int64\n-\tGet           []string\n-\tOrder         string\n-\tAlpha         bool\n-}\n-\n-func (sort *Sort) args(key string) []interface{} {\n-\targs := []interface{}{\"sort\", key}\n-\tif sort.By != \"\" {\n-\t\targs = append(args, \"by\", sort.By)\n-\t}\n-\tif sort.Offset != 0 || sort.Count != 0 {\n-\t\targs = append(args, \"limit\", sort.Offset, sort.Count)\n-\t}\n-\tfor _, get := range sort.Get {\n-\t\targs = append(args, \"get\", get)\n-\t}\n-\tif sort.Order != \"\" {\n-\t\targs = append(args, sort.Order)\n-\t}\n-\tif sort.Alpha {\n-\t\targs = append(args, \"alpha\")\n-\t}\n-\treturn args\n-}\n-\n-func (c cmdable) Sort(key string, sort *Sort) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(sort.args(key)...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SortStore(key, store string, sort *Sort) *IntCmd {\n-\targs := sort.args(key)\n-\tif store != \"\" {\n-\t\targs = append(args, \"store\", store)\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SortInterfaces(key string, sort *Sort) *SliceCmd {\n-\tcmd := NewSliceCmd(sort.args(key)...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Touch(keys ...string) *IntCmd {\n-\targs := make([]interface{}, len(keys)+1)\n-\targs[0] = \"touch\"\n-\tfor i, key := range keys {\n-\t\targs[i+1] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) TTL(key string) *DurationCmd {\n-\tcmd := NewDurationCmd(time.Second, \"ttl\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Type(key string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"type\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Scan(cursor uint64, match string, count int64) *ScanCmd {\n-\targs := []interface{}{\"scan\", cursor}\n-\tif match != \"\" {\n-\t\targs = append(args, \"match\", match)\n-\t}\n-\tif count > 0 {\n-\t\targs = append(args, \"count\", count)\n-\t}\n-\tcmd := NewScanCmd(c, args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SScan(key string, cursor uint64, match string, count int64) *ScanCmd {\n-\targs := []interface{}{\"sscan\", key, cursor}\n-\tif match != \"\" {\n-\t\targs = append(args, \"match\", match)\n-\t}\n-\tif count > 0 {\n-\t\targs = append(args, \"count\", count)\n-\t}\n-\tcmd := NewScanCmd(c, args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HScan(key string, cursor uint64, match string, count int64) *ScanCmd {\n-\targs := []interface{}{\"hscan\", key, cursor}\n-\tif match != \"\" {\n-\t\targs = append(args, \"match\", match)\n-\t}\n-\tif count > 0 {\n-\t\targs = append(args, \"count\", count)\n-\t}\n-\tcmd := NewScanCmd(c, args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZScan(key string, cursor uint64, match string, count int64) *ScanCmd {\n-\targs := []interface{}{\"zscan\", key, cursor}\n-\tif match != \"\" {\n-\t\targs = append(args, \"match\", match)\n-\t}\n-\tif count > 0 {\n-\t\targs = append(args, \"count\", count)\n-\t}\n-\tcmd := NewScanCmd(c, args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) Append(key, value string) *IntCmd {\n-\tcmd := NewIntCmd(\"append\", key, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type BitCount struct {\n-\tStart, End int64\n-}\n-\n-func (c cmdable) BitCount(key string, bitCount *BitCount) *IntCmd {\n-\targs := []interface{}{\"bitcount\", key}\n-\tif bitCount != nil {\n-\t\targs = append(\n-\t\t\targs,\n-\t\t\tbitCount.Start,\n-\t\t\tbitCount.End,\n-\t\t)\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) bitOp(op, destKey string, keys ...string) *IntCmd {\n-\targs := make([]interface{}, 3+len(keys))\n-\targs[0] = \"bitop\"\n-\targs[1] = op\n-\targs[2] = destKey\n-\tfor i, key := range keys {\n-\t\targs[3+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) BitOpAnd(destKey string, keys ...string) *IntCmd {\n-\treturn c.bitOp(\"and\", destKey, keys...)\n-}\n-\n-func (c cmdable) BitOpOr(destKey string, keys ...string) *IntCmd {\n-\treturn c.bitOp(\"or\", destKey, keys...)\n-}\n-\n-func (c cmdable) BitOpXor(destKey string, keys ...string) *IntCmd {\n-\treturn c.bitOp(\"xor\", destKey, keys...)\n-}\n-\n-func (c cmdable) BitOpNot(destKey string, key string) *IntCmd {\n-\treturn c.bitOp(\"not\", destKey, key)\n-}\n-\n-func (c cmdable) BitPos(key string, bit int64, pos ...int64) *IntCmd {\n-\targs := make([]interface{}, 3+len(pos))\n-\targs[0] = \"bitpos\"\n-\targs[1] = key\n-\targs[2] = bit\n-\tswitch len(pos) {\n-\tcase 0:\n-\tcase 1:\n-\t\targs[3] = pos[0]\n-\tcase 2:\n-\t\targs[3] = pos[0]\n-\t\targs[4] = pos[1]\n-\tdefault:\n-\t\tpanic(\"too many arguments\")\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) BitField(key string, args ...interface{}) *IntSliceCmd {\n-\ta := make([]interface{}, 0, 2+len(args))\n-\ta = append(a, \"bitfield\")\n-\ta = append(a, key)\n-\ta = append(a, args...)\n-\tcmd := NewIntSliceCmd(a...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Decr(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"decr\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) DecrBy(key string, decrement int64) *IntCmd {\n-\tcmd := NewIntCmd(\"decrby\", key, decrement)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `GET key` command. It returns redis.Nil error when key does not exist.\n-func (c cmdable) Get(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"get\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) GetBit(key string, offset int64) *IntCmd {\n-\tcmd := NewIntCmd(\"getbit\", key, offset)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) GetRange(key string, start, end int64) *StringCmd {\n-\tcmd := NewStringCmd(\"getrange\", key, start, end)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) GetSet(key string, value interface{}) *StringCmd {\n-\tcmd := NewStringCmd(\"getset\", key, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Incr(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"incr\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) IncrBy(key string, value int64) *IntCmd {\n-\tcmd := NewIntCmd(\"incrby\", key, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) IncrByFloat(key string, value float64) *FloatCmd {\n-\tcmd := NewFloatCmd(\"incrbyfloat\", key, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) MGet(keys ...string) *SliceCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"mget\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// MSet is like Set but accepts multiple values:\n-//   - MSet(\"key1\", \"value1\", \"key2\", \"value2\")\n-//   - MSet([]string{\"key1\", \"value1\", \"key2\", \"value2\"})\n-//   - MSet(map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"})\n-func (c cmdable) MSet(values ...interface{}) *StatusCmd {\n-\targs := make([]interface{}, 1, 1+len(values))\n-\targs[0] = \"mset\"\n-\targs = appendArgs(args, values)\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// MSetNX is like SetNX but accepts multiple values:\n-//   - MSetNX(\"key1\", \"value1\", \"key2\", \"value2\")\n-//   - MSetNX([]string{\"key1\", \"value1\", \"key2\", \"value2\"})\n-//   - MSetNX(map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"})\n-func (c cmdable) MSetNX(values ...interface{}) *BoolCmd {\n-\targs := make([]interface{}, 1, 1+len(values))\n-\targs[0] = \"msetnx\"\n-\targs = appendArgs(args, values)\n-\tcmd := NewBoolCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SET key value [expiration]` command.\n-//\n-// Use expiration for `SETEX`-like behavior.\n-// Zero expiration means the key has no expiration time.\n-func (c cmdable) Set(key string, value interface{}, expiration time.Duration) *StatusCmd {\n-\targs := make([]interface{}, 3, 5)\n-\targs[0] = \"set\"\n-\targs[1] = key\n-\targs[2] = value\n-\tif expiration > 0 {\n-\t\tif usePrecise(expiration) {\n-\t\t\targs = append(args, \"px\", formatMs(expiration))\n-\t\t} else {\n-\t\t\targs = append(args, \"ex\", formatSec(expiration))\n-\t\t}\n-\t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SetBit(key string, offset int64, value int) *IntCmd {\n-\tcmd := NewIntCmd(\n-\t\t\"setbit\",\n-\t\tkey,\n-\t\toffset,\n-\t\tvalue,\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SET key value [expiration] NX` command.\n-//\n-// Zero expiration means the key has no expiration time.\n-func (c cmdable) SetNX(key string, value interface{}, expiration time.Duration) *BoolCmd {\n-\tvar cmd *BoolCmd\n-\tif expiration == 0 {\n-\t\t// Use old `SETNX` to support old Redis versions.\n-\t\tcmd = NewBoolCmd(\"setnx\", key, value)\n-\t} else {\n-\t\tif usePrecise(expiration) {\n-\t\t\tcmd = NewBoolCmd(\"set\", key, value, \"px\", formatMs(expiration), \"nx\")\n-\t\t} else {\n-\t\t\tcmd = NewBoolCmd(\"set\", key, value, \"ex\", formatSec(expiration), \"nx\")\n-\t\t}\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SET key value [expiration] XX` command.\n-//\n-// Zero expiration means the key has no expiration time.\n-func (c cmdable) SetXX(key string, value interface{}, expiration time.Duration) *BoolCmd {\n-\tvar cmd *BoolCmd\n-\tif expiration == 0 {\n-\t\tcmd = NewBoolCmd(\"set\", key, value, \"xx\")\n-\t} else {\n-\t\tif usePrecise(expiration) {\n-\t\t\tcmd = NewBoolCmd(\"set\", key, value, \"px\", formatMs(expiration), \"xx\")\n-\t\t} else {\n-\t\t\tcmd = NewBoolCmd(\"set\", key, value, \"ex\", formatSec(expiration), \"xx\")\n-\t\t}\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SetRange(key string, offset int64, value string) *IntCmd {\n-\tcmd := NewIntCmd(\"setrange\", key, offset, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) StrLen(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"strlen\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) HDel(key string, fields ...string) *IntCmd {\n-\targs := make([]interface{}, 2+len(fields))\n-\targs[0] = \"hdel\"\n-\targs[1] = key\n-\tfor i, field := range fields {\n-\t\targs[2+i] = field\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HExists(key, field string) *BoolCmd {\n-\tcmd := NewBoolCmd(\"hexists\", key, field)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HGet(key, field string) *StringCmd {\n-\tcmd := NewStringCmd(\"hget\", key, field)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HGetAll(key string) *StringStringMapCmd {\n-\tcmd := NewStringStringMapCmd(\"hgetall\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HIncrBy(key, field string, incr int64) *IntCmd {\n-\tcmd := NewIntCmd(\"hincrby\", key, field, incr)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HIncrByFloat(key, field string, incr float64) *FloatCmd {\n-\tcmd := NewFloatCmd(\"hincrbyfloat\", key, field, incr)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HKeys(key string) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"hkeys\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HLen(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"hlen\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// HMGet returns the values for the specified fields in the hash stored at key.\n-// It returns an interface{} to distinguish between empty string and nil value.\n-func (c cmdable) HMGet(key string, fields ...string) *SliceCmd {\n-\targs := make([]interface{}, 2+len(fields))\n-\targs[0] = \"hmget\"\n-\targs[1] = key\n-\tfor i, field := range fields {\n-\t\targs[2+i] = field\n-\t}\n-\tcmd := NewSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// HSet accepts values in following formats:\n-//   - HMSet(\"myhash\", \"key1\", \"value1\", \"key2\", \"value2\")\n-//   - HMSet(\"myhash\", []string{\"key1\", \"value1\", \"key2\", \"value2\"})\n-//   - HMSet(\"myhash\", map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"})\n-//\n-// Note that it requires Redis v4 for multiple field/value pairs support.\n-func (c cmdable) HSet(key string, values ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(values))\n-\targs[0] = \"hset\"\n-\targs[1] = key\n-\targs = appendArgs(args, values)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// HMSet is a deprecated version of HSet left for compatibility with Redis 3.\n-func (c cmdable) HMSet(key string, values ...interface{}) *BoolCmd {\n-\targs := make([]interface{}, 2, 2+len(values))\n-\targs[0] = \"hmset\"\n-\targs[1] = key\n-\targs = appendArgs(args, values)\n-\tcmd := NewBoolCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HSetNX(key, field string, value interface{}) *BoolCmd {\n-\tcmd := NewBoolCmd(\"hsetnx\", key, field, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) HVals(key string) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"hvals\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) BLPop(timeout time.Duration, keys ...string) *StringSliceCmd {\n-\targs := make([]interface{}, 1+len(keys)+1)\n-\targs[0] = \"blpop\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\targs[len(args)-1] = formatSec(timeout)\n-\tcmd := NewStringSliceCmd(args...)\n-\tcmd.setReadTimeout(timeout)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) BRPop(timeout time.Duration, keys ...string) *StringSliceCmd {\n-\targs := make([]interface{}, 1+len(keys)+1)\n-\targs[0] = \"brpop\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\targs[len(keys)+1] = formatSec(timeout)\n-\tcmd := NewStringSliceCmd(args...)\n-\tcmd.setReadTimeout(timeout)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) BRPopLPush(source, destination string, timeout time.Duration) *StringCmd {\n-\tcmd := NewStringCmd(\n-\t\t\"brpoplpush\",\n-\t\tsource,\n-\t\tdestination,\n-\t\tformatSec(timeout),\n-\t)\n-\tcmd.setReadTimeout(timeout)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LIndex(key string, index int64) *StringCmd {\n-\tcmd := NewStringCmd(\"lindex\", key, index)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LInsert(key, op string, pivot, value interface{}) *IntCmd {\n-\tcmd := NewIntCmd(\"linsert\", key, op, pivot, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LInsertBefore(key string, pivot, value interface{}) *IntCmd {\n-\tcmd := NewIntCmd(\"linsert\", key, \"before\", pivot, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LInsertAfter(key string, pivot, value interface{}) *IntCmd {\n-\tcmd := NewIntCmd(\"linsert\", key, \"after\", pivot, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LLen(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"llen\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LPop(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"lpop\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LPush(key string, values ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(values))\n-\targs[0] = \"lpush\"\n-\targs[1] = key\n-\targs = appendArgs(args, values)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LPushX(key string, values ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(values))\n-\targs[0] = \"lpushx\"\n-\targs[1] = key\n-\targs = appendArgs(args, values)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LRange(key string, start, stop int64) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\n-\t\t\"lrange\",\n-\t\tkey,\n-\t\tstart,\n-\t\tstop,\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LRem(key string, count int64, value interface{}) *IntCmd {\n-\tcmd := NewIntCmd(\"lrem\", key, count, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LSet(key string, index int64, value interface{}) *StatusCmd {\n-\tcmd := NewStatusCmd(\"lset\", key, index, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LTrim(key string, start, stop int64) *StatusCmd {\n-\tcmd := NewStatusCmd(\n-\t\t\"ltrim\",\n-\t\tkey,\n-\t\tstart,\n-\t\tstop,\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RPop(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"rpop\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RPopLPush(source, destination string) *StringCmd {\n-\tcmd := NewStringCmd(\"rpoplpush\", source, destination)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RPush(key string, values ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(values))\n-\targs[0] = \"rpush\"\n-\targs[1] = key\n-\targs = appendArgs(args, values)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) RPushX(key string, values ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(values))\n-\targs[0] = \"rpushx\"\n-\targs[1] = key\n-\targs = appendArgs(args, values)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) SAdd(key string, members ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(members))\n-\targs[0] = \"sadd\"\n-\targs[1] = key\n-\targs = appendArgs(args, members)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SCard(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"scard\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SDiff(keys ...string) *StringSliceCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"sdiff\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SDiffStore(destination string, keys ...string) *IntCmd {\n-\targs := make([]interface{}, 2+len(keys))\n-\targs[0] = \"sdiffstore\"\n-\targs[1] = destination\n-\tfor i, key := range keys {\n-\t\targs[2+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SInter(keys ...string) *StringSliceCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"sinter\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SInterStore(destination string, keys ...string) *IntCmd {\n-\targs := make([]interface{}, 2+len(keys))\n-\targs[0] = \"sinterstore\"\n-\targs[1] = destination\n-\tfor i, key := range keys {\n-\t\targs[2+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SIsMember(key string, member interface{}) *BoolCmd {\n-\tcmd := NewBoolCmd(\"sismember\", key, member)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SMEMBERS key` command output as a slice\n-func (c cmdable) SMembers(key string) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"smembers\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SMEMBERS key` command output as a map\n-func (c cmdable) SMembersMap(key string) *StringStructMapCmd {\n-\tcmd := NewStringStructMapCmd(\"smembers\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SMove(source, destination string, member interface{}) *BoolCmd {\n-\tcmd := NewBoolCmd(\"smove\", source, destination, member)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SPOP key` command.\n-func (c cmdable) SPop(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"spop\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SPOP key count` command.\n-func (c cmdable) SPopN(key string, count int64) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"spop\", key, count)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SRANDMEMBER key` command.\n-func (c cmdable) SRandMember(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"srandmember\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `SRANDMEMBER key count` command.\n-func (c cmdable) SRandMemberN(key string, count int64) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"srandmember\", key, count)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SRem(key string, members ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(members))\n-\targs[0] = \"srem\"\n-\targs[1] = key\n-\targs = appendArgs(args, members)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SUnion(keys ...string) *StringSliceCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"sunion\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SUnionStore(destination string, keys ...string) *IntCmd {\n-\targs := make([]interface{}, 2+len(keys))\n-\targs[0] = \"sunionstore\"\n-\targs[1] = destination\n-\tfor i, key := range keys {\n-\t\targs[2+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type XAddArgs struct {\n-\tStream       string\n-\tMaxLen       int64 // MAXLEN N\n-\tMaxLenApprox int64 // MAXLEN ~ N\n-\tID           string\n-\tValues       map[string]interface{}\n-}\n-\n-func (c cmdable) XAdd(a *XAddArgs) *StringCmd {\n-\targs := make([]interface{}, 0, 6+len(a.Values)*2)\n-\targs = append(args, \"xadd\")\n-\targs = append(args, a.Stream)\n-\tif a.MaxLen > 0 {\n-\t\targs = append(args, \"maxlen\", a.MaxLen)\n-\t} else if a.MaxLenApprox > 0 {\n-\t\targs = append(args, \"maxlen\", \"~\", a.MaxLenApprox)\n-\t}\n-\tif a.ID != \"\" {\n-\t\targs = append(args, a.ID)\n-\t} else {\n-\t\targs = append(args, \"*\")\n-\t}\n-\tfor k, v := range a.Values {\n-\t\targs = append(args, k)\n-\t\targs = append(args, v)\n-\t}\n-\n-\tcmd := NewStringCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XDel(stream string, ids ...string) *IntCmd {\n-\targs := []interface{}{\"xdel\", stream}\n-\tfor _, id := range ids {\n-\t\targs = append(args, id)\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XLen(stream string) *IntCmd {\n-\tcmd := NewIntCmd(\"xlen\", stream)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XRange(stream, start, stop string) *XMessageSliceCmd {\n-\tcmd := NewXMessageSliceCmd(\"xrange\", stream, start, stop)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XRangeN(stream, start, stop string, count int64) *XMessageSliceCmd {\n-\tcmd := NewXMessageSliceCmd(\"xrange\", stream, start, stop, \"count\", count)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XRevRange(stream, start, stop string) *XMessageSliceCmd {\n-\tcmd := NewXMessageSliceCmd(\"xrevrange\", stream, start, stop)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XRevRangeN(stream, start, stop string, count int64) *XMessageSliceCmd {\n-\tcmd := NewXMessageSliceCmd(\"xrevrange\", stream, start, stop, \"count\", count)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type XReadArgs struct {\n-\tStreams []string // list of streams and ids, e.g. stream1 stream2 id1 id2\n-\tCount   int64\n-\tBlock   time.Duration\n-}\n-\n-func (c cmdable) XRead(a *XReadArgs) *XStreamSliceCmd {\n-\targs := make([]interface{}, 0, 5+len(a.Streams))\n-\targs = append(args, \"xread\")\n-\tif a.Count > 0 {\n-\t\targs = append(args, \"count\")\n-\t\targs = append(args, a.Count)\n-\t}\n-\tif a.Block >= 0 {\n-\t\targs = append(args, \"block\")\n-\t\targs = append(args, int64(a.Block/time.Millisecond))\n-\t}\n-\n-\targs = append(args, \"streams\")\n-\tfor _, s := range a.Streams {\n-\t\targs = append(args, s)\n-\t}\n-\n-\tcmd := NewXStreamSliceCmd(args...)\n-\tif a.Block >= 0 {\n-\t\tcmd.setReadTimeout(a.Block)\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XReadStreams(streams ...string) *XStreamSliceCmd {\n-\treturn c.XRead(&XReadArgs{\n-\t\tStreams: streams,\n-\t\tBlock:   -1,\n-\t})\n-}\n-\n-func (c cmdable) XGroupCreate(stream, group, start string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"xgroup\", \"create\", stream, group, start)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XGroupCreateMkStream(stream, group, start string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"xgroup\", \"create\", stream, group, start, \"mkstream\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XGroupSetID(stream, group, start string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"xgroup\", \"setid\", stream, group, start)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XGroupDestroy(stream, group string) *IntCmd {\n-\tcmd := NewIntCmd(\"xgroup\", \"destroy\", stream, group)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XGroupDelConsumer(stream, group, consumer string) *IntCmd {\n-\tcmd := NewIntCmd(\"xgroup\", \"delconsumer\", stream, group, consumer)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type XReadGroupArgs struct {\n-\tGroup    string\n-\tConsumer string\n-\tStreams  []string // list of streams and ids, e.g. stream1 stream2 id1 id2\n-\tCount    int64\n-\tBlock    time.Duration\n-\tNoAck    bool\n-}\n-\n-func (c cmdable) XReadGroup(a *XReadGroupArgs) *XStreamSliceCmd {\n-\targs := make([]interface{}, 0, 8+len(a.Streams))\n-\targs = append(args, \"xreadgroup\", \"group\", a.Group, a.Consumer)\n-\tif a.Count > 0 {\n-\t\targs = append(args, \"count\", a.Count)\n-\t}\n-\tif a.Block >= 0 {\n-\t\targs = append(args, \"block\", int64(a.Block/time.Millisecond))\n-\t}\n-\tif a.NoAck {\n-\t\targs = append(args, \"noack\")\n-\t}\n-\targs = append(args, \"streams\")\n-\tfor _, s := range a.Streams {\n-\t\targs = append(args, s)\n-\t}\n-\n-\tcmd := NewXStreamSliceCmd(args...)\n-\tif a.Block >= 0 {\n-\t\tcmd.setReadTimeout(a.Block)\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XAck(stream, group string, ids ...string) *IntCmd {\n-\targs := []interface{}{\"xack\", stream, group}\n-\tfor _, id := range ids {\n-\t\targs = append(args, id)\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XPending(stream, group string) *XPendingCmd {\n-\tcmd := NewXPendingCmd(\"xpending\", stream, group)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type XPendingExtArgs struct {\n-\tStream   string\n-\tGroup    string\n-\tStart    string\n-\tEnd      string\n-\tCount    int64\n-\tConsumer string\n-}\n-\n-func (c cmdable) XPendingExt(a *XPendingExtArgs) *XPendingExtCmd {\n-\targs := make([]interface{}, 0, 7)\n-\targs = append(args, \"xpending\", a.Stream, a.Group, a.Start, a.End, a.Count)\n-\tif a.Consumer != \"\" {\n-\t\targs = append(args, a.Consumer)\n-\t}\n-\tcmd := NewXPendingExtCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type XClaimArgs struct {\n-\tStream   string\n-\tGroup    string\n-\tConsumer string\n-\tMinIdle  time.Duration\n-\tMessages []string\n-}\n-\n-func (c cmdable) XClaim(a *XClaimArgs) *XMessageSliceCmd {\n-\targs := xClaimArgs(a)\n-\tcmd := NewXMessageSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XClaimJustID(a *XClaimArgs) *StringSliceCmd {\n-\targs := xClaimArgs(a)\n-\targs = append(args, \"justid\")\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func xClaimArgs(a *XClaimArgs) []interface{} {\n-\targs := make([]interface{}, 0, 4+len(a.Messages))\n-\targs = append(args,\n-\t\t\"xclaim\",\n-\t\ta.Stream,\n-\t\ta.Group, a.Consumer,\n-\t\tint64(a.MinIdle/time.Millisecond))\n-\tfor _, id := range a.Messages {\n-\t\targs = append(args, id)\n-\t}\n-\treturn args\n-}\n-\n-func (c cmdable) XTrim(key string, maxLen int64) *IntCmd {\n-\tcmd := NewIntCmd(\"xtrim\", key, \"maxlen\", maxLen)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XTrimApprox(key string, maxLen int64) *IntCmd {\n-\tcmd := NewIntCmd(\"xtrim\", key, \"maxlen\", \"~\", maxLen)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) XInfoGroups(key string) *XInfoGroupsCmd {\n-\tcmd := NewXInfoGroupsCmd(key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-// Z represents sorted set member.\n-type Z struct {\n-\tScore  float64\n-\tMember interface{}\n-}\n-\n-// ZWithKey represents sorted set member including the name of the key where it was popped.\n-type ZWithKey struct {\n-\tZ\n-\tKey string\n-}\n-\n-// ZStore is used as an arg to ZInterStore and ZUnionStore.\n-type ZStore struct {\n-\tKeys    []string\n-\tWeights []float64\n-\t// Can be SUM, MIN or MAX.\n-\tAggregate string\n-}\n-\n-// Redis `BZPOPMAX key [key ...] timeout` command.\n-func (c cmdable) BZPopMax(timeout time.Duration, keys ...string) *ZWithKeyCmd {\n-\targs := make([]interface{}, 1+len(keys)+1)\n-\targs[0] = \"bzpopmax\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\targs[len(args)-1] = formatSec(timeout)\n-\tcmd := NewZWithKeyCmd(args...)\n-\tcmd.setReadTimeout(timeout)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `BZPOPMIN key [key ...] timeout` command.\n-func (c cmdable) BZPopMin(timeout time.Duration, keys ...string) *ZWithKeyCmd {\n-\targs := make([]interface{}, 1+len(keys)+1)\n-\targs[0] = \"bzpopmin\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\targs[len(args)-1] = formatSec(timeout)\n-\tcmd := NewZWithKeyCmd(args...)\n-\tcmd.setReadTimeout(timeout)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) zAdd(a []interface{}, n int, members ...*Z) *IntCmd {\n-\tfor i, m := range members {\n-\t\ta[n+2*i] = m.Score\n-\t\ta[n+2*i+1] = m.Member\n-\t}\n-\tcmd := NewIntCmd(a...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `ZADD key score member [score member ...]` command.\n-func (c cmdable) ZAdd(key string, members ...*Z) *IntCmd {\n-\tconst n = 2\n-\ta := make([]interface{}, n+2*len(members))\n-\ta[0], a[1] = \"zadd\", key\n-\treturn c.zAdd(a, n, members...)\n-}\n-\n-// Redis `ZADD key NX score member [score member ...]` command.\n-func (c cmdable) ZAddNX(key string, members ...*Z) *IntCmd {\n-\tconst n = 3\n-\ta := make([]interface{}, n+2*len(members))\n-\ta[0], a[1], a[2] = \"zadd\", key, \"nx\"\n-\treturn c.zAdd(a, n, members...)\n-}\n-\n-// Redis `ZADD key XX score member [score member ...]` command.\n-func (c cmdable) ZAddXX(key string, members ...*Z) *IntCmd {\n-\tconst n = 3\n-\ta := make([]interface{}, n+2*len(members))\n-\ta[0], a[1], a[2] = \"zadd\", key, \"xx\"\n-\treturn c.zAdd(a, n, members...)\n-}\n-\n-// Redis `ZADD key CH score member [score member ...]` command.\n-func (c cmdable) ZAddCh(key string, members ...*Z) *IntCmd {\n-\tconst n = 3\n-\ta := make([]interface{}, n+2*len(members))\n-\ta[0], a[1], a[2] = \"zadd\", key, \"ch\"\n-\treturn c.zAdd(a, n, members...)\n-}\n-\n-// Redis `ZADD key NX CH score member [score member ...]` command.\n-func (c cmdable) ZAddNXCh(key string, members ...*Z) *IntCmd {\n-\tconst n = 4\n-\ta := make([]interface{}, n+2*len(members))\n-\ta[0], a[1], a[2], a[3] = \"zadd\", key, \"nx\", \"ch\"\n-\treturn c.zAdd(a, n, members...)\n-}\n-\n-// Redis `ZADD key XX CH score member [score member ...]` command.\n-func (c cmdable) ZAddXXCh(key string, members ...*Z) *IntCmd {\n-\tconst n = 4\n-\ta := make([]interface{}, n+2*len(members))\n-\ta[0], a[1], a[2], a[3] = \"zadd\", key, \"xx\", \"ch\"\n-\treturn c.zAdd(a, n, members...)\n-}\n-\n-func (c cmdable) zIncr(a []interface{}, n int, members ...*Z) *FloatCmd {\n-\tfor i, m := range members {\n-\t\ta[n+2*i] = m.Score\n-\t\ta[n+2*i+1] = m.Member\n-\t}\n-\tcmd := NewFloatCmd(a...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Redis `ZADD key INCR score member` command.\n-func (c cmdable) ZIncr(key string, member *Z) *FloatCmd {\n-\tconst n = 3\n-\ta := make([]interface{}, n+2)\n-\ta[0], a[1], a[2] = \"zadd\", key, \"incr\"\n-\treturn c.zIncr(a, n, member)\n-}\n-\n-// Redis `ZADD key NX INCR score member` command.\n-func (c cmdable) ZIncrNX(key string, member *Z) *FloatCmd {\n-\tconst n = 4\n-\ta := make([]interface{}, n+2)\n-\ta[0], a[1], a[2], a[3] = \"zadd\", key, \"incr\", \"nx\"\n-\treturn c.zIncr(a, n, member)\n-}\n-\n-// Redis `ZADD key XX INCR score member` command.\n-func (c cmdable) ZIncrXX(key string, member *Z) *FloatCmd {\n-\tconst n = 4\n-\ta := make([]interface{}, n+2)\n-\ta[0], a[1], a[2], a[3] = \"zadd\", key, \"incr\", \"xx\"\n-\treturn c.zIncr(a, n, member)\n-}\n-\n-func (c cmdable) ZCard(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"zcard\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZCount(key, min, max string) *IntCmd {\n-\tcmd := NewIntCmd(\"zcount\", key, min, max)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZLexCount(key, min, max string) *IntCmd {\n-\tcmd := NewIntCmd(\"zlexcount\", key, min, max)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZIncrBy(key string, increment float64, member string) *FloatCmd {\n-\tcmd := NewFloatCmd(\"zincrby\", key, increment, member)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZInterStore(destination string, store *ZStore) *IntCmd {\n-\targs := make([]interface{}, 3+len(store.Keys))\n-\targs[0] = \"zinterstore\"\n-\targs[1] = destination\n-\targs[2] = len(store.Keys)\n-\tfor i, key := range store.Keys {\n-\t\targs[3+i] = key\n-\t}\n-\tif len(store.Weights) > 0 {\n-\t\targs = append(args, \"weights\")\n-\t\tfor _, weight := range store.Weights {\n-\t\t\targs = append(args, weight)\n-\t\t}\n-\t}\n-\tif store.Aggregate != \"\" {\n-\t\targs = append(args, \"aggregate\", store.Aggregate)\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZPopMax(key string, count ...int64) *ZSliceCmd {\n-\targs := []interface{}{\n-\t\t\"zpopmax\",\n-\t\tkey,\n-\t}\n-\n-\tswitch len(count) {\n-\tcase 0:\n-\t\tbreak\n-\tcase 1:\n-\t\targs = append(args, count[0])\n-\tdefault:\n-\t\tpanic(\"too many arguments\")\n-\t}\n-\n-\tcmd := NewZSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZPopMin(key string, count ...int64) *ZSliceCmd {\n-\targs := []interface{}{\n-\t\t\"zpopmin\",\n-\t\tkey,\n-\t}\n-\n-\tswitch len(count) {\n-\tcase 0:\n-\t\tbreak\n-\tcase 1:\n-\t\targs = append(args, count[0])\n-\tdefault:\n-\t\tpanic(\"too many arguments\")\n-\t}\n-\n-\tcmd := NewZSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) zRange(key string, start, stop int64, withScores bool) *StringSliceCmd {\n-\targs := []interface{}{\n-\t\t\"zrange\",\n-\t\tkey,\n-\t\tstart,\n-\t\tstop,\n-\t}\n-\tif withScores {\n-\t\targs = append(args, \"withscores\")\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRange(key string, start, stop int64) *StringSliceCmd {\n-\treturn c.zRange(key, start, stop, false)\n-}\n-\n-func (c cmdable) ZRangeWithScores(key string, start, stop int64) *ZSliceCmd {\n-\tcmd := NewZSliceCmd(\"zrange\", key, start, stop, \"withscores\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-type ZRangeBy struct {\n-\tMin, Max      string\n-\tOffset, Count int64\n-}\n-\n-func (c cmdable) zRangeBy(zcmd, key string, opt *ZRangeBy, withScores bool) *StringSliceCmd {\n-\targs := []interface{}{zcmd, key, opt.Min, opt.Max}\n-\tif withScores {\n-\t\targs = append(args, \"withscores\")\n-\t}\n-\tif opt.Offset != 0 || opt.Count != 0 {\n-\t\targs = append(\n-\t\t\targs,\n-\t\t\t\"limit\",\n-\t\t\topt.Offset,\n-\t\t\topt.Count,\n-\t\t)\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRangeByScore(key string, opt *ZRangeBy) *StringSliceCmd {\n-\treturn c.zRangeBy(\"zrangebyscore\", key, opt, false)\n-}\n-\n-func (c cmdable) ZRangeByLex(key string, opt *ZRangeBy) *StringSliceCmd {\n-\treturn c.zRangeBy(\"zrangebylex\", key, opt, false)\n-}\n-\n-func (c cmdable) ZRangeByScoreWithScores(key string, opt *ZRangeBy) *ZSliceCmd {\n-\targs := []interface{}{\"zrangebyscore\", key, opt.Min, opt.Max, \"withscores\"}\n-\tif opt.Offset != 0 || opt.Count != 0 {\n-\t\targs = append(\n-\t\t\targs,\n-\t\t\t\"limit\",\n-\t\t\topt.Offset,\n-\t\t\topt.Count,\n-\t\t)\n-\t}\n-\tcmd := NewZSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRank(key, member string) *IntCmd {\n-\tcmd := NewIntCmd(\"zrank\", key, member)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRem(key string, members ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(members))\n-\targs[0] = \"zrem\"\n-\targs[1] = key\n-\targs = appendArgs(args, members)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRemRangeByRank(key string, start, stop int64) *IntCmd {\n-\tcmd := NewIntCmd(\n-\t\t\"zremrangebyrank\",\n-\t\tkey,\n-\t\tstart,\n-\t\tstop,\n-\t)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRemRangeByScore(key, min, max string) *IntCmd {\n-\tcmd := NewIntCmd(\"zremrangebyscore\", key, min, max)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRemRangeByLex(key, min, max string) *IntCmd {\n-\tcmd := NewIntCmd(\"zremrangebylex\", key, min, max)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRevRange(key string, start, stop int64) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"zrevrange\", key, start, stop)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRevRangeWithScores(key string, start, stop int64) *ZSliceCmd {\n-\tcmd := NewZSliceCmd(\"zrevrange\", key, start, stop, \"withscores\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) zRevRangeBy(zcmd, key string, opt *ZRangeBy) *StringSliceCmd {\n-\targs := []interface{}{zcmd, key, opt.Max, opt.Min}\n-\tif opt.Offset != 0 || opt.Count != 0 {\n-\t\targs = append(\n-\t\t\targs,\n-\t\t\t\"limit\",\n-\t\t\topt.Offset,\n-\t\t\topt.Count,\n-\t\t)\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRevRangeByScore(key string, opt *ZRangeBy) *StringSliceCmd {\n-\treturn c.zRevRangeBy(\"zrevrangebyscore\", key, opt)\n-}\n-\n-func (c cmdable) ZRevRangeByLex(key string, opt *ZRangeBy) *StringSliceCmd {\n-\treturn c.zRevRangeBy(\"zrevrangebylex\", key, opt)\n-}\n-\n-func (c cmdable) ZRevRangeByScoreWithScores(key string, opt *ZRangeBy) *ZSliceCmd {\n-\targs := []interface{}{\"zrevrangebyscore\", key, opt.Max, opt.Min, \"withscores\"}\n-\tif opt.Offset != 0 || opt.Count != 0 {\n-\t\targs = append(\n-\t\t\targs,\n-\t\t\t\"limit\",\n-\t\t\topt.Offset,\n-\t\t\topt.Count,\n-\t\t)\n-\t}\n-\tcmd := NewZSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZRevRank(key, member string) *IntCmd {\n-\tcmd := NewIntCmd(\"zrevrank\", key, member)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZScore(key, member string) *FloatCmd {\n-\tcmd := NewFloatCmd(\"zscore\", key, member)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ZUnionStore(dest string, store *ZStore) *IntCmd {\n-\targs := make([]interface{}, 3+len(store.Keys))\n-\targs[0] = \"zunionstore\"\n-\targs[1] = dest\n-\targs[2] = len(store.Keys)\n-\tfor i, key := range store.Keys {\n-\t\targs[3+i] = key\n-\t}\n-\tif len(store.Weights) > 0 {\n-\t\targs = append(args, \"weights\")\n-\t\tfor _, weight := range store.Weights {\n-\t\t\targs = append(args, weight)\n-\t\t}\n-\t}\n-\tif store.Aggregate != \"\" {\n-\t\targs = append(args, \"aggregate\", store.Aggregate)\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) PFAdd(key string, els ...interface{}) *IntCmd {\n-\targs := make([]interface{}, 2, 2+len(els))\n-\targs[0] = \"pfadd\"\n-\targs[1] = key\n-\targs = appendArgs(args, els)\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PFCount(keys ...string) *IntCmd {\n-\targs := make([]interface{}, 1+len(keys))\n-\targs[0] = \"pfcount\"\n-\tfor i, key := range keys {\n-\t\targs[1+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PFMerge(dest string, keys ...string) *StatusCmd {\n-\targs := make([]interface{}, 2+len(keys))\n-\targs[0] = \"pfmerge\"\n-\targs[1] = dest\n-\tfor i, key := range keys {\n-\t\targs[2+i] = key\n-\t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) BgRewriteAOF() *StatusCmd {\n-\tcmd := NewStatusCmd(\"bgrewriteaof\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) BgSave() *StatusCmd {\n-\tcmd := NewStatusCmd(\"bgsave\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClientKill(ipPort string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"client\", \"kill\", ipPort)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// ClientKillByFilter is new style synx, while the ClientKill is old\n-// CLIENT KILL <option> [value] ... <option> [value]\n-func (c cmdable) ClientKillByFilter(keys ...string) *IntCmd {\n-\targs := make([]interface{}, 2+len(keys))\n-\targs[0] = \"client\"\n-\targs[1] = \"kill\"\n-\tfor i, key := range keys {\n-\t\targs[2+i] = key\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClientList() *StringCmd {\n-\tcmd := NewStringCmd(\"client\", \"list\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClientPause(dur time.Duration) *BoolCmd {\n-\tcmd := NewBoolCmd(\"client\", \"pause\", formatMs(dur))\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClientID() *IntCmd {\n-\tcmd := NewIntCmd(\"client\", \"id\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClientUnblock(id int64) *IntCmd {\n-\tcmd := NewIntCmd(\"client\", \"unblock\", id)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClientUnblockWithError(id int64) *IntCmd {\n-\tcmd := NewIntCmd(\"client\", \"unblock\", id, \"error\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// ClientSetName assigns a name to the connection.\n-func (c statefulCmdable) ClientSetName(name string) *BoolCmd {\n-\tcmd := NewBoolCmd(\"client\", \"setname\", name)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// ClientGetName returns the name of the connection.\n-func (c cmdable) ClientGetName() *StringCmd {\n-\tcmd := NewStringCmd(\"client\", \"getname\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ConfigGet(parameter string) *SliceCmd {\n-\tcmd := NewSliceCmd(\"config\", \"get\", parameter)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ConfigResetStat() *StatusCmd {\n-\tcmd := NewStatusCmd(\"config\", \"resetstat\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ConfigSet(parameter, value string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"config\", \"set\", parameter, value)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ConfigRewrite() *StatusCmd {\n-\tcmd := NewStatusCmd(\"config\", \"rewrite\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// Deperecated. Use DBSize instead.\n-func (c cmdable) DbSize() *IntCmd {\n-\treturn c.DBSize()\n-}\n-\n-func (c cmdable) DBSize() *IntCmd {\n-\tcmd := NewIntCmd(\"dbsize\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) FlushAll() *StatusCmd {\n-\tcmd := NewStatusCmd(\"flushall\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) FlushAllAsync() *StatusCmd {\n-\tcmd := NewStatusCmd(\"flushall\", \"async\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) FlushDB() *StatusCmd {\n-\tcmd := NewStatusCmd(\"flushdb\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) FlushDBAsync() *StatusCmd {\n-\tcmd := NewStatusCmd(\"flushdb\", \"async\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Info(section ...string) *StringCmd {\n-\targs := []interface{}{\"info\"}\n-\tif len(section) > 0 {\n-\t\targs = append(args, section[0])\n-\t}\n-\tcmd := NewStringCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) LastSave() *IntCmd {\n-\tcmd := NewIntCmd(\"lastsave\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) Save() *StatusCmd {\n-\tcmd := NewStatusCmd(\"save\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) shutdown(modifier string) *StatusCmd {\n-\tvar args []interface{}\n-\tif modifier == \"\" {\n-\t\targs = []interface{}{\"shutdown\"}\n-\t} else {\n-\t\targs = []interface{}{\"shutdown\", modifier}\n-\t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c(cmd)\n-\tif err := cmd.Err(); err != nil {\n-\t\tif err == io.EOF {\n-\t\t\t// Server quit as expected.\n-\t\t\tcmd.err = nil\n-\t\t}\n-\t} else {\n-\t\t// Server did not quit. String reply contains the reason.\n-\t\tcmd.err = errors.New(cmd.val)\n-\t\tcmd.val = \"\"\n-\t}\n-\treturn cmd\n-}\n-\n-func (c cmdable) Shutdown() *StatusCmd {\n-\treturn c.shutdown(\"\")\n-}\n-\n-func (c cmdable) ShutdownSave() *StatusCmd {\n-\treturn c.shutdown(\"save\")\n-}\n-\n-func (c cmdable) ShutdownNoSave() *StatusCmd {\n-\treturn c.shutdown(\"nosave\")\n-}\n-\n-func (c cmdable) SlaveOf(host, port string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"slaveof\", host, port)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) SlowLog() {\n-\tpanic(\"not implemented\")\n-}\n-\n-func (c cmdable) Sync() {\n-\tpanic(\"not implemented\")\n-}\n-\n-func (c cmdable) Time() *TimeCmd {\n-\tcmd := NewTimeCmd(\"time\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) Eval(script string, keys []string, args ...interface{}) *Cmd {\n-\tcmdArgs := make([]interface{}, 3+len(keys), 3+len(keys)+len(args))\n-\tcmdArgs[0] = \"eval\"\n-\tcmdArgs[1] = script\n-\tcmdArgs[2] = len(keys)\n-\tfor i, key := range keys {\n-\t\tcmdArgs[3+i] = key\n-\t}\n-\tcmdArgs = appendArgs(cmdArgs, args)\n-\tcmd := NewCmd(cmdArgs...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) EvalSha(sha1 string, keys []string, args ...interface{}) *Cmd {\n-\tcmdArgs := make([]interface{}, 3+len(keys), 3+len(keys)+len(args))\n-\tcmdArgs[0] = \"evalsha\"\n-\tcmdArgs[1] = sha1\n-\tcmdArgs[2] = len(keys)\n-\tfor i, key := range keys {\n-\t\tcmdArgs[3+i] = key\n-\t}\n-\tcmdArgs = appendArgs(cmdArgs, args)\n-\tcmd := NewCmd(cmdArgs...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ScriptExists(hashes ...string) *BoolSliceCmd {\n-\targs := make([]interface{}, 2+len(hashes))\n-\targs[0] = \"script\"\n-\targs[1] = \"exists\"\n-\tfor i, hash := range hashes {\n-\t\targs[2+i] = hash\n-\t}\n-\tcmd := NewBoolSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ScriptFlush() *StatusCmd {\n-\tcmd := NewStatusCmd(\"script\", \"flush\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ScriptKill() *StatusCmd {\n-\tcmd := NewStatusCmd(\"script\", \"kill\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ScriptLoad(script string) *StringCmd {\n-\tcmd := NewStringCmd(\"script\", \"load\", script)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) DebugObject(key string) *StringCmd {\n-\tcmd := NewStringCmd(\"debug\", \"object\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-// Publish posts the message to the channel.\n-func (c cmdable) Publish(channel string, message interface{}) *IntCmd {\n-\tcmd := NewIntCmd(\"publish\", channel, message)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PubSubChannels(pattern string) *StringSliceCmd {\n-\targs := []interface{}{\"pubsub\", \"channels\"}\n-\tif pattern != \"*\" {\n-\t\targs = append(args, pattern)\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PubSubNumSub(channels ...string) *StringIntMapCmd {\n-\targs := make([]interface{}, 2+len(channels))\n-\targs[0] = \"pubsub\"\n-\targs[1] = \"numsub\"\n-\tfor i, channel := range channels {\n-\t\targs[2+i] = channel\n-\t}\n-\tcmd := NewStringIntMapCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) PubSubNumPat() *IntCmd {\n-\tcmd := NewIntCmd(\"pubsub\", \"numpat\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) ClusterSlots() *ClusterSlotsCmd {\n-\tcmd := NewClusterSlotsCmd(\"cluster\", \"slots\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterNodes() *StringCmd {\n-\tcmd := NewStringCmd(\"cluster\", \"nodes\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterMeet(host, port string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"meet\", host, port)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterForget(nodeID string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"forget\", nodeID)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterReplicate(nodeID string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"replicate\", nodeID)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterResetSoft() *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"reset\", \"soft\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterResetHard() *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"reset\", \"hard\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterInfo() *StringCmd {\n-\tcmd := NewStringCmd(\"cluster\", \"info\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterKeySlot(key string) *IntCmd {\n-\tcmd := NewIntCmd(\"cluster\", \"keyslot\", key)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterGetKeysInSlot(slot int, count int) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"cluster\", \"getkeysinslot\", slot, count)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterCountFailureReports(nodeID string) *IntCmd {\n-\tcmd := NewIntCmd(\"cluster\", \"count-failure-reports\", nodeID)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterCountKeysInSlot(slot int) *IntCmd {\n-\tcmd := NewIntCmd(\"cluster\", \"countkeysinslot\", slot)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterDelSlots(slots ...int) *StatusCmd {\n-\targs := make([]interface{}, 2+len(slots))\n-\targs[0] = \"cluster\"\n-\targs[1] = \"delslots\"\n-\tfor i, slot := range slots {\n-\t\targs[2+i] = slot\n-\t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterDelSlotsRange(min, max int) *StatusCmd {\n-\tsize := max - min + 1\n-\tslots := make([]int, size)\n-\tfor i := 0; i < size; i++ {\n-\t\tslots[i] = min + i\n-\t}\n-\treturn c.ClusterDelSlots(slots...)\n-}\n-\n-func (c cmdable) ClusterSaveConfig() *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"saveconfig\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterSlaves(nodeID string) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"cluster\", \"slaves\", nodeID)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ReadOnly() *StatusCmd {\n-\tcmd := NewStatusCmd(\"readonly\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ReadWrite() *StatusCmd {\n-\tcmd := NewStatusCmd(\"readwrite\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterFailover() *StatusCmd {\n-\tcmd := NewStatusCmd(\"cluster\", \"failover\")\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterAddSlots(slots ...int) *StatusCmd {\n-\targs := make([]interface{}, 2+len(slots))\n-\targs[0] = \"cluster\"\n-\targs[1] = \"addslots\"\n-\tfor i, num := range slots {\n-\t\targs[2+i] = num\n-\t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) ClusterAddSlotsRange(min, max int) *StatusCmd {\n-\tsize := max - min + 1\n-\tslots := make([]int, size)\n-\tfor i := 0; i < size; i++ {\n-\t\tslots[i] = min + i\n-\t}\n-\treturn c.ClusterAddSlots(slots...)\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) GeoAdd(key string, geoLocation ...*GeoLocation) *IntCmd {\n-\targs := make([]interface{}, 2+3*len(geoLocation))\n-\targs[0] = \"geoadd\"\n-\targs[1] = key\n-\tfor i, eachLoc := range geoLocation {\n-\t\targs[2+3*i] = eachLoc.Longitude\n-\t\targs[2+3*i+1] = eachLoc.Latitude\n-\t\targs[2+3*i+2] = eachLoc.Name\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// GeoRadius is a read-only GEORADIUS_RO command.\n-func (c cmdable) GeoRadius(key string, longitude, latitude float64, query *GeoRadiusQuery) *GeoLocationCmd {\n-\tcmd := NewGeoLocationCmd(query, \"georadius_ro\", key, longitude, latitude)\n-\tif query.Store != \"\" || query.StoreDist != \"\" {\n-\t\tcmd.SetErr(errors.New(\"GeoRadius does not support Store or StoreDist\"))\n-\t\treturn cmd\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// GeoRadiusStore is a writing GEORADIUS command.\n-func (c cmdable) GeoRadiusStore(key string, longitude, latitude float64, query *GeoRadiusQuery) *IntCmd {\n-\targs := geoLocationArgs(query, \"georadius\", key, longitude, latitude)\n-\tcmd := NewIntCmd(args...)\n-\tif query.Store == \"\" && query.StoreDist == \"\" {\n-\t\tcmd.SetErr(errors.New(\"GeoRadiusStore requires Store or StoreDist\"))\n-\t\treturn cmd\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// GeoRadius is a read-only GEORADIUSBYMEMBER_RO command.\n-func (c cmdable) GeoRadiusByMember(key, member string, query *GeoRadiusQuery) *GeoLocationCmd {\n-\tcmd := NewGeoLocationCmd(query, \"georadiusbymember_ro\", key, member)\n-\tif query.Store != \"\" || query.StoreDist != \"\" {\n-\t\tcmd.SetErr(errors.New(\"GeoRadiusByMember does not support Store or StoreDist\"))\n-\t\treturn cmd\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-// GeoRadiusByMemberStore is a writing GEORADIUSBYMEMBER command.\n-func (c cmdable) GeoRadiusByMemberStore(key, member string, query *GeoRadiusQuery) *IntCmd {\n-\targs := geoLocationArgs(query, \"georadiusbymember\", key, member)\n-\tcmd := NewIntCmd(args...)\n-\tif query.Store == \"\" && query.StoreDist == \"\" {\n-\t\tcmd.SetErr(errors.New(\"GeoRadiusByMemberStore requires Store or StoreDist\"))\n-\t\treturn cmd\n-\t}\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) GeoDist(key string, member1, member2, unit string) *FloatCmd {\n-\tif unit == \"\" {\n-\t\tunit = \"km\"\n-\t}\n-\tcmd := NewFloatCmd(\"geodist\", key, member1, member2, unit)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) GeoHash(key string, members ...string) *StringSliceCmd {\n-\targs := make([]interface{}, 2+len(members))\n-\targs[0] = \"geohash\"\n-\targs[1] = key\n-\tfor i, member := range members {\n-\t\targs[2+i] = member\n-\t}\n-\tcmd := NewStringSliceCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-func (c cmdable) GeoPos(key string, members ...string) *GeoPosCmd {\n-\targs := make([]interface{}, 2+len(members))\n-\targs[0] = \"geopos\"\n-\targs[1] = key\n-\tfor i, member := range members {\n-\t\targs[2+i] = member\n-\t}\n-\tcmd := NewGeoPosCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-func (c cmdable) MemoryUsage(key string, samples ...int) *IntCmd {\n-\targs := []interface{}{\"memory\", \"usage\", key}\n-\tif len(samples) > 0 {\n-\t\tif len(samples) != 1 {\n-\t\t\tpanic(\"MemoryUsage expects single sample count\")\n-\t\t}\n-\t\targs = append(args, \"SAMPLES\", samples[0])\n-\t}\n-\tcmd := NewIntCmd(args...)\n-\t_ = c(cmd)\n-\treturn cmd\n-}"
    },
    {
      "sha": "a9c56f0762123d501e247a66eb30fe7607d3805d",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/internal/consistenthash/consistenthash.go",
      "status": "removed",
      "additions": 0,
      "deletions": 81,
      "changes": 81,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Fconsistenthash%2Fconsistenthash.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Fconsistenthash%2Fconsistenthash.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Fconsistenthash%2Fconsistenthash.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,81 +0,0 @@\n-/*\n-Copyright 2013 Google Inc.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-     http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-*/\n-\n-// Package consistenthash provides an implementation of a ring hash.\n-package consistenthash\n-\n-import (\n-\t\"hash/crc32\"\n-\t\"sort\"\n-\t\"strconv\"\n-)\n-\n-type Hash func(data []byte) uint32\n-\n-type Map struct {\n-\thash     Hash\n-\treplicas int\n-\tkeys     []int // Sorted\n-\thashMap  map[int]string\n-}\n-\n-func New(replicas int, fn Hash) *Map {\n-\tm := &Map{\n-\t\treplicas: replicas,\n-\t\thash:     fn,\n-\t\thashMap:  make(map[int]string),\n-\t}\n-\tif m.hash == nil {\n-\t\tm.hash = crc32.ChecksumIEEE\n-\t}\n-\treturn m\n-}\n-\n-// Returns true if there are no items available.\n-func (m *Map) IsEmpty() bool {\n-\treturn len(m.keys) == 0\n-}\n-\n-// Adds some keys to the hash.\n-func (m *Map) Add(keys ...string) {\n-\tfor _, key := range keys {\n-\t\tfor i := 0; i < m.replicas; i++ {\n-\t\t\thash := int(m.hash([]byte(strconv.Itoa(i) + key)))\n-\t\t\tm.keys = append(m.keys, hash)\n-\t\t\tm.hashMap[hash] = key\n-\t\t}\n-\t}\n-\tsort.Ints(m.keys)\n-}\n-\n-// Gets the closest item in the hash to the provided key.\n-func (m *Map) Get(key string) string {\n-\tif m.IsEmpty() {\n-\t\treturn \"\"\n-\t}\n-\n-\thash := int(m.hash([]byte(key)))\n-\n-\t// Binary search for appropriate replica.\n-\tidx := sort.Search(len(m.keys), func(i int) bool { return m.keys[i] >= hash })\n-\n-\t// Means we have cycled back to the first replica.\n-\tif idx == len(m.keys) {\n-\t\tidx = 0\n-\t}\n-\n-\treturn m.hashMap[m.keys[idx]]\n-}"
    },
    {
      "sha": "ad3fc3c9ffb622a6736ad455491831bef7db6169",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/internal/internal.go",
      "status": "removed",
      "additions": 0,
      "deletions": 24,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Finternal.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Finternal.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Finternal.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,24 +0,0 @@\n-package internal\n-\n-import (\n-\t\"math/rand\"\n-\t\"time\"\n-)\n-\n-// Retry backoff with jitter sleep to prevent overloaded conditions during intervals\n-// https://www.awsarchitectureblog.com/2015/03/backoff.html\n-func RetryBackoff(retry int, minBackoff, maxBackoff time.Duration) time.Duration {\n-\tif retry < 0 {\n-\t\tretry = 0\n-\t}\n-\n-\tbackoff := minBackoff << uint(retry)\n-\tif backoff > maxBackoff || backoff < minBackoff {\n-\t\tbackoff = maxBackoff\n-\t}\n-\n-\tif backoff == 0 {\n-\t\treturn 0\n-\t}\n-\treturn time.Duration(rand.Int63n(int64(backoff)))\n-}"
    },
    {
      "sha": "405a2728d6c3ce1226a349af17ead3bf4ab5420a",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/internal/log.go",
      "status": "removed",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Flog.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Flog.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Flog.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,8 +0,0 @@\n-package internal\n-\n-import (\n-\t\"log\"\n-\t\"os\"\n-)\n-\n-var Logger = log.New(os.Stderr, \"redis: \", log.LstdFlags|log.Lshortfile)"
    },
    {
      "sha": "d4a355a44ffe362f1a6a0699440fd15b9fcd0623",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/internal/pool/pool_sticky.go",
      "status": "removed",
      "additions": 0,
      "deletions": 112,
      "changes": 112,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Fpool%2Fpool_sticky.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Fpool%2Fpool_sticky.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Finternal%2Fpool%2Fpool_sticky.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,112 +0,0 @@\n-package pool\n-\n-import (\n-\t\"context\"\n-\t\"sync\"\n-)\n-\n-type StickyConnPool struct {\n-\tpool     *ConnPool\n-\treusable bool\n-\n-\tcn     *Conn\n-\tclosed bool\n-\tmu     sync.Mutex\n-}\n-\n-var _ Pooler = (*StickyConnPool)(nil)\n-\n-func NewStickyConnPool(pool *ConnPool, reusable bool) *StickyConnPool {\n-\treturn &StickyConnPool{\n-\t\tpool:     pool,\n-\t\treusable: reusable,\n-\t}\n-}\n-\n-func (p *StickyConnPool) NewConn(context.Context) (*Conn, error) {\n-\tpanic(\"not implemented\")\n-}\n-\n-func (p *StickyConnPool) CloseConn(*Conn) error {\n-\tpanic(\"not implemented\")\n-}\n-\n-func (p *StickyConnPool) Get(ctx context.Context) (*Conn, error) {\n-\tp.mu.Lock()\n-\tdefer p.mu.Unlock()\n-\n-\tif p.closed {\n-\t\treturn nil, ErrClosed\n-\t}\n-\tif p.cn != nil {\n-\t\treturn p.cn, nil\n-\t}\n-\n-\tcn, err := p.pool.Get(ctx)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tp.cn = cn\n-\treturn cn, nil\n-}\n-\n-func (p *StickyConnPool) putUpstream() {\n-\tp.pool.Put(p.cn)\n-\tp.cn = nil\n-}\n-\n-func (p *StickyConnPool) Put(cn *Conn) {}\n-\n-func (p *StickyConnPool) removeUpstream(reason error) {\n-\tp.pool.Remove(p.cn, reason)\n-\tp.cn = nil\n-}\n-\n-func (p *StickyConnPool) Remove(cn *Conn, reason error) {\n-\tp.removeUpstream(reason)\n-}\n-\n-func (p *StickyConnPool) Len() int {\n-\tp.mu.Lock()\n-\tdefer p.mu.Unlock()\n-\n-\tif p.cn == nil {\n-\t\treturn 0\n-\t}\n-\treturn 1\n-}\n-\n-func (p *StickyConnPool) IdleLen() int {\n-\tp.mu.Lock()\n-\tdefer p.mu.Unlock()\n-\n-\tif p.cn == nil {\n-\t\treturn 1\n-\t}\n-\treturn 0\n-}\n-\n-func (p *StickyConnPool) Stats() *Stats {\n-\treturn nil\n-}\n-\n-func (p *StickyConnPool) Close() error {\n-\tp.mu.Lock()\n-\tdefer p.mu.Unlock()\n-\n-\tif p.closed {\n-\t\treturn ErrClosed\n-\t}\n-\tp.closed = true\n-\n-\tif p.cn != nil {\n-\t\tif p.reusable {\n-\t\t\tp.putUpstream()\n-\t\t} else {\n-\t\t\tp.removeUpstream(ErrClosed)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}"
    },
    {
      "sha": "88b7d0a2ea901ad0ec64b5cd83d366c270243503",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/script.go",
      "status": "removed",
      "additions": 0,
      "deletions": 62,
      "changes": 62,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fscript.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fscript.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fscript.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,62 +0,0 @@\n-package redis\n-\n-import (\n-\t\"crypto/sha1\"\n-\t\"encoding/hex\"\n-\t\"io\"\n-\t\"strings\"\n-)\n-\n-type scripter interface {\n-\tEval(script string, keys []string, args ...interface{}) *Cmd\n-\tEvalSha(sha1 string, keys []string, args ...interface{}) *Cmd\n-\tScriptExists(hashes ...string) *BoolSliceCmd\n-\tScriptLoad(script string) *StringCmd\n-}\n-\n-var _ scripter = (*Client)(nil)\n-var _ scripter = (*Ring)(nil)\n-var _ scripter = (*ClusterClient)(nil)\n-\n-type Script struct {\n-\tsrc, hash string\n-}\n-\n-func NewScript(src string) *Script {\n-\th := sha1.New()\n-\t_, _ = io.WriteString(h, src)\n-\treturn &Script{\n-\t\tsrc:  src,\n-\t\thash: hex.EncodeToString(h.Sum(nil)),\n-\t}\n-}\n-\n-func (s *Script) Hash() string {\n-\treturn s.hash\n-}\n-\n-func (s *Script) Load(c scripter) *StringCmd {\n-\treturn c.ScriptLoad(s.src)\n-}\n-\n-func (s *Script) Exists(c scripter) *BoolSliceCmd {\n-\treturn c.ScriptExists(s.hash)\n-}\n-\n-func (s *Script) Eval(c scripter, keys []string, args ...interface{}) *Cmd {\n-\treturn c.Eval(s.src, keys, args...)\n-}\n-\n-func (s *Script) EvalSha(c scripter, keys []string, args ...interface{}) *Cmd {\n-\treturn c.EvalSha(s.hash, keys, args...)\n-}\n-\n-// Run optimistically uses EVALSHA to run the script. If script does not exist\n-// it is retried using EVAL.\n-func (s *Script) Run(c scripter, keys []string, args ...interface{}) *Cmd {\n-\tr := s.EvalSha(c, keys, args...)\n-\tif err := r.Err(); err != nil && strings.HasPrefix(err.Error(), \"NOSCRIPT \") {\n-\t\treturn s.Eval(c, keys, args...)\n-\t}\n-\treturn r\n-}"
    },
    {
      "sha": "8aa40ef79948421caa85b22aef31ba063f7617ec",
      "filename": "backend/vendor/github.com/go-redis/redis/v7/sentinel.go",
      "status": "removed",
      "additions": 0,
      "deletions": 509,
      "changes": 509,
      "blob_url": "https://github.com/umputun/remark42/blob/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fsentinel.go",
      "raw_url": "https://github.com/umputun/remark42/raw/2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fsentinel.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv7%2Fsentinel.go?ref=2c36fab8aa7f65f6290d45a1d0d47a91e40c11e5",
      "patch": "@@ -1,509 +0,0 @@\n-package redis\n-\n-import (\n-\t\"context\"\n-\t\"crypto/tls\"\n-\t\"errors\"\n-\t\"net\"\n-\t\"strings\"\n-\t\"sync\"\n-\t\"time\"\n-\n-\t\"github.com/go-redis/redis/v7/internal\"\n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-)\n-\n-//------------------------------------------------------------------------------\n-\n-// FailoverOptions are used to configure a failover client and should\n-// be passed to NewFailoverClient.\n-type FailoverOptions struct {\n-\t// The master name.\n-\tMasterName string\n-\t// A seed list of host:port addresses of sentinel nodes.\n-\tSentinelAddrs    []string\n-\tSentinelUsername string\n-\tSentinelPassword string\n-\n-\t// Following options are copied from Options struct.\n-\n-\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n-\tOnConnect func(*Conn) error\n-\n-\tUsername string\n-\tPassword string\n-\tDB       int\n-\n-\tMaxRetries      int\n-\tMinRetryBackoff time.Duration\n-\tMaxRetryBackoff time.Duration\n-\n-\tDialTimeout  time.Duration\n-\tReadTimeout  time.Duration\n-\tWriteTimeout time.Duration\n-\n-\tPoolSize           int\n-\tMinIdleConns       int\n-\tMaxConnAge         time.Duration\n-\tPoolTimeout        time.Duration\n-\tIdleTimeout        time.Duration\n-\tIdleCheckFrequency time.Duration\n-\n-\tTLSConfig *tls.Config\n-}\n-\n-func (opt *FailoverOptions) options() *Options {\n-\treturn &Options{\n-\t\tAddr:      \"FailoverClient\",\n-\t\tDialer:    opt.Dialer,\n-\t\tOnConnect: opt.OnConnect,\n-\n-\t\tDB:       opt.DB,\n-\t\tUsername: opt.Username,\n-\t\tPassword: opt.Password,\n-\n-\t\tMaxRetries:      opt.MaxRetries,\n-\t\tMinRetryBackoff: opt.MinRetryBackoff,\n-\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n-\n-\t\tDialTimeout:  opt.DialTimeout,\n-\t\tReadTimeout:  opt.ReadTimeout,\n-\t\tWriteTimeout: opt.WriteTimeout,\n-\n-\t\tPoolSize:           opt.PoolSize,\n-\t\tPoolTimeout:        opt.PoolTimeout,\n-\t\tIdleTimeout:        opt.IdleTimeout,\n-\t\tIdleCheckFrequency: opt.IdleCheckFrequency,\n-\t\tMinIdleConns:       opt.MinIdleConns,\n-\t\tMaxConnAge:         opt.MaxConnAge,\n-\n-\t\tTLSConfig: opt.TLSConfig,\n-\t}\n-}\n-\n-// NewFailoverClient returns a Redis client that uses Redis Sentinel\n-// for automatic failover. It's safe for concurrent use by multiple\n-// goroutines.\n-func NewFailoverClient(failoverOpt *FailoverOptions) *Client {\n-\topt := failoverOpt.options()\n-\topt.init()\n-\n-\tfailover := &sentinelFailover{\n-\t\tmasterName:    failoverOpt.MasterName,\n-\t\tsentinelAddrs: failoverOpt.SentinelAddrs,\n-\t\tusername:      failoverOpt.SentinelUsername,\n-\t\tpassword:      failoverOpt.SentinelPassword,\n-\n-\t\topt: opt,\n-\t}\n-\n-\tc := Client{\n-\t\tbaseClient: newBaseClient(opt, failover.Pool()),\n-\t\tctx:        context.Background(),\n-\t}\n-\tc.cmdable = c.Process\n-\tc.onClose = failover.Close\n-\n-\treturn &c\n-}\n-\n-//------------------------------------------------------------------------------\n-\n-type SentinelClient struct {\n-\t*baseClient\n-\tctx context.Context\n-}\n-\n-func NewSentinelClient(opt *Options) *SentinelClient {\n-\topt.init()\n-\tc := &SentinelClient{\n-\t\tbaseClient: &baseClient{\n-\t\t\topt:      opt,\n-\t\t\tconnPool: newConnPool(opt),\n-\t\t},\n-\t\tctx: context.Background(),\n-\t}\n-\treturn c\n-}\n-\n-func (c *SentinelClient) Context() context.Context {\n-\treturn c.ctx\n-}\n-\n-func (c *SentinelClient) WithContext(ctx context.Context) *SentinelClient {\n-\tif ctx == nil {\n-\t\tpanic(\"nil context\")\n-\t}\n-\tclone := *c\n-\tclone.ctx = ctx\n-\treturn &clone\n-}\n-\n-func (c *SentinelClient) Process(cmd Cmder) error {\n-\treturn c.ProcessContext(c.ctx, cmd)\n-}\n-\n-func (c *SentinelClient) ProcessContext(ctx context.Context, cmd Cmder) error {\n-\treturn c.baseClient.process(ctx, cmd)\n-}\n-\n-func (c *SentinelClient) pubSub() *PubSub {\n-\tpubsub := &PubSub{\n-\t\topt: c.opt,\n-\n-\t\tnewConn: func(channels []string) (*pool.Conn, error) {\n-\t\t\treturn c.newConn(context.TODO())\n-\t\t},\n-\t\tcloseConn: c.connPool.CloseConn,\n-\t}\n-\tpubsub.init()\n-\treturn pubsub\n-}\n-\n-// Ping is used to test if a connection is still alive, or to\n-// measure latency.\n-func (c *SentinelClient) Ping() *StringCmd {\n-\tcmd := NewStringCmd(\"ping\")\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Subscribe subscribes the client to the specified channels.\n-// Channels can be omitted to create empty subscription.\n-func (c *SentinelClient) Subscribe(channels ...string) *PubSub {\n-\tpubsub := c.pubSub()\n-\tif len(channels) > 0 {\n-\t\t_ = pubsub.Subscribe(channels...)\n-\t}\n-\treturn pubsub\n-}\n-\n-// PSubscribe subscribes the client to the given patterns.\n-// Patterns can be omitted to create empty subscription.\n-func (c *SentinelClient) PSubscribe(channels ...string) *PubSub {\n-\tpubsub := c.pubSub()\n-\tif len(channels) > 0 {\n-\t\t_ = pubsub.PSubscribe(channels...)\n-\t}\n-\treturn pubsub\n-}\n-\n-func (c *SentinelClient) GetMasterAddrByName(name string) *StringSliceCmd {\n-\tcmd := NewStringSliceCmd(\"sentinel\", \"get-master-addr-by-name\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-func (c *SentinelClient) Sentinels(name string) *SliceCmd {\n-\tcmd := NewSliceCmd(\"sentinel\", \"sentinels\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Failover forces a failover as if the master was not reachable, and without\n-// asking for agreement to other Sentinels.\n-func (c *SentinelClient) Failover(name string) *StatusCmd {\n-\tcmd := NewStatusCmd(\"sentinel\", \"failover\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Reset resets all the masters with matching name. The pattern argument is a\n-// glob-style pattern. The reset process clears any previous state in a master\n-// (including a failover in progress), and removes every slave and sentinel\n-// already discovered and associated with the master.\n-func (c *SentinelClient) Reset(pattern string) *IntCmd {\n-\tcmd := NewIntCmd(\"sentinel\", \"reset\", pattern)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// FlushConfig forces Sentinel to rewrite its configuration on disk, including\n-// the current Sentinel state.\n-func (c *SentinelClient) FlushConfig() *StatusCmd {\n-\tcmd := NewStatusCmd(\"sentinel\", \"flushconfig\")\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Master shows the state and info of the specified master.\n-func (c *SentinelClient) Master(name string) *StringStringMapCmd {\n-\tcmd := NewStringStringMapCmd(\"sentinel\", \"master\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Masters shows a list of monitored masters and their state.\n-func (c *SentinelClient) Masters() *SliceCmd {\n-\tcmd := NewSliceCmd(\"sentinel\", \"masters\")\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Slaves shows a list of slaves for the specified master and their state.\n-func (c *SentinelClient) Slaves(name string) *SliceCmd {\n-\tcmd := NewSliceCmd(\"sentinel\", \"slaves\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// CkQuorum checks if the current Sentinel configuration is able to reach the\n-// quorum needed to failover a master, and the majority needed to authorize the\n-// failover. This command should be used in monitoring systems to check if a\n-// Sentinel deployment is ok.\n-func (c *SentinelClient) CkQuorum(name string) *StringCmd {\n-\tcmd := NewStringCmd(\"sentinel\", \"ckquorum\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Monitor tells the Sentinel to start monitoring a new master with the specified\n-// name, ip, port, and quorum.\n-func (c *SentinelClient) Monitor(name, ip, port, quorum string) *StringCmd {\n-\tcmd := NewStringCmd(\"sentinel\", \"monitor\", name, ip, port, quorum)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Set is used in order to change configuration parameters of a specific master.\n-func (c *SentinelClient) Set(name, option, value string) *StringCmd {\n-\tcmd := NewStringCmd(\"sentinel\", \"set\", name, option, value)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-// Remove is used in order to remove the specified master: the master will no\n-// longer be monitored, and will totally be removed from the internal state of\n-// the Sentinel.\n-func (c *SentinelClient) Remove(name string) *StringCmd {\n-\tcmd := NewStringCmd(\"sentinel\", \"remove\", name)\n-\t_ = c.Process(cmd)\n-\treturn cmd\n-}\n-\n-type sentinelFailover struct {\n-\tsentinelAddrs []string\n-\n-\topt      *Options\n-\tusername string\n-\tpassword string\n-\n-\tpool     *pool.ConnPool\n-\tpoolOnce sync.Once\n-\n-\tmu          sync.RWMutex\n-\tmasterName  string\n-\t_masterAddr string\n-\tsentinel    *SentinelClient\n-\tpubsub      *PubSub\n-}\n-\n-func (c *sentinelFailover) Close() error {\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\tif c.sentinel != nil {\n-\t\treturn c.closeSentinel()\n-\t}\n-\treturn nil\n-}\n-\n-func (c *sentinelFailover) closeSentinel() error {\n-\tfirstErr := c.pubsub.Close()\n-\tc.pubsub = nil\n-\n-\terr := c.sentinel.Close()\n-\tif err != nil && firstErr == nil {\n-\t\tfirstErr = err\n-\t}\n-\tc.sentinel = nil\n-\n-\treturn firstErr\n-}\n-\n-func (c *sentinelFailover) Pool() *pool.ConnPool {\n-\tc.poolOnce.Do(func() {\n-\t\topt := *c.opt\n-\t\topt.Dialer = c.dial\n-\t\tc.pool = newConnPool(&opt)\n-\t})\n-\treturn c.pool\n-}\n-\n-func (c *sentinelFailover) dial(ctx context.Context, network, _ string) (net.Conn, error) {\n-\taddr, err := c.MasterAddr()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif c.opt.Dialer != nil {\n-\t\treturn c.opt.Dialer(ctx, network, addr)\n-\t}\n-\treturn net.DialTimeout(\"tcp\", addr, c.opt.DialTimeout)\n-}\n-\n-func (c *sentinelFailover) MasterAddr() (string, error) {\n-\taddr, err := c.masterAddr()\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tc.switchMaster(addr)\n-\treturn addr, nil\n-}\n-\n-func (c *sentinelFailover) masterAddr() (string, error) {\n-\tc.mu.RLock()\n-\tsentinel := c.sentinel\n-\tc.mu.RUnlock()\n-\n-\tif sentinel != nil {\n-\t\taddr := c.getMasterAddr(sentinel)\n-\t\tif addr != \"\" {\n-\t\t\treturn addr, nil\n-\t\t}\n-\t}\n-\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\n-\tif c.sentinel != nil {\n-\t\taddr := c.getMasterAddr(c.sentinel)\n-\t\tif addr != \"\" {\n-\t\t\treturn addr, nil\n-\t\t}\n-\t\t_ = c.closeSentinel()\n-\t}\n-\n-\tfor i, sentinelAddr := range c.sentinelAddrs {\n-\t\tsentinel := NewSentinelClient(&Options{\n-\t\t\tAddr:   sentinelAddr,\n-\t\t\tDialer: c.opt.Dialer,\n-\n-\t\t\tUsername: c.username,\n-\t\t\tPassword: c.password,\n-\n-\t\t\tMaxRetries: c.opt.MaxRetries,\n-\n-\t\t\tDialTimeout:  c.opt.DialTimeout,\n-\t\t\tReadTimeout:  c.opt.ReadTimeout,\n-\t\t\tWriteTimeout: c.opt.WriteTimeout,\n-\n-\t\t\tPoolSize:           c.opt.PoolSize,\n-\t\t\tPoolTimeout:        c.opt.PoolTimeout,\n-\t\t\tIdleTimeout:        c.opt.IdleTimeout,\n-\t\t\tIdleCheckFrequency: c.opt.IdleCheckFrequency,\n-\n-\t\t\tTLSConfig: c.opt.TLSConfig,\n-\t\t})\n-\n-\t\tmasterAddr, err := sentinel.GetMasterAddrByName(c.masterName).Result()\n-\t\tif err != nil {\n-\t\t\tinternal.Logger.Printf(\"sentinel: GetMasterAddrByName master=%q failed: %s\",\n-\t\t\t\tc.masterName, err)\n-\t\t\t_ = sentinel.Close()\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// Push working sentinel to the top.\n-\t\tc.sentinelAddrs[0], c.sentinelAddrs[i] = c.sentinelAddrs[i], c.sentinelAddrs[0]\n-\t\tc.setSentinel(sentinel)\n-\n-\t\taddr := net.JoinHostPort(masterAddr[0], masterAddr[1])\n-\t\treturn addr, nil\n-\t}\n-\n-\treturn \"\", errors.New(\"redis: all sentinels are unreachable\")\n-}\n-\n-func (c *sentinelFailover) getMasterAddr(sentinel *SentinelClient) string {\n-\taddr, err := sentinel.GetMasterAddrByName(c.masterName).Result()\n-\tif err != nil {\n-\t\tinternal.Logger.Printf(\"sentinel: GetMasterAddrByName name=%q failed: %s\",\n-\t\t\tc.masterName, err)\n-\t\treturn \"\"\n-\t}\n-\treturn net.JoinHostPort(addr[0], addr[1])\n-}\n-\n-func (c *sentinelFailover) switchMaster(addr string) {\n-\tc.mu.RLock()\n-\tmasterAddr := c._masterAddr\n-\tc.mu.RUnlock()\n-\tif masterAddr == addr {\n-\t\treturn\n-\t}\n-\n-\tc.mu.Lock()\n-\tdefer c.mu.Unlock()\n-\n-\tif c._masterAddr == addr {\n-\t\treturn\n-\t}\n-\n-\tinternal.Logger.Printf(\"sentinel: new master=%q addr=%q\",\n-\t\tc.masterName, addr)\n-\t_ = c.Pool().Filter(func(cn *pool.Conn) bool {\n-\t\treturn cn.RemoteAddr().String() != addr\n-\t})\n-\tc._masterAddr = addr\n-}\n-\n-func (c *sentinelFailover) setSentinel(sentinel *SentinelClient) {\n-\tif c.sentinel != nil {\n-\t\tpanic(\"not reached\")\n-\t}\n-\tc.sentinel = sentinel\n-\tc.discoverSentinels()\n-\n-\tc.pubsub = sentinel.Subscribe(\"+switch-master\")\n-\tgo c.listen(c.pubsub)\n-}\n-\n-func (c *sentinelFailover) discoverSentinels() {\n-\tsentinels, err := c.sentinel.Sentinels(c.masterName).Result()\n-\tif err != nil {\n-\t\tinternal.Logger.Printf(\"sentinel: Sentinels master=%q failed: %s\", c.masterName, err)\n-\t\treturn\n-\t}\n-\tfor _, sentinel := range sentinels {\n-\t\tvals := sentinel.([]interface{})\n-\t\tfor i := 0; i < len(vals); i += 2 {\n-\t\t\tkey := vals[i].(string)\n-\t\t\tif key == \"name\" {\n-\t\t\t\tsentinelAddr := vals[i+1].(string)\n-\t\t\t\tif !contains(c.sentinelAddrs, sentinelAddr) {\n-\t\t\t\t\tinternal.Logger.Printf(\"sentinel: discovered new sentinel=%q for master=%q\",\n-\t\t\t\t\t\tsentinelAddr, c.masterName)\n-\t\t\t\t\tc.sentinelAddrs = append(c.sentinelAddrs, sentinelAddr)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func (c *sentinelFailover) listen(pubsub *PubSub) {\n-\tch := pubsub.Channel()\n-\tfor {\n-\t\tmsg, ok := <-ch\n-\t\tif !ok {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\tif msg.Channel == \"+switch-master\" {\n-\t\t\tparts := strings.Split(msg.Payload, \" \")\n-\t\t\tif parts[0] != c.masterName {\n-\t\t\t\tinternal.Logger.Printf(\"sentinel: ignore addr for master=%q\", parts[0])\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\taddr := net.JoinHostPort(parts[3], parts[4])\n-\t\t\tc.switchMaster(addr)\n-\t\t}\n-\t}\n-}\n-\n-func contains(slice []string, str string) bool {\n-\tfor _, s := range slice {\n-\t\tif s == str {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}"
    },
    {
      "sha": "b975a7b4c3264a9876ac1df8ce6f44ac20b8c4ce",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/.gitignore",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.gitignore?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/.gitignore"
    },
    {
      "sha": "de514554a9cce0cd9acbdabf681e80e8a25cfe90",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/.golangci.yml",
      "status": "added",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.golangci.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,4 @@\n+run:\n+  concurrency: 8\n+  deadline: 5m\n+  tests: false"
    },
    {
      "sha": "8b7f044ad1f56bf1646588b9bd3f9715426c2906",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/.prettierrc.yml",
      "status": "added",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.prettierrc.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.prettierrc.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2F.prettierrc.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,4 @@\n+semi: false\n+singleQuote: true\n+proseWrap: always\n+printWidth: 100"
    },
    {
      "sha": "195e51933866cc492cd66e007337d4a167e23b88",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/CHANGELOG.md",
      "status": "added",
      "additions": 177,
      "deletions": 0,
      "changes": 177,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FCHANGELOG.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FCHANGELOG.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FCHANGELOG.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,177 @@\n+## [8.11.5](https://github.com/go-redis/redis/compare/v8.11.4...v8.11.5) (2022-03-17)\n+\n+\n+### Bug Fixes\n+\n+* add missing Expire methods to Cmdable ([17e3b43](https://github.com/go-redis/redis/commit/17e3b43879d516437ada71cf9c0deac6a382ed9a))\n+* add whitespace for avoid unlikely colisions ([7f7c181](https://github.com/go-redis/redis/commit/7f7c1817617cfec909efb13d14ad22ef05a6ad4c))\n+* example/otel compile error ([#2028](https://github.com/go-redis/redis/issues/2028)) ([187c07c](https://github.com/go-redis/redis/commit/187c07c41bf68dc3ab280bc3a925e960bbef6475))\n+* **extra/redisotel:** set span.kind attribute to client ([065b200](https://github.com/go-redis/redis/commit/065b200070b41e6e949710b4f9e01b50ccc60ab2))\n+* format ([96f53a0](https://github.com/go-redis/redis/commit/96f53a0159a28affa94beec1543a62234e7f8b32))\n+* invalid type assert in stringArg ([de6c131](https://github.com/go-redis/redis/commit/de6c131865b8263400c8491777b295035f2408e4))\n+* rename Golang to Go ([#2030](https://github.com/go-redis/redis/issues/2030)) ([b82a2d9](https://github.com/go-redis/redis/commit/b82a2d9d4d2de7b7cbe8fcd4895be62dbcacacbc))\n+* set timeout for WAIT command. Fixes [#1963](https://github.com/go-redis/redis/issues/1963) ([333fee1](https://github.com/go-redis/redis/commit/333fee1a8fd98a2fbff1ab187c1b03246a7eb01f))\n+* update some argument counts in pre-allocs ([f6974eb](https://github.com/go-redis/redis/commit/f6974ebb5c40a8adf90d2cacab6dc297f4eba4c2))\n+\n+\n+### Features\n+\n+* Add redis v7's NX, XX, GT, LT expire variants ([e19bbb2](https://github.com/go-redis/redis/commit/e19bbb26e2e395c6e077b48d80d79e99f729a8b8))\n+* add support for acl sentinel auth in universal client ([ab0ccc4](https://github.com/go-redis/redis/commit/ab0ccc47413f9b2a6eabc852fed5005a3ee1af6e))\n+* add support for COPY command ([#2016](https://github.com/go-redis/redis/issues/2016)) ([730afbc](https://github.com/go-redis/redis/commit/730afbcffb93760e8a36cc06cfe55ab102b693a7))\n+* add support for passing extra attributes added to spans ([39faaa1](https://github.com/go-redis/redis/commit/39faaa171523834ba527c9789710c4fde87f5a2e))\n+* add support for time.Duration write and scan ([2f1b74e](https://github.com/go-redis/redis/commit/2f1b74e20cdd7719b2aecf0768d3e3ae7c3e781b))\n+* **redisotel:** ability to override TracerProvider ([#1998](https://github.com/go-redis/redis/issues/1998)) ([bf8d4aa](https://github.com/go-redis/redis/commit/bf8d4aa60c00366cda2e98c3ddddc8cf68507417))\n+* set net.peer.name and net.peer.port in otel example ([69bf454](https://github.com/go-redis/redis/commit/69bf454f706204211cd34835f76b2e8192d3766d))\n+\n+\n+\n+## [8.11.4](https://github.com/go-redis/redis/compare/v8.11.3...v8.11.4) (2021-10-04)\n+\n+\n+### Features\n+\n+* add acl auth support for sentinels ([f66582f](https://github.com/go-redis/redis/commit/f66582f44f3dc3a4705a5260f982043fde4aa634))\n+* add Cmd.{String,Int,Float,Bool}Slice helpers and an example ([5d3d293](https://github.com/go-redis/redis/commit/5d3d293cc9c60b90871e2420602001463708ce24))\n+* add SetVal method for each command ([168981d](https://github.com/go-redis/redis/commit/168981da2d84ee9e07d15d3e74d738c162e264c4))\n+\n+\n+\n+## v8.11\n+\n+- Remove OpenTelemetry metrics.\n+- Supports more redis commands and options.\n+\n+## v8.10\n+\n+- Removed extra OpenTelemetry spans from go-redis core. Now go-redis instrumentation only adds a\n+  single span with a Redis command (instead of 4 spans). There are multiple reasons behind this\n+  decision:\n+\n+  - Traces become smaller and less noisy.\n+  - It may be costly to process those 3 extra spans for each query.\n+  - go-redis no longer depends on OpenTelemetry.\n+\n+  Eventually we hope to replace the information that we no longer collect with OpenTelemetry\n+  Metrics.\n+\n+## v8.9\n+\n+- Changed `PubSub.Channel` to only rely on `Ping` result. You can now use `WithChannelSize`,\n+  `WithChannelHealthCheckInterval`, and `WithChannelSendTimeout` to override default settings.\n+\n+## v8.8\n+\n+- To make updating easier, extra modules now have the same version as go-redis does. That means that\n+  you need to update your imports:\n+\n+```\n+github.com/go-redis/redis/extra/redisotel -> github.com/go-redis/redis/extra/redisotel/v8\n+github.com/go-redis/redis/extra/rediscensus -> github.com/go-redis/redis/extra/rediscensus/v8\n+```\n+\n+## v8.5\n+\n+- [knadh](https://github.com/knadh) contributed long-awaited ability to scan Redis Hash into a\n+  struct:\n+\n+```go\n+err := rdb.HGetAll(ctx, \"hash\").Scan(&data)\n+\n+err := rdb.MGet(ctx, \"key1\", \"key2\").Scan(&data)\n+```\n+\n+- Please check [redismock](https://github.com/go-redis/redismock) by\n+  [monkey92t](https://github.com/monkey92t) if you are looking for mocking Redis Client.\n+\n+## v8\n+\n+- All commands require `context.Context` as a first argument, e.g. `rdb.Ping(ctx)`. If you are not\n+  using `context.Context` yet, the simplest option is to define global package variable\n+  `var ctx = context.TODO()` and use it when `ctx` is required.\n+\n+- Full support for `context.Context` canceling.\n+\n+- Added `redis.NewFailoverClusterClient` that supports routing read-only commands to a slave node.\n+\n+- Added `redisext.OpenTemetryHook` that adds\n+  [Redis OpenTelemetry instrumentation](https://redis.uptrace.dev/tracing/).\n+\n+- Redis slow log support.\n+\n+- Ring uses Rendezvous Hashing by default which provides better distribution. You need to move\n+  existing keys to a new location or keys will be inaccessible / lost. To use old hashing scheme:\n+\n+```go\n+import \"github.com/golang/groupcache/consistenthash\"\n+\n+ring := redis.NewRing(&redis.RingOptions{\n+    NewConsistentHash: func() {\n+        return consistenthash.New(100, crc32.ChecksumIEEE)\n+    },\n+})\n+```\n+\n+- `ClusterOptions.MaxRedirects` default value is changed from 8 to 3.\n+- `Options.MaxRetries` default value is changed from 0 to 3.\n+\n+- `Cluster.ForEachNode` is renamed to `ForEachShard` for consistency with `Ring`.\n+\n+## v7.3\n+\n+- New option `Options.Username` which causes client to use `AuthACL`. Be aware if your connection\n+  URL contains username.\n+\n+## v7.2\n+\n+- Existing `HMSet` is renamed to `HSet` and old deprecated `HMSet` is restored for Redis 3 users.\n+\n+## v7.1\n+\n+- Existing `Cmd.String` is renamed to `Cmd.Text`. New `Cmd.String` implements `fmt.Stringer`\n+  interface.\n+\n+## v7\n+\n+- _Important_. Tx.Pipeline now returns a non-transactional pipeline. Use Tx.TxPipeline for a\n+  transactional pipeline.\n+- WrapProcess is replaced with more convenient AddHook that has access to context.Context.\n+- WithContext now can not be used to create a shallow copy of the client.\n+- New methods ProcessContext, DoContext, and ExecContext.\n+- Client respects Context.Deadline when setting net.Conn deadline.\n+- Client listens on Context.Done while waiting for a connection from the pool and returns an error\n+  when context context is cancelled.\n+- Add PubSub.ChannelWithSubscriptions that sends `*Subscription` in addition to `*Message` to allow\n+  detecting reconnections.\n+- `time.Time` is now marshalled in RFC3339 format. `rdb.Get(\"foo\").Time()` helper is added to parse\n+  the time.\n+- `SetLimiter` is removed and added `Options.Limiter` instead.\n+- `HMSet` is deprecated as of Redis v4.\n+\n+## v6.15\n+\n+- Cluster and Ring pipelines process commands for each node in its own goroutine.\n+\n+## 6.14\n+\n+- Added Options.MinIdleConns.\n+- Added Options.MaxConnAge.\n+- PoolStats.FreeConns is renamed to PoolStats.IdleConns.\n+- Add Client.Do to simplify creating custom commands.\n+- Add Cmd.String, Cmd.Int, Cmd.Int64, Cmd.Uint64, Cmd.Float64, and Cmd.Bool helpers.\n+- Lower memory usage.\n+\n+## v6.13\n+\n+- Ring got new options called `HashReplicas` and `Hash`. It is recommended to set\n+  `HashReplicas = 1000` for better keys distribution between shards.\n+- Cluster client was optimized to use much less memory when reloading cluster state.\n+- PubSub.ReceiveMessage is re-worked to not use ReceiveTimeout so it does not lose data when timeout\n+  occurres. In most cases it is recommended to use PubSub.Channel instead.\n+- Dialer.KeepAlive is set to 5 minutes by default.\n+\n+## v6.12\n+\n+- ClusterClient got new option called `ClusterSlots` which allows to build cluster of normal Redis\n+  Servers that don't have cluster mode enabled. See\n+  https://godoc.org/github.com/go-redis/redis#example-NewClusterClient--ManualSetup"
    },
    {
      "sha": "298bed9beaf7d43c0d2c464d6fb36dcec733b3bb",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/LICENSE",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FLICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FLICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FLICENSE?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/LICENSE"
    },
    {
      "sha": "a4cfe0576e68c3485c7038c4af7debab5c0276cf",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/Makefile",
      "status": "added",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FMakefile",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FMakefile",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FMakefile?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,35 @@\n+PACKAGE_DIRS := $(shell find . -mindepth 2 -type f -name 'go.mod' -exec dirname {} \\; | sort)\n+\n+test: testdeps\n+\tgo test ./...\n+\tgo test ./... -short -race\n+\tgo test ./... -run=NONE -bench=. -benchmem\n+\tenv GOOS=linux GOARCH=386 go test ./...\n+\tgo vet\n+\n+testdeps: testdata/redis/src/redis-server\n+\n+bench: testdeps\n+\tgo test ./... -test.run=NONE -test.bench=. -test.benchmem\n+\n+.PHONY: all test testdeps bench\n+\n+testdata/redis:\n+\tmkdir -p $@\n+\twget -qO- https://download.redis.io/releases/redis-6.2.5.tar.gz | tar xvz --strip-components=1 -C $@\n+\n+testdata/redis/src/redis-server: testdata/redis\n+\tcd $< && make all\n+\n+fmt:\n+\tgofmt -w -s ./\n+\tgoimports -w  -local github.com/go-redis/redis ./\n+\n+go_mod_tidy:\n+\tgo get -u && go mod tidy\n+\tset -e; for dir in $(PACKAGE_DIRS); do \\\n+\t  echo \"go mod tidy in $${dir}\"; \\\n+\t  (cd \"$${dir}\" && \\\n+\t    go get -u && \\\n+\t    go mod tidy); \\\n+\tdone"
    },
    {
      "sha": "f3b6a018cb545dfa0ff4eeb309a17eee7340727a",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/README.md",
      "status": "added",
      "additions": 175,
      "deletions": 0,
      "changes": 175,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FREADME.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FREADME.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FREADME.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,175 @@\n+# Redis client for Go\n+\n+![build workflow](https://github.com/go-redis/redis/actions/workflows/build.yml/badge.svg)\n+[![PkgGoDev](https://pkg.go.dev/badge/github.com/go-redis/redis/v8)](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc)\n+[![Documentation](https://img.shields.io/badge/redis-documentation-informational)](https://redis.uptrace.dev/)\n+\n+go-redis is brought to you by :star: [**uptrace/uptrace**](https://github.com/uptrace/uptrace).\n+Uptrace is an open source and blazingly fast **distributed tracing** backend powered by\n+OpenTelemetry and ClickHouse. Give it a star as well!\n+\n+## Resources\n+\n+- [Discussions](https://github.com/go-redis/redis/discussions)\n+- [Documentation](https://redis.uptrace.dev)\n+- [Reference](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc)\n+- [Examples](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#pkg-examples)\n+- [RealWorld example app](https://github.com/uptrace/go-treemux-realworld-example-app)\n+\n+Other projects you may like:\n+\n+- [Bun](https://bun.uptrace.dev) - fast and simple SQL client for PostgreSQL, MySQL, and SQLite.\n+- [BunRouter](https://bunrouter.uptrace.dev/) - fast and flexible HTTP router for Go.\n+\n+## Ecosystem\n+\n+- [Redis Mock](https://github.com/go-redis/redismock)\n+- [Distributed Locks](https://github.com/bsm/redislock)\n+- [Redis Cache](https://github.com/go-redis/cache)\n+- [Rate limiting](https://github.com/go-redis/redis_rate)\n+\n+## Features\n+\n+- Redis 3 commands except QUIT, MONITOR, and SYNC.\n+- Automatic connection pooling with\n+  [circuit breaker](https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern) support.\n+- [Pub/Sub](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#PubSub).\n+- [Transactions](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#example-Client-TxPipeline).\n+- [Pipeline](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#example-Client.Pipeline) and\n+  [TxPipeline](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#example-Client.TxPipeline).\n+- [Scripting](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#Script).\n+- [Timeouts](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#Options).\n+- [Redis Sentinel](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#NewFailoverClient).\n+- [Redis Cluster](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#NewClusterClient).\n+- [Cluster of Redis Servers](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#example-NewClusterClient-ManualSetup)\n+  without using cluster mode and Redis Sentinel.\n+- [Ring](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#NewRing).\n+- [Instrumentation](https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc#example-package-Instrumentation).\n+\n+## Installation\n+\n+go-redis supports 2 last Go versions and requires a Go version with\n+[modules](https://github.com/golang/go/wiki/Modules) support. So make sure to initialize a Go\n+module:\n+\n+```shell\n+go mod init github.com/my/repo\n+```\n+\n+And then install go-redis/v8 (note _v8_ in the import; omitting it is a popular mistake):\n+\n+```shell\n+go get github.com/go-redis/redis/v8\n+```\n+\n+## Quickstart\n+\n+```go\n+import (\n+    \"context\"\n+    \"github.com/go-redis/redis/v8\"\n+    \"fmt\"\n+)\n+\n+var ctx = context.Background()\n+\n+func ExampleClient() {\n+    rdb := redis.NewClient(&redis.Options{\n+        Addr:     \"localhost:6379\",\n+        Password: \"\", // no password set\n+        DB:       0,  // use default DB\n+    })\n+\n+    err := rdb.Set(ctx, \"key\", \"value\", 0).Err()\n+    if err != nil {\n+        panic(err)\n+    }\n+\n+    val, err := rdb.Get(ctx, \"key\").Result()\n+    if err != nil {\n+        panic(err)\n+    }\n+    fmt.Println(\"key\", val)\n+\n+    val2, err := rdb.Get(ctx, \"key2\").Result()\n+    if err == redis.Nil {\n+        fmt.Println(\"key2 does not exist\")\n+    } else if err != nil {\n+        panic(err)\n+    } else {\n+        fmt.Println(\"key2\", val2)\n+    }\n+    // Output: key value\n+    // key2 does not exist\n+}\n+```\n+\n+## Look and feel\n+\n+Some corner cases:\n+\n+```go\n+// SET key value EX 10 NX\n+set, err := rdb.SetNX(ctx, \"key\", \"value\", 10*time.Second).Result()\n+\n+// SET key value keepttl NX\n+set, err := rdb.SetNX(ctx, \"key\", \"value\", redis.KeepTTL).Result()\n+\n+// SORT list LIMIT 0 2 ASC\n+vals, err := rdb.Sort(ctx, \"list\", &redis.Sort{Offset: 0, Count: 2, Order: \"ASC\"}).Result()\n+\n+// ZRANGEBYSCORE zset -inf +inf WITHSCORES LIMIT 0 2\n+vals, err := rdb.ZRangeByScoreWithScores(ctx, \"zset\", &redis.ZRangeBy{\n+    Min: \"-inf\",\n+    Max: \"+inf\",\n+    Offset: 0,\n+    Count: 2,\n+}).Result()\n+\n+// ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3 AGGREGATE SUM\n+vals, err := rdb.ZInterStore(ctx, \"out\", &redis.ZStore{\n+    Keys: []string{\"zset1\", \"zset2\"},\n+    Weights: []int64{2, 3}\n+}).Result()\n+\n+// EVAL \"return {KEYS[1],ARGV[1]}\" 1 \"key\" \"hello\"\n+vals, err := rdb.Eval(ctx, \"return {KEYS[1],ARGV[1]}\", []string{\"key\"}, \"hello\").Result()\n+\n+// custom command\n+res, err := rdb.Do(ctx, \"set\", \"key\", \"value\").Result()\n+```\n+\n+## Run the test\n+\n+go-redis will start a redis-server and run the test cases.\n+\n+The paths of redis-server bin file and redis config file are defined in `main_test.go`:\n+\n+```\n+var (\n+\tredisServerBin, _  = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"src\", \"redis-server\"))\n+\tredisServerConf, _ = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"redis.conf\"))\n+)\n+```\n+\n+For local testing, you can change the variables to refer to your local files, or create a soft link\n+to the corresponding folder for redis-server and copy the config file to `testdata/redis/`:\n+\n+```\n+ln -s /usr/bin/redis-server ./go-redis/testdata/redis/src\n+cp ./go-redis/testdata/redis.conf ./go-redis/testdata/redis/\n+```\n+\n+Lastly, run:\n+\n+```\n+go test\n+```\n+\n+## Contributors\n+\n+Thanks to all the people who already contributed!\n+\n+<a href=\"https://github.com/go-redis/redis/graphs/contributors\">\n+  <img src=\"https://contributors-img.web.app/image?repo=go-redis/redis\" />\n+</a>"
    },
    {
      "sha": "1115db4e3e57c45499472abb4ff5a3219150226d",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/RELEASING.md",
      "status": "added",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FRELEASING.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FRELEASING.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2FRELEASING.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,15 @@\n+# Releasing\n+\n+1. Run `release.sh` script which updates versions in go.mod files and pushes a new branch to GitHub:\n+\n+```shell\n+TAG=v1.0.0 ./scripts/release.sh\n+```\n+\n+2. Open a pull request and wait for the build to finish.\n+\n+3. Merge the pull request and run `tag.sh` to create tags for packages:\n+\n+```shell\n+TAG=v1.0.0 ./scripts/tag.sh\n+```"
    },
    {
      "sha": "a54f2f37ed9cb532e48f63e92ad7bb6aaebafa7f",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/cluster.go",
      "status": "renamed",
      "additions": 287,
      "deletions": 206,
      "changes": 493,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcluster.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcluster.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcluster.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -5,18 +5,18 @@ import (\n \t\"crypto/tls\"\n \t\"fmt\"\n \t\"math\"\n-\t\"math/rand\"\n \t\"net\"\n \t\"runtime\"\n \t\"sort\"\n \t\"sync\"\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal\"\n-\t\"github.com/go-redis/redis/v7/internal/hashtag\"\n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal\"\n+\t\"github.com/go-redis/redis/v8/internal/hashtag\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal/rand\"\n )\n \n var errClusterNoNodes = fmt.Errorf(\"redis: cluster has no nodes\")\n@@ -27,9 +27,12 @@ type ClusterOptions struct {\n \t// A seed list of host:port addresses of cluster nodes.\n \tAddrs []string\n \n+\t// NewClient creates a cluster node client with provided name and options.\n+\tNewClient func(opt *Options) *Client\n+\n \t// The maximum number of retries before giving up. Command is retried\n \t// on network errors and MOVED/ASK redirects.\n-\t// Default is 8 retries.\n+\t// Default is 3 retries.\n \tMaxRedirects int\n \n \t// Enables read-only commands on slave nodes.\n@@ -46,16 +49,13 @@ type ClusterOptions struct {\n \t// and load-balance read/write operations between master and slaves.\n \t// It can use service like ZooKeeper to maintain configuration information\n \t// and Cluster.ReloadState to manually trigger state reloading.\n-\tClusterSlots func() ([]ClusterSlot, error)\n-\n-\t// Optional hook that is called when a new node is created.\n-\tOnNewNode func(*Client)\n+\tClusterSlots func(context.Context) ([]ClusterSlot, error)\n \n \t// Following options are copied from Options struct.\n \n \tDialer func(ctx context.Context, network, addr string) (net.Conn, error)\n \n-\tOnConnect func(*Conn) error\n+\tOnConnect func(ctx context.Context, cn *Conn) error\n \n \tUsername string\n \tPassword string\n@@ -68,8 +68,8 @@ type ClusterOptions struct {\n \tReadTimeout  time.Duration\n \tWriteTimeout time.Duration\n \n-\t// NewClient creates a cluster node client with provided name and options.\n-\tNewClient func(opt *Options) *Client\n+\t// PoolFIFO uses FIFO mode for each node connection pool GET/PUT (default LIFO).\n+\tPoolFIFO bool\n \n \t// PoolSize applies per cluster node and not for the whole cluster.\n \tPoolSize           int\n@@ -86,15 +86,15 @@ func (opt *ClusterOptions) init() {\n \tif opt.MaxRedirects == -1 {\n \t\topt.MaxRedirects = 0\n \t} else if opt.MaxRedirects == 0 {\n-\t\topt.MaxRedirects = 8\n+\t\topt.MaxRedirects = 3\n \t}\n \n-\tif (opt.RouteByLatency || opt.RouteRandomly) && opt.ClusterSlots == nil {\n+\tif opt.RouteByLatency || opt.RouteRandomly {\n \t\topt.ReadOnly = true\n \t}\n \n \tif opt.PoolSize == 0 {\n-\t\topt.PoolSize = 5 * runtime.NumCPU()\n+\t\topt.PoolSize = 5 * runtime.GOMAXPROCS(0)\n \t}\n \n \tswitch opt.ReadTimeout {\n@@ -110,6 +110,9 @@ func (opt *ClusterOptions) init() {\n \t\topt.WriteTimeout = opt.ReadTimeout\n \t}\n \n+\tif opt.MaxRetries == 0 {\n+\t\topt.MaxRetries = -1\n+\t}\n \tswitch opt.MinRetryBackoff {\n \tcase -1:\n \t\topt.MinRetryBackoff = 0\n@@ -135,17 +138,18 @@ func (opt *ClusterOptions) clientOptions() *Options {\n \t\tDialer:    opt.Dialer,\n \t\tOnConnect: opt.OnConnect,\n \n+\t\tUsername: opt.Username,\n+\t\tPassword: opt.Password,\n+\n \t\tMaxRetries:      opt.MaxRetries,\n \t\tMinRetryBackoff: opt.MinRetryBackoff,\n \t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n-\t\tUsername:        opt.Username,\n-\t\tPassword:        opt.Password,\n-\t\treadOnly:        opt.ReadOnly,\n \n \t\tDialTimeout:  opt.DialTimeout,\n \t\tReadTimeout:  opt.ReadTimeout,\n \t\tWriteTimeout: opt.WriteTimeout,\n \n+\t\tPoolFIFO:           opt.PoolFIFO,\n \t\tPoolSize:           opt.PoolSize,\n \t\tMinIdleConns:       opt.MinIdleConns,\n \t\tMaxConnAge:         opt.MaxConnAge,\n@@ -154,6 +158,12 @@ func (opt *ClusterOptions) clientOptions() *Options {\n \t\tIdleCheckFrequency: disableIdleCheck,\n \n \t\tTLSConfig: opt.TLSConfig,\n+\t\t// If ClusterSlots is populated, then we probably have an artificial\n+\t\t// cluster whose nodes are not in clustering mode (otherwise there isn't\n+\t\t// much use for ClusterSlots config).  This means we cannot execute the\n+\t\t// READONLY command against that node -- setting readOnly to false in such\n+\t\t// situations in the options below will prevent that from happening.\n+\t\treadOnly: opt.ReadOnly && opt.ClusterSlots == nil,\n \t}\n }\n \n@@ -179,10 +189,6 @@ func newClusterNode(clOpt *ClusterOptions, addr string) *clusterNode {\n \t\tgo node.updateLatency()\n \t}\n \n-\tif clOpt.OnNewNode != nil {\n-\t\tclOpt.OnNewNode(node.Client)\n-\t}\n-\n \treturn &node\n }\n \n@@ -195,16 +201,19 @@ func (n *clusterNode) Close() error {\n }\n \n func (n *clusterNode) updateLatency() {\n-\tconst probes = 10\n+\tconst numProbe = 10\n+\tvar dur uint64\n+\n+\tfor i := 0; i < numProbe; i++ {\n+\t\ttime.Sleep(time.Duration(10+rand.Intn(10)) * time.Millisecond)\n \n-\tvar latency uint32\n-\tfor i := 0; i < probes; i++ {\n \t\tstart := time.Now()\n-\t\tn.Client.Ping()\n-\t\tprobe := uint32(time.Since(start) / time.Microsecond)\n-\t\tlatency = (latency + probe) / 2\n+\t\tn.Client.Ping(context.TODO())\n+\t\tdur += uint64(time.Since(start) / time.Microsecond)\n \t}\n-\tatomic.StoreUint32(&n.latency, latency)\n+\n+\tlatency := float64(dur) / float64(numProbe)\n+\tatomic.StoreUint32(&n.latency, uint32(latency+0.5))\n }\n \n func (n *clusterNode) Latency() time.Duration {\n@@ -248,11 +257,11 @@ func (n *clusterNode) SetGeneration(gen uint32) {\n type clusterNodes struct {\n \topt *ClusterOptions\n \n-\tmu           sync.RWMutex\n-\tallAddrs     []string\n-\tallNodes     map[string]*clusterNode\n-\tclusterAddrs []string\n-\tclosed       bool\n+\tmu          sync.RWMutex\n+\taddrs       []string\n+\tnodes       map[string]*clusterNode\n+\tactiveAddrs []string\n+\tclosed      bool\n \n \t_generation uint32 // atomic\n }\n@@ -261,8 +270,8 @@ func newClusterNodes(opt *ClusterOptions) *clusterNodes {\n \treturn &clusterNodes{\n \t\topt: opt,\n \n-\t\tallAddrs: opt.Addrs,\n-\t\tallNodes: make(map[string]*clusterNode),\n+\t\taddrs: opt.Addrs,\n+\t\tnodes: make(map[string]*clusterNode),\n \t}\n }\n \n@@ -276,27 +285,28 @@ func (c *clusterNodes) Close() error {\n \tc.closed = true\n \n \tvar firstErr error\n-\tfor _, node := range c.allNodes {\n+\tfor _, node := range c.nodes {\n \t\tif err := node.Client.Close(); err != nil && firstErr == nil {\n \t\t\tfirstErr = err\n \t\t}\n \t}\n \n-\tc.allNodes = nil\n-\tc.clusterAddrs = nil\n+\tc.nodes = nil\n+\tc.activeAddrs = nil\n \n \treturn firstErr\n }\n \n func (c *clusterNodes) Addrs() ([]string, error) {\n \tvar addrs []string\n+\n \tc.mu.RLock()\n-\tclosed := c.closed\n+\tclosed := c.closed //nolint:ifshort\n \tif !closed {\n-\t\tif len(c.clusterAddrs) > 0 {\n-\t\t\taddrs = c.clusterAddrs\n+\t\tif len(c.activeAddrs) > 0 {\n+\t\t\taddrs = c.activeAddrs\n \t\t} else {\n-\t\t\taddrs = c.allAddrs\n+\t\t\taddrs = c.addrs\n \t\t}\n \t}\n \tc.mu.RUnlock()\n@@ -318,24 +328,31 @@ func (c *clusterNodes) NextGeneration() uint32 {\n func (c *clusterNodes) GC(generation uint32) {\n \t//nolint:prealloc\n \tvar collected []*clusterNode\n+\n \tc.mu.Lock()\n-\tfor addr, node := range c.allNodes {\n+\n+\tc.activeAddrs = c.activeAddrs[:0]\n+\tfor addr, node := range c.nodes {\n \t\tif node.Generation() >= generation {\n+\t\t\tc.activeAddrs = append(c.activeAddrs, addr)\n+\t\t\tif c.opt.RouteByLatency {\n+\t\t\t\tgo node.updateLatency()\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tc.clusterAddrs = remove(c.clusterAddrs, addr)\n-\t\tdelete(c.allNodes, addr)\n+\t\tdelete(c.nodes, addr)\n \t\tcollected = append(collected, node)\n \t}\n+\n \tc.mu.Unlock()\n \n \tfor _, node := range collected {\n \t\t_ = node.Client.Close()\n \t}\n }\n \n-func (c *clusterNodes) Get(addr string) (*clusterNode, error) {\n+func (c *clusterNodes) GetOrCreate(addr string) (*clusterNode, error) {\n \tnode, err := c.get(addr)\n \tif err != nil {\n \t\treturn nil, err\n@@ -351,18 +368,17 @@ func (c *clusterNodes) Get(addr string) (*clusterNode, error) {\n \t\treturn nil, pool.ErrClosed\n \t}\n \n-\tnode, ok := c.allNodes[addr]\n+\tnode, ok := c.nodes[addr]\n \tif ok {\n-\t\treturn node, err\n+\t\treturn node, nil\n \t}\n \n \tnode = newClusterNode(c.opt, addr)\n \n-\tc.allAddrs = appendIfNotExists(c.allAddrs, addr)\n-\tc.clusterAddrs = append(c.clusterAddrs, addr)\n-\tc.allNodes[addr] = node\n+\tc.addrs = appendIfNotExists(c.addrs, addr)\n+\tc.nodes[addr] = node\n \n-\treturn node, err\n+\treturn node, nil\n }\n \n func (c *clusterNodes) get(addr string) (*clusterNode, error) {\n@@ -372,7 +388,7 @@ func (c *clusterNodes) get(addr string) (*clusterNode, error) {\n \tif c.closed {\n \t\terr = pool.ErrClosed\n \t} else {\n-\t\tnode = c.allNodes[addr]\n+\t\tnode = c.nodes[addr]\n \t}\n \tc.mu.RUnlock()\n \treturn node, err\n@@ -386,8 +402,8 @@ func (c *clusterNodes) All() ([]*clusterNode, error) {\n \t\treturn nil, pool.ErrClosed\n \t}\n \n-\tcp := make([]*clusterNode, 0, len(c.allNodes))\n-\tfor _, node := range c.allNodes {\n+\tcp := make([]*clusterNode, 0, len(c.nodes))\n+\tfor _, node := range c.nodes {\n \t\tcp = append(cp, node)\n \t}\n \treturn cp, nil\n@@ -400,7 +416,7 @@ func (c *clusterNodes) Random() (*clusterNode, error) {\n \t}\n \n \tn := rand.Intn(len(addrs))\n-\treturn c.Get(addrs[n])\n+\treturn c.GetOrCreate(addrs[n])\n }\n \n //------------------------------------------------------------------------------\n@@ -458,7 +474,7 @@ func newClusterState(\n \t\t\t\taddr = replaceLoopbackHost(addr, originHost)\n \t\t\t}\n \n-\t\t\tnode, err := c.nodes.Get(addr)\n+\t\t\tnode, err := c.nodes.GetOrCreate(addr)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n@@ -552,8 +568,6 @@ func (c *clusterState) slotSlaveNode(slot int) (*clusterNode, error) {\n }\n \n func (c *clusterState) slotClosestNode(slot int) (*clusterNode, error) {\n-\tconst threshold = time.Millisecond\n-\n \tnodes := c.slotNodes(slot)\n \tif len(nodes) == 0 {\n \t\treturn c.nodes.Random()\n@@ -564,20 +578,33 @@ func (c *clusterState) slotClosestNode(slot int) (*clusterNode, error) {\n \t\tif n.Failing() {\n \t\t\tcontinue\n \t\t}\n-\t\tif node == nil || node.Latency()-n.Latency() > threshold {\n+\t\tif node == nil || n.Latency() < node.Latency() {\n \t\t\tnode = n\n \t\t}\n \t}\n-\treturn node, nil\n+\tif node != nil {\n+\t\treturn node, nil\n+\t}\n+\n+\t// If all nodes are failing - return random node\n+\treturn c.nodes.Random()\n }\n \n func (c *clusterState) slotRandomNode(slot int) (*clusterNode, error) {\n \tnodes := c.slotNodes(slot)\n \tif len(nodes) == 0 {\n \t\treturn c.nodes.Random()\n \t}\n-\tn := rand.Intn(len(nodes))\n-\treturn nodes[n], nil\n+\tif len(nodes) == 1 {\n+\t\treturn nodes[0], nil\n+\t}\n+\trandomNodes := rand.Perm(len(nodes))\n+\tfor _, idx := range randomNodes {\n+\t\tif node := nodes[idx]; !node.Failing() {\n+\t\t\treturn node, nil\n+\t\t}\n+\t}\n+\treturn nodes[randomNodes[0]], nil\n }\n \n func (c *clusterState) slotNodes(slot int) []*clusterNode {\n@@ -597,20 +624,20 @@ func (c *clusterState) slotNodes(slot int) []*clusterNode {\n //------------------------------------------------------------------------------\n \n type clusterStateHolder struct {\n-\tload func() (*clusterState, error)\n+\tload func(ctx context.Context) (*clusterState, error)\n \n \tstate     atomic.Value\n \treloading uint32 // atomic\n }\n \n-func newClusterStateHolder(fn func() (*clusterState, error)) *clusterStateHolder {\n+func newClusterStateHolder(fn func(ctx context.Context) (*clusterState, error)) *clusterStateHolder {\n \treturn &clusterStateHolder{\n \t\tload: fn,\n \t}\n }\n \n-func (c *clusterStateHolder) Reload() (*clusterState, error) {\n-\tstate, err := c.load()\n+func (c *clusterStateHolder) Reload(ctx context.Context) (*clusterState, error) {\n+\tstate, err := c.load(ctx)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -625,32 +652,33 @@ func (c *clusterStateHolder) LazyReload() {\n \tgo func() {\n \t\tdefer atomic.StoreUint32(&c.reloading, 0)\n \n-\t\t_, err := c.Reload()\n+\t\t_, err := c.Reload(context.Background())\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n-\t\ttime.Sleep(100 * time.Millisecond)\n+\t\ttime.Sleep(200 * time.Millisecond)\n \t}()\n }\n \n-func (c *clusterStateHolder) Get() (*clusterState, error) {\n+func (c *clusterStateHolder) Get(ctx context.Context) (*clusterState, error) {\n \tv := c.state.Load()\n-\tif v != nil {\n-\t\tstate := v.(*clusterState)\n-\t\tif time.Since(state.createdAt) > time.Minute {\n-\t\t\tc.LazyReload()\n-\t\t}\n-\t\treturn state, nil\n+\tif v == nil {\n+\t\treturn c.Reload(ctx)\n \t}\n-\treturn c.Reload()\n+\n+\tstate := v.(*clusterState)\n+\tif time.Since(state.createdAt) > 10*time.Second {\n+\t\tc.LazyReload()\n+\t}\n+\treturn state, nil\n }\n \n-func (c *clusterStateHolder) ReloadOrGet() (*clusterState, error) {\n-\tstate, err := c.Reload()\n+func (c *clusterStateHolder) ReloadOrGet(ctx context.Context) (*clusterState, error) {\n+\tstate, err := c.Reload(ctx)\n \tif err == nil {\n \t\treturn state, nil\n \t}\n-\treturn c.Get()\n+\treturn c.Get(ctx)\n }\n \n //------------------------------------------------------------------------------\n@@ -717,9 +745,8 @@ func (c *ClusterClient) Options() *ClusterOptions {\n \n // ReloadState reloads cluster state. If available it calls ClusterSlots func\n // to get cluster slots information.\n-func (c *ClusterClient) ReloadState() error {\n-\t_, err := c.state.Reload()\n-\treturn err\n+func (c *ClusterClient) ReloadState(ctx context.Context) {\n+\tc.state.LazyReload()\n }\n \n // Close closes the cluster client, releasing any open resources.\n@@ -731,34 +758,17 @@ func (c *ClusterClient) Close() error {\n }\n \n // Do creates a Cmd from the args and processes the cmd.\n-func (c *ClusterClient) Do(args ...interface{}) *Cmd {\n-\treturn c.DoContext(c.ctx, args...)\n-}\n-\n-func (c *ClusterClient) DoContext(ctx context.Context, args ...interface{}) *Cmd {\n-\tcmd := NewCmd(args...)\n-\t_ = c.ProcessContext(ctx, cmd)\n+func (c *ClusterClient) Do(ctx context.Context, args ...interface{}) *Cmd {\n+\tcmd := NewCmd(ctx, args...)\n+\t_ = c.Process(ctx, cmd)\n \treturn cmd\n }\n \n-func (c *ClusterClient) Process(cmd Cmder) error {\n-\treturn c.ProcessContext(c.ctx, cmd)\n-}\n-\n-func (c *ClusterClient) ProcessContext(ctx context.Context, cmd Cmder) error {\n+func (c *ClusterClient) Process(ctx context.Context, cmd Cmder) error {\n \treturn c.hooks.process(ctx, cmd, c.process)\n }\n \n func (c *ClusterClient) process(ctx context.Context, cmd Cmder) error {\n-\terr := c._process(ctx, cmd)\n-\tif err != nil {\n-\t\tcmd.SetErr(err)\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (c *ClusterClient) _process(ctx context.Context, cmd Cmder) error {\n \tcmdInfo := c.cmdInfo(cmd.Name())\n \tslot := c.cmdSlot(cmd)\n \n@@ -774,31 +784,31 @@ func (c *ClusterClient) _process(ctx context.Context, cmd Cmder) error {\n \n \t\tif node == nil {\n \t\t\tvar err error\n-\t\t\tnode, err = c.cmdNode(cmdInfo, slot)\n+\t\t\tnode, err = c.cmdNode(ctx, cmdInfo, slot)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \n \t\tif ask {\n \t\t\tpipe := node.Client.Pipeline()\n-\t\t\t_ = pipe.Process(NewCmd(\"asking\"))\n-\t\t\t_ = pipe.Process(cmd)\n-\t\t\t_, lastErr = pipe.ExecContext(ctx)\n+\t\t\t_ = pipe.Process(ctx, NewCmd(ctx, \"asking\"))\n+\t\t\t_ = pipe.Process(ctx, cmd)\n+\t\t\t_, lastErr = pipe.Exec(ctx)\n \t\t\t_ = pipe.Close()\n \t\t\task = false\n \t\t} else {\n-\t\t\tlastErr = node.Client.ProcessContext(ctx, cmd)\n+\t\t\tlastErr = node.Client.Process(ctx, cmd)\n \t\t}\n \n \t\t// If there is no error - we are done.\n \t\tif lastErr == nil {\n \t\t\treturn nil\n \t\t}\n-\t\tif lastErr != Nil {\n-\t\t\tc.state.LazyReload()\n-\t\t}\n-\t\tif lastErr == pool.ErrClosed || isReadOnlyError(lastErr) {\n+\t\tif isReadOnly := isReadOnlyError(lastErr); isReadOnly || lastErr == pool.ErrClosed {\n+\t\t\tif isReadOnly {\n+\t\t\t\tc.state.LazyReload()\n+\t\t\t}\n \t\t\tnode = nil\n \t\t\tcontinue\n \t\t}\n@@ -814,15 +824,17 @@ func (c *ClusterClient) _process(ctx context.Context, cmd Cmder) error {\n \t\tvar addr string\n \t\tmoved, ask, addr = isMovedError(lastErr)\n \t\tif moved || ask {\n+\t\t\tc.state.LazyReload()\n+\n \t\t\tvar err error\n-\t\t\tnode, err = c.nodes.Get(addr)\n+\t\t\tnode, err = c.nodes.GetOrCreate(addr)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tif isRetryableError(lastErr, cmd.readTimeout() == nil) {\n+\t\tif shouldRetry(lastErr, cmd.readTimeout() == nil) {\n \t\t\t// First retry the same node.\n \t\t\tif attempt == 0 {\n \t\t\t\tcontinue\n@@ -841,8 +853,11 @@ func (c *ClusterClient) _process(ctx context.Context, cmd Cmder) error {\n \n // ForEachMaster concurrently calls the fn on each master node in the cluster.\n // It returns the first error if any.\n-func (c *ClusterClient) ForEachMaster(fn func(client *Client) error) error {\n-\tstate, err := c.state.ReloadOrGet()\n+func (c *ClusterClient) ForEachMaster(\n+\tctx context.Context,\n+\tfn func(ctx context.Context, client *Client) error,\n+) error {\n+\tstate, err := c.state.ReloadOrGet(ctx)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -854,7 +869,7 @@ func (c *ClusterClient) ForEachMaster(fn func(client *Client) error) error {\n \t\twg.Add(1)\n \t\tgo func(node *clusterNode) {\n \t\t\tdefer wg.Done()\n-\t\t\terr := fn(node.Client)\n+\t\t\terr := fn(ctx, node.Client)\n \t\t\tif err != nil {\n \t\t\t\tselect {\n \t\t\t\tcase errCh <- err:\n@@ -876,8 +891,11 @@ func (c *ClusterClient) ForEachMaster(fn func(client *Client) error) error {\n \n // ForEachSlave concurrently calls the fn on each slave node in the cluster.\n // It returns the first error if any.\n-func (c *ClusterClient) ForEachSlave(fn func(client *Client) error) error {\n-\tstate, err := c.state.ReloadOrGet()\n+func (c *ClusterClient) ForEachSlave(\n+\tctx context.Context,\n+\tfn func(ctx context.Context, client *Client) error,\n+) error {\n+\tstate, err := c.state.ReloadOrGet(ctx)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -889,7 +907,7 @@ func (c *ClusterClient) ForEachSlave(fn func(client *Client) error) error {\n \t\twg.Add(1)\n \t\tgo func(node *clusterNode) {\n \t\t\tdefer wg.Done()\n-\t\t\terr := fn(node.Client)\n+\t\t\terr := fn(ctx, node.Client)\n \t\t\tif err != nil {\n \t\t\t\tselect {\n \t\t\t\tcase errCh <- err:\n@@ -909,10 +927,13 @@ func (c *ClusterClient) ForEachSlave(fn func(client *Client) error) error {\n \t}\n }\n \n-// ForEachNode concurrently calls the fn on each known node in the cluster.\n+// ForEachShard concurrently calls the fn on each known node in the cluster.\n // It returns the first error if any.\n-func (c *ClusterClient) ForEachNode(fn func(client *Client) error) error {\n-\tstate, err := c.state.ReloadOrGet()\n+func (c *ClusterClient) ForEachShard(\n+\tctx context.Context,\n+\tfn func(ctx context.Context, client *Client) error,\n+) error {\n+\tstate, err := c.state.ReloadOrGet(ctx)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -922,7 +943,7 @@ func (c *ClusterClient) ForEachNode(fn func(client *Client) error) error {\n \n \tworker := func(node *clusterNode) {\n \t\tdefer wg.Done()\n-\t\terr := fn(node.Client)\n+\t\terr := fn(ctx, node.Client)\n \t\tif err != nil {\n \t\t\tselect {\n \t\t\tcase errCh <- err:\n@@ -954,7 +975,7 @@ func (c *ClusterClient) ForEachNode(fn func(client *Client) error) error {\n func (c *ClusterClient) PoolStats() *PoolStats {\n \tvar acc PoolStats\n \n-\tstate, _ := c.state.Get()\n+\tstate, _ := c.state.Get(context.TODO())\n \tif state == nil {\n \t\treturn &acc\n \t}\n@@ -984,9 +1005,9 @@ func (c *ClusterClient) PoolStats() *PoolStats {\n \treturn &acc\n }\n \n-func (c *ClusterClient) loadState() (*clusterState, error) {\n+func (c *ClusterClient) loadState(ctx context.Context) (*clusterState, error) {\n \tif c.opt.ClusterSlots != nil {\n-\t\tslots, err := c.opt.ClusterSlots()\n+\t\tslots, err := c.opt.ClusterSlots(ctx)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -999,16 +1020,19 @@ func (c *ClusterClient) loadState() (*clusterState, error) {\n \t}\n \n \tvar firstErr error\n-\tfor _, addr := range addrs {\n-\t\tnode, err := c.nodes.Get(addr)\n+\n+\tfor _, idx := range rand.Perm(len(addrs)) {\n+\t\taddr := addrs[idx]\n+\n+\t\tnode, err := c.nodes.GetOrCreate(addr)\n \t\tif err != nil {\n \t\t\tif firstErr == nil {\n \t\t\t\tfirstErr = err\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tslots, err := node.Client.ClusterSlots().Result()\n+\t\tslots, err := node.Client.ClusterSlots(ctx).Result()\n \t\tif err != nil {\n \t\t\tif firstErr == nil {\n \t\t\t\tfirstErr = err\n@@ -1019,6 +1043,16 @@ func (c *ClusterClient) loadState() (*clusterState, error) {\n \t\treturn newClusterState(c.nodes, slots, node.Client.opt.Addr)\n \t}\n \n+\t/*\n+\t * No node is connectable. It's possible that all nodes' IP has changed.\n+\t * Clear activeAddrs to let client be able to re-connect using the initial\n+\t * setting of the addresses (e.g. [redis-cluster-0:6379, redis-cluster-1:6379]),\n+\t * which might have chance to resolve domain name and get updated IP address.\n+\t */\n+\tc.nodes.mu.Lock()\n+\tc.nodes.activeAddrs = nil\n+\tc.nodes.mu.Unlock()\n+\n \treturn nil, firstErr\n }\n \n@@ -1036,7 +1070,7 @@ func (c *ClusterClient) reaper(idleCheckFrequency time.Duration) {\n \t\tfor _, node := range nodes {\n \t\t\t_, err := node.Client.connPool.(*pool.ConnPool).ReapStaleConns()\n \t\t\tif err != nil {\n-\t\t\t\tinternal.Logger.Printf(\"ReapStaleConns failed: %s\", err)\n+\t\t\t\tinternal.Logger.Printf(c.Context(), \"ReapStaleConns failed: %s\", err)\n \t\t\t}\n \t\t}\n \t}\n@@ -1051,8 +1085,8 @@ func (c *ClusterClient) Pipeline() Pipeliner {\n \treturn &pipe\n }\n \n-func (c *ClusterClient) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.Pipeline().Pipelined(fn)\n+func (c *ClusterClient) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.Pipeline().Pipelined(ctx, fn)\n }\n \n func (c *ClusterClient) processPipeline(ctx context.Context, cmds []Cmder) error {\n@@ -1061,7 +1095,7 @@ func (c *ClusterClient) processPipeline(ctx context.Context, cmds []Cmder) error\n \n func (c *ClusterClient) _processPipeline(ctx context.Context, cmds []Cmder) error {\n \tcmdsMap := newCmdsMap()\n-\terr := c.mapCmdsByNode(cmdsMap, cmds)\n+\terr := c.mapCmdsByNode(ctx, cmdsMap, cmds)\n \tif err != nil {\n \t\tsetCmdsErr(cmds, err)\n \t\treturn err\n@@ -1088,7 +1122,7 @@ func (c *ClusterClient) _processPipeline(ctx context.Context, cmds []Cmder) erro\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tif attempt < c.opt.MaxRedirects {\n-\t\t\t\t\tif err := c.mapCmdsByNode(failedCmds, cmds); err != nil {\n+\t\t\t\t\tif err := c.mapCmdsByNode(ctx, failedCmds, cmds); err != nil {\n \t\t\t\t\t\tsetCmdsErr(cmds, err)\n \t\t\t\t\t}\n \t\t\t\t} else {\n@@ -1107,8 +1141,8 @@ func (c *ClusterClient) _processPipeline(ctx context.Context, cmds []Cmder) erro\n \treturn cmdsFirstErr(cmds)\n }\n \n-func (c *ClusterClient) mapCmdsByNode(cmdsMap *cmdsMap, cmds []Cmder) error {\n-\tstate, err := c.state.Get()\n+func (c *ClusterClient) mapCmdsByNode(ctx context.Context, cmdsMap *cmdsMap, cmds []Cmder) error {\n+\tstate, err := c.state.Get(ctx)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -1159,21 +1193,28 @@ func (c *ClusterClient) _processPipelineNode(\n \t\t\t}\n \n \t\t\treturn cn.WithReader(ctx, c.opt.ReadTimeout, func(rd *proto.Reader) error {\n-\t\t\t\treturn c.pipelineReadCmds(node, rd, cmds, failedCmds)\n+\t\t\t\treturn c.pipelineReadCmds(ctx, node, rd, cmds, failedCmds)\n \t\t\t})\n \t\t})\n \t})\n }\n \n func (c *ClusterClient) pipelineReadCmds(\n-\tnode *clusterNode, rd *proto.Reader, cmds []Cmder, failedCmds *cmdsMap,\n+\tctx context.Context,\n+\tnode *clusterNode,\n+\trd *proto.Reader,\n+\tcmds []Cmder,\n+\tfailedCmds *cmdsMap,\n ) error {\n \tfor _, cmd := range cmds {\n \t\terr := cmd.readReply(rd)\n+\t\tcmd.SetErr(err)\n+\n \t\tif err == nil {\n \t\t\tcontinue\n \t\t}\n-\t\tif c.checkMovedErr(cmd, err, failedCmds) {\n+\n+\t\tif c.checkMovedErr(ctx, cmd, err, failedCmds) {\n \t\t\tcontinue\n \t\t}\n \n@@ -1190,14 +1231,14 @@ func (c *ClusterClient) pipelineReadCmds(\n }\n \n func (c *ClusterClient) checkMovedErr(\n-\tcmd Cmder, err error, failedCmds *cmdsMap,\n+\tctx context.Context, cmd Cmder, err error, failedCmds *cmdsMap,\n ) bool {\n \tmoved, ask, addr := isMovedError(err)\n \tif !moved && !ask {\n \t\treturn false\n \t}\n \n-\tnode, err := c.nodes.Get(addr)\n+\tnode, err := c.nodes.GetOrCreate(addr)\n \tif err != nil {\n \t\treturn false\n \t}\n@@ -1209,7 +1250,7 @@ func (c *ClusterClient) checkMovedErr(\n \t}\n \n \tif ask {\n-\t\tfailedCmds.Add(node, NewCmd(\"asking\"), cmd)\n+\t\tfailedCmds.Add(node, NewCmd(ctx, \"asking\"), cmd)\n \t\treturn true\n \t}\n \n@@ -1226,16 +1267,19 @@ func (c *ClusterClient) TxPipeline() Pipeliner {\n \treturn &pipe\n }\n \n-func (c *ClusterClient) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.TxPipeline().Pipelined(fn)\n+func (c *ClusterClient) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.TxPipeline().Pipelined(ctx, fn)\n }\n \n func (c *ClusterClient) processTxPipeline(ctx context.Context, cmds []Cmder) error {\n-\treturn c.hooks.processPipeline(ctx, cmds, c._processTxPipeline)\n+\treturn c.hooks.processTxPipeline(ctx, cmds, c._processTxPipeline)\n }\n \n func (c *ClusterClient) _processTxPipeline(ctx context.Context, cmds []Cmder) error {\n-\tstate, err := c.state.Get()\n+\t// Trim multi .. exec.\n+\tcmds = cmds[1 : len(cmds)-1]\n+\n+\tstate, err := c.state.Get(ctx)\n \tif err != nil {\n \t\tsetCmdsErr(cmds, err)\n \t\treturn err\n@@ -1270,8 +1314,9 @@ func (c *ClusterClient) _processTxPipeline(ctx context.Context, cmds []Cmder) er\n \t\t\t\t\tif err == nil {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n+\n \t\t\t\t\tif attempt < c.opt.MaxRedirects {\n-\t\t\t\t\t\tif err := c.mapCmdsByNode(failedCmds, cmds); err != nil {\n+\t\t\t\t\t\tif err := c.mapCmdsByNode(ctx, failedCmds, cmds); err != nil {\n \t\t\t\t\t\t\tsetCmdsErr(cmds, err)\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n@@ -1317,11 +1362,11 @@ func (c *ClusterClient) _processTxPipelineNode(\n \t\t\t\t// Trim multi and exec.\n \t\t\t\tcmds = cmds[1 : len(cmds)-1]\n \n-\t\t\t\terr := c.txPipelineReadQueued(rd, statusCmd, cmds, failedCmds)\n+\t\t\t\terr := c.txPipelineReadQueued(ctx, rd, statusCmd, cmds, failedCmds)\n \t\t\t\tif err != nil {\n \t\t\t\t\tmoved, ask, addr := isMovedError(err)\n \t\t\t\t\tif moved || ask {\n-\t\t\t\t\t\treturn c.cmdsMoved(cmds, moved, ask, addr, failedCmds)\n+\t\t\t\t\t\treturn c.cmdsMoved(ctx, cmds, moved, ask, addr, failedCmds)\n \t\t\t\t\t}\n \t\t\t\t\treturn err\n \t\t\t\t}\n@@ -1333,7 +1378,11 @@ func (c *ClusterClient) _processTxPipelineNode(\n }\n \n func (c *ClusterClient) txPipelineReadQueued(\n-\trd *proto.Reader, statusCmd *StatusCmd, cmds []Cmder, failedCmds *cmdsMap,\n+\tctx context.Context,\n+\trd *proto.Reader,\n+\tstatusCmd *StatusCmd,\n+\tcmds []Cmder,\n+\tfailedCmds *cmdsMap,\n ) error {\n \t// Parse queued replies.\n \tif err := statusCmd.readReply(rd); err != nil {\n@@ -1342,7 +1391,7 @@ func (c *ClusterClient) txPipelineReadQueued(\n \n \tfor _, cmd := range cmds {\n \t\terr := statusCmd.readReply(rd)\n-\t\tif err == nil || c.checkMovedErr(cmd, err, failedCmds) || isRedisError(err) {\n+\t\tif err == nil || c.checkMovedErr(ctx, cmd, err, failedCmds) || isRedisError(err) {\n \t\t\tcontinue\n \t\t}\n \t\treturn err\n@@ -1370,9 +1419,12 @@ func (c *ClusterClient) txPipelineReadQueued(\n }\n \n func (c *ClusterClient) cmdsMoved(\n-\tcmds []Cmder, moved, ask bool, addr string, failedCmds *cmdsMap,\n+\tctx context.Context, cmds []Cmder,\n+\tmoved, ask bool,\n+\taddr string,\n+\tfailedCmds *cmdsMap,\n ) error {\n-\tnode, err := c.nodes.Get(addr)\n+\tnode, err := c.nodes.GetOrCreate(addr)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -1387,19 +1439,15 @@ func (c *ClusterClient) cmdsMoved(\n \n \tif ask {\n \t\tfor _, cmd := range cmds {\n-\t\t\tfailedCmds.Add(node, NewCmd(\"asking\"), cmd)\n+\t\t\tfailedCmds.Add(node, NewCmd(ctx, \"asking\"), cmd)\n \t\t}\n \t\treturn nil\n \t}\n \n \treturn nil\n }\n \n-func (c *ClusterClient) Watch(fn func(*Tx) error, keys ...string) error {\n-\treturn c.WatchContext(c.ctx, fn, keys...)\n-}\n-\n-func (c *ClusterClient) WatchContext(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n+func (c *ClusterClient) Watch(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n \tif len(keys) == 0 {\n \t\treturn fmt.Errorf(\"redis: Watch requires at least one key\")\n \t}\n@@ -1412,7 +1460,7 @@ func (c *ClusterClient) WatchContext(ctx context.Context, fn func(*Tx) error, ke\n \t\t}\n \t}\n \n-\tnode, err := c.slotMasterNode(slot)\n+\tnode, err := c.slotMasterNode(ctx, slot)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -1424,32 +1472,32 @@ func (c *ClusterClient) WatchContext(ctx context.Context, fn func(*Tx) error, ke\n \t\t\t}\n \t\t}\n \n-\t\terr = node.Client.WatchContext(ctx, fn, keys...)\n+\t\terr = node.Client.Watch(ctx, fn, keys...)\n \t\tif err == nil {\n \t\t\tbreak\n \t\t}\n-\t\tif err != Nil {\n-\t\t\tc.state.LazyReload()\n-\t\t}\n \n \t\tmoved, ask, addr := isMovedError(err)\n \t\tif moved || ask {\n-\t\t\tnode, err = c.nodes.Get(addr)\n+\t\t\tnode, err = c.nodes.GetOrCreate(addr)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tif err == pool.ErrClosed || isReadOnlyError(err) {\n-\t\t\tnode, err = c.slotMasterNode(slot)\n+\t\tif isReadOnly := isReadOnlyError(err); isReadOnly || err == pool.ErrClosed {\n+\t\t\tif isReadOnly {\n+\t\t\t\tc.state.LazyReload()\n+\t\t\t}\n+\t\t\tnode, err = c.slotMasterNode(ctx, slot)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tif isRetryableError(err, true) {\n+\t\tif shouldRetry(err, true) {\n \t\t\tcontinue\n \t\t}\n \n@@ -1464,15 +1512,15 @@ func (c *ClusterClient) pubSub() *PubSub {\n \tpubsub := &PubSub{\n \t\topt: c.opt.clientOptions(),\n \n-\t\tnewConn: func(channels []string) (*pool.Conn, error) {\n+\t\tnewConn: func(ctx context.Context, channels []string) (*pool.Conn, error) {\n \t\t\tif node != nil {\n \t\t\t\tpanic(\"node != nil\")\n \t\t\t}\n \n \t\t\tvar err error\n \t\t\tif len(channels) > 0 {\n \t\t\t\tslot := hashtag.Slot(channels[0])\n-\t\t\t\tnode, err = c.slotMasterNode(slot)\n+\t\t\t\tnode, err = c.slotMasterNode(ctx, slot)\n \t\t\t} else {\n \t\t\t\tnode, err = c.nodes.Random()\n \t\t\t}\n@@ -1502,20 +1550,20 @@ func (c *ClusterClient) pubSub() *PubSub {\n \n // Subscribe subscribes the client to the specified channels.\n // Channels can be omitted to create empty subscription.\n-func (c *ClusterClient) Subscribe(channels ...string) *PubSub {\n+func (c *ClusterClient) Subscribe(ctx context.Context, channels ...string) *PubSub {\n \tpubsub := c.pubSub()\n \tif len(channels) > 0 {\n-\t\t_ = pubsub.Subscribe(channels...)\n+\t\t_ = pubsub.Subscribe(ctx, channels...)\n \t}\n \treturn pubsub\n }\n \n // PSubscribe subscribes the client to the given patterns.\n // Patterns can be omitted to create empty subscription.\n-func (c *ClusterClient) PSubscribe(channels ...string) *PubSub {\n+func (c *ClusterClient) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n \tpubsub := c.pubSub()\n \tif len(channels) > 0 {\n-\t\t_ = pubsub.PSubscribe(channels...)\n+\t\t_ = pubsub.PSubscribe(ctx, channels...)\n \t}\n \treturn pubsub\n }\n@@ -1524,42 +1572,57 @@ func (c *ClusterClient) retryBackoff(attempt int) time.Duration {\n \treturn internal.RetryBackoff(attempt, c.opt.MinRetryBackoff, c.opt.MaxRetryBackoff)\n }\n \n-func (c *ClusterClient) cmdsInfo() (map[string]*CommandInfo, error) {\n+func (c *ClusterClient) cmdsInfo(ctx context.Context) (map[string]*CommandInfo, error) {\n+\t// Try 3 random nodes.\n+\tconst nodeLimit = 3\n+\n \taddrs, err := c.nodes.Addrs()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n \tvar firstErr error\n-\tfor _, addr := range addrs {\n-\t\tnode, err := c.nodes.Get(addr)\n+\n+\tperm := rand.Perm(len(addrs))\n+\tif len(perm) > nodeLimit {\n+\t\tperm = perm[:nodeLimit]\n+\t}\n+\n+\tfor _, idx := range perm {\n+\t\taddr := addrs[idx]\n+\n+\t\tnode, err := c.nodes.GetOrCreate(addr)\n \t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif node == nil {\n+\t\t\tif firstErr == nil {\n+\t\t\t\tfirstErr = err\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tinfo, err := node.Client.Command().Result()\n+\t\tinfo, err := node.Client.Command(ctx).Result()\n \t\tif err == nil {\n \t\t\treturn info, nil\n \t\t}\n \t\tif firstErr == nil {\n \t\t\tfirstErr = err\n \t\t}\n \t}\n+\n+\tif firstErr == nil {\n+\t\tpanic(\"not reached\")\n+\t}\n \treturn nil, firstErr\n }\n \n func (c *ClusterClient) cmdInfo(name string) *CommandInfo {\n-\tcmdsInfo, err := c.cmdsInfoCache.Get()\n+\tcmdsInfo, err := c.cmdsInfoCache.Get(c.ctx)\n \tif err != nil {\n \t\treturn nil\n \t}\n \n \tinfo := cmdsInfo[name]\n \tif info == nil {\n-\t\tinternal.Logger.Printf(\"info for cmd=%s not found\", name)\n+\t\tinternal.Logger.Printf(c.Context(), \"info for cmd=%s not found\", name)\n \t}\n \treturn info\n }\n@@ -1582,8 +1645,12 @@ func cmdSlot(cmd Cmder, pos int) int {\n \treturn hashtag.Slot(firstKey)\n }\n \n-func (c *ClusterClient) cmdNode(cmdInfo *CommandInfo, slot int) (*clusterNode, error) {\n-\tstate, err := c.state.Get()\n+func (c *ClusterClient) cmdNode(\n+\tctx context.Context,\n+\tcmdInfo *CommandInfo,\n+\tslot int,\n+) (*clusterNode, error) {\n+\tstate, err := c.state.Get(ctx)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -1604,14 +1671,43 @@ func (c *clusterClient) slotReadOnlyNode(state *clusterState, slot int) (*cluste\n \treturn state.slotSlaveNode(slot)\n }\n \n-func (c *ClusterClient) slotMasterNode(slot int) (*clusterNode, error) {\n-\tstate, err := c.state.Get()\n+func (c *ClusterClient) slotMasterNode(ctx context.Context, slot int) (*clusterNode, error) {\n+\tstate, err := c.state.Get(ctx)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn state.slotMasterNode(slot)\n }\n \n+// SlaveForKey gets a client for a replica node to run any command on it.\n+// This is especially useful if we want to run a particular lua script which has\n+// only read only commands on the replica.\n+// This is because other redis commands generally have a flag that points that\n+// they are read only and automatically run on the replica nodes\n+// if ClusterOptions.ReadOnly flag is set to true.\n+func (c *ClusterClient) SlaveForKey(ctx context.Context, key string) (*Client, error) {\n+\tstate, err := c.state.Get(ctx)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tslot := hashtag.Slot(key)\n+\tnode, err := c.slotReadOnlyNode(state, slot)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn node.Client, err\n+}\n+\n+// MasterForKey return a client to the master node for a particular key.\n+func (c *ClusterClient) MasterForKey(ctx context.Context, key string) (*Client, error) {\n+\tslot := hashtag.Slot(key)\n+\tnode, err := c.slotMasterNode(ctx, slot)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn node.Client, err\n+}\n+\n func appendUniqueNode(nodes []*clusterNode, node *clusterNode) []*clusterNode {\n \tfor _, n := range nodes {\n \t\tif n == node {\n@@ -1634,21 +1730,6 @@ loop:\n \treturn ss\n }\n \n-func remove(ss []string, es ...string) []string {\n-\tif len(es) == 0 {\n-\t\treturn ss[:0]\n-\t}\n-\tfor _, e := range es {\n-\t\tfor i, s := range ss {\n-\t\t\tif s == e {\n-\t\t\t\tss = append(ss[:i], ss[i+1:]...)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn ss\n-}\n-\n //------------------------------------------------------------------------------\n \n type cmdsMap struct {",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/cluster.go"
    },
    {
      "sha": "085bce83d5674eca293ccf186a4d506ad54fac04",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/cluster_commands.go",
      "status": "added",
      "additions": 109,
      "deletions": 0,
      "changes": 109,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcluster_commands.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcluster_commands.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcluster_commands.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,109 @@\n+package redis\n+\n+import (\n+\t\"context\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+)\n+\n+func (c *ClusterClient) DBSize(ctx context.Context) *IntCmd {\n+\tcmd := NewIntCmd(ctx, \"dbsize\")\n+\t_ = c.hooks.process(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n+\t\tvar size int64\n+\t\terr := c.ForEachMaster(ctx, func(ctx context.Context, master *Client) error {\n+\t\t\tn, err := master.DBSize(ctx).Result()\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tatomic.AddInt64(&size, n)\n+\t\t\treturn nil\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tcmd.SetErr(err)\n+\t\t} else {\n+\t\t\tcmd.val = size\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn cmd\n+}\n+\n+func (c *ClusterClient) ScriptLoad(ctx context.Context, script string) *StringCmd {\n+\tcmd := NewStringCmd(ctx, \"script\", \"load\", script)\n+\t_ = c.hooks.process(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n+\t\tmu := &sync.Mutex{}\n+\t\terr := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {\n+\t\t\tval, err := shard.ScriptLoad(ctx, script).Result()\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\tmu.Lock()\n+\t\t\tif cmd.Val() == \"\" {\n+\t\t\t\tcmd.val = val\n+\t\t\t}\n+\t\t\tmu.Unlock()\n+\n+\t\t\treturn nil\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tcmd.SetErr(err)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn cmd\n+}\n+\n+func (c *ClusterClient) ScriptFlush(ctx context.Context) *StatusCmd {\n+\tcmd := NewStatusCmd(ctx, \"script\", \"flush\")\n+\t_ = c.hooks.process(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n+\t\terr := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {\n+\t\t\treturn shard.ScriptFlush(ctx).Err()\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tcmd.SetErr(err)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn cmd\n+}\n+\n+func (c *ClusterClient) ScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd {\n+\targs := make([]interface{}, 2+len(hashes))\n+\targs[0] = \"script\"\n+\targs[1] = \"exists\"\n+\tfor i, hash := range hashes {\n+\t\targs[2+i] = hash\n+\t}\n+\tcmd := NewBoolSliceCmd(ctx, args...)\n+\n+\tresult := make([]bool, len(hashes))\n+\tfor i := range result {\n+\t\tresult[i] = true\n+\t}\n+\n+\t_ = c.hooks.process(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n+\t\tmu := &sync.Mutex{}\n+\t\terr := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {\n+\t\t\tval, err := shard.ScriptExists(ctx, hashes...).Result()\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\tmu.Lock()\n+\t\t\tfor i, v := range val {\n+\t\t\t\tresult[i] = result[i] && v\n+\t\t\t}\n+\t\t\tmu.Unlock()\n+\n+\t\t\treturn nil\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tcmd.SetErr(err)\n+\t\t} else {\n+\t\t\tcmd.val = result\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn cmd\n+}"
    },
    {
      "sha": "4bb12a85be43837c5b4c93666161f57842ed2c4b",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/command.go",
      "status": "added",
      "additions": 3478,
      "deletions": 0,
      "changes": 3478,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcommand.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcommand.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcommand.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97"
    },
    {
      "sha": "bbfe089df166db9c1dda980a957a16d9c6f9ae44",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/commands.go",
      "status": "added",
      "additions": 3475,
      "deletions": 0,
      "changes": 3475,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcommands.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcommands.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fcommands.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97"
    },
    {
      "sha": "55262533a63dcccc159250a57f31bd9c9d25bdf8",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/doc.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fdoc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fdoc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fdoc.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/doc.go"
    },
    {
      "sha": "521594bbd0c939d077732130ccdff2a9c8366f75",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/error.go",
      "status": "renamed",
      "additions": 49,
      "deletions": 13,
      "changes": 62,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Ferror.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Ferror.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Ferror.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -6,10 +6,11 @@ import (\n \t\"net\"\n \t\"strings\"\n \n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/proto\"\n )\n \n+// ErrClosed performs any operation on the closed client will return this error.\n var ErrClosed = pool.ErrClosed\n \n type Error interface {\n@@ -24,15 +25,16 @@ type Error interface {\n \n var _ Error = proto.RedisError(\"\")\n \n-func isRetryableError(err error, retryTimeout bool) bool {\n+func shouldRetry(err error, retryTimeout bool) bool {\n \tswitch err {\n+\tcase io.EOF, io.ErrUnexpectedEOF:\n+\t\treturn true\n \tcase nil, context.Canceled, context.DeadlineExceeded:\n \t\treturn false\n-\tcase io.EOF:\n-\t\treturn true\n \t}\n-\tif netErr, ok := err.(net.Error); ok {\n-\t\tif netErr.Timeout() {\n+\n+\tif v, ok := err.(timeoutError); ok {\n+\t\tif v.Timeout() {\n \t\t\treturn retryTimeout\n \t\t}\n \t\treturn true\n@@ -51,6 +53,10 @@ func isRetryableError(err error, retryTimeout bool) bool {\n \tif strings.HasPrefix(s, \"CLUSTERDOWN \") {\n \t\treturn true\n \t}\n+\tif strings.HasPrefix(s, \"TRYAGAIN \") {\n+\t\treturn true\n+\t}\n+\n \treturn false\n }\n \n@@ -59,20 +65,36 @@ func isRedisError(err error) bool {\n \treturn ok\n }\n \n-func isBadConn(err error, allowTimeout bool) bool {\n-\tif err == nil {\n+func isBadConn(err error, allowTimeout bool, addr string) bool {\n+\tswitch err {\n+\tcase nil:\n \t\treturn false\n+\tcase context.Canceled, context.DeadlineExceeded:\n+\t\treturn true\n \t}\n+\n \tif isRedisError(err) {\n-\t\t// Close connections in read only state in case domain addr is used\n-\t\t// and domain resolves to a different Redis Server. See #790.\n-\t\treturn isReadOnlyError(err)\n+\t\tswitch {\n+\t\tcase isReadOnlyError(err):\n+\t\t\t// Close connections in read only state in case domain addr is used\n+\t\t\t// and domain resolves to a different Redis Server. See #790.\n+\t\t\treturn true\n+\t\tcase isMovedSameConnAddr(err, addr):\n+\t\t\t// Close connections when we are asked to move to the same addr\n+\t\t\t// of the connection. Force a DNS resolution when all connections\n+\t\t\t// of the pool are recycled\n+\t\t\treturn true\n+\t\tdefault:\n+\t\t\treturn false\n+\t\t}\n \t}\n+\n \tif allowTimeout {\n \t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n-\t\t\treturn false\n+\t\t\treturn !netErr.Temporary()\n \t\t}\n \t}\n+\n \treturn true\n }\n \n@@ -106,3 +128,17 @@ func isLoadingError(err error) bool {\n func isReadOnlyError(err error) bool {\n \treturn strings.HasPrefix(err.Error(), \"READONLY \")\n }\n+\n+func isMovedSameConnAddr(err error, addr string) bool {\n+\tredisError := err.Error()\n+\tif !strings.HasPrefix(redisError, \"MOVED \") {\n+\t\treturn false\n+\t}\n+\treturn strings.HasSuffix(redisError, \" \"+addr)\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+type timeoutError interface {\n+\tTimeout() bool\n+}",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/error.go"
    },
    {
      "sha": "b97fa0d6851796b3e48a080e0b5b1f687557a906",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/arg.go",
      "status": "added",
      "additions": 56,
      "deletions": 0,
      "changes": 56,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Farg.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Farg.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Farg.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,56 @@\n+package internal\n+\n+import (\n+\t\"fmt\"\n+\t\"strconv\"\n+\t\"time\"\n+)\n+\n+func AppendArg(b []byte, v interface{}) []byte {\n+\tswitch v := v.(type) {\n+\tcase nil:\n+\t\treturn append(b, \"<nil>\"...)\n+\tcase string:\n+\t\treturn appendUTF8String(b, Bytes(v))\n+\tcase []byte:\n+\t\treturn appendUTF8String(b, v)\n+\tcase int:\n+\t\treturn strconv.AppendInt(b, int64(v), 10)\n+\tcase int8:\n+\t\treturn strconv.AppendInt(b, int64(v), 10)\n+\tcase int16:\n+\t\treturn strconv.AppendInt(b, int64(v), 10)\n+\tcase int32:\n+\t\treturn strconv.AppendInt(b, int64(v), 10)\n+\tcase int64:\n+\t\treturn strconv.AppendInt(b, v, 10)\n+\tcase uint:\n+\t\treturn strconv.AppendUint(b, uint64(v), 10)\n+\tcase uint8:\n+\t\treturn strconv.AppendUint(b, uint64(v), 10)\n+\tcase uint16:\n+\t\treturn strconv.AppendUint(b, uint64(v), 10)\n+\tcase uint32:\n+\t\treturn strconv.AppendUint(b, uint64(v), 10)\n+\tcase uint64:\n+\t\treturn strconv.AppendUint(b, v, 10)\n+\tcase float32:\n+\t\treturn strconv.AppendFloat(b, float64(v), 'f', -1, 64)\n+\tcase float64:\n+\t\treturn strconv.AppendFloat(b, v, 'f', -1, 64)\n+\tcase bool:\n+\t\tif v {\n+\t\t\treturn append(b, \"true\"...)\n+\t\t}\n+\t\treturn append(b, \"false\"...)\n+\tcase time.Time:\n+\t\treturn v.AppendFormat(b, time.RFC3339Nano)\n+\tdefault:\n+\t\treturn append(b, fmt.Sprint(v)...)\n+\t}\n+}\n+\n+func appendUTF8String(dst []byte, src []byte) []byte {\n+\tdst = append(dst, src...)\n+\treturn dst\n+}"
    },
    {
      "sha": "b3a4f211e3369d3af22509ebf04b03e593a5fee0",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/hashtag/hashtag.go",
      "status": "renamed",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhashtag%2Fhashtag.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhashtag%2Fhashtag.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhashtag%2Fhashtag.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,8 +1,9 @@\n package hashtag\n \n import (\n-\t\"math/rand\"\n \t\"strings\"\n+\n+\t\"github.com/go-redis/redis/v8/internal/rand\"\n )\n \n const slotNumber = 16384\n@@ -59,7 +60,7 @@ func RandomSlot() int {\n \treturn rand.Intn(slotNumber)\n }\n \n-// hashSlot returns a consistent slot number between 0 and 16383\n+// Slot returns a consistent slot number between 0 and 16383\n // for any given string key.\n func Slot(key string) int {\n \tif key == \"\" {",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/hashtag/hashtag.go"
    },
    {
      "sha": "852c8bd525a7fe9c64746c5439caa830b4cd6e65",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/hscan/hscan.go",
      "status": "added",
      "additions": 201,
      "deletions": 0,
      "changes": 201,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhscan%2Fhscan.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhscan%2Fhscan.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhscan%2Fhscan.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,201 @@\n+package hscan\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"strconv\"\n+)\n+\n+// decoderFunc represents decoding functions for default built-in types.\n+type decoderFunc func(reflect.Value, string) error\n+\n+var (\n+\t// List of built-in decoders indexed by their numeric constant values (eg: reflect.Bool = 1).\n+\tdecoders = []decoderFunc{\n+\t\treflect.Bool:          decodeBool,\n+\t\treflect.Int:           decodeInt,\n+\t\treflect.Int8:          decodeInt8,\n+\t\treflect.Int16:         decodeInt16,\n+\t\treflect.Int32:         decodeInt32,\n+\t\treflect.Int64:         decodeInt64,\n+\t\treflect.Uint:          decodeUint,\n+\t\treflect.Uint8:         decodeUint8,\n+\t\treflect.Uint16:        decodeUint16,\n+\t\treflect.Uint32:        decodeUint32,\n+\t\treflect.Uint64:        decodeUint64,\n+\t\treflect.Float32:       decodeFloat32,\n+\t\treflect.Float64:       decodeFloat64,\n+\t\treflect.Complex64:     decodeUnsupported,\n+\t\treflect.Complex128:    decodeUnsupported,\n+\t\treflect.Array:         decodeUnsupported,\n+\t\treflect.Chan:          decodeUnsupported,\n+\t\treflect.Func:          decodeUnsupported,\n+\t\treflect.Interface:     decodeUnsupported,\n+\t\treflect.Map:           decodeUnsupported,\n+\t\treflect.Ptr:           decodeUnsupported,\n+\t\treflect.Slice:         decodeSlice,\n+\t\treflect.String:        decodeString,\n+\t\treflect.Struct:        decodeUnsupported,\n+\t\treflect.UnsafePointer: decodeUnsupported,\n+\t}\n+\n+\t// Global map of struct field specs that is populated once for every new\n+\t// struct type that is scanned. This caches the field types and the corresponding\n+\t// decoder functions to avoid iterating through struct fields on subsequent scans.\n+\tglobalStructMap = newStructMap()\n+)\n+\n+func Struct(dst interface{}) (StructValue, error) {\n+\tv := reflect.ValueOf(dst)\n+\n+\t// The destination to scan into should be a struct pointer.\n+\tif v.Kind() != reflect.Ptr || v.IsNil() {\n+\t\treturn StructValue{}, fmt.Errorf(\"redis.Scan(non-pointer %T)\", dst)\n+\t}\n+\n+\tv = v.Elem()\n+\tif v.Kind() != reflect.Struct {\n+\t\treturn StructValue{}, fmt.Errorf(\"redis.Scan(non-struct %T)\", dst)\n+\t}\n+\n+\treturn StructValue{\n+\t\tspec:  globalStructMap.get(v.Type()),\n+\t\tvalue: v,\n+\t}, nil\n+}\n+\n+// Scan scans the results from a key-value Redis map result set to a destination struct.\n+// The Redis keys are matched to the struct's field with the `redis` tag.\n+func Scan(dst interface{}, keys []interface{}, vals []interface{}) error {\n+\tif len(keys) != len(vals) {\n+\t\treturn errors.New(\"args should have the same number of keys and vals\")\n+\t}\n+\n+\tstrct, err := Struct(dst)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Iterate through the (key, value) sequence.\n+\tfor i := 0; i < len(vals); i++ {\n+\t\tkey, ok := keys[i].(string)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tval, ok := vals[i].(string)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif err := strct.Scan(key, val); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+func decodeBool(f reflect.Value, s string) error {\n+\tb, err := strconv.ParseBool(s)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tf.SetBool(b)\n+\treturn nil\n+}\n+\n+func decodeInt8(f reflect.Value, s string) error {\n+\treturn decodeNumber(f, s, 8)\n+}\n+\n+func decodeInt16(f reflect.Value, s string) error {\n+\treturn decodeNumber(f, s, 16)\n+}\n+\n+func decodeInt32(f reflect.Value, s string) error {\n+\treturn decodeNumber(f, s, 32)\n+}\n+\n+func decodeInt64(f reflect.Value, s string) error {\n+\treturn decodeNumber(f, s, 64)\n+}\n+\n+func decodeInt(f reflect.Value, s string) error {\n+\treturn decodeNumber(f, s, 0)\n+}\n+\n+func decodeNumber(f reflect.Value, s string, bitSize int) error {\n+\tv, err := strconv.ParseInt(s, 10, bitSize)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tf.SetInt(v)\n+\treturn nil\n+}\n+\n+func decodeUint8(f reflect.Value, s string) error {\n+\treturn decodeUnsignedNumber(f, s, 8)\n+}\n+\n+func decodeUint16(f reflect.Value, s string) error {\n+\treturn decodeUnsignedNumber(f, s, 16)\n+}\n+\n+func decodeUint32(f reflect.Value, s string) error {\n+\treturn decodeUnsignedNumber(f, s, 32)\n+}\n+\n+func decodeUint64(f reflect.Value, s string) error {\n+\treturn decodeUnsignedNumber(f, s, 64)\n+}\n+\n+func decodeUint(f reflect.Value, s string) error {\n+\treturn decodeUnsignedNumber(f, s, 0)\n+}\n+\n+func decodeUnsignedNumber(f reflect.Value, s string, bitSize int) error {\n+\tv, err := strconv.ParseUint(s, 10, bitSize)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tf.SetUint(v)\n+\treturn nil\n+}\n+\n+func decodeFloat32(f reflect.Value, s string) error {\n+\tv, err := strconv.ParseFloat(s, 32)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tf.SetFloat(v)\n+\treturn nil\n+}\n+\n+// although the default is float64, but we better define it.\n+func decodeFloat64(f reflect.Value, s string) error {\n+\tv, err := strconv.ParseFloat(s, 64)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tf.SetFloat(v)\n+\treturn nil\n+}\n+\n+func decodeString(f reflect.Value, s string) error {\n+\tf.SetString(s)\n+\treturn nil\n+}\n+\n+func decodeSlice(f reflect.Value, s string) error {\n+\t// []byte slice ([]uint8).\n+\tif f.Type().Elem().Kind() == reflect.Uint8 {\n+\t\tf.SetBytes([]byte(s))\n+\t}\n+\treturn nil\n+}\n+\n+func decodeUnsupported(v reflect.Value, s string) error {\n+\treturn fmt.Errorf(\"redis.Scan(unsupported %s)\", v.Type())\n+}"
    },
    {
      "sha": "6839412ba259da28d2ef53ea2e82098080d64a1d",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/hscan/structmap.go",
      "status": "added",
      "additions": 93,
      "deletions": 0,
      "changes": 93,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhscan%2Fstructmap.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhscan%2Fstructmap.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fhscan%2Fstructmap.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,93 @@\n+package hscan\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+// structMap contains the map of struct fields for target structs\n+// indexed by the struct type.\n+type structMap struct {\n+\tm sync.Map\n+}\n+\n+func newStructMap() *structMap {\n+\treturn new(structMap)\n+}\n+\n+func (s *structMap) get(t reflect.Type) *structSpec {\n+\tif v, ok := s.m.Load(t); ok {\n+\t\treturn v.(*structSpec)\n+\t}\n+\n+\tspec := newStructSpec(t, \"redis\")\n+\ts.m.Store(t, spec)\n+\treturn spec\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+// structSpec contains the list of all fields in a target struct.\n+type structSpec struct {\n+\tm map[string]*structField\n+}\n+\n+func (s *structSpec) set(tag string, sf *structField) {\n+\ts.m[tag] = sf\n+}\n+\n+func newStructSpec(t reflect.Type, fieldTag string) *structSpec {\n+\tnumField := t.NumField()\n+\tout := &structSpec{\n+\t\tm: make(map[string]*structField, numField),\n+\t}\n+\n+\tfor i := 0; i < numField; i++ {\n+\t\tf := t.Field(i)\n+\n+\t\ttag := f.Tag.Get(fieldTag)\n+\t\tif tag == \"\" || tag == \"-\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\ttag = strings.Split(tag, \",\")[0]\n+\t\tif tag == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Use the built-in decoder.\n+\t\tout.set(tag, &structField{index: i, fn: decoders[f.Type.Kind()]})\n+\t}\n+\n+\treturn out\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+// structField represents a single field in a target struct.\n+type structField struct {\n+\tindex int\n+\tfn    decoderFunc\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+type StructValue struct {\n+\tspec  *structSpec\n+\tvalue reflect.Value\n+}\n+\n+func (s StructValue) Scan(key string, value string) error {\n+\tfield, ok := s.spec.m[key]\n+\tif !ok {\n+\t\treturn nil\n+\t}\n+\tif err := field.fn(s.value.Field(field.index), value); err != nil {\n+\t\tt := s.value.Type()\n+\t\treturn fmt.Errorf(\"cannot scan redis.result %s into struct field %s.%s of type %s, error-%s\",\n+\t\t\tvalue, t.Name(), t.Field(field.index).Name, t.Field(field.index).Type, err.Error())\n+\t}\n+\treturn nil\n+}"
    },
    {
      "sha": "4a59c599be77d76687e7a7d591dbfda40ef7fb8a",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/internal.go",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Finternal.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Finternal.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Finternal.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,29 @@\n+package internal\n+\n+import (\n+\t\"time\"\n+\n+\t\"github.com/go-redis/redis/v8/internal/rand\"\n+)\n+\n+func RetryBackoff(retry int, minBackoff, maxBackoff time.Duration) time.Duration {\n+\tif retry < 0 {\n+\t\tpanic(\"not reached\")\n+\t}\n+\tif minBackoff == 0 {\n+\t\treturn 0\n+\t}\n+\n+\td := minBackoff << uint(retry)\n+\tif d < minBackoff {\n+\t\treturn maxBackoff\n+\t}\n+\n+\td = minBackoff + time.Duration(rand.Int63n(int64(d)))\n+\n+\tif d > maxBackoff || d < minBackoff {\n+\t\td = maxBackoff\n+\t}\n+\n+\treturn d\n+}"
    },
    {
      "sha": "c8b9213de48cdbeb5c5971b50f47a088e8fd72ed",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/log.go",
      "status": "added",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Flog.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Flog.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Flog.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,26 @@\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+)\n+\n+type Logging interface {\n+\tPrintf(ctx context.Context, format string, v ...interface{})\n+}\n+\n+type logger struct {\n+\tlog *log.Logger\n+}\n+\n+func (l *logger) Printf(ctx context.Context, format string, v ...interface{}) {\n+\t_ = l.log.Output(2, fmt.Sprintf(format, v...))\n+}\n+\n+// Logger calls Output to print to the stderr.\n+// Arguments are handled in the manner of fmt.Print.\n+var Logger Logging = &logger{\n+\tlog: log.New(os.Stderr, \"redis: \", log.LstdFlags|log.Lshortfile),\n+}"
    },
    {
      "sha": "64f46272aedc1408c709066d591f8274bd34b9a6",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/once.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fonce.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fonce.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fonce.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/once.go"
    },
    {
      "sha": "5661659865123d9cc64cdb1b72c9835181478a5d",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/pool/conn.go",
      "status": "renamed",
      "additions": 17,
      "deletions": 14,
      "changes": 31,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fconn.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fconn.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fconn.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,26 +1,28 @@\n package pool\n \n import (\n+\t\"bufio\"\n \t\"context\"\n \t\"net\"\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal/proto\"\n )\n \n var noDeadline = time.Time{}\n \n type Conn struct {\n+\tusedAt  int64 // atomic\n \tnetConn net.Conn\n \n \trd *proto.Reader\n+\tbw *bufio.Writer\n \twr *proto.Writer\n \n \tInited    bool\n \tpooled    bool\n \tcreatedAt time.Time\n-\tusedAt    int64 // atomic\n }\n \n func NewConn(netConn net.Conn) *Conn {\n@@ -29,7 +31,8 @@ func NewConn(netConn net.Conn) *Conn {\n \t\tcreatedAt: time.Now(),\n \t}\n \tcn.rd = proto.NewReader(netConn)\n-\tcn.wr = proto.NewWriter(netConn)\n+\tcn.bw = bufio.NewWriter(netConn)\n+\tcn.wr = proto.NewWriter(cn.bw)\n \tcn.SetUsedAt(time.Now())\n \treturn cn\n }\n@@ -46,20 +49,22 @@ func (cn *Conn) SetUsedAt(tm time.Time) {\n func (cn *Conn) SetNetConn(netConn net.Conn) {\n \tcn.netConn = netConn\n \tcn.rd.Reset(netConn)\n-\tcn.wr.Reset(netConn)\n+\tcn.bw.Reset(netConn)\n }\n \n func (cn *Conn) Write(b []byte) (int, error) {\n \treturn cn.netConn.Write(b)\n }\n \n func (cn *Conn) RemoteAddr() net.Addr {\n-\treturn cn.netConn.RemoteAddr()\n+\tif cn.netConn != nil {\n+\t\treturn cn.netConn.RemoteAddr()\n+\t}\n+\treturn nil\n }\n \n func (cn *Conn) WithReader(ctx context.Context, timeout time.Duration, fn func(rd *proto.Reader) error) error {\n-\terr := cn.netConn.SetReadDeadline(cn.deadline(ctx, timeout))\n-\tif err != nil {\n+\tif err := cn.netConn.SetReadDeadline(cn.deadline(ctx, timeout)); err != nil {\n \t\treturn err\n \t}\n \treturn fn(cn.rd)\n@@ -68,21 +73,19 @@ func (cn *Conn) WithReader(ctx context.Context, timeout time.Duration, fn func(r\n func (cn *Conn) WithWriter(\n \tctx context.Context, timeout time.Duration, fn func(wr *proto.Writer) error,\n ) error {\n-\terr := cn.netConn.SetWriteDeadline(cn.deadline(ctx, timeout))\n-\tif err != nil {\n+\tif err := cn.netConn.SetWriteDeadline(cn.deadline(ctx, timeout)); err != nil {\n \t\treturn err\n \t}\n \n-\tif cn.wr.Buffered() > 0 {\n-\t\tcn.wr.Reset(cn.netConn)\n+\tif cn.bw.Buffered() > 0 {\n+\t\tcn.bw.Reset(cn.netConn)\n \t}\n \n-\terr = fn(cn.wr)\n-\tif err != nil {\n+\tif err := fn(cn.wr); err != nil {\n \t\treturn err\n \t}\n \n-\treturn cn.wr.Flush()\n+\treturn cn.bw.Flush()\n }\n \n func (cn *Conn) Close() error {",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/pool/conn.go"
    },
    {
      "sha": "44a4e779dfae4531d91d1e0632091f6d607fab41",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/pool/pool.go",
      "status": "renamed",
      "additions": 75,
      "deletions": 35,
      "changes": 110,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -8,11 +8,16 @@ import (\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal\"\n+\t\"github.com/go-redis/redis/v8/internal\"\n )\n \n-var ErrClosed = errors.New(\"redis: client is closed\")\n-var ErrPoolTimeout = errors.New(\"redis: connection pool timeout\")\n+var (\n+\t// ErrClosed performs any operation on the closed client will return this error.\n+\tErrClosed = errors.New(\"redis: client is closed\")\n+\n+\t// ErrPoolTimeout timed out waiting to get a connection from the connection pool.\n+\tErrPoolTimeout = errors.New(\"redis: connection pool timeout\")\n+)\n \n var timers = sync.Pool{\n \tNew: func() interface{} {\n@@ -38,8 +43,8 @@ type Pooler interface {\n \tCloseConn(*Conn) error\n \n \tGet(context.Context) (*Conn, error)\n-\tPut(*Conn)\n-\tRemove(*Conn, error)\n+\tPut(context.Context, *Conn)\n+\tRemove(context.Context, *Conn, error)\n \n \tLen() int\n \tIdleLen() int\n@@ -52,6 +57,7 @@ type Options struct {\n \tDialer  func(context.Context) (net.Conn, error)\n \tOnClose func(*Conn) error\n \n+\tPoolFIFO           bool\n \tPoolSize           int\n \tMinIdleConns       int\n \tMaxConnAge         time.Duration\n@@ -60,13 +66,16 @@ type Options struct {\n \tIdleCheckFrequency time.Duration\n }\n \n+type lastDialErrorWrap struct {\n+\terr error\n+}\n+\n type ConnPool struct {\n \topt *Options\n \n \tdialErrorsNum uint32 // atomic\n \n-\tlastDialErrorMu sync.RWMutex\n-\tlastDialError   error\n+\tlastDialError atomic.Value\n \n \tqueue chan struct{}\n \n@@ -112,9 +121,10 @@ func (p *ConnPool) checkMinIdleConns() {\n \tfor p.poolSize < p.opt.PoolSize && p.idleConnsLen < p.opt.MinIdleConns {\n \t\tp.poolSize++\n \t\tp.idleConnsLen++\n+\n \t\tgo func() {\n \t\t\terr := p.addIdleConn()\n-\t\t\tif err != nil {\n+\t\t\tif err != nil && err != ErrClosed {\n \t\t\t\tp.connsMu.Lock()\n \t\t\t\tp.poolSize--\n \t\t\t\tp.idleConnsLen--\n@@ -131,9 +141,16 @@ func (p *ConnPool) addIdleConn() error {\n \t}\n \n \tp.connsMu.Lock()\n+\tdefer p.connsMu.Unlock()\n+\n+\t// It is not allowed to add new connections to the closed connection pool.\n+\tif p.closed() {\n+\t\t_ = cn.Close()\n+\t\treturn ErrClosed\n+\t}\n+\n \tp.conns = append(p.conns, cn)\n \tp.idleConns = append(p.idleConns, cn)\n-\tp.connsMu.Unlock()\n \treturn nil\n }\n \n@@ -148,6 +165,14 @@ func (p *ConnPool) newConn(ctx context.Context, pooled bool) (*Conn, error) {\n \t}\n \n \tp.connsMu.Lock()\n+\tdefer p.connsMu.Unlock()\n+\n+\t// It is not allowed to add new connections to the closed connection pool.\n+\tif p.closed() {\n+\t\t_ = cn.Close()\n+\t\treturn nil, ErrClosed\n+\t}\n+\n \tp.conns = append(p.conns, cn)\n \tif pooled {\n \t\t// If pool is full remove the cn on next Put.\n@@ -157,7 +182,7 @@ func (p *ConnPool) newConn(ctx context.Context, pooled bool) (*Conn, error) {\n \t\t\tp.poolSize++\n \t\t}\n \t}\n-\tp.connsMu.Unlock()\n+\n \treturn cn, nil\n }\n \n@@ -204,16 +229,15 @@ func (p *ConnPool) tryDial() {\n }\n \n func (p *ConnPool) setLastDialError(err error) {\n-\tp.lastDialErrorMu.Lock()\n-\tp.lastDialError = err\n-\tp.lastDialErrorMu.Unlock()\n+\tp.lastDialError.Store(&lastDialErrorWrap{err: err})\n }\n \n func (p *ConnPool) getLastDialError() error {\n-\tp.lastDialErrorMu.RLock()\n-\terr := p.lastDialError\n-\tp.lastDialErrorMu.RUnlock()\n-\treturn err\n+\terr, _ := p.lastDialError.Load().(*lastDialErrorWrap)\n+\tif err != nil {\n+\t\treturn err.err\n+\t}\n+\treturn nil\n }\n \n // Get returns existed connection from the pool or creates a new one.\n@@ -222,16 +246,19 @@ func (p *ConnPool) Get(ctx context.Context) (*Conn, error) {\n \t\treturn nil, ErrClosed\n \t}\n \n-\terr := p.waitTurn(ctx)\n-\tif err != nil {\n+\tif err := p.waitTurn(ctx); err != nil {\n \t\treturn nil, err\n \t}\n \n \tfor {\n \t\tp.connsMu.Lock()\n-\t\tcn := p.popIdle()\n+\t\tcn, err := p.popIdle()\n \t\tp.connsMu.Unlock()\n \n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n \t\tif cn == nil {\n \t\t\tbreak\n \t\t}\n@@ -300,28 +327,39 @@ func (p *ConnPool) freeTurn() {\n \t<-p.queue\n }\n \n-func (p *ConnPool) popIdle() *Conn {\n-\tif len(p.idleConns) == 0 {\n-\t\treturn nil\n+func (p *ConnPool) popIdle() (*Conn, error) {\n+\tif p.closed() {\n+\t\treturn nil, ErrClosed\n+\t}\n+\tn := len(p.idleConns)\n+\tif n == 0 {\n+\t\treturn nil, nil\n \t}\n \n-\tidx := len(p.idleConns) - 1\n-\tcn := p.idleConns[idx]\n-\tp.idleConns = p.idleConns[:idx]\n+\tvar cn *Conn\n+\tif p.opt.PoolFIFO {\n+\t\tcn = p.idleConns[0]\n+\t\tcopy(p.idleConns, p.idleConns[1:])\n+\t\tp.idleConns = p.idleConns[:n-1]\n+\t} else {\n+\t\tidx := n - 1\n+\t\tcn = p.idleConns[idx]\n+\t\tp.idleConns = p.idleConns[:idx]\n+\t}\n \tp.idleConnsLen--\n \tp.checkMinIdleConns()\n-\treturn cn\n+\treturn cn, nil\n }\n \n-func (p *ConnPool) Put(cn *Conn) {\n+func (p *ConnPool) Put(ctx context.Context, cn *Conn) {\n \tif cn.rd.Buffered() > 0 {\n-\t\tinternal.Logger.Printf(\"Conn has unread data\")\n-\t\tp.Remove(cn, BadConnError{})\n+\t\tinternal.Logger.Printf(ctx, \"Conn has unread data\")\n+\t\tp.Remove(ctx, cn, BadConnError{})\n \t\treturn\n \t}\n \n \tif !cn.pooled {\n-\t\tp.Remove(cn, nil)\n+\t\tp.Remove(ctx, cn, nil)\n \t\treturn\n \t}\n \n@@ -332,7 +370,7 @@ func (p *ConnPool) Put(cn *Conn) {\n \tp.freeTurn()\n }\n \n-func (p *ConnPool) Remove(cn *Conn, reason error) {\n+func (p *ConnPool) Remove(ctx context.Context, cn *Conn, reason error) {\n \tp.removeConnWithLock(cn)\n \tp.freeTurn()\n \t_ = p.closeConn(cn)\n@@ -403,16 +441,17 @@ func (p *ConnPool) closed() bool {\n }\n \n func (p *ConnPool) Filter(fn func(*Conn) bool) error {\n-\tvar firstErr error\n \tp.connsMu.Lock()\n+\tdefer p.connsMu.Unlock()\n+\n+\tvar firstErr error\n \tfor _, cn := range p.conns {\n \t\tif fn(cn) {\n \t\t\tif err := p.closeConn(cn); err != nil && firstErr == nil {\n \t\t\t\tfirstErr = err\n \t\t\t}\n \t\t}\n \t}\n-\tp.connsMu.Unlock()\n \treturn firstErr\n }\n \n@@ -453,7 +492,7 @@ func (p *ConnPool) reaper(frequency time.Duration) {\n \t\t\t}\n \t\t\t_, err := p.ReapStaleConns()\n \t\t\tif err != nil {\n-\t\t\t\tinternal.Logger.Printf(\"ReapStaleConns failed: %s\", err)\n+\t\t\t\tinternal.Logger.Printf(context.Background(), \"ReapStaleConns failed: %s\", err)\n \t\t\t\tcontinue\n \t\t\t}\n \t\tcase <-p.closedCh:\n@@ -470,6 +509,7 @@ func (p *ConnPool) ReapStaleConns() (int, error) {\n \t\tp.connsMu.Lock()\n \t\tcn := p.reapStaleConn()\n \t\tp.connsMu.Unlock()\n+\n \t\tp.freeTurn()\n \n \t\tif cn != nil {",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/pool/pool.go"
    },
    {
      "sha": "5a3fde191bbbc90a57808a5466375a5e833095c7",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/pool/pool_single.go",
      "status": "added",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool_single.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool_single.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool_single.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,58 @@\n+package pool\n+\n+import \"context\"\n+\n+type SingleConnPool struct {\n+\tpool      Pooler\n+\tcn        *Conn\n+\tstickyErr error\n+}\n+\n+var _ Pooler = (*SingleConnPool)(nil)\n+\n+func NewSingleConnPool(pool Pooler, cn *Conn) *SingleConnPool {\n+\treturn &SingleConnPool{\n+\t\tpool: pool,\n+\t\tcn:   cn,\n+\t}\n+}\n+\n+func (p *SingleConnPool) NewConn(ctx context.Context) (*Conn, error) {\n+\treturn p.pool.NewConn(ctx)\n+}\n+\n+func (p *SingleConnPool) CloseConn(cn *Conn) error {\n+\treturn p.pool.CloseConn(cn)\n+}\n+\n+func (p *SingleConnPool) Get(ctx context.Context) (*Conn, error) {\n+\tif p.stickyErr != nil {\n+\t\treturn nil, p.stickyErr\n+\t}\n+\treturn p.cn, nil\n+}\n+\n+func (p *SingleConnPool) Put(ctx context.Context, cn *Conn) {}\n+\n+func (p *SingleConnPool) Remove(ctx context.Context, cn *Conn, reason error) {\n+\tp.cn = nil\n+\tp.stickyErr = reason\n+}\n+\n+func (p *SingleConnPool) Close() error {\n+\tp.cn = nil\n+\tp.stickyErr = ErrClosed\n+\treturn nil\n+}\n+\n+func (p *SingleConnPool) Len() int {\n+\treturn 0\n+}\n+\n+func (p *SingleConnPool) IdleLen() int {\n+\treturn 0\n+}\n+\n+func (p *SingleConnPool) Stats() *Stats {\n+\treturn &Stats{}\n+}"
    },
    {
      "sha": "3adb99bc820f73f11f5b4ee306f800605e5ac59e",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/pool/pool_sticky.go",
      "status": "renamed",
      "additions": 54,
      "deletions": 61,
      "changes": 115,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool_sticky.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool_sticky.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fpool%2Fpool_sticky.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -2,6 +2,7 @@ package pool\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"sync/atomic\"\n )\n@@ -30,47 +31,41 @@ func (e BadConnError) Unwrap() error {\n \treturn e.wrapped\n }\n \n-type SingleConnPool struct {\n-\tpool  Pooler\n-\tlevel int32 // atomic\n+//------------------------------------------------------------------------------\n+\n+type StickyConnPool struct {\n+\tpool   Pooler\n+\tshared int32 // atomic\n \n \tstate uint32 // atomic\n \tch    chan *Conn\n \n \t_badConnError atomic.Value\n }\n \n-var _ Pooler = (*SingleConnPool)(nil)\n+var _ Pooler = (*StickyConnPool)(nil)\n \n-func NewSingleConnPool(pool Pooler) *SingleConnPool {\n-\tp, ok := pool.(*SingleConnPool)\n+func NewStickyConnPool(pool Pooler) *StickyConnPool {\n+\tp, ok := pool.(*StickyConnPool)\n \tif !ok {\n-\t\tp = &SingleConnPool{\n+\t\tp = &StickyConnPool{\n \t\t\tpool: pool,\n \t\t\tch:   make(chan *Conn, 1),\n \t\t}\n \t}\n-\tatomic.AddInt32(&p.level, 1)\n+\tatomic.AddInt32(&p.shared, 1)\n \treturn p\n }\n \n-func (p *SingleConnPool) SetConn(cn *Conn) {\n-\tif atomic.CompareAndSwapUint32(&p.state, stateDefault, stateInited) {\n-\t\tp.ch <- cn\n-\t} else {\n-\t\tpanic(\"not reached\")\n-\t}\n-}\n-\n-func (p *SingleConnPool) NewConn(ctx context.Context) (*Conn, error) {\n+func (p *StickyConnPool) NewConn(ctx context.Context) (*Conn, error) {\n \treturn p.pool.NewConn(ctx)\n }\n \n-func (p *SingleConnPool) CloseConn(cn *Conn) error {\n+func (p *StickyConnPool) CloseConn(cn *Conn) error {\n \treturn p.pool.CloseConn(cn)\n }\n \n-func (p *SingleConnPool) Get(ctx context.Context) (*Conn, error) {\n+func (p *StickyConnPool) Get(ctx context.Context) (*Conn, error) {\n \t// In worst case this races with Close which is not a very common operation.\n \tfor i := 0; i < 1000; i++ {\n \t\tswitch atomic.LoadUint32(&p.state) {\n@@ -82,7 +77,7 @@ func (p *SingleConnPool) Get(ctx context.Context) (*Conn, error) {\n \t\t\tif atomic.CompareAndSwapUint32(&p.state, stateDefault, stateInited) {\n \t\t\t\treturn cn, nil\n \t\t\t}\n-\t\t\tp.pool.Remove(cn, ErrClosed)\n+\t\t\tp.pool.Remove(ctx, cn, ErrClosed)\n \t\tcase stateInited:\n \t\t\tif err := p.badConnError(); err != nil {\n \t\t\t\treturn nil, err\n@@ -98,60 +93,38 @@ func (p *SingleConnPool) Get(ctx context.Context) (*Conn, error) {\n \t\t\tpanic(\"not reached\")\n \t\t}\n \t}\n-\treturn nil, fmt.Errorf(\"redis: SingleConnPool.Get: infinite loop\")\n+\treturn nil, fmt.Errorf(\"redis: StickyConnPool.Get: infinite loop\")\n }\n \n-func (p *SingleConnPool) Put(cn *Conn) {\n+func (p *StickyConnPool) Put(ctx context.Context, cn *Conn) {\n \tdefer func() {\n \t\tif recover() != nil {\n-\t\t\tp.freeConn(cn)\n+\t\t\tp.freeConn(ctx, cn)\n \t\t}\n \t}()\n \tp.ch <- cn\n }\n \n-func (p *SingleConnPool) freeConn(cn *Conn) {\n+func (p *StickyConnPool) freeConn(ctx context.Context, cn *Conn) {\n \tif err := p.badConnError(); err != nil {\n-\t\tp.pool.Remove(cn, err)\n+\t\tp.pool.Remove(ctx, cn, err)\n \t} else {\n-\t\tp.pool.Put(cn)\n+\t\tp.pool.Put(ctx, cn)\n \t}\n }\n \n-func (p *SingleConnPool) Remove(cn *Conn, reason error) {\n+func (p *StickyConnPool) Remove(ctx context.Context, cn *Conn, reason error) {\n \tdefer func() {\n \t\tif recover() != nil {\n-\t\t\tp.pool.Remove(cn, ErrClosed)\n+\t\t\tp.pool.Remove(ctx, cn, ErrClosed)\n \t\t}\n \t}()\n \tp._badConnError.Store(BadConnError{wrapped: reason})\n \tp.ch <- cn\n }\n \n-func (p *SingleConnPool) Len() int {\n-\tswitch atomic.LoadUint32(&p.state) {\n-\tcase stateDefault:\n-\t\treturn 0\n-\tcase stateInited:\n-\t\treturn 1\n-\tcase stateClosed:\n-\t\treturn 0\n-\tdefault:\n-\t\tpanic(\"not reached\")\n-\t}\n-}\n-\n-func (p *SingleConnPool) IdleLen() int {\n-\treturn len(p.ch)\n-}\n-\n-func (p *SingleConnPool) Stats() *Stats {\n-\treturn &Stats{}\n-}\n-\n-func (p *SingleConnPool) Close() error {\n-\tlevel := atomic.AddInt32(&p.level, -1)\n-\tif level > 0 {\n+func (p *StickyConnPool) Close() error {\n+\tif shared := atomic.AddInt32(&p.shared, -1); shared > 0 {\n \t\treturn nil\n \t}\n \n@@ -164,16 +137,16 @@ func (p *SingleConnPool) Close() error {\n \t\t\tclose(p.ch)\n \t\t\tcn, ok := <-p.ch\n \t\t\tif ok {\n-\t\t\t\tp.freeConn(cn)\n+\t\t\t\tp.freeConn(context.TODO(), cn)\n \t\t\t}\n \t\t\treturn nil\n \t\t}\n \t}\n \n-\treturn fmt.Errorf(\"redis: SingleConnPool.Close: infinite loop\")\n+\treturn errors.New(\"redis: StickyConnPool.Close: infinite loop\")\n }\n \n-func (p *SingleConnPool) Reset() error {\n+func (p *StickyConnPool) Reset(ctx context.Context) error {\n \tif p.badConnError() == nil {\n \t\treturn nil\n \t}\n@@ -183,26 +156,46 @@ func (p *SingleConnPool) Reset() error {\n \t\tif !ok {\n \t\t\treturn ErrClosed\n \t\t}\n-\t\tp.pool.Remove(cn, ErrClosed)\n+\t\tp.pool.Remove(ctx, cn, ErrClosed)\n \t\tp._badConnError.Store(BadConnError{wrapped: nil})\n \tdefault:\n-\t\treturn fmt.Errorf(\"redis: SingleConnPool does not have a Conn\")\n+\t\treturn errors.New(\"redis: StickyConnPool does not have a Conn\")\n \t}\n \n \tif !atomic.CompareAndSwapUint32(&p.state, stateInited, stateDefault) {\n \t\tstate := atomic.LoadUint32(&p.state)\n-\t\treturn fmt.Errorf(\"redis: invalid SingleConnPool state: %d\", state)\n+\t\treturn fmt.Errorf(\"redis: invalid StickyConnPool state: %d\", state)\n \t}\n \n \treturn nil\n }\n \n-func (p *SingleConnPool) badConnError() error {\n+func (p *StickyConnPool) badConnError() error {\n \tif v := p._badConnError.Load(); v != nil {\n-\t\terr := v.(BadConnError)\n-\t\tif err.wrapped != nil {\n+\t\tif err := v.(BadConnError); err.wrapped != nil {\n \t\t\treturn err\n \t\t}\n \t}\n \treturn nil\n }\n+\n+func (p *StickyConnPool) Len() int {\n+\tswitch atomic.LoadUint32(&p.state) {\n+\tcase stateDefault:\n+\t\treturn 0\n+\tcase stateInited:\n+\t\treturn 1\n+\tcase stateClosed:\n+\t\treturn 0\n+\tdefault:\n+\t\tpanic(\"not reached\")\n+\t}\n+}\n+\n+func (p *StickyConnPool) IdleLen() int {\n+\treturn len(p.ch)\n+}\n+\n+func (p *StickyConnPool) Stats() *Stats {\n+\treturn &Stats{}\n+}",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/pool/pool_single.go"
    },
    {
      "sha": "0e6ca779b18984871279e8c5ddf272bb3e223533",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/proto/reader.go",
      "status": "renamed",
      "additions": 26,
      "deletions": 8,
      "changes": 34,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Freader.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Freader.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Freader.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -5,9 +5,10 @@ import (\n \t\"fmt\"\n \t\"io\"\n \n-\t\"github.com/go-redis/redis/v7/internal/util\"\n+\t\"github.com/go-redis/redis/v8/internal/util\"\n )\n \n+// redis resp protocol data type.\n const (\n \tErrorReply  = '-'\n \tStatusReply = '+'\n@@ -18,7 +19,7 @@ const (\n \n //------------------------------------------------------------------------------\n \n-const Nil = RedisError(\"redis: nil\")\n+const Nil = RedisError(\"redis: nil\") // nolint:errname\n \n type RedisError string\n \n@@ -71,13 +72,25 @@ func (r *Reader) ReadLine() ([]byte, error) {\n func (r *Reader) readLine() ([]byte, error) {\n \tb, err := r.rd.ReadSlice('\\n')\n \tif err != nil {\n-\t\treturn nil, err\n+\t\tif err != bufio.ErrBufferFull {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tfull := make([]byte, len(b))\n+\t\tcopy(full, b)\n+\n+\t\tb, err = r.rd.ReadBytes('\\n')\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tfull = append(full, b...) //nolint:makezero\n+\t\tb = full\n \t}\n \tif len(b) <= 2 || b[len(b)-1] != '\\n' || b[len(b)-2] != '\\r' {\n \t\treturn nil, fmt.Errorf(\"redis: invalid reply: %q\", b)\n \t}\n-\tb = b[:len(b)-2]\n-\treturn b, nil\n+\treturn b[:len(b)-2], nil\n }\n \n func (r *Reader) ReadReply(m MultiBulkParse) (interface{}, error) {\n@@ -181,7 +194,7 @@ func (r *Reader) ReadArrayReply(m MultiBulkParse) (interface{}, error) {\n \t}\n }\n \n-func (r *Reader) ReadArrayLen() (int64, error) {\n+func (r *Reader) ReadArrayLen() (int, error) {\n \tline, err := r.ReadLine()\n \tif err != nil {\n \t\treturn 0, err\n@@ -190,7 +203,11 @@ func (r *Reader) ReadArrayLen() (int64, error) {\n \tcase ErrorReply:\n \t\treturn 0, ParseErrorReply(line)\n \tcase ArrayReply:\n-\t\treturn parseArrayLen(line)\n+\t\tn, err := parseArrayLen(line)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\treturn int(n), nil\n \tdefault:\n \t\treturn 0, fmt.Errorf(\"redis: can't parse array reply: %.100q\", line)\n \t}\n@@ -216,7 +233,8 @@ func (r *Reader) ReadScanReply() ([]string, uint64, error) {\n \t}\n \n \tkeys := make([]string, n)\n-\tfor i := int64(0); i < n; i++ {\n+\n+\tfor i := 0; i < n; i++ {\n \t\tkey, err := r.ReadString()\n \t\tif err != nil {\n \t\t\treturn nil, 0, err",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/proto/reader.go"
    },
    {
      "sha": "0e994765feed102597ddfcb7b610a7a1efbd5bd9",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/proto/scan.go",
      "status": "renamed",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Fscan.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Fscan.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Fscan.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -4,10 +4,13 @@ import (\n \t\"encoding\"\n \t\"fmt\"\n \t\"reflect\"\n+\t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal/util\"\n+\t\"github.com/go-redis/redis/v8/internal/util\"\n )\n \n+// Scan parses bytes `b` to `v` with appropriate type.\n+//nolint:gocyclo\n func Scan(b []byte, v interface{}) error {\n \tswitch v := v.(type) {\n \tcase nil:\n@@ -99,6 +102,17 @@ func Scan(b []byte, v interface{}) error {\n \tcase *bool:\n \t\t*v = len(b) == 1 && b[0] == '1'\n \t\treturn nil\n+\tcase *time.Time:\n+\t\tvar err error\n+\t\t*v, err = time.Parse(time.RFC3339Nano, util.BytesToString(b))\n+\t\treturn err\n+\tcase *time.Duration:\n+\t\tn, err := util.ParseInt(b, 10, 64)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*v = time.Duration(n)\n+\t\treturn nil\n \tcase encoding.BinaryUnmarshaler:\n \t\treturn v.UnmarshalBinary(b)\n \tdefault:\n@@ -124,7 +138,7 @@ func ScanSlice(data []string, slice interface{}) error {\n \tfor i, s := range data {\n \t\telem := next()\n \t\tif err := Scan([]byte(s), elem.Addr().Interface()); err != nil {\n-\t\t\terr = fmt.Errorf(\"redis: ScanSlice index=%d value=%q failed: %s\", i, s, err)\n+\t\t\terr = fmt.Errorf(\"redis: ScanSlice index=%d value=%q failed: %w\", i, s, err)\n \t\t\treturn err\n \t\t}\n \t}",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/proto/scan.go"
    },
    {
      "sha": "c4260981ed14bea997b86f18d51825ef2c60e89a",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/proto/writer.go",
      "status": "renamed",
      "additions": 25,
      "deletions": 35,
      "changes": 60,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Fwriter.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Fwriter.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fproto%2Fwriter.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,46 +1,49 @@\n package proto\n \n import (\n-\t\"bufio\"\n \t\"encoding\"\n \t\"fmt\"\n \t\"io\"\n \t\"strconv\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal/util\"\n+\t\"github.com/go-redis/redis/v8/internal/util\"\n )\n \n+type writer interface {\n+\tio.Writer\n+\tio.ByteWriter\n+\t// io.StringWriter\n+\tWriteString(s string) (n int, err error)\n+}\n+\n type Writer struct {\n-\twr *bufio.Writer\n+\twriter\n \n \tlenBuf []byte\n \tnumBuf []byte\n }\n \n-func NewWriter(wr io.Writer) *Writer {\n+func NewWriter(wr writer) *Writer {\n \treturn &Writer{\n-\t\twr: bufio.NewWriter(wr),\n+\t\twriter: wr,\n \n \t\tlenBuf: make([]byte, 64),\n \t\tnumBuf: make([]byte, 64),\n \t}\n }\n \n func (w *Writer) WriteArgs(args []interface{}) error {\n-\terr := w.wr.WriteByte(ArrayReply)\n-\tif err != nil {\n+\tif err := w.WriteByte(ArrayReply); err != nil {\n \t\treturn err\n \t}\n \n-\terr = w.writeLen(len(args))\n-\tif err != nil {\n+\tif err := w.writeLen(len(args)); err != nil {\n \t\treturn err\n \t}\n \n \tfor _, arg := range args {\n-\t\terr := w.writeArg(arg)\n-\t\tif err != nil {\n+\t\tif err := w.WriteArg(arg); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -51,11 +54,11 @@ func (w *Writer) WriteArgs(args []interface{}) error {\n func (w *Writer) writeLen(n int) error {\n \tw.lenBuf = strconv.AppendUint(w.lenBuf[:0], uint64(n), 10)\n \tw.lenBuf = append(w.lenBuf, '\\r', '\\n')\n-\t_, err := w.wr.Write(w.lenBuf)\n+\t_, err := w.Write(w.lenBuf)\n \treturn err\n }\n \n-func (w *Writer) writeArg(v interface{}) error {\n+func (w *Writer) WriteArg(v interface{}) error {\n \tswitch v := v.(type) {\n \tcase nil:\n \t\treturn w.string(\"\")\n@@ -93,7 +96,10 @@ func (w *Writer) writeArg(v interface{}) error {\n \t\t}\n \t\treturn w.int(0)\n \tcase time.Time:\n-\t\treturn w.string(v.Format(time.RFC3339Nano))\n+\t\tw.numBuf = v.AppendFormat(w.numBuf[:0], time.RFC3339Nano)\n+\t\treturn w.bytes(w.numBuf)\n+\tcase time.Duration:\n+\t\treturn w.int(v.Nanoseconds())\n \tcase encoding.BinaryMarshaler:\n \t\tb, err := v.MarshalBinary()\n \t\tif err != nil {\n@@ -107,18 +113,15 @@ func (w *Writer) writeArg(v interface{}) error {\n }\n \n func (w *Writer) bytes(b []byte) error {\n-\terr := w.wr.WriteByte(StringReply)\n-\tif err != nil {\n+\tif err := w.WriteByte(StringReply); err != nil {\n \t\treturn err\n \t}\n \n-\terr = w.writeLen(len(b))\n-\tif err != nil {\n+\tif err := w.writeLen(len(b)); err != nil {\n \t\treturn err\n \t}\n \n-\t_, err = w.wr.Write(b)\n-\tif err != nil {\n+\tif _, err := w.Write(b); err != nil {\n \t\treturn err\n \t}\n \n@@ -145,21 +148,8 @@ func (w *Writer) float(f float64) error {\n }\n \n func (w *Writer) crlf() error {\n-\terr := w.wr.WriteByte('\\r')\n-\tif err != nil {\n+\tif err := w.WriteByte('\\r'); err != nil {\n \t\treturn err\n \t}\n-\treturn w.wr.WriteByte('\\n')\n-}\n-\n-func (w *Writer) Buffered() int {\n-\treturn w.wr.Buffered()\n-}\n-\n-func (w *Writer) Reset(wr io.Writer) {\n-\tw.wr.Reset(wr)\n-}\n-\n-func (w *Writer) Flush() error {\n-\treturn w.wr.Flush()\n+\treturn w.WriteByte('\\n')\n }",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/proto/writer.go"
    },
    {
      "sha": "2edccba94fe88821e1d8e3750922fbd0b9817374",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/rand/rand.go",
      "status": "added",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Frand%2Frand.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Frand%2Frand.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Frand%2Frand.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,50 @@\n+package rand\n+\n+import (\n+\t\"math/rand\"\n+\t\"sync\"\n+)\n+\n+// Int returns a non-negative pseudo-random int.\n+func Int() int { return pseudo.Int() }\n+\n+// Intn returns, as an int, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n+func Intn(n int) int { return pseudo.Intn(n) }\n+\n+// Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).\n+// It panics if n <= 0.\n+func Int63n(n int64) int64 { return pseudo.Int63n(n) }\n+\n+// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).\n+func Perm(n int) []int { return pseudo.Perm(n) }\n+\n+// Seed uses the provided seed value to initialize the default Source to a\n+// deterministic state. If Seed is not called, the generator behaves as if\n+// seeded by Seed(1).\n+func Seed(n int64) { pseudo.Seed(n) }\n+\n+var pseudo = rand.New(&source{src: rand.NewSource(1)})\n+\n+type source struct {\n+\tsrc rand.Source\n+\tmu  sync.Mutex\n+}\n+\n+func (s *source) Int63() int64 {\n+\ts.mu.Lock()\n+\tn := s.src.Int63()\n+\ts.mu.Unlock()\n+\treturn n\n+}\n+\n+func (s *source) Seed(seed int64) {\n+\ts.mu.Lock()\n+\ts.src.Seed(seed)\n+\ts.mu.Unlock()\n+}\n+\n+// Shuffle pseudo-randomizes the order of elements.\n+// n is the number of elements.\n+// swap swaps the elements with indexes i and j.\n+func Shuffle(n int, swap func(i, j int)) { pseudo.Shuffle(n, swap) }"
    },
    {
      "sha": "fd2f43409472909eb539e73f92b70d74d5b9b2e8",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/safe.go",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fsafe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fsafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Fsafe.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,12 @@\n+//go:build appengine\n+// +build appengine\n+\n+package internal\n+\n+func String(b []byte) string {\n+\treturn string(b)\n+}\n+\n+func Bytes(s string) []byte {\n+\treturn []byte(s)\n+}"
    },
    {
      "sha": "9f2e418f7901993bcd990d1e62523eebee018440",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/unsafe.go",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Funsafe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Funsafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Funsafe.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,21 @@\n+//go:build !appengine\n+// +build !appengine\n+\n+package internal\n+\n+import \"unsafe\"\n+\n+// String converts byte slice to string.\n+func String(b []byte) string {\n+\treturn *(*string)(unsafe.Pointer(&b))\n+}\n+\n+// Bytes converts string to byte slice.\n+func Bytes(s string) []byte {\n+\treturn *(*[]byte)(unsafe.Pointer(\n+\t\t&struct {\n+\t\t\tstring\n+\t\t\tCap int\n+\t\t}{s, len(s)},\n+\t))\n+}"
    },
    {
      "sha": "e34a7f032620129337468474297c941798167883",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/util.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 11,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -4,7 +4,7 @@ import (\n \t\"context\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal/util\"\n+\t\"github.com/go-redis/redis/v8/internal/util\"\n )\n \n func Sleep(ctx context.Context, dur time.Duration) error {\n@@ -44,13 +44,3 @@ func isLower(s string) bool {\n \t}\n \treturn true\n }\n-\n-func Unwrap(err error) error {\n-\tu, ok := err.(interface {\n-\t\tUnwrap() error\n-\t})\n-\tif !ok {\n-\t\treturn nil\n-\t}\n-\treturn u.Unwrap()\n-}",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/util.go"
    },
    {
      "sha": "21307110bd544ee19414db435e47e32748e50e95",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/util/safe.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Fsafe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Fsafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Fsafe.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,3 +1,4 @@\n+//go:build appengine\n // +build appengine\n \n package util",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/util/safe.go"
    },
    {
      "sha": "db5033802a958bfbd1c0590daf1d58e9b7bb663e",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/util/strconv.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Fstrconv.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Fstrconv.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Fstrconv.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/util/strconv.go"
    },
    {
      "sha": "daa8d7692ae0cabb9447b57825853a746c5034b3",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/internal/util/unsafe.go",
      "status": "renamed",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Funsafe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Funsafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Finternal%2Futil%2Funsafe.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,3 +1,4 @@\n+//go:build !appengine\n // +build !appengine\n \n package util",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/internal/util/unsafe.go"
    },
    {
      "sha": "2f8bc2beda083563af654cbd1e7c06c94bb9766c",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/iterator.go",
      "status": "renamed",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fiterator.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fiterator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fiterator.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -1,6 +1,7 @@\n package redis\n \n import (\n+\t\"context\"\n \t\"sync\"\n )\n \n@@ -21,7 +22,7 @@ func (it *ScanIterator) Err() error {\n }\n \n // Next advances the cursor and returns true if more values can be read.\n-func (it *ScanIterator) Next() bool {\n+func (it *ScanIterator) Next(ctx context.Context) bool {\n \tit.mu.Lock()\n \tdefer it.mu.Unlock()\n \n@@ -43,13 +44,14 @@ func (it *ScanIterator) Next() bool {\n \t\t}\n \n \t\t// Fetch next page.\n-\t\tif it.cmd.args[0] == \"scan\" {\n+\t\tswitch it.cmd.args[0] {\n+\t\tcase \"scan\", \"qscan\":\n \t\t\tit.cmd.args[1] = it.cmd.cursor\n-\t\t} else {\n+\t\tdefault:\n \t\t\tit.cmd.args[2] = it.cmd.cursor\n \t\t}\n \n-\t\terr := it.cmd.process(it.cmd)\n+\t\terr := it.cmd.process(ctx, it.cmd)\n \t\tif err != nil {\n \t\t\treturn false\n \t\t}",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/iterator.go"
    },
    {
      "sha": "a4abe32c3a04e76984b6a07feca6a8d393acdb89",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/options.go",
      "status": "renamed",
      "additions": 206,
      "deletions": 26,
      "changes": 232,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Foptions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Foptions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Foptions.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -8,11 +8,12 @@ import (\n \t\"net\"\n \t\"net/url\"\n \t\"runtime\"\n+\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n )\n \n // Limiter is the interface of a rate limiter or a circuit breaker.\n@@ -26,6 +27,7 @@ type Limiter interface {\n \tReportResult(result error)\n }\n \n+// Options keeps the settings to setup redis connection.\n type Options struct {\n \t// The network type, either tcp or unix.\n \t// Default is tcp.\n@@ -38,21 +40,23 @@ type Options struct {\n \tDialer func(ctx context.Context, network, addr string) (net.Conn, error)\n \n \t// Hook that is called when new connection is established.\n-\tOnConnect func(*Conn) error\n+\tOnConnect func(ctx context.Context, cn *Conn) error\n \n-\t// Use the specified Username to authenticate the current connection with one of the connections defined in the ACL\n-\t// list when connecting to a Redis 6.0 instance, or greater, that is using the Redis ACL system.\n+\t// Use the specified Username to authenticate the current connection\n+\t// with one of the connections defined in the ACL list when connecting\n+\t// to a Redis 6.0 instance, or greater, that is using the Redis ACL system.\n \tUsername string\n-\n \t// Optional password. Must match the password specified in the\n \t// requirepass server configuration option (if connecting to a Redis 5.0 instance, or lower),\n-\t// or the User Password when connecting to a Redis 6.0 instance, or greater, that is using the Redis ACL system.\n+\t// or the User Password when connecting to a Redis 6.0 instance, or greater,\n+\t// that is using the Redis ACL system.\n \tPassword string\n+\n \t// Database to be selected after connecting to the server.\n \tDB int\n \n \t// Maximum number of retries before giving up.\n-\t// Default is to not retry failed commands.\n+\t// Default is 3 retries; -1 (not 0) disables retries.\n \tMaxRetries int\n \t// Minimum backoff between each retry.\n \t// Default is 8 milliseconds; -1 disables backoff.\n@@ -73,8 +77,12 @@ type Options struct {\n \t// Default is ReadTimeout.\n \tWriteTimeout time.Duration\n \n+\t// Type of connection pool.\n+\t// true for FIFO pool, false for LIFO pool.\n+\t// Note that fifo has higher overhead compared to lifo.\n+\tPoolFIFO bool\n \t// Maximum number of socket connections.\n-\t// Default is 10 connections per every CPU as reported by runtime.NumCPU.\n+\t// Default is 10 connections per every available CPU as reported by runtime.GOMAXPROCS.\n \tPoolSize int\n \t// Minimum number of idle connections which is useful when establishing\n \t// new connection is slow.\n@@ -117,6 +125,9 @@ func (opt *Options) init() {\n \t\t\topt.Network = \"tcp\"\n \t\t}\n \t}\n+\tif opt.DialTimeout == 0 {\n+\t\topt.DialTimeout = 5 * time.Second\n+\t}\n \tif opt.Dialer == nil {\n \t\topt.Dialer = func(ctx context.Context, network, addr string) (net.Conn, error) {\n \t\t\tnetDialer := &net.Dialer{\n@@ -130,10 +141,7 @@ func (opt *Options) init() {\n \t\t}\n \t}\n \tif opt.PoolSize == 0 {\n-\t\topt.PoolSize = 10 * runtime.NumCPU()\n-\t}\n-\tif opt.DialTimeout == 0 {\n-\t\topt.DialTimeout = 5 * time.Second\n+\t\topt.PoolSize = 10 * runtime.GOMAXPROCS(0)\n \t}\n \tswitch opt.ReadTimeout {\n \tcase -1:\n@@ -159,6 +167,8 @@ func (opt *Options) init() {\n \n \tif opt.MaxRetries == -1 {\n \t\topt.MaxRetries = 0\n+\t} else if opt.MaxRetries == 0 {\n+\t\topt.MaxRetries = 3\n \t}\n \tswitch opt.MinRetryBackoff {\n \tcase -1:\n@@ -180,27 +190,55 @@ func (opt *Options) clone() *Options {\n }\n \n // ParseURL parses an URL into Options that can be used to connect to Redis.\n+// Scheme is required.\n+// There are two connection types: by tcp socket and by unix socket.\n+// Tcp connection:\n+//\t\tredis://<user>:<password>@<host>:<port>/<db_number>\n+// Unix connection:\n+//\t\tunix://<user>:<password>@</path/to/redis.sock>?db=<db_number>\n+// Most Option fields can be set using query parameters, with the following restrictions:\n+//\t- field names are mapped using snake-case conversion: to set MaxRetries, use max_retries\n+//\t- only scalar type fields are supported (bool, int, time.Duration)\n+//\t- for time.Duration fields, values must be a valid input for time.ParseDuration();\n+//\t  additionally a plain integer as value (i.e. without unit) is intepreted as seconds\n+//\t- to disable a duration field, use value less than or equal to 0; to use the default\n+//\t  value, leave the value blank or remove the parameter\n+//\t- only the last value is interpreted if a parameter is given multiple times\n+//\t- fields \"network\", \"addr\", \"username\" and \"password\" can only be set using other\n+//\t  URL attributes (scheme, host, userinfo, resp.), query paremeters using these\n+//\t  names will be treated as unknown parameters\n+//\t- unknown parameter names will result in an error\n+// Examples:\n+//\t\tredis://user:password@localhost:6789/3?dial_timeout=3&db=1&read_timeout=6s&max_retries=2\n+//\t\tis equivalent to:\n+//\t\t&Options{\n+//\t\t\tNetwork:     \"tcp\",\n+//\t\t\tAddr:        \"localhost:6789\",\n+//\t\t\tDB:          1,               // path \"/3\" was overridden by \"&db=1\"\n+//\t\t\tDialTimeout: 3 * time.Second, // no time unit = seconds\n+//\t\t\tReadTimeout: 6 * time.Second,\n+//\t\t\tMaxRetries:  2,\n+//\t\t}\n func ParseURL(redisURL string) (*Options, error) {\n-\to := &Options{Network: \"tcp\"}\n \tu, err := url.Parse(redisURL)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tif u.Scheme != \"redis\" && u.Scheme != \"rediss\" {\n-\t\treturn nil, errors.New(\"invalid redis URL scheme: \" + u.Scheme)\n+\tswitch u.Scheme {\n+\tcase \"redis\", \"rediss\":\n+\t\treturn setupTCPConn(u)\n+\tcase \"unix\":\n+\t\treturn setupUnixConn(u)\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"redis: invalid URL scheme: %s\", u.Scheme)\n \t}\n+}\n \n-\tif u.User != nil {\n-\t\to.Username = u.User.Username()\n-\t\tif p, ok := u.User.Password(); ok {\n-\t\t\to.Password = p\n-\t\t}\n-\t}\n+func setupTCPConn(u *url.URL) (*Options, error) {\n+\to := &Options{Network: \"tcp\"}\n \n-\tif len(u.Query()) > 0 {\n-\t\treturn nil, errors.New(\"no options supported\")\n-\t}\n+\to.Username, o.Password = getUserPassword(u)\n \n \th, p, err := net.SplitHostPort(u.Host)\n \tif err != nil {\n@@ -222,23 +260,165 @@ func ParseURL(redisURL string) (*Options, error) {\n \t\to.DB = 0\n \tcase 1:\n \t\tif o.DB, err = strconv.Atoi(f[0]); err != nil {\n-\t\t\treturn nil, fmt.Errorf(\"invalid redis database number: %q\", f[0])\n+\t\t\treturn nil, fmt.Errorf(\"redis: invalid database number: %q\", f[0])\n \t\t}\n \tdefault:\n-\t\treturn nil, errors.New(\"invalid redis URL path: \" + u.Path)\n+\t\treturn nil, fmt.Errorf(\"redis: invalid URL path: %s\", u.Path)\n \t}\n \n \tif u.Scheme == \"rediss\" {\n \t\to.TLSConfig = &tls.Config{ServerName: h}\n \t}\n+\n+\treturn setupConnParams(u, o)\n+}\n+\n+func setupUnixConn(u *url.URL) (*Options, error) {\n+\to := &Options{\n+\t\tNetwork: \"unix\",\n+\t}\n+\n+\tif strings.TrimSpace(u.Path) == \"\" { // path is required with unix connection\n+\t\treturn nil, errors.New(\"redis: empty unix socket path\")\n+\t}\n+\to.Addr = u.Path\n+\to.Username, o.Password = getUserPassword(u)\n+\treturn setupConnParams(u, o)\n+}\n+\n+type queryOptions struct {\n+\tq   url.Values\n+\terr error\n+}\n+\n+func (o *queryOptions) string(name string) string {\n+\tvs := o.q[name]\n+\tif len(vs) == 0 {\n+\t\treturn \"\"\n+\t}\n+\tdelete(o.q, name) // enable detection of unknown parameters\n+\treturn vs[len(vs)-1]\n+}\n+\n+func (o *queryOptions) int(name string) int {\n+\ts := o.string(name)\n+\tif s == \"\" {\n+\t\treturn 0\n+\t}\n+\ti, err := strconv.Atoi(s)\n+\tif err == nil {\n+\t\treturn i\n+\t}\n+\tif o.err == nil {\n+\t\to.err = fmt.Errorf(\"redis: invalid %s number: %s\", name, err)\n+\t}\n+\treturn 0\n+}\n+\n+func (o *queryOptions) duration(name string) time.Duration {\n+\ts := o.string(name)\n+\tif s == \"\" {\n+\t\treturn 0\n+\t}\n+\t// try plain number first\n+\tif i, err := strconv.Atoi(s); err == nil {\n+\t\tif i <= 0 {\n+\t\t\t// disable timeouts\n+\t\t\treturn -1\n+\t\t}\n+\t\treturn time.Duration(i) * time.Second\n+\t}\n+\tdur, err := time.ParseDuration(s)\n+\tif err == nil {\n+\t\treturn dur\n+\t}\n+\tif o.err == nil {\n+\t\to.err = fmt.Errorf(\"redis: invalid %s duration: %w\", name, err)\n+\t}\n+\treturn 0\n+}\n+\n+func (o *queryOptions) bool(name string) bool {\n+\tswitch s := o.string(name); s {\n+\tcase \"true\", \"1\":\n+\t\treturn true\n+\tcase \"false\", \"0\", \"\":\n+\t\treturn false\n+\tdefault:\n+\t\tif o.err == nil {\n+\t\t\to.err = fmt.Errorf(\"redis: invalid %s boolean: expected true/false/1/0 or an empty string, got %q\", name, s)\n+\t\t}\n+\t\treturn false\n+\t}\n+}\n+\n+func (o *queryOptions) remaining() []string {\n+\tif len(o.q) == 0 {\n+\t\treturn nil\n+\t}\n+\tkeys := make([]string, 0, len(o.q))\n+\tfor k := range o.q {\n+\t\tkeys = append(keys, k)\n+\t}\n+\tsort.Strings(keys)\n+\treturn keys\n+}\n+\n+// setupConnParams converts query parameters in u to option value in o.\n+func setupConnParams(u *url.URL, o *Options) (*Options, error) {\n+\tq := queryOptions{q: u.Query()}\n+\n+\t// compat: a future major release may use q.int(\"db\")\n+\tif tmp := q.string(\"db\"); tmp != \"\" {\n+\t\tdb, err := strconv.Atoi(tmp)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"redis: invalid database number: %w\", err)\n+\t\t}\n+\t\to.DB = db\n+\t}\n+\n+\to.MaxRetries = q.int(\"max_retries\")\n+\to.MinRetryBackoff = q.duration(\"min_retry_backoff\")\n+\to.MaxRetryBackoff = q.duration(\"max_retry_backoff\")\n+\to.DialTimeout = q.duration(\"dial_timeout\")\n+\to.ReadTimeout = q.duration(\"read_timeout\")\n+\to.WriteTimeout = q.duration(\"write_timeout\")\n+\to.PoolFIFO = q.bool(\"pool_fifo\")\n+\to.PoolSize = q.int(\"pool_size\")\n+\to.MinIdleConns = q.int(\"min_idle_conns\")\n+\to.MaxConnAge = q.duration(\"max_conn_age\")\n+\to.PoolTimeout = q.duration(\"pool_timeout\")\n+\to.IdleTimeout = q.duration(\"idle_timeout\")\n+\to.IdleCheckFrequency = q.duration(\"idle_check_frequency\")\n+\tif q.err != nil {\n+\t\treturn nil, q.err\n+\t}\n+\n+\t// any parameters left?\n+\tif r := q.remaining(); len(r) > 0 {\n+\t\treturn nil, fmt.Errorf(\"redis: unexpected option: %s\", strings.Join(r, \", \"))\n+\t}\n+\n \treturn o, nil\n }\n \n+func getUserPassword(u *url.URL) (string, string) {\n+\tvar user, password string\n+\tif u.User != nil {\n+\t\tuser = u.User.Username()\n+\t\tif p, ok := u.User.Password(); ok {\n+\t\t\tpassword = p\n+\t\t}\n+\t}\n+\treturn user, password\n+}\n+\n func newConnPool(opt *Options) *pool.ConnPool {\n \treturn pool.NewConnPool(&pool.Options{\n \t\tDialer: func(ctx context.Context) (net.Conn, error) {\n \t\t\treturn opt.Dialer(ctx, opt.Network, opt.Addr)\n \t\t},\n+\t\tPoolFIFO:           opt.PoolFIFO,\n \t\tPoolSize:           opt.PoolSize,\n \t\tMinIdleConns:       opt.MinIdleConns,\n \t\tMaxConnAge:         opt.MaxConnAge,",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/options.go"
    },
    {
      "sha": "e4ea4bb074c418c016bae3351c65450ff7f8a8eb",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/package.json",
      "status": "added",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpackage.json",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpackage.json",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpackage.json?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,8 @@\n+{\n+  \"name\": \"redis\",\n+  \"version\": \"8.11.5\",\n+  \"main\": \"index.js\",\n+  \"repository\": \"git@github.com:go-redis/redis.git\",\n+  \"author\": \"Vladimir Mihailenco <vladimir.webdev@gmail.com>\",\n+  \"license\": \"BSD-2-clause\"\n+}"
    },
    {
      "sha": "31bab971e63fd2f15db681347574053262303b37",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/pipeline.go",
      "status": "renamed",
      "additions": 23,
      "deletions": 18,
      "changes": 41,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpipeline.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpipeline.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpipeline.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -4,7 +4,7 @@ import (\n \t\"context\"\n \t\"sync\"\n \n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n )\n \n type pipelineExecer func(context.Context, []Cmder) error\n@@ -24,12 +24,12 @@ type pipelineExecer func(context.Context, []Cmder) error\n // depends of your batch size and/or use TxPipeline.\n type Pipeliner interface {\n \tStatefulCmdable\n-\tDo(args ...interface{}) *Cmd\n-\tProcess(cmd Cmder) error\n+\tLen() int\n+\tDo(ctx context.Context, args ...interface{}) *Cmd\n+\tProcess(ctx context.Context, cmd Cmder) error\n \tClose() error\n \tDiscard() error\n-\tExec() ([]Cmder, error)\n-\tExecContext(ctx context.Context) ([]Cmder, error)\n+\tExec(ctx context.Context) ([]Cmder, error)\n }\n \n var _ Pipeliner = (*Pipeline)(nil)\n@@ -54,14 +54,23 @@ func (c *Pipeline) init() {\n \tc.statefulCmdable = c.Process\n }\n \n-func (c *Pipeline) Do(args ...interface{}) *Cmd {\n-\tcmd := NewCmd(args...)\n-\t_ = c.Process(cmd)\n+// Len returns the number of queued commands.\n+func (c *Pipeline) Len() int {\n+\tc.mu.Lock()\n+\tln := len(c.cmds)\n+\tc.mu.Unlock()\n+\treturn ln\n+}\n+\n+// Do queues the custom command for later execution.\n+func (c *Pipeline) Do(ctx context.Context, args ...interface{}) *Cmd {\n+\tcmd := NewCmd(ctx, args...)\n+\t_ = c.Process(ctx, cmd)\n \treturn cmd\n }\n \n // Process queues the cmd for later execution.\n-func (c *Pipeline) Process(cmd Cmder) error {\n+func (c *Pipeline) Process(ctx context.Context, cmd Cmder) error {\n \tc.mu.Lock()\n \tc.cmds = append(c.cmds, cmd)\n \tc.mu.Unlock()\n@@ -98,11 +107,7 @@ func (c *Pipeline) discard() error {\n //\n // Exec always returns list of commands and error of the first failed\n // command if any.\n-func (c *Pipeline) Exec() ([]Cmder, error) {\n-\treturn c.ExecContext(c.ctx)\n-}\n-\n-func (c *Pipeline) ExecContext(ctx context.Context) ([]Cmder, error) {\n+func (c *Pipeline) Exec(ctx context.Context) ([]Cmder, error) {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n \n@@ -120,11 +125,11 @@ func (c *Pipeline) ExecContext(ctx context.Context) ([]Cmder, error) {\n \treturn cmds, c.exec(ctx, cmds)\n }\n \n-func (c *Pipeline) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n+func (c *Pipeline) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n \tif err := fn(c); err != nil {\n \t\treturn nil, err\n \t}\n-\tcmds, err := c.Exec()\n+\tcmds, err := c.Exec(ctx)\n \t_ = c.Close()\n \treturn cmds, err\n }\n@@ -133,8 +138,8 @@ func (c *Pipeline) Pipeline() Pipeliner {\n \treturn c\n }\n \n-func (c *Pipeline) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.Pipelined(fn)\n+func (c *Pipeline) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.Pipelined(ctx, fn)\n }\n \n func (c *Pipeline) TxPipeline() Pipeliner {",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/pipeline.go"
    },
    {
      "sha": "efc2354af0c547b99cc7a96f5c595f34609e9675",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/pubsub.go",
      "status": "renamed",
      "additions": 214,
      "deletions": 141,
      "changes": 355,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpubsub.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpubsub.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fpubsub.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -2,21 +2,16 @@ package redis\n \n import (\n \t\"context\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal\"\n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/proto\"\n )\n \n-const pingTimeout = 30 * time.Second\n-\n-var errPingTimeout = errors.New(\"redis: ping timeout\")\n-\n // PubSub implements Pub/Sub commands as described in\n // http://redis.io/topics/pubsub. Message receiving is NOT safe\n // for concurrent use by multiple goroutines.\n@@ -26,7 +21,7 @@ var errPingTimeout = errors.New(\"redis: ping timeout\")\n type PubSub struct {\n \topt *Options\n \n-\tnewConn   func([]string) (*pool.Conn, error)\n+\tnewConn   func(ctx context.Context, channels []string) (*pool.Conn, error)\n \tcloseConn func(*pool.Conn) error\n \n \tmu       sync.Mutex\n@@ -40,9 +35,12 @@ type PubSub struct {\n \tcmd *Cmd\n \n \tchOnce sync.Once\n-\tmsgCh  chan *Message\n-\tallCh  chan interface{}\n-\tping   chan struct{}\n+\tmsgCh  *channel\n+\tallCh  *channel\n+}\n+\n+func (c *PubSub) init() {\n+\tc.exit = make(chan struct{})\n }\n \n func (c *PubSub) String() string {\n@@ -51,18 +49,14 @@ func (c *PubSub) String() string {\n \treturn fmt.Sprintf(\"PubSub(%s)\", strings.Join(channels, \", \"))\n }\n \n-func (c *PubSub) init() {\n-\tc.exit = make(chan struct{})\n-}\n-\n-func (c *PubSub) connWithLock() (*pool.Conn, error) {\n+func (c *PubSub) connWithLock(ctx context.Context) (*pool.Conn, error) {\n \tc.mu.Lock()\n-\tcn, err := c.conn(nil)\n+\tcn, err := c.conn(ctx, nil)\n \tc.mu.Unlock()\n \treturn cn, err\n }\n \n-func (c *PubSub) conn(newChannels []string) (*pool.Conn, error) {\n+func (c *PubSub) conn(ctx context.Context, newChannels []string) (*pool.Conn, error) {\n \tif c.closed {\n \t\treturn nil, pool.ErrClosed\n \t}\n@@ -73,12 +67,12 @@ func (c *PubSub) conn(newChannels []string) (*pool.Conn, error) {\n \tchannels := mapKeys(c.channels)\n \tchannels = append(channels, newChannels...)\n \n-\tcn, err := c.newConn(channels)\n+\tcn, err := c.newConn(ctx, channels)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tif err := c.resubscribe(cn); err != nil {\n+\tif err := c.resubscribe(ctx, cn); err != nil {\n \t\t_ = c.closeConn(cn)\n \t\treturn nil, err\n \t}\n@@ -93,15 +87,15 @@ func (c *PubSub) writeCmd(ctx context.Context, cn *pool.Conn, cmd Cmder) error {\n \t})\n }\n \n-func (c *PubSub) resubscribe(cn *pool.Conn) error {\n+func (c *PubSub) resubscribe(ctx context.Context, cn *pool.Conn) error {\n \tvar firstErr error\n \n \tif len(c.channels) > 0 {\n-\t\tfirstErr = c._subscribe(cn, \"subscribe\", mapKeys(c.channels))\n+\t\tfirstErr = c._subscribe(ctx, cn, \"subscribe\", mapKeys(c.channels))\n \t}\n \n \tif len(c.patterns) > 0 {\n-\t\terr := c._subscribe(cn, \"psubscribe\", mapKeys(c.patterns))\n+\t\terr := c._subscribe(ctx, cn, \"psubscribe\", mapKeys(c.patterns))\n \t\tif err != nil && firstErr == nil {\n \t\t\tfirstErr = err\n \t\t}\n@@ -121,43 +115,48 @@ func mapKeys(m map[string]struct{}) []string {\n }\n \n func (c *PubSub) _subscribe(\n-\tcn *pool.Conn, redisCmd string, channels []string,\n+\tctx context.Context, cn *pool.Conn, redisCmd string, channels []string,\n ) error {\n \targs := make([]interface{}, 0, 1+len(channels))\n \targs = append(args, redisCmd)\n \tfor _, channel := range channels {\n \t\targs = append(args, channel)\n \t}\n-\tcmd := NewSliceCmd(args...)\n-\treturn c.writeCmd(context.TODO(), cn, cmd)\n+\tcmd := NewSliceCmd(ctx, args...)\n+\treturn c.writeCmd(ctx, cn, cmd)\n }\n \n-func (c *PubSub) releaseConnWithLock(cn *pool.Conn, err error, allowTimeout bool) {\n+func (c *PubSub) releaseConnWithLock(\n+\tctx context.Context,\n+\tcn *pool.Conn,\n+\terr error,\n+\tallowTimeout bool,\n+) {\n \tc.mu.Lock()\n-\tc.releaseConn(cn, err, allowTimeout)\n+\tc.releaseConn(ctx, cn, err, allowTimeout)\n \tc.mu.Unlock()\n }\n \n-func (c *PubSub) releaseConn(cn *pool.Conn, err error, allowTimeout bool) {\n+func (c *PubSub) releaseConn(ctx context.Context, cn *pool.Conn, err error, allowTimeout bool) {\n \tif c.cn != cn {\n \t\treturn\n \t}\n-\tif isBadConn(err, allowTimeout) {\n-\t\tc.reconnect(err)\n+\tif isBadConn(err, allowTimeout, c.opt.Addr) {\n+\t\tc.reconnect(ctx, err)\n \t}\n }\n \n-func (c *PubSub) reconnect(reason error) {\n+func (c *PubSub) reconnect(ctx context.Context, reason error) {\n \t_ = c.closeTheCn(reason)\n-\t_, _ = c.conn(nil)\n+\t_, _ = c.conn(ctx, nil)\n }\n \n func (c *PubSub) closeTheCn(reason error) error {\n \tif c.cn == nil {\n \t\treturn nil\n \t}\n \tif !c.closed {\n-\t\tinternal.Logger.Printf(\"redis: discarding bad PubSub connection: %s\", reason)\n+\t\tinternal.Logger.Printf(c.getContext(), \"redis: discarding bad PubSub connection: %s\", reason)\n \t}\n \terr := c.closeConn(c.cn)\n \tc.cn = nil\n@@ -179,11 +178,11 @@ func (c *PubSub) Close() error {\n \n // Subscribe the client to the specified channels. It returns\n // empty subscription if there are no channels.\n-func (c *PubSub) Subscribe(channels ...string) error {\n+func (c *PubSub) Subscribe(ctx context.Context, channels ...string) error {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n \n-\terr := c.subscribe(\"subscribe\", channels...)\n+\terr := c.subscribe(ctx, \"subscribe\", channels...)\n \tif c.channels == nil {\n \t\tc.channels = make(map[string]struct{})\n \t}\n@@ -195,11 +194,11 @@ func (c *PubSub) Subscribe(channels ...string) error {\n \n // PSubscribe the client to the given patterns. It returns\n // empty subscription if there are no patterns.\n-func (c *PubSub) PSubscribe(patterns ...string) error {\n+func (c *PubSub) PSubscribe(ctx context.Context, patterns ...string) error {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n \n-\terr := c.subscribe(\"psubscribe\", patterns...)\n+\terr := c.subscribe(ctx, \"psubscribe\", patterns...)\n \tif c.patterns == nil {\n \t\tc.patterns = make(map[string]struct{})\n \t}\n@@ -211,55 +210,58 @@ func (c *PubSub) PSubscribe(patterns ...string) error {\n \n // Unsubscribe the client from the given channels, or from all of\n // them if none is given.\n-func (c *PubSub) Unsubscribe(channels ...string) error {\n+func (c *PubSub) Unsubscribe(ctx context.Context, channels ...string) error {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n \n \tfor _, channel := range channels {\n \t\tdelete(c.channels, channel)\n \t}\n-\terr := c.subscribe(\"unsubscribe\", channels...)\n+\terr := c.subscribe(ctx, \"unsubscribe\", channels...)\n \treturn err\n }\n \n // PUnsubscribe the client from the given patterns, or from all of\n // them if none is given.\n-func (c *PubSub) PUnsubscribe(patterns ...string) error {\n+func (c *PubSub) PUnsubscribe(ctx context.Context, patterns ...string) error {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n \n \tfor _, pattern := range patterns {\n \t\tdelete(c.patterns, pattern)\n \t}\n-\terr := c.subscribe(\"punsubscribe\", patterns...)\n+\terr := c.subscribe(ctx, \"punsubscribe\", patterns...)\n \treturn err\n }\n \n-func (c *PubSub) subscribe(redisCmd string, channels ...string) error {\n-\tcn, err := c.conn(channels)\n+func (c *PubSub) subscribe(ctx context.Context, redisCmd string, channels ...string) error {\n+\tcn, err := c.conn(ctx, channels)\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\terr = c._subscribe(cn, redisCmd, channels)\n-\tc.releaseConn(cn, err, false)\n+\terr = c._subscribe(ctx, cn, redisCmd, channels)\n+\tc.releaseConn(ctx, cn, err, false)\n \treturn err\n }\n \n-func (c *PubSub) Ping(payload ...string) error {\n+func (c *PubSub) Ping(ctx context.Context, payload ...string) error {\n \targs := []interface{}{\"ping\"}\n \tif len(payload) == 1 {\n \t\targs = append(args, payload[0])\n \t}\n-\tcmd := NewCmd(args...)\n+\tcmd := NewCmd(ctx, args...)\n \n-\tcn, err := c.connWithLock()\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tcn, err := c.conn(ctx, nil)\n \tif err != nil {\n \t\treturn err\n \t}\n \n-\terr = c.writeCmd(context.TODO(), cn, cmd)\n-\tc.releaseConnWithLock(cn, err, false)\n+\terr = c.writeCmd(ctx, cn, cmd)\n+\tc.releaseConn(ctx, cn, err, false)\n \treturn err\n }\n \n@@ -279,9 +281,10 @@ func (m *Subscription) String() string {\n \n // Message received as result of a PUBLISH command issued by another client.\n type Message struct {\n-\tChannel string\n-\tPattern string\n-\tPayload string\n+\tChannel      string\n+\tPattern      string\n+\tPayload      string\n+\tPayloadSlice []string\n }\n \n func (m *Message) String() string {\n@@ -317,10 +320,24 @@ func (c *PubSub) newMessage(reply interface{}) (interface{}, error) {\n \t\t\t\tCount:   int(reply[2].(int64)),\n \t\t\t}, nil\n \t\tcase \"message\":\n-\t\t\treturn &Message{\n-\t\t\t\tChannel: reply[1].(string),\n-\t\t\t\tPayload: reply[2].(string),\n-\t\t\t}, nil\n+\t\t\tswitch payload := reply[2].(type) {\n+\t\t\tcase string:\n+\t\t\t\treturn &Message{\n+\t\t\t\t\tChannel: reply[1].(string),\n+\t\t\t\t\tPayload: payload,\n+\t\t\t\t}, nil\n+\t\t\tcase []interface{}:\n+\t\t\t\tss := make([]string, len(payload))\n+\t\t\t\tfor i, s := range payload {\n+\t\t\t\t\tss[i] = s.(string)\n+\t\t\t\t}\n+\t\t\t\treturn &Message{\n+\t\t\t\t\tChannel:      reply[1].(string),\n+\t\t\t\t\tPayloadSlice: ss,\n+\t\t\t\t}, nil\n+\t\t\tdefault:\n+\t\t\t\treturn nil, fmt.Errorf(\"redis: unsupported pubsub message payload: %T\", payload)\n+\t\t\t}\n \t\tcase \"pmessage\":\n \t\t\treturn &Message{\n \t\t\t\tPattern: reply[1].(string),\n@@ -342,21 +359,24 @@ func (c *PubSub) newMessage(reply interface{}) (interface{}, error) {\n // ReceiveTimeout acts like Receive but returns an error if message\n // is not received in time. This is low-level API and in most cases\n // Channel should be used instead.\n-func (c *PubSub) ReceiveTimeout(timeout time.Duration) (interface{}, error) {\n+func (c *PubSub) ReceiveTimeout(ctx context.Context, timeout time.Duration) (interface{}, error) {\n \tif c.cmd == nil {\n-\t\tc.cmd = NewCmd()\n+\t\tc.cmd = NewCmd(ctx)\n \t}\n \n-\tcn, err := c.connWithLock()\n+\t// Don't hold the lock to allow subscriptions and pings.\n+\n+\tcn, err := c.connWithLock(ctx)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\terr = cn.WithReader(context.TODO(), timeout, func(rd *proto.Reader) error {\n+\terr = cn.WithReader(ctx, timeout, func(rd *proto.Reader) error {\n \t\treturn c.cmd.readReply(rd)\n \t})\n \n-\tc.releaseConnWithLock(cn, err, timeout > 0)\n+\tc.releaseConnWithLock(ctx, cn, err, timeout > 0)\n+\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -367,16 +387,16 @@ func (c *PubSub) ReceiveTimeout(timeout time.Duration) (interface{}, error) {\n // Receive returns a message as a Subscription, Message, Pong or error.\n // See PubSub example for details. This is low-level API and in most cases\n // Channel should be used instead.\n-func (c *PubSub) Receive() (interface{}, error) {\n-\treturn c.ReceiveTimeout(0)\n+func (c *PubSub) Receive(ctx context.Context) (interface{}, error) {\n+\treturn c.ReceiveTimeout(ctx, 0)\n }\n \n // ReceiveMessage returns a Message or error ignoring Subscription and Pong\n // messages. This is low-level API and in most cases Channel should be used\n // instead.\n-func (c *PubSub) ReceiveMessage() (*Message, error) {\n+func (c *PubSub) ReceiveMessage(ctx context.Context) (*Message, error) {\n \tfor {\n-\t\tmsg, err := c.Receive()\n+\t\tmsg, err := c.Receive(ctx)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -395,108 +415,167 @@ func (c *PubSub) ReceiveMessage() (*Message, error) {\n \t}\n }\n \n+func (c *PubSub) getContext() context.Context {\n+\tif c.cmd != nil {\n+\t\treturn c.cmd.ctx\n+\t}\n+\treturn context.Background()\n+}\n+\n+//------------------------------------------------------------------------------\n+\n // Channel returns a Go channel for concurrently receiving messages.\n // The channel is closed together with the PubSub. If the Go channel\n // is blocked full for 30 seconds the message is dropped.\n // Receive* APIs can not be used after channel is created.\n //\n // go-redis periodically sends ping messages to test connection health\n // and re-subscribes if ping can not not received for 30 seconds.\n-func (c *PubSub) Channel() <-chan *Message {\n-\treturn c.ChannelSize(100)\n-}\n-\n-// ChannelSize is like Channel, but creates a Go channel\n-// with specified buffer size.\n-func (c *PubSub) ChannelSize(size int) <-chan *Message {\n+func (c *PubSub) Channel(opts ...ChannelOption) <-chan *Message {\n \tc.chOnce.Do(func() {\n-\t\tc.initPing()\n-\t\tc.initMsgChan(size)\n+\t\tc.msgCh = newChannel(c, opts...)\n+\t\tc.msgCh.initMsgChan()\n \t})\n \tif c.msgCh == nil {\n \t\terr := fmt.Errorf(\"redis: Channel can't be called after ChannelWithSubscriptions\")\n \t\tpanic(err)\n \t}\n-\tif cap(c.msgCh) != size {\n-\t\terr := fmt.Errorf(\"redis: PubSub.Channel size can not be changed once created\")\n-\t\tpanic(err)\n-\t}\n-\treturn c.msgCh\n+\treturn c.msgCh.msgCh\n+}\n+\n+// ChannelSize is like Channel, but creates a Go channel\n+// with specified buffer size.\n+//\n+// Deprecated: use Channel(WithChannelSize(size)), remove in v9.\n+func (c *PubSub) ChannelSize(size int) <-chan *Message {\n+\treturn c.Channel(WithChannelSize(size))\n }\n \n // ChannelWithSubscriptions is like Channel, but message type can be either\n // *Subscription or *Message. Subscription messages can be used to detect\n // reconnections.\n //\n // ChannelWithSubscriptions can not be used together with Channel or ChannelSize.\n-func (c *PubSub) ChannelWithSubscriptions(size int) <-chan interface{} {\n+func (c *PubSub) ChannelWithSubscriptions(_ context.Context, size int) <-chan interface{} {\n \tc.chOnce.Do(func() {\n-\t\tc.initPing()\n-\t\tc.initAllChan(size)\n+\t\tc.allCh = newChannel(c, WithChannelSize(size))\n+\t\tc.allCh.initAllChan()\n \t})\n \tif c.allCh == nil {\n \t\terr := fmt.Errorf(\"redis: ChannelWithSubscriptions can't be called after Channel\")\n \t\tpanic(err)\n \t}\n-\tif cap(c.allCh) != size {\n-\t\terr := fmt.Errorf(\"redis: PubSub.Channel size can not be changed once created\")\n-\t\tpanic(err)\n+\treturn c.allCh.allCh\n+}\n+\n+type ChannelOption func(c *channel)\n+\n+// WithChannelSize specifies the Go chan size that is used to buffer incoming messages.\n+//\n+// The default is 100 messages.\n+func WithChannelSize(size int) ChannelOption {\n+\treturn func(c *channel) {\n+\t\tc.chanSize = size\n+\t}\n+}\n+\n+// WithChannelHealthCheckInterval specifies the health check interval.\n+// PubSub will ping Redis Server if it does not receive any messages within the interval.\n+// To disable health check, use zero interval.\n+//\n+// The default is 3 seconds.\n+func WithChannelHealthCheckInterval(d time.Duration) ChannelOption {\n+\treturn func(c *channel) {\n+\t\tc.checkInterval = d\n+\t}\n+}\n+\n+// WithChannelSendTimeout specifies the channel send timeout after which\n+// the message is dropped.\n+//\n+// The default is 60 seconds.\n+func WithChannelSendTimeout(d time.Duration) ChannelOption {\n+\treturn func(c *channel) {\n+\t\tc.chanSendTimeout = d\n+\t}\n+}\n+\n+type channel struct {\n+\tpubSub *PubSub\n+\n+\tmsgCh chan *Message\n+\tallCh chan interface{}\n+\tping  chan struct{}\n+\n+\tchanSize        int\n+\tchanSendTimeout time.Duration\n+\tcheckInterval   time.Duration\n+}\n+\n+func newChannel(pubSub *PubSub, opts ...ChannelOption) *channel {\n+\tc := &channel{\n+\t\tpubSub: pubSub,\n+\n+\t\tchanSize:        100,\n+\t\tchanSendTimeout: time.Minute,\n+\t\tcheckInterval:   3 * time.Second,\n+\t}\n+\tfor _, opt := range opts {\n+\t\topt(c)\n \t}\n-\treturn c.allCh\n+\tif c.checkInterval > 0 {\n+\t\tc.initHealthCheck()\n+\t}\n+\treturn c\n }\n \n-func (c *PubSub) initPing() {\n+func (c *channel) initHealthCheck() {\n+\tctx := context.TODO()\n \tc.ping = make(chan struct{}, 1)\n+\n \tgo func() {\n-\t\ttimer := time.NewTimer(pingTimeout)\n+\t\ttimer := time.NewTimer(time.Minute)\n \t\ttimer.Stop()\n \n-\t\thealthy := true\n \t\tfor {\n-\t\t\ttimer.Reset(pingTimeout)\n+\t\t\ttimer.Reset(c.checkInterval)\n \t\t\tselect {\n \t\t\tcase <-c.ping:\n-\t\t\t\thealthy = true\n \t\t\t\tif !timer.Stop() {\n \t\t\t\t\t<-timer.C\n \t\t\t\t}\n \t\t\tcase <-timer.C:\n-\t\t\t\tpingErr := c.Ping()\n-\t\t\t\tif healthy {\n-\t\t\t\t\thealthy = false\n-\t\t\t\t} else {\n-\t\t\t\t\tif pingErr == nil {\n-\t\t\t\t\t\tpingErr = errPingTimeout\n-\t\t\t\t\t}\n-\t\t\t\t\tc.mu.Lock()\n-\t\t\t\t\tc.reconnect(pingErr)\n-\t\t\t\t\thealthy = true\n-\t\t\t\t\tc.mu.Unlock()\n+\t\t\t\tif pingErr := c.pubSub.Ping(ctx); pingErr != nil {\n+\t\t\t\t\tc.pubSub.mu.Lock()\n+\t\t\t\t\tc.pubSub.reconnect(ctx, pingErr)\n+\t\t\t\t\tc.pubSub.mu.Unlock()\n \t\t\t\t}\n-\t\t\tcase <-c.exit:\n+\t\t\tcase <-c.pubSub.exit:\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n \t}()\n }\n \n // initMsgChan must be in sync with initAllChan.\n-func (c *PubSub) initMsgChan(size int) {\n-\tc.msgCh = make(chan *Message, size)\n+func (c *channel) initMsgChan() {\n+\tctx := context.TODO()\n+\tc.msgCh = make(chan *Message, c.chanSize)\n+\n \tgo func() {\n-\t\ttimer := time.NewTimer(pingTimeout)\n+\t\ttimer := time.NewTimer(time.Minute)\n \t\ttimer.Stop()\n \n \t\tvar errCount int\n \t\tfor {\n-\t\t\tmsg, err := c.Receive()\n+\t\t\tmsg, err := c.pubSub.Receive(ctx)\n \t\t\tif err != nil {\n \t\t\t\tif err == pool.ErrClosed {\n \t\t\t\t\tclose(c.msgCh)\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tif errCount > 0 {\n-\t\t\t\t\ttime.Sleep(c.retryBackoff(errCount))\n+\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n \t\t\t\t}\n \t\t\t\terrCount++\n \t\t\t\tcontinue\n@@ -516,40 +595,43 @@ func (c *PubSub) initMsgChan(size int) {\n \t\t\tcase *Pong:\n \t\t\t\t// Ignore.\n \t\t\tcase *Message:\n-\t\t\t\ttimer.Reset(pingTimeout)\n+\t\t\t\ttimer.Reset(c.chanSendTimeout)\n \t\t\t\tselect {\n \t\t\t\tcase c.msgCh <- msg:\n \t\t\t\t\tif !timer.Stop() {\n \t\t\t\t\t\t<-timer.C\n \t\t\t\t\t}\n \t\t\t\tcase <-timer.C:\n \t\t\t\t\tinternal.Logger.Printf(\n-\t\t\t\t\t\t\"redis: %s channel is full for %s (message is dropped)\", c, pingTimeout)\n+\t\t\t\t\t\tctx, \"redis: %s channel is full for %s (message is dropped)\",\n+\t\t\t\t\t\tc, c.chanSendTimeout)\n \t\t\t\t}\n \t\t\tdefault:\n-\t\t\t\tinternal.Logger.Printf(\"redis: unknown message type: %T\", msg)\n+\t\t\t\tinternal.Logger.Printf(ctx, \"redis: unknown message type: %T\", msg)\n \t\t\t}\n \t\t}\n \t}()\n }\n \n // initAllChan must be in sync with initMsgChan.\n-func (c *PubSub) initAllChan(size int) {\n-\tc.allCh = make(chan interface{}, size)\n+func (c *channel) initAllChan() {\n+\tctx := context.TODO()\n+\tc.allCh = make(chan interface{}, c.chanSize)\n+\n \tgo func() {\n-\t\ttimer := time.NewTimer(pingTimeout)\n+\t\ttimer := time.NewTimer(time.Minute)\n \t\ttimer.Stop()\n \n \t\tvar errCount int\n \t\tfor {\n-\t\t\tmsg, err := c.Receive()\n+\t\t\tmsg, err := c.pubSub.Receive(ctx)\n \t\t\tif err != nil {\n \t\t\t\tif err == pool.ErrClosed {\n \t\t\t\t\tclose(c.allCh)\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tif errCount > 0 {\n-\t\t\t\t\ttime.Sleep(c.retryBackoff(errCount))\n+\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n \t\t\t\t}\n \t\t\t\terrCount++\n \t\t\t\tcontinue\n@@ -564,32 +646,23 @@ func (c *PubSub) initAllChan(size int) {\n \t\t\t}\n \n \t\t\tswitch msg := msg.(type) {\n-\t\t\tcase *Subscription:\n-\t\t\t\tc.sendMessage(msg, timer)\n \t\t\tcase *Pong:\n \t\t\t\t// Ignore.\n-\t\t\tcase *Message:\n-\t\t\t\tc.sendMessage(msg, timer)\n+\t\t\tcase *Subscription, *Message:\n+\t\t\t\ttimer.Reset(c.chanSendTimeout)\n+\t\t\t\tselect {\n+\t\t\t\tcase c.allCh <- msg:\n+\t\t\t\t\tif !timer.Stop() {\n+\t\t\t\t\t\t<-timer.C\n+\t\t\t\t\t}\n+\t\t\t\tcase <-timer.C:\n+\t\t\t\t\tinternal.Logger.Printf(\n+\t\t\t\t\t\tctx, \"redis: %s channel is full for %s (message is dropped)\",\n+\t\t\t\t\t\tc, c.chanSendTimeout)\n+\t\t\t\t}\n \t\t\tdefault:\n-\t\t\t\tinternal.Logger.Printf(\"redis: unknown message type: %T\", msg)\n+\t\t\t\tinternal.Logger.Printf(ctx, \"redis: unknown message type: %T\", msg)\n \t\t\t}\n \t\t}\n \t}()\n }\n-\n-func (c *PubSub) sendMessage(msg interface{}, timer *time.Timer) {\n-\ttimer.Reset(pingTimeout)\n-\tselect {\n-\tcase c.allCh <- msg:\n-\t\tif !timer.Stop() {\n-\t\t\t<-timer.C\n-\t\t}\n-\tcase <-timer.C:\n-\t\tinternal.Logger.Printf(\n-\t\t\t\"redis: %s channel is full for %s (message is dropped)\", c, pingTimeout)\n-\t}\n-}\n-\n-func (c *PubSub) retryBackoff(attempt int) time.Duration {\n-\treturn internal.RetryBackoff(attempt, c.opt.MinRetryBackoff, c.opt.MaxRetryBackoff)\n-}",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/pubsub.go"
    },
    {
      "sha": "bcf8a2a94bd064ae331a0a8dd2ede097752b03a8",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/redis.go",
      "status": "renamed",
      "additions": 156,
      "deletions": 141,
      "changes": 297,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fredis.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fredis.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fredis.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -2,19 +2,20 @@ package redis\n \n import (\n \t\"context\"\n+\t\"errors\"\n \t\"fmt\"\n-\t\"log\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal\"\n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/proto\"\n )\n \n // Nil reply returned by Redis when key does not exist.\n const Nil = proto.Nil\n \n-func SetLogger(logger *log.Logger) {\n+func SetLogger(logger internal.Logging) {\n \tinternal.Logger = logger\n }\n \n@@ -49,89 +50,73 @@ func (hs *hooks) AddHook(hook Hook) {\n func (hs hooks) process(\n \tctx context.Context, cmd Cmder, fn func(context.Context, Cmder) error,\n ) error {\n-\tctx, err := hs.beforeProcess(ctx, cmd)\n-\tif err != nil {\n+\tif len(hs.hooks) == 0 {\n+\t\terr := fn(ctx, cmd)\n \t\tcmd.SetErr(err)\n \t\treturn err\n \t}\n \n-\tcmdErr := fn(ctx, cmd)\n+\tvar hookIndex int\n+\tvar retErr error\n \n-\tif err := hs.afterProcess(ctx, cmd); err != nil {\n-\t\tcmd.SetErr(err)\n-\t\treturn err\n+\tfor ; hookIndex < len(hs.hooks) && retErr == nil; hookIndex++ {\n+\t\tctx, retErr = hs.hooks[hookIndex].BeforeProcess(ctx, cmd)\n+\t\tif retErr != nil {\n+\t\t\tcmd.SetErr(retErr)\n+\t\t}\n \t}\n \n-\treturn cmdErr\n-}\n-\n-func (hs hooks) beforeProcess(ctx context.Context, cmd Cmder) (context.Context, error) {\n-\tfor _, h := range hs.hooks {\n-\t\tvar err error\n-\t\tctx, err = h.BeforeProcess(ctx, cmd)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n+\tif retErr == nil {\n+\t\tretErr = fn(ctx, cmd)\n+\t\tcmd.SetErr(retErr)\n \t}\n-\treturn ctx, nil\n-}\n \n-func (hs hooks) afterProcess(ctx context.Context, cmd Cmder) error {\n-\tvar firstErr error\n-\tfor _, h := range hs.hooks {\n-\t\terr := h.AfterProcess(ctx, cmd)\n-\t\tif err != nil && firstErr == nil {\n-\t\t\tfirstErr = err\n+\tfor hookIndex--; hookIndex >= 0; hookIndex-- {\n+\t\tif err := hs.hooks[hookIndex].AfterProcess(ctx, cmd); err != nil {\n+\t\t\tretErr = err\n+\t\t\tcmd.SetErr(retErr)\n \t\t}\n \t}\n-\treturn firstErr\n+\n+\treturn retErr\n }\n \n func (hs hooks) processPipeline(\n \tctx context.Context, cmds []Cmder, fn func(context.Context, []Cmder) error,\n ) error {\n-\tctx, err := hs.beforeProcessPipeline(ctx, cmds)\n-\tif err != nil {\n-\t\tsetCmdsErr(cmds, err)\n+\tif len(hs.hooks) == 0 {\n+\t\terr := fn(ctx, cmds)\n \t\treturn err\n \t}\n \n-\tcmdsErr := fn(ctx, cmds)\n+\tvar hookIndex int\n+\tvar retErr error\n \n-\tif err := hs.afterProcessPipeline(ctx, cmds); err != nil {\n-\t\tsetCmdsErr(cmds, err)\n-\t\treturn err\n+\tfor ; hookIndex < len(hs.hooks) && retErr == nil; hookIndex++ {\n+\t\tctx, retErr = hs.hooks[hookIndex].BeforeProcessPipeline(ctx, cmds)\n+\t\tif retErr != nil {\n+\t\t\tsetCmdsErr(cmds, retErr)\n+\t\t}\n \t}\n \n-\treturn cmdsErr\n-}\n-\n-func (hs hooks) beforeProcessPipeline(ctx context.Context, cmds []Cmder) (context.Context, error) {\n-\tfor _, h := range hs.hooks {\n-\t\tvar err error\n-\t\tctx, err = h.BeforeProcessPipeline(ctx, cmds)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n+\tif retErr == nil {\n+\t\tretErr = fn(ctx, cmds)\n \t}\n-\treturn ctx, nil\n-}\n \n-func (hs hooks) afterProcessPipeline(ctx context.Context, cmds []Cmder) error {\n-\tvar firstErr error\n-\tfor _, h := range hs.hooks {\n-\t\terr := h.AfterProcessPipeline(ctx, cmds)\n-\t\tif err != nil && firstErr == nil {\n-\t\t\tfirstErr = err\n+\tfor hookIndex--; hookIndex >= 0; hookIndex-- {\n+\t\tif err := hs.hooks[hookIndex].AfterProcessPipeline(ctx, cmds); err != nil {\n+\t\t\tretErr = err\n+\t\t\tsetCmdsErr(cmds, retErr)\n \t\t}\n \t}\n-\treturn firstErr\n+\n+\treturn retErr\n }\n \n func (hs hooks) processTxPipeline(\n \tctx context.Context, cmds []Cmder, fn func(context.Context, []Cmder) error,\n ) error {\n-\tcmds = wrapMultiExec(cmds)\n+\tcmds = wrapMultiExec(ctx, cmds)\n \treturn hs.processPipeline(ctx, cmds, fn)\n }\n \n@@ -201,6 +186,7 @@ func (c *baseClient) getConn(ctx context.Context) (*pool.Conn, error) {\n \t\t}\n \t\treturn nil, err\n \t}\n+\n \treturn cn, nil\n }\n \n@@ -210,10 +196,13 @@ func (c *baseClient) _getConn(ctx context.Context) (*pool.Conn, error) {\n \t\treturn nil, err\n \t}\n \n-\terr = c.initConn(ctx, cn)\n-\tif err != nil {\n-\t\tc.connPool.Remove(cn, err)\n-\t\tif err := internal.Unwrap(err); err != nil {\n+\tif cn.Inited {\n+\t\treturn cn, nil\n+\t}\n+\n+\tif err := c.initConn(ctx, cn); err != nil {\n+\t\tc.connPool.Remove(ctx, cn, err)\n+\t\tif err := errors.Unwrap(err); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn nil, err\n@@ -235,25 +224,24 @@ func (c *baseClient) initConn(ctx context.Context, cn *pool.Conn) error {\n \t\treturn nil\n \t}\n \n-\tconnPool := pool.NewSingleConnPool(nil)\n-\tconnPool.SetConn(cn)\n+\tconnPool := pool.NewSingleConnPool(c.connPool, cn)\n \tconn := newConn(ctx, c.opt, connPool)\n \n-\t_, err := conn.Pipelined(func(pipe Pipeliner) error {\n+\t_, err := conn.Pipelined(ctx, func(pipe Pipeliner) error {\n \t\tif c.opt.Password != \"\" {\n \t\t\tif c.opt.Username != \"\" {\n-\t\t\t\tpipe.AuthACL(c.opt.Username, c.opt.Password)\n+\t\t\t\tpipe.AuthACL(ctx, c.opt.Username, c.opt.Password)\n \t\t\t} else {\n-\t\t\t\tpipe.Auth(c.opt.Password)\n+\t\t\t\tpipe.Auth(ctx, c.opt.Password)\n \t\t\t}\n \t\t}\n \n \t\tif c.opt.DB > 0 {\n-\t\t\tpipe.Select(c.opt.DB)\n+\t\t\tpipe.Select(ctx, c.opt.DB)\n \t\t}\n \n \t\tif c.opt.readOnly {\n-\t\t\tpipe.ReadOnly()\n+\t\t\tpipe.ReadOnly(ctx)\n \t\t}\n \n \t\treturn nil\n@@ -263,20 +251,20 @@ func (c *baseClient) initConn(ctx context.Context, cn *pool.Conn) error {\n \t}\n \n \tif c.opt.OnConnect != nil {\n-\t\treturn c.opt.OnConnect(conn)\n+\t\treturn c.opt.OnConnect(ctx, conn)\n \t}\n \treturn nil\n }\n \n-func (c *baseClient) releaseConn(cn *pool.Conn, err error) {\n+func (c *baseClient) releaseConn(ctx context.Context, cn *pool.Conn, err error) {\n \tif c.opt.Limiter != nil {\n \t\tc.opt.Limiter.ReportResult(err)\n \t}\n \n-\tif isBadConn(err, false) {\n-\t\tc.connPool.Remove(cn, err)\n+\tif isBadConn(err, false, c.opt.Addr) {\n+\t\tc.connPool.Remove(ctx, cn, err)\n \t} else {\n-\t\tc.connPool.Put(cn)\n+\t\tc.connPool.Put(ctx, cn)\n \t}\n }\n \n@@ -287,54 +275,81 @@ func (c *baseClient) withConn(\n \tif err != nil {\n \t\treturn err\n \t}\n+\n \tdefer func() {\n-\t\tc.releaseConn(cn, err)\n+\t\tc.releaseConn(ctx, cn, err)\n \t}()\n \n-\terr = fn(ctx, cn)\n-\treturn err\n-}\n+\tdone := ctx.Done() //nolint:ifshort\n \n-func (c *baseClient) process(ctx context.Context, cmd Cmder) error {\n-\terr := c._process(ctx, cmd)\n-\tif err != nil {\n-\t\tcmd.SetErr(err)\n+\tif done == nil {\n+\t\terr = fn(ctx, cn)\n+\t\treturn err\n+\t}\n+\n+\terrc := make(chan error, 1)\n+\tgo func() { errc <- fn(ctx, cn) }()\n+\n+\tselect {\n+\tcase <-done:\n+\t\t_ = cn.Close()\n+\t\t// Wait for the goroutine to finish and send something.\n+\t\t<-errc\n+\n+\t\terr = ctx.Err()\n+\t\treturn err\n+\tcase err = <-errc:\n \t\treturn err\n \t}\n-\treturn nil\n }\n \n-func (c *baseClient) _process(ctx context.Context, cmd Cmder) error {\n+func (c *baseClient) process(ctx context.Context, cmd Cmder) error {\n \tvar lastErr error\n \tfor attempt := 0; attempt <= c.opt.MaxRetries; attempt++ {\n-\t\tif attempt > 0 {\n-\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n+\t\tattempt := attempt\n+\n+\t\tretry, err := c._process(ctx, cmd, attempt)\n+\t\tif err == nil || !retry {\n+\t\t\treturn err\n \t\t}\n \n-\t\tretryTimeout := true\n-\t\tlastErr = c.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n-\t\t\terr := cn.WithWriter(ctx, c.opt.WriteTimeout, func(wr *proto.Writer) error {\n-\t\t\t\treturn writeCmd(wr, cmd)\n-\t\t\t})\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n+\t\tlastErr = err\n+\t}\n+\treturn lastErr\n+}\n \n-\t\t\terr = cn.WithReader(ctx, c.cmdTimeout(cmd), cmd.readReply)\n-\t\t\tif err != nil {\n-\t\t\t\tretryTimeout = cmd.readTimeout() == nil\n-\t\t\t\treturn err\n-\t\t\t}\n+func (c *baseClient) _process(ctx context.Context, cmd Cmder, attempt int) (bool, error) {\n+\tif attempt > 0 {\n+\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n \n-\t\t\treturn nil\n+\tretryTimeout := uint32(1)\n+\terr := c.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n+\t\terr := cn.WithWriter(ctx, c.opt.WriteTimeout, func(wr *proto.Writer) error {\n+\t\t\treturn writeCmd(wr, cmd)\n \t\t})\n-\t\tif lastErr == nil || !isRetryableError(lastErr, retryTimeout) {\n-\t\t\treturn lastErr\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\terr = cn.WithReader(ctx, c.cmdTimeout(cmd), cmd.readReply)\n+\t\tif err != nil {\n+\t\t\tif cmd.readTimeout() == nil {\n+\t\t\t\tatomic.StoreUint32(&retryTimeout, 1)\n+\t\t\t}\n+\t\t\treturn err\n \t\t}\n+\n+\t\treturn nil\n+\t})\n+\tif err == nil {\n+\t\treturn false, nil\n \t}\n-\treturn lastErr\n+\n+\tretry := shouldRetry(err, atomic.LoadUint32(&retryTimeout) == 1)\n+\treturn retry, err\n }\n \n func (c *baseClient) retryBackoff(attempt int) time.Duration {\n@@ -411,7 +426,7 @@ func (c *baseClient) _generalProcessPipeline(\n \t\t\tcanRetry, err = p(ctx, cn, cmds)\n \t\t\treturn err\n \t\t})\n-\t\tif lastErr == nil || !canRetry || !isRetryableError(lastErr, true) {\n+\t\tif lastErr == nil || !canRetry || !shouldRetry(lastErr, true) {\n \t\t\treturn lastErr\n \t\t}\n \t}\n@@ -437,6 +452,7 @@ func (c *baseClient) pipelineProcessCmds(\n func pipelineReadCmds(rd *proto.Reader, cmds []Cmder) error {\n \tfor _, cmd := range cmds {\n \t\terr := cmd.readReply(rd)\n+\t\tcmd.SetErr(err)\n \t\tif err != nil && !isRedisError(err) {\n \t\t\treturn err\n \t\t}\n@@ -469,14 +485,14 @@ func (c *baseClient) txPipelineProcessCmds(\n \treturn false, err\n }\n \n-func wrapMultiExec(cmds []Cmder) []Cmder {\n+func wrapMultiExec(ctx context.Context, cmds []Cmder) []Cmder {\n \tif len(cmds) == 0 {\n \t\tpanic(\"not reached\")\n \t}\n \tcmdCopy := make([]Cmder, len(cmds)+2)\n-\tcmdCopy[0] = NewStatusCmd(\"multi\")\n+\tcmdCopy[0] = NewStatusCmd(ctx, \"multi\")\n \tcopy(cmdCopy[1:], cmds)\n-\tcmdCopy[len(cmdCopy)-1] = NewSliceCmd(\"exec\")\n+\tcmdCopy[len(cmdCopy)-1] = NewSliceCmd(ctx, \"exec\")\n \treturn cmdCopy\n }\n \n@@ -565,26 +581,18 @@ func (c *Client) WithContext(ctx context.Context) *Client {\n \treturn clone\n }\n \n-func (c *Client) Conn() *Conn {\n-\treturn newConn(c.ctx, c.opt, pool.NewSingleConnPool(c.connPool))\n+func (c *Client) Conn(ctx context.Context) *Conn {\n+\treturn newConn(ctx, c.opt, pool.NewStickyConnPool(c.connPool))\n }\n \n // Do creates a Cmd from the args and processes the cmd.\n-func (c *Client) Do(args ...interface{}) *Cmd {\n-\treturn c.DoContext(c.ctx, args...)\n-}\n-\n-func (c *Client) DoContext(ctx context.Context, args ...interface{}) *Cmd {\n-\tcmd := NewCmd(args...)\n-\t_ = c.ProcessContext(ctx, cmd)\n+func (c *Client) Do(ctx context.Context, args ...interface{}) *Cmd {\n+\tcmd := NewCmd(ctx, args...)\n+\t_ = c.Process(ctx, cmd)\n \treturn cmd\n }\n \n-func (c *Client) Process(cmd Cmder) error {\n-\treturn c.ProcessContext(c.ctx, cmd)\n-}\n-\n-func (c *Client) ProcessContext(ctx context.Context, cmd Cmder) error {\n+func (c *Client) Process(ctx context.Context, cmd Cmder) error {\n \treturn c.hooks.process(ctx, cmd, c.baseClient.process)\n }\n \n@@ -609,8 +617,8 @@ func (c *Client) PoolStats() *PoolStats {\n \treturn (*PoolStats)(stats)\n }\n \n-func (c *Client) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.Pipeline().Pipelined(fn)\n+func (c *Client) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.Pipeline().Pipelined(ctx, fn)\n }\n \n func (c *Client) Pipeline() Pipeliner {\n@@ -622,8 +630,8 @@ func (c *Client) Pipeline() Pipeliner {\n \treturn &pipe\n }\n \n-func (c *Client) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.TxPipeline().Pipelined(fn)\n+func (c *Client) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.TxPipeline().Pipelined(ctx, fn)\n }\n \n // TxPipeline acts like Pipeline, but wraps queued commands with MULTI/EXEC.\n@@ -640,8 +648,8 @@ func (c *Client) pubSub() *PubSub {\n \tpubsub := &PubSub{\n \t\topt: c.opt,\n \n-\t\tnewConn: func(channels []string) (*pool.Conn, error) {\n-\t\t\treturn c.newConn(context.TODO())\n+\t\tnewConn: func(ctx context.Context, channels []string) (*pool.Conn, error) {\n+\t\t\treturn c.newConn(ctx)\n \t\t},\n \t\tcloseConn: c.connPool.CloseConn,\n \t}\n@@ -675,20 +683,20 @@ func (c *Client) pubSub() *PubSub {\n //    }\n //\n //    ch := sub.Channel()\n-func (c *Client) Subscribe(channels ...string) *PubSub {\n+func (c *Client) Subscribe(ctx context.Context, channels ...string) *PubSub {\n \tpubsub := c.pubSub()\n \tif len(channels) > 0 {\n-\t\t_ = pubsub.Subscribe(channels...)\n+\t\t_ = pubsub.Subscribe(ctx, channels...)\n \t}\n \treturn pubsub\n }\n \n // PSubscribe subscribes the client to the given patterns.\n // Patterns can be omitted to create empty subscription.\n-func (c *Client) PSubscribe(channels ...string) *PubSub {\n+func (c *Client) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n \tpubsub := c.pubSub()\n \tif len(channels) > 0 {\n-\t\t_ = pubsub.PSubscribe(channels...)\n+\t\t_ = pubsub.PSubscribe(ctx, channels...)\n \t}\n \treturn pubsub\n }\n@@ -699,9 +707,12 @@ type conn struct {\n \tbaseClient\n \tcmdable\n \tstatefulCmdable\n+\thooks // TODO: inherit hooks\n }\n \n-// Conn is like Client, but its pool contains single connection.\n+// Conn represents a single Redis connection rather than a pool of connections.\n+// Prefer running commands from Client unless there is a specific need\n+// for a continuous single Redis connection.\n type Conn struct {\n \t*conn\n \tctx context.Context\n@@ -722,16 +733,20 @@ func newConn(ctx context.Context, opt *Options, connPool pool.Pooler) *Conn {\n \treturn &c\n }\n \n-func (c *Conn) Process(cmd Cmder) error {\n-\treturn c.ProcessContext(c.ctx, cmd)\n+func (c *Conn) Process(ctx context.Context, cmd Cmder) error {\n+\treturn c.hooks.process(ctx, cmd, c.baseClient.process)\n }\n \n-func (c *Conn) ProcessContext(ctx context.Context, cmd Cmder) error {\n-\treturn c.baseClient.process(ctx, cmd)\n+func (c *Conn) processPipeline(ctx context.Context, cmds []Cmder) error {\n+\treturn c.hooks.processPipeline(ctx, cmds, c.baseClient.processPipeline)\n+}\n+\n+func (c *Conn) processTxPipeline(ctx context.Context, cmds []Cmder) error {\n+\treturn c.hooks.processTxPipeline(ctx, cmds, c.baseClient.processTxPipeline)\n }\n \n-func (c *Conn) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.Pipeline().Pipelined(fn)\n+func (c *Conn) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.Pipeline().Pipelined(ctx, fn)\n }\n \n func (c *Conn) Pipeline() Pipeliner {\n@@ -743,8 +758,8 @@ func (c *Conn) Pipeline() Pipeliner {\n \treturn &pipe\n }\n \n-func (c *Conn) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.TxPipeline().Pipelined(fn)\n+func (c *Conn) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.TxPipeline().Pipelined(ctx, fn)\n }\n \n // TxPipeline acts like Pipeline, but wraps queued commands with MULTI/EXEC.",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/redis.go"
    },
    {
      "sha": "24cfd4994026363b2868afa9045f713e55fa60da",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/result.go",
      "status": "renamed",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fresult.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fresult.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fresult.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -2,127 +2,127 @@ package redis\n \n import \"time\"\n \n-// NewCmdResult returns a Cmd initialised with val and err for testing\n+// NewCmdResult returns a Cmd initialised with val and err for testing.\n func NewCmdResult(val interface{}, err error) *Cmd {\n \tvar cmd Cmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewSliceResult returns a SliceCmd initialised with val and err for testing\n+// NewSliceResult returns a SliceCmd initialised with val and err for testing.\n func NewSliceResult(val []interface{}, err error) *SliceCmd {\n \tvar cmd SliceCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewStatusResult returns a StatusCmd initialised with val and err for testing\n+// NewStatusResult returns a StatusCmd initialised with val and err for testing.\n func NewStatusResult(val string, err error) *StatusCmd {\n \tvar cmd StatusCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewIntResult returns an IntCmd initialised with val and err for testing\n+// NewIntResult returns an IntCmd initialised with val and err for testing.\n func NewIntResult(val int64, err error) *IntCmd {\n \tvar cmd IntCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewDurationResult returns a DurationCmd initialised with val and err for testing\n+// NewDurationResult returns a DurationCmd initialised with val and err for testing.\n func NewDurationResult(val time.Duration, err error) *DurationCmd {\n \tvar cmd DurationCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewBoolResult returns a BoolCmd initialised with val and err for testing\n+// NewBoolResult returns a BoolCmd initialised with val and err for testing.\n func NewBoolResult(val bool, err error) *BoolCmd {\n \tvar cmd BoolCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewStringResult returns a StringCmd initialised with val and err for testing\n+// NewStringResult returns a StringCmd initialised with val and err for testing.\n func NewStringResult(val string, err error) *StringCmd {\n \tvar cmd StringCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewFloatResult returns a FloatCmd initialised with val and err for testing\n+// NewFloatResult returns a FloatCmd initialised with val and err for testing.\n func NewFloatResult(val float64, err error) *FloatCmd {\n \tvar cmd FloatCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewStringSliceResult returns a StringSliceCmd initialised with val and err for testing\n+// NewStringSliceResult returns a StringSliceCmd initialised with val and err for testing.\n func NewStringSliceResult(val []string, err error) *StringSliceCmd {\n \tvar cmd StringSliceCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewBoolSliceResult returns a BoolSliceCmd initialised with val and err for testing\n+// NewBoolSliceResult returns a BoolSliceCmd initialised with val and err for testing.\n func NewBoolSliceResult(val []bool, err error) *BoolSliceCmd {\n \tvar cmd BoolSliceCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewStringStringMapResult returns a StringStringMapCmd initialised with val and err for testing\n+// NewStringStringMapResult returns a StringStringMapCmd initialised with val and err for testing.\n func NewStringStringMapResult(val map[string]string, err error) *StringStringMapCmd {\n \tvar cmd StringStringMapCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewStringIntMapCmdResult returns a StringIntMapCmd initialised with val and err for testing\n+// NewStringIntMapCmdResult returns a StringIntMapCmd initialised with val and err for testing.\n func NewStringIntMapCmdResult(val map[string]int64, err error) *StringIntMapCmd {\n \tvar cmd StringIntMapCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewTimeCmdResult returns a TimeCmd initialised with val and err for testing\n+// NewTimeCmdResult returns a TimeCmd initialised with val and err for testing.\n func NewTimeCmdResult(val time.Time, err error) *TimeCmd {\n \tvar cmd TimeCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewZSliceCmdResult returns a ZSliceCmd initialised with val and err for testing\n+// NewZSliceCmdResult returns a ZSliceCmd initialised with val and err for testing.\n func NewZSliceCmdResult(val []Z, err error) *ZSliceCmd {\n \tvar cmd ZSliceCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewZWithKeyCmdResult returns a NewZWithKeyCmd initialised with val and err for testing\n+// NewZWithKeyCmdResult returns a NewZWithKeyCmd initialised with val and err for testing.\n func NewZWithKeyCmdResult(val *ZWithKey, err error) *ZWithKeyCmd {\n \tvar cmd ZWithKeyCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewScanCmdResult returns a ScanCmd initialised with val and err for testing\n+// NewScanCmdResult returns a ScanCmd initialised with val and err for testing.\n func NewScanCmdResult(keys []string, cursor uint64, err error) *ScanCmd {\n \tvar cmd ScanCmd\n \tcmd.page = keys\n@@ -131,47 +131,47 @@ func NewScanCmdResult(keys []string, cursor uint64, err error) *ScanCmd {\n \treturn &cmd\n }\n \n-// NewClusterSlotsCmdResult returns a ClusterSlotsCmd initialised with val and err for testing\n+// NewClusterSlotsCmdResult returns a ClusterSlotsCmd initialised with val and err for testing.\n func NewClusterSlotsCmdResult(val []ClusterSlot, err error) *ClusterSlotsCmd {\n \tvar cmd ClusterSlotsCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewGeoLocationCmdResult returns a GeoLocationCmd initialised with val and err for testing\n+// NewGeoLocationCmdResult returns a GeoLocationCmd initialised with val and err for testing.\n func NewGeoLocationCmdResult(val []GeoLocation, err error) *GeoLocationCmd {\n \tvar cmd GeoLocationCmd\n \tcmd.locations = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewGeoPosCmdResult returns a GeoPosCmd initialised with val and err for testing\n+// NewGeoPosCmdResult returns a GeoPosCmd initialised with val and err for testing.\n func NewGeoPosCmdResult(val []*GeoPos, err error) *GeoPosCmd {\n \tvar cmd GeoPosCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewCommandsInfoCmdResult returns a CommandsInfoCmd initialised with val and err for testing\n+// NewCommandsInfoCmdResult returns a CommandsInfoCmd initialised with val and err for testing.\n func NewCommandsInfoCmdResult(val map[string]*CommandInfo, err error) *CommandsInfoCmd {\n \tvar cmd CommandsInfoCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewXMessageSliceCmdResult returns a XMessageSliceCmd initialised with val and err for testing\n+// NewXMessageSliceCmdResult returns a XMessageSliceCmd initialised with val and err for testing.\n func NewXMessageSliceCmdResult(val []XMessage, err error) *XMessageSliceCmd {\n \tvar cmd XMessageSliceCmd\n \tcmd.val = val\n \tcmd.SetErr(err)\n \treturn &cmd\n }\n \n-// NewXStreamSliceCmdResult returns a XStreamSliceCmd initialised with val and err for testing\n+// NewXStreamSliceCmdResult returns a XStreamSliceCmd initialised with val and err for testing.\n func NewXStreamSliceCmdResult(val []XStream, err error) *XStreamSliceCmd {\n \tvar cmd XStreamSliceCmd\n \tcmd.val = val",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/result.go"
    },
    {
      "sha": "4df00fc857f532da2e7d77844d0f8ea4f31225ac",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/ring.go",
      "status": "renamed",
      "additions": 182,
      "deletions": 172,
      "changes": 354,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fring.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fring.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fring.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -2,72 +2,74 @@ package redis\n \n import (\n \t\"context\"\n+\t\"crypto/tls\"\n \t\"errors\"\n \t\"fmt\"\n-\t\"math/rand\"\n+\t\"net\"\n \t\"strconv\"\n \t\"sync\"\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/go-redis/redis/v7/internal\"\n-\t\"github.com/go-redis/redis/v7/internal/consistenthash\"\n-\t\"github.com/go-redis/redis/v7/internal/hashtag\"\n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-)\n+\t\"github.com/cespare/xxhash/v2\"\n+\trendezvous \"github.com/dgryski/go-rendezvous\" //nolint\n \n-// Hash is type of hash function used in consistent hash.\n-type Hash consistenthash.Hash\n+\t\"github.com/go-redis/redis/v8/internal\"\n+\t\"github.com/go-redis/redis/v8/internal/hashtag\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/rand\"\n+)\n \n var errRingShardsDown = errors.New(\"redis: all ring shards are down\")\n \n+//------------------------------------------------------------------------------\n+\n+type ConsistentHash interface {\n+\tGet(string) string\n+}\n+\n+type rendezvousWrapper struct {\n+\t*rendezvous.Rendezvous\n+}\n+\n+func (w rendezvousWrapper) Get(key string) string {\n+\treturn w.Lookup(key)\n+}\n+\n+func newRendezvous(shards []string) ConsistentHash {\n+\treturn rendezvousWrapper{rendezvous.New(shards, xxhash.Sum64String)}\n+}\n+\n+//------------------------------------------------------------------------------\n+\n // RingOptions are used to configure a ring client and should be\n // passed to NewRing.\n type RingOptions struct {\n \t// Map of name => host:port addresses of ring shards.\n \tAddrs map[string]string\n \n-\t// Map of name => password of ring shards, to allow different shards to have\n-\t// different passwords. It will be ignored if the Password field is set.\n-\tPasswords map[string]string\n+\t// NewClient creates a shard client with provided name and options.\n+\tNewClient func(name string, opt *Options) *Client\n \n \t// Frequency of PING commands sent to check shards availability.\n \t// Shard is considered down after 3 subsequent failed checks.\n \tHeartbeatFrequency time.Duration\n \n-\t// Hash function used in consistent hash.\n-\t// Default is crc32.ChecksumIEEE.\n-\tHash Hash\n-\n-\t// Number of replicas in consistent hash.\n-\t// Default is 100 replicas.\n-\t//\n-\t// Higher number of replicas will provide less deviation, that is keys will be\n-\t// distributed to nodes more evenly.\n+\t// NewConsistentHash returns a consistent hash that is used\n+\t// to distribute keys across the shards.\n \t//\n-\t// Following is deviation for common nreplicas:\n-\t//  --------------------------------------------------------\n-\t//  | nreplicas | standard error | 99% confidence interval |\n-\t//  |     10    |     0.3152     |      (0.37, 1.98)       |\n-\t//  |    100    |     0.0997     |      (0.76, 1.28)       |\n-\t//  |   1000    |     0.0316     |      (0.92, 1.09)       |\n-\t//  --------------------------------------------------------\n-\t//\n-\t//  See https://arxiv.org/abs/1406.2294 for reference\n-\tHashReplicas int\n-\n-\t// NewClient creates a shard client with provided name and options.\n-\tNewClient func(name string, opt *Options) *Client\n-\n-\t// Optional hook that is called when a new shard is created.\n-\tOnNewShard func(*Client)\n+\t// See https://medium.com/@dgryski/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8\n+\t// for consistent hashing algorithmic tradeoffs.\n+\tNewConsistentHash func(shards []string) ConsistentHash\n \n \t// Following options are copied from Options struct.\n \n-\tOnConnect func(*Conn) error\n+\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n+\tOnConnect func(ctx context.Context, cn *Conn) error\n \n-\tDB       int\n+\tUsername string\n \tPassword string\n+\tDB       int\n \n \tMaxRetries      int\n \tMinRetryBackoff time.Duration\n@@ -77,23 +79,40 @@ type RingOptions struct {\n \tReadTimeout  time.Duration\n \tWriteTimeout time.Duration\n \n+\t// PoolFIFO uses FIFO mode for each node connection pool GET/PUT (default LIFO).\n+\tPoolFIFO bool\n+\n \tPoolSize           int\n \tMinIdleConns       int\n \tMaxConnAge         time.Duration\n \tPoolTimeout        time.Duration\n \tIdleTimeout        time.Duration\n \tIdleCheckFrequency time.Duration\n+\n+\tTLSConfig *tls.Config\n+\tLimiter   Limiter\n }\n \n func (opt *RingOptions) init() {\n+\tif opt.NewClient == nil {\n+\t\topt.NewClient = func(name string, opt *Options) *Client {\n+\t\t\treturn NewClient(opt)\n+\t\t}\n+\t}\n+\n \tif opt.HeartbeatFrequency == 0 {\n \t\topt.HeartbeatFrequency = 500 * time.Millisecond\n \t}\n \n-\tif opt.HashReplicas == 0 {\n-\t\topt.HashReplicas = 100\n+\tif opt.NewConsistentHash == nil {\n+\t\topt.NewConsistentHash = newRendezvous\n \t}\n \n+\tif opt.MaxRetries == -1 {\n+\t\topt.MaxRetries = 0\n+\t} else if opt.MaxRetries == 0 {\n+\t\topt.MaxRetries = 3\n+\t}\n \tswitch opt.MinRetryBackoff {\n \tcase -1:\n \t\topt.MinRetryBackoff = 0\n@@ -108,31 +127,32 @@ func (opt *RingOptions) init() {\n \t}\n }\n \n-func (opt *RingOptions) clientOptions(shard string) *Options {\n+func (opt *RingOptions) clientOptions() *Options {\n \treturn &Options{\n+\t\tDialer:    opt.Dialer,\n \t\tOnConnect: opt.OnConnect,\n \n+\t\tUsername: opt.Username,\n+\t\tPassword: opt.Password,\n \t\tDB:       opt.DB,\n-\t\tPassword: opt.getPassword(shard),\n+\n+\t\tMaxRetries: -1,\n \n \t\tDialTimeout:  opt.DialTimeout,\n \t\tReadTimeout:  opt.ReadTimeout,\n \t\tWriteTimeout: opt.WriteTimeout,\n \n+\t\tPoolFIFO:           opt.PoolFIFO,\n \t\tPoolSize:           opt.PoolSize,\n \t\tMinIdleConns:       opt.MinIdleConns,\n \t\tMaxConnAge:         opt.MaxConnAge,\n \t\tPoolTimeout:        opt.PoolTimeout,\n \t\tIdleTimeout:        opt.IdleTimeout,\n \t\tIdleCheckFrequency: opt.IdleCheckFrequency,\n-\t}\n-}\n \n-func (opt *RingOptions) getPassword(shard string) string {\n-\tif opt.Password == \"\" {\n-\t\treturn opt.Passwords[shard]\n+\t\tTLSConfig: opt.TLSConfig,\n+\t\tLimiter:   opt.Limiter,\n \t}\n-\treturn opt.Password\n }\n \n //------------------------------------------------------------------------------\n@@ -142,6 +162,15 @@ type ringShard struct {\n \tdown   int32\n }\n \n+func newRingShard(opt *RingOptions, name, addr string) *ringShard {\n+\tclopt := opt.clientOptions()\n+\tclopt.Addr = addr\n+\n+\treturn &ringShard{\n+\t\tClient: opt.NewClient(name, clopt),\n+\t}\n+}\n+\n func (shard *ringShard) String() string {\n \tvar state string\n \tif shard.IsUp() {\n@@ -182,41 +211,59 @@ func (shard *ringShard) Vote(up bool) bool {\n type ringShards struct {\n \topt *RingOptions\n \n-\tmu     sync.RWMutex\n-\thash   *consistenthash.Map\n-\tshards map[string]*ringShard // read only\n-\tlist   []*ringShard          // read only\n-\tlen    int\n-\tclosed bool\n+\tmu       sync.RWMutex\n+\thash     ConsistentHash\n+\tshards   map[string]*ringShard // read only\n+\tlist     []*ringShard          // read only\n+\tnumShard int\n+\tclosed   bool\n }\n \n func newRingShards(opt *RingOptions) *ringShards {\n-\treturn &ringShards{\n+\tshards := make(map[string]*ringShard, len(opt.Addrs))\n+\tlist := make([]*ringShard, 0, len(shards))\n+\n+\tfor name, addr := range opt.Addrs {\n+\t\tshard := newRingShard(opt, name, addr)\n+\t\tshards[name] = shard\n+\n+\t\tlist = append(list, shard)\n+\t}\n+\n+\tc := &ringShards{\n \t\topt: opt,\n \n-\t\thash:   newConsistentHash(opt),\n-\t\tshards: make(map[string]*ringShard),\n+\t\tshards: shards,\n+\t\tlist:   list,\n \t}\n-}\n+\tc.rebalance()\n \n-func (c *ringShards) Add(name string, cl *Client) {\n-\tshard := &ringShard{Client: cl}\n-\tc.hash.Add(name)\n-\tc.shards[name] = shard\n-\tc.list = append(c.list, shard)\n+\treturn c\n }\n \n func (c *ringShards) List() []*ringShard {\n+\tvar list []*ringShard\n+\n \tc.mu.RLock()\n-\tlist := c.list\n+\tif !c.closed {\n+\t\tlist = c.list\n+\t}\n \tc.mu.RUnlock()\n+\n \treturn list\n }\n \n func (c *ringShards) Hash(key string) string {\n+\tkey = hashtag.Key(key)\n+\n+\tvar hash string\n+\n \tc.mu.RLock()\n-\thash := c.hash.Get(key)\n+\tif c.numShard > 0 {\n+\t\thash = c.hash.Get(key)\n+\t}\n \tc.mu.RUnlock()\n+\n \treturn hash\n }\n \n@@ -230,6 +277,11 @@ func (c *ringShards) GetByKey(key string) (*ringShard, error) {\n \t\treturn nil, pool.ErrClosed\n \t}\n \n+\tif c.numShard == 0 {\n+\t\tc.mu.RUnlock()\n+\t\treturn nil, errRingShardsDown\n+\t}\n+\n \thash := c.hash.Get(key)\n \tif hash == \"\" {\n \t\tc.mu.RUnlock()\n@@ -242,13 +294,13 @@ func (c *ringShards) GetByKey(key string) (*ringShard, error) {\n \treturn shard, nil\n }\n \n-func (c *ringShards) GetByHash(name string) (*ringShard, error) {\n-\tif name == \"\" {\n+func (c *ringShards) GetByName(shardName string) (*ringShard, error) {\n+\tif shardName == \"\" {\n \t\treturn c.Random()\n \t}\n \n \tc.mu.RLock()\n-\tshard := c.shards[name]\n+\tshard := c.shards[shardName]\n \tc.mu.RUnlock()\n \treturn shard, nil\n }\n@@ -261,23 +313,16 @@ func (c *ringShards) Random() (*ringShard, error) {\n func (c *ringShards) Heartbeat(frequency time.Duration) {\n \tticker := time.NewTicker(frequency)\n \tdefer ticker.Stop()\n+\n+\tctx := context.Background()\n \tfor range ticker.C {\n \t\tvar rebalance bool\n \n-\t\tc.mu.RLock()\n-\n-\t\tif c.closed {\n-\t\t\tc.mu.RUnlock()\n-\t\t\tbreak\n-\t\t}\n-\n-\t\tshards := c.list\n-\t\tc.mu.RUnlock()\n-\n-\t\tfor _, shard := range shards {\n-\t\t\terr := shard.Client.Ping().Err()\n-\t\t\tif shard.Vote(err == nil || err == pool.ErrPoolTimeout) {\n-\t\t\t\tinternal.Logger.Printf(\"ring shard state changed: %s\", shard)\n+\t\tfor _, shard := range c.List() {\n+\t\t\terr := shard.Client.Ping(ctx).Err()\n+\t\t\tisUp := err == nil || err == pool.ErrPoolTimeout\n+\t\t\tif shard.Vote(isUp) {\n+\t\t\t\tinternal.Logger.Printf(context.Background(), \"ring shard state changed: %s\", shard)\n \t\t\t\trebalance = true\n \t\t\t}\n \t\t}\n@@ -294,24 +339,25 @@ func (c *ringShards) rebalance() {\n \tshards := c.shards\n \tc.mu.RUnlock()\n \n-\thash := newConsistentHash(c.opt)\n-\tvar shardsNum int\n+\tliveShards := make([]string, 0, len(shards))\n+\n \tfor name, shard := range shards {\n \t\tif shard.IsUp() {\n-\t\t\thash.Add(name)\n-\t\t\tshardsNum++\n+\t\t\tliveShards = append(liveShards, name)\n \t\t}\n \t}\n \n+\thash := c.opt.NewConsistentHash(liveShards)\n+\n \tc.mu.Lock()\n \tc.hash = hash\n-\tc.len = shardsNum\n+\tc.numShard = len(liveShards)\n \tc.mu.Unlock()\n }\n \n func (c *ringShards) Len() int {\n \tc.mu.RLock()\n-\tl := c.len\n+\tl := c.numShard\n \tc.mu.RUnlock()\n \treturn l\n }\n@@ -377,34 +423,15 @@ func NewRing(opt *RingOptions) *Ring {\n \t\t},\n \t\tctx: context.Background(),\n \t}\n+\n \tring.cmdsInfoCache = newCmdsInfoCache(ring.cmdsInfo)\n \tring.cmdable = ring.Process\n \n-\tfor name, addr := range opt.Addrs {\n-\t\tshard := newRingShard(opt, name, addr)\n-\t\tring.shards.Add(name, shard)\n-\t}\n-\n \tgo ring.shards.Heartbeat(opt.HeartbeatFrequency)\n \n \treturn &ring\n }\n \n-func newRingShard(opt *RingOptions, name, addr string) *Client {\n-\tclopt := opt.clientOptions(name)\n-\tclopt.Addr = addr\n-\tvar shard *Client\n-\tif opt.NewClient != nil {\n-\t\tshard = opt.NewClient(name, clopt)\n-\t} else {\n-\t\tshard = NewClient(clopt)\n-\t}\n-\tif opt.OnNewShard != nil {\n-\t\topt.OnNewShard(shard)\n-\t}\n-\treturn shard\n-}\n-\n func (c *Ring) Context() context.Context {\n \treturn c.ctx\n }\n@@ -421,21 +448,13 @@ func (c *Ring) WithContext(ctx context.Context) *Ring {\n }\n \n // Do creates a Cmd from the args and processes the cmd.\n-func (c *Ring) Do(args ...interface{}) *Cmd {\n-\treturn c.DoContext(c.ctx, args...)\n-}\n-\n-func (c *Ring) DoContext(ctx context.Context, args ...interface{}) *Cmd {\n-\tcmd := NewCmd(args...)\n-\t_ = c.ProcessContext(ctx, cmd)\n+func (c *Ring) Do(ctx context.Context, args ...interface{}) *Cmd {\n+\tcmd := NewCmd(ctx, args...)\n+\t_ = c.Process(ctx, cmd)\n \treturn cmd\n }\n \n-func (c *Ring) Process(cmd Cmder) error {\n-\treturn c.ProcessContext(c.ctx, cmd)\n-}\n-\n-func (c *Ring) ProcessContext(ctx context.Context, cmd Cmder) error {\n+func (c *Ring) Process(ctx context.Context, cmd Cmder) error {\n \treturn c.hooks.process(ctx, cmd, c.process)\n }\n \n@@ -469,36 +488,39 @@ func (c *Ring) Len() int {\n }\n \n // Subscribe subscribes the client to the specified channels.\n-func (c *Ring) Subscribe(channels ...string) *PubSub {\n+func (c *Ring) Subscribe(ctx context.Context, channels ...string) *PubSub {\n \tif len(channels) == 0 {\n \t\tpanic(\"at least one channel is required\")\n \t}\n \n \tshard, err := c.shards.GetByKey(channels[0])\n \tif err != nil {\n-\t\t//TODO: return PubSub with sticky error\n+\t\t// TODO: return PubSub with sticky error\n \t\tpanic(err)\n \t}\n-\treturn shard.Client.Subscribe(channels...)\n+\treturn shard.Client.Subscribe(ctx, channels...)\n }\n \n // PSubscribe subscribes the client to the given patterns.\n-func (c *Ring) PSubscribe(channels ...string) *PubSub {\n+func (c *Ring) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n \tif len(channels) == 0 {\n \t\tpanic(\"at least one channel is required\")\n \t}\n \n \tshard, err := c.shards.GetByKey(channels[0])\n \tif err != nil {\n-\t\t//TODO: return PubSub with sticky error\n+\t\t// TODO: return PubSub with sticky error\n \t\tpanic(err)\n \t}\n-\treturn shard.Client.PSubscribe(channels...)\n+\treturn shard.Client.PSubscribe(ctx, channels...)\n }\n \n // ForEachShard concurrently calls the fn on each live shard in the ring.\n // It returns the first error if any.\n-func (c *Ring) ForEachShard(fn func(client *Client) error) error {\n+func (c *Ring) ForEachShard(\n+\tctx context.Context,\n+\tfn func(ctx context.Context, client *Client) error,\n+) error {\n \tshards := c.shards.List()\n \tvar wg sync.WaitGroup\n \terrCh := make(chan error, 1)\n@@ -510,7 +532,7 @@ func (c *Ring) ForEachShard(fn func(client *Client) error) error {\n \t\twg.Add(1)\n \t\tgo func(shard *ringShard) {\n \t\t\tdefer wg.Done()\n-\t\t\terr := fn(shard.Client)\n+\t\t\terr := fn(ctx, shard.Client)\n \t\t\tif err != nil {\n \t\t\t\tselect {\n \t\t\t\tcase errCh <- err:\n@@ -529,35 +551,38 @@ func (c *Ring) ForEachShard(fn func(client *Client) error) error {\n \t}\n }\n \n-func (c *Ring) cmdsInfo() (map[string]*CommandInfo, error) {\n+func (c *Ring) cmdsInfo(ctx context.Context) (map[string]*CommandInfo, error) {\n \tshards := c.shards.List()\n-\tfirstErr := errRingShardsDown\n+\tvar firstErr error\n \tfor _, shard := range shards {\n-\t\tcmdsInfo, err := shard.Client.Command().Result()\n+\t\tcmdsInfo, err := shard.Client.Command(ctx).Result()\n \t\tif err == nil {\n \t\t\treturn cmdsInfo, nil\n \t\t}\n \t\tif firstErr == nil {\n \t\t\tfirstErr = err\n \t\t}\n \t}\n+\tif firstErr == nil {\n+\t\treturn nil, errRingShardsDown\n+\t}\n \treturn nil, firstErr\n }\n \n-func (c *Ring) cmdInfo(name string) *CommandInfo {\n-\tcmdsInfo, err := c.cmdsInfoCache.Get()\n+func (c *Ring) cmdInfo(ctx context.Context, name string) *CommandInfo {\n+\tcmdsInfo, err := c.cmdsInfoCache.Get(ctx)\n \tif err != nil {\n \t\treturn nil\n \t}\n \tinfo := cmdsInfo[name]\n \tif info == nil {\n-\t\tinternal.Logger.Printf(\"info for cmd=%s not found\", name)\n+\t\tinternal.Logger.Printf(ctx, \"info for cmd=%s not found\", name)\n \t}\n \treturn info\n }\n \n-func (c *Ring) cmdShard(cmd Cmder) (*ringShard, error) {\n-\tcmdInfo := c.cmdInfo(cmd.Name())\n+func (c *Ring) cmdShard(ctx context.Context, cmd Cmder) (*ringShard, error) {\n+\tcmdInfo := c.cmdInfo(ctx, cmd.Name())\n \tpos := cmdFirstKeyPos(cmd, cmdInfo)\n \tif pos == 0 {\n \t\treturn c.shards.Random()\n@@ -567,15 +592,6 @@ func (c *Ring) cmdShard(cmd Cmder) (*ringShard, error) {\n }\n \n func (c *Ring) process(ctx context.Context, cmd Cmder) error {\n-\terr := c._process(ctx, cmd)\n-\tif err != nil {\n-\t\tcmd.SetErr(err)\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n-func (c *Ring) _process(ctx context.Context, cmd Cmder) error {\n \tvar lastErr error\n \tfor attempt := 0; attempt <= c.opt.MaxRetries; attempt++ {\n \t\tif attempt > 0 {\n@@ -584,21 +600,21 @@ func (c *Ring) _process(ctx context.Context, cmd Cmder) error {\n \t\t\t}\n \t\t}\n \n-\t\tshard, err := c.cmdShard(cmd)\n+\t\tshard, err := c.cmdShard(ctx, cmd)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \n-\t\tlastErr = shard.Client.ProcessContext(ctx, cmd)\n-\t\tif lastErr == nil || !isRetryableError(lastErr, cmd.readTimeout() == nil) {\n+\t\tlastErr = shard.Client.Process(ctx, cmd)\n+\t\tif lastErr == nil || !shouldRetry(lastErr, cmd.readTimeout() == nil) {\n \t\t\treturn lastErr\n \t\t}\n \t}\n \treturn lastErr\n }\n \n-func (c *Ring) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.Pipeline().Pipelined(fn)\n+func (c *Ring) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.Pipeline().Pipelined(ctx, fn)\n }\n \n func (c *Ring) Pipeline() Pipeliner {\n@@ -616,8 +632,8 @@ func (c *Ring) processPipeline(ctx context.Context, cmds []Cmder) error {\n \t})\n }\n \n-func (c *Ring) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.TxPipeline().Pipelined(fn)\n+func (c *Ring) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.TxPipeline().Pipelined(ctx, fn)\n }\n \n func (c *Ring) TxPipeline() Pipeliner {\n@@ -640,10 +656,10 @@ func (c *Ring) generalProcessPipeline(\n ) error {\n \tcmdsMap := make(map[string][]Cmder)\n \tfor _, cmd := range cmds {\n-\t\tcmdInfo := c.cmdInfo(cmd.Name())\n+\t\tcmdInfo := c.cmdInfo(ctx, cmd.Name())\n \t\thash := cmd.stringArg(cmdFirstKeyPos(cmd, cmdInfo))\n \t\tif hash != \"\" {\n-\t\t\thash = c.shards.Hash(hashtag.Key(hash))\n+\t\t\thash = c.shards.Hash(hash)\n \t\t}\n \t\tcmdsMap[hash] = append(cmdsMap[hash], cmd)\n \t}\n@@ -665,30 +681,20 @@ func (c *Ring) generalProcessPipeline(\n func (c *Ring) processShardPipeline(\n \tctx context.Context, hash string, cmds []Cmder, tx bool,\n ) error {\n-\t//TODO: retry?\n-\tshard, err := c.shards.GetByHash(hash)\n+\t// TODO: retry?\n+\tshard, err := c.shards.GetByName(hash)\n \tif err != nil {\n \t\tsetCmdsErr(cmds, err)\n \t\treturn err\n \t}\n \n \tif tx {\n-\t\terr = shard.Client.processTxPipeline(ctx, cmds)\n-\t} else {\n-\t\terr = shard.Client.processPipeline(ctx, cmds)\n+\t\treturn shard.Client.processTxPipeline(ctx, cmds)\n \t}\n-\treturn err\n-}\n-\n-// Close closes the ring client, releasing any open resources.\n-//\n-// It is rare to Close a Ring, as the Ring is meant to be long-lived\n-// and shared between many goroutines.\n-func (c *Ring) Close() error {\n-\treturn c.shards.Close()\n+\treturn shard.Client.processPipeline(ctx, cmds)\n }\n \n-func (c *Ring) Watch(fn func(*Tx) error, keys ...string) error {\n+func (c *Ring) Watch(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n \tif len(keys) == 0 {\n \t\treturn fmt.Errorf(\"redis: Watch requires at least one key\")\n \t}\n@@ -718,9 +724,13 @@ func (c *Ring) Watch(fn func(*Tx) error, keys ...string) error {\n \t\t}\n \t}\n \n-\treturn shards[0].Client.Watch(fn, keys...)\n+\treturn shards[0].Client.Watch(ctx, fn, keys...)\n }\n \n-func newConsistentHash(opt *RingOptions) *consistenthash.Map {\n-\treturn consistenthash.New(opt.HashReplicas, consistenthash.Hash(opt.Hash))\n+// Close closes the ring client, releasing any open resources.\n+//\n+// It is rare to Close a Ring, as the Ring is meant to be long-lived\n+// and shared between many goroutines.\n+func (c *Ring) Close() error {\n+\treturn c.shards.Close()\n }",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/ring.go"
    },
    {
      "sha": "5cab18d617c89f2bc30f75af765a5876b56331d6",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/script.go",
      "status": "added",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fscript.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fscript.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fscript.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,65 @@\n+package redis\n+\n+import (\n+\t\"context\"\n+\t\"crypto/sha1\"\n+\t\"encoding/hex\"\n+\t\"io\"\n+\t\"strings\"\n+)\n+\n+type Scripter interface {\n+\tEval(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd\n+\tEvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd\n+\tScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd\n+\tScriptLoad(ctx context.Context, script string) *StringCmd\n+}\n+\n+var (\n+\t_ Scripter = (*Client)(nil)\n+\t_ Scripter = (*Ring)(nil)\n+\t_ Scripter = (*ClusterClient)(nil)\n+)\n+\n+type Script struct {\n+\tsrc, hash string\n+}\n+\n+func NewScript(src string) *Script {\n+\th := sha1.New()\n+\t_, _ = io.WriteString(h, src)\n+\treturn &Script{\n+\t\tsrc:  src,\n+\t\thash: hex.EncodeToString(h.Sum(nil)),\n+\t}\n+}\n+\n+func (s *Script) Hash() string {\n+\treturn s.hash\n+}\n+\n+func (s *Script) Load(ctx context.Context, c Scripter) *StringCmd {\n+\treturn c.ScriptLoad(ctx, s.src)\n+}\n+\n+func (s *Script) Exists(ctx context.Context, c Scripter) *BoolSliceCmd {\n+\treturn c.ScriptExists(ctx, s.hash)\n+}\n+\n+func (s *Script) Eval(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n+\treturn c.Eval(ctx, s.src, keys, args...)\n+}\n+\n+func (s *Script) EvalSha(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n+\treturn c.EvalSha(ctx, s.hash, keys, args...)\n+}\n+\n+// Run optimistically uses EVALSHA to run the script. If script does not exist\n+// it is retried using EVAL.\n+func (s *Script) Run(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n+\tr := s.EvalSha(ctx, c, keys, args...)\n+\tif err := r.Err(); err != nil && strings.HasPrefix(err.Error(), \"NOSCRIPT \") {\n+\t\treturn s.Eval(ctx, c, keys, args...)\n+\t}\n+\treturn r\n+}"
    },
    {
      "sha": "ec6221dc83d4279ed92644209ca9fbfc92a77ef0",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/sentinel.go",
      "status": "added",
      "additions": 796,
      "deletions": 0,
      "changes": 796,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fsentinel.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fsentinel.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fsentinel.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,796 @@\n+package redis\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/go-redis/redis/v8/internal\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/rand\"\n+)\n+\n+//------------------------------------------------------------------------------\n+\n+// FailoverOptions are used to configure a failover client and should\n+// be passed to NewFailoverClient.\n+type FailoverOptions struct {\n+\t// The master name.\n+\tMasterName string\n+\t// A seed list of host:port addresses of sentinel nodes.\n+\tSentinelAddrs []string\n+\n+\t// If specified with SentinelPassword, enables ACL-based authentication (via\n+\t// AUTH <user> <pass>).\n+\tSentinelUsername string\n+\t// Sentinel password from \"requirepass <password>\" (if enabled) in Sentinel\n+\t// configuration, or, if SentinelUsername is also supplied, used for ACL-based\n+\t// authentication.\n+\tSentinelPassword string\n+\n+\t// Allows routing read-only commands to the closest master or slave node.\n+\t// This option only works with NewFailoverClusterClient.\n+\tRouteByLatency bool\n+\t// Allows routing read-only commands to the random master or slave node.\n+\t// This option only works with NewFailoverClusterClient.\n+\tRouteRandomly bool\n+\n+\t// Route all commands to slave read-only nodes.\n+\tSlaveOnly bool\n+\n+\t// Use slaves disconnected with master when cannot get connected slaves\n+\t// Now, this option only works in RandomSlaveAddr function.\n+\tUseDisconnectedSlaves bool\n+\n+\t// Following options are copied from Options struct.\n+\n+\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n+\tOnConnect func(ctx context.Context, cn *Conn) error\n+\n+\tUsername string\n+\tPassword string\n+\tDB       int\n+\n+\tMaxRetries      int\n+\tMinRetryBackoff time.Duration\n+\tMaxRetryBackoff time.Duration\n+\n+\tDialTimeout  time.Duration\n+\tReadTimeout  time.Duration\n+\tWriteTimeout time.Duration\n+\n+\t// PoolFIFO uses FIFO mode for each node connection pool GET/PUT (default LIFO).\n+\tPoolFIFO bool\n+\n+\tPoolSize           int\n+\tMinIdleConns       int\n+\tMaxConnAge         time.Duration\n+\tPoolTimeout        time.Duration\n+\tIdleTimeout        time.Duration\n+\tIdleCheckFrequency time.Duration\n+\n+\tTLSConfig *tls.Config\n+}\n+\n+func (opt *FailoverOptions) clientOptions() *Options {\n+\treturn &Options{\n+\t\tAddr: \"FailoverClient\",\n+\n+\t\tDialer:    opt.Dialer,\n+\t\tOnConnect: opt.OnConnect,\n+\n+\t\tDB:       opt.DB,\n+\t\tUsername: opt.Username,\n+\t\tPassword: opt.Password,\n+\n+\t\tMaxRetries:      opt.MaxRetries,\n+\t\tMinRetryBackoff: opt.MinRetryBackoff,\n+\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n+\n+\t\tDialTimeout:  opt.DialTimeout,\n+\t\tReadTimeout:  opt.ReadTimeout,\n+\t\tWriteTimeout: opt.WriteTimeout,\n+\n+\t\tPoolFIFO:           opt.PoolFIFO,\n+\t\tPoolSize:           opt.PoolSize,\n+\t\tPoolTimeout:        opt.PoolTimeout,\n+\t\tIdleTimeout:        opt.IdleTimeout,\n+\t\tIdleCheckFrequency: opt.IdleCheckFrequency,\n+\t\tMinIdleConns:       opt.MinIdleConns,\n+\t\tMaxConnAge:         opt.MaxConnAge,\n+\n+\t\tTLSConfig: opt.TLSConfig,\n+\t}\n+}\n+\n+func (opt *FailoverOptions) sentinelOptions(addr string) *Options {\n+\treturn &Options{\n+\t\tAddr: addr,\n+\n+\t\tDialer:    opt.Dialer,\n+\t\tOnConnect: opt.OnConnect,\n+\n+\t\tDB:       0,\n+\t\tUsername: opt.SentinelUsername,\n+\t\tPassword: opt.SentinelPassword,\n+\n+\t\tMaxRetries:      opt.MaxRetries,\n+\t\tMinRetryBackoff: opt.MinRetryBackoff,\n+\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n+\n+\t\tDialTimeout:  opt.DialTimeout,\n+\t\tReadTimeout:  opt.ReadTimeout,\n+\t\tWriteTimeout: opt.WriteTimeout,\n+\n+\t\tPoolFIFO:           opt.PoolFIFO,\n+\t\tPoolSize:           opt.PoolSize,\n+\t\tPoolTimeout:        opt.PoolTimeout,\n+\t\tIdleTimeout:        opt.IdleTimeout,\n+\t\tIdleCheckFrequency: opt.IdleCheckFrequency,\n+\t\tMinIdleConns:       opt.MinIdleConns,\n+\t\tMaxConnAge:         opt.MaxConnAge,\n+\n+\t\tTLSConfig: opt.TLSConfig,\n+\t}\n+}\n+\n+func (opt *FailoverOptions) clusterOptions() *ClusterOptions {\n+\treturn &ClusterOptions{\n+\t\tDialer:    opt.Dialer,\n+\t\tOnConnect: opt.OnConnect,\n+\n+\t\tUsername: opt.Username,\n+\t\tPassword: opt.Password,\n+\n+\t\tMaxRedirects: opt.MaxRetries,\n+\n+\t\tRouteByLatency: opt.RouteByLatency,\n+\t\tRouteRandomly:  opt.RouteRandomly,\n+\n+\t\tMinRetryBackoff: opt.MinRetryBackoff,\n+\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n+\n+\t\tDialTimeout:  opt.DialTimeout,\n+\t\tReadTimeout:  opt.ReadTimeout,\n+\t\tWriteTimeout: opt.WriteTimeout,\n+\n+\t\tPoolFIFO:           opt.PoolFIFO,\n+\t\tPoolSize:           opt.PoolSize,\n+\t\tPoolTimeout:        opt.PoolTimeout,\n+\t\tIdleTimeout:        opt.IdleTimeout,\n+\t\tIdleCheckFrequency: opt.IdleCheckFrequency,\n+\t\tMinIdleConns:       opt.MinIdleConns,\n+\t\tMaxConnAge:         opt.MaxConnAge,\n+\n+\t\tTLSConfig: opt.TLSConfig,\n+\t}\n+}\n+\n+// NewFailoverClient returns a Redis client that uses Redis Sentinel\n+// for automatic failover. It's safe for concurrent use by multiple\n+// goroutines.\n+func NewFailoverClient(failoverOpt *FailoverOptions) *Client {\n+\tif failoverOpt.RouteByLatency {\n+\t\tpanic(\"to route commands by latency, use NewFailoverClusterClient\")\n+\t}\n+\tif failoverOpt.RouteRandomly {\n+\t\tpanic(\"to route commands randomly, use NewFailoverClusterClient\")\n+\t}\n+\n+\tsentinelAddrs := make([]string, len(failoverOpt.SentinelAddrs))\n+\tcopy(sentinelAddrs, failoverOpt.SentinelAddrs)\n+\n+\trand.Shuffle(len(sentinelAddrs), func(i, j int) {\n+\t\tsentinelAddrs[i], sentinelAddrs[j] = sentinelAddrs[j], sentinelAddrs[i]\n+\t})\n+\n+\tfailover := &sentinelFailover{\n+\t\topt:           failoverOpt,\n+\t\tsentinelAddrs: sentinelAddrs,\n+\t}\n+\n+\topt := failoverOpt.clientOptions()\n+\topt.Dialer = masterSlaveDialer(failover)\n+\topt.init()\n+\n+\tconnPool := newConnPool(opt)\n+\n+\tfailover.mu.Lock()\n+\tfailover.onFailover = func(ctx context.Context, addr string) {\n+\t\t_ = connPool.Filter(func(cn *pool.Conn) bool {\n+\t\t\treturn cn.RemoteAddr().String() != addr\n+\t\t})\n+\t}\n+\tfailover.mu.Unlock()\n+\n+\tc := Client{\n+\t\tbaseClient: newBaseClient(opt, connPool),\n+\t\tctx:        context.Background(),\n+\t}\n+\tc.cmdable = c.Process\n+\tc.onClose = failover.Close\n+\n+\treturn &c\n+}\n+\n+func masterSlaveDialer(\n+\tfailover *sentinelFailover,\n+) func(ctx context.Context, network, addr string) (net.Conn, error) {\n+\treturn func(ctx context.Context, network, _ string) (net.Conn, error) {\n+\t\tvar addr string\n+\t\tvar err error\n+\n+\t\tif failover.opt.SlaveOnly {\n+\t\t\taddr, err = failover.RandomSlaveAddr(ctx)\n+\t\t} else {\n+\t\t\taddr, err = failover.MasterAddr(ctx)\n+\t\t\tif err == nil {\n+\t\t\t\tfailover.trySwitchMaster(ctx, addr)\n+\t\t\t}\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif failover.opt.Dialer != nil {\n+\t\t\treturn failover.opt.Dialer(ctx, network, addr)\n+\t\t}\n+\n+\t\tnetDialer := &net.Dialer{\n+\t\t\tTimeout:   failover.opt.DialTimeout,\n+\t\t\tKeepAlive: 5 * time.Minute,\n+\t\t}\n+\t\tif failover.opt.TLSConfig == nil {\n+\t\t\treturn netDialer.DialContext(ctx, network, addr)\n+\t\t}\n+\t\treturn tls.DialWithDialer(netDialer, network, addr, failover.opt.TLSConfig)\n+\t}\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+// SentinelClient is a client for a Redis Sentinel.\n+type SentinelClient struct {\n+\t*baseClient\n+\thooks\n+\tctx context.Context\n+}\n+\n+func NewSentinelClient(opt *Options) *SentinelClient {\n+\topt.init()\n+\tc := &SentinelClient{\n+\t\tbaseClient: &baseClient{\n+\t\t\topt:      opt,\n+\t\t\tconnPool: newConnPool(opt),\n+\t\t},\n+\t\tctx: context.Background(),\n+\t}\n+\treturn c\n+}\n+\n+func (c *SentinelClient) Context() context.Context {\n+\treturn c.ctx\n+}\n+\n+func (c *SentinelClient) WithContext(ctx context.Context) *SentinelClient {\n+\tif ctx == nil {\n+\t\tpanic(\"nil context\")\n+\t}\n+\tclone := *c\n+\tclone.ctx = ctx\n+\treturn &clone\n+}\n+\n+func (c *SentinelClient) Process(ctx context.Context, cmd Cmder) error {\n+\treturn c.hooks.process(ctx, cmd, c.baseClient.process)\n+}\n+\n+func (c *SentinelClient) pubSub() *PubSub {\n+\tpubsub := &PubSub{\n+\t\topt: c.opt,\n+\n+\t\tnewConn: func(ctx context.Context, channels []string) (*pool.Conn, error) {\n+\t\t\treturn c.newConn(ctx)\n+\t\t},\n+\t\tcloseConn: c.connPool.CloseConn,\n+\t}\n+\tpubsub.init()\n+\treturn pubsub\n+}\n+\n+// Ping is used to test if a connection is still alive, or to\n+// measure latency.\n+func (c *SentinelClient) Ping(ctx context.Context) *StringCmd {\n+\tcmd := NewStringCmd(ctx, \"ping\")\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Subscribe subscribes the client to the specified channels.\n+// Channels can be omitted to create empty subscription.\n+func (c *SentinelClient) Subscribe(ctx context.Context, channels ...string) *PubSub {\n+\tpubsub := c.pubSub()\n+\tif len(channels) > 0 {\n+\t\t_ = pubsub.Subscribe(ctx, channels...)\n+\t}\n+\treturn pubsub\n+}\n+\n+// PSubscribe subscribes the client to the given patterns.\n+// Patterns can be omitted to create empty subscription.\n+func (c *SentinelClient) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n+\tpubsub := c.pubSub()\n+\tif len(channels) > 0 {\n+\t\t_ = pubsub.PSubscribe(ctx, channels...)\n+\t}\n+\treturn pubsub\n+}\n+\n+func (c *SentinelClient) GetMasterAddrByName(ctx context.Context, name string) *StringSliceCmd {\n+\tcmd := NewStringSliceCmd(ctx, \"sentinel\", \"get-master-addr-by-name\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+func (c *SentinelClient) Sentinels(ctx context.Context, name string) *SliceCmd {\n+\tcmd := NewSliceCmd(ctx, \"sentinel\", \"sentinels\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Failover forces a failover as if the master was not reachable, and without\n+// asking for agreement to other Sentinels.\n+func (c *SentinelClient) Failover(ctx context.Context, name string) *StatusCmd {\n+\tcmd := NewStatusCmd(ctx, \"sentinel\", \"failover\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Reset resets all the masters with matching name. The pattern argument is a\n+// glob-style pattern. The reset process clears any previous state in a master\n+// (including a failover in progress), and removes every slave and sentinel\n+// already discovered and associated with the master.\n+func (c *SentinelClient) Reset(ctx context.Context, pattern string) *IntCmd {\n+\tcmd := NewIntCmd(ctx, \"sentinel\", \"reset\", pattern)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// FlushConfig forces Sentinel to rewrite its configuration on disk, including\n+// the current Sentinel state.\n+func (c *SentinelClient) FlushConfig(ctx context.Context) *StatusCmd {\n+\tcmd := NewStatusCmd(ctx, \"sentinel\", \"flushconfig\")\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Master shows the state and info of the specified master.\n+func (c *SentinelClient) Master(ctx context.Context, name string) *StringStringMapCmd {\n+\tcmd := NewStringStringMapCmd(ctx, \"sentinel\", \"master\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Masters shows a list of monitored masters and their state.\n+func (c *SentinelClient) Masters(ctx context.Context) *SliceCmd {\n+\tcmd := NewSliceCmd(ctx, \"sentinel\", \"masters\")\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Slaves shows a list of slaves for the specified master and their state.\n+func (c *SentinelClient) Slaves(ctx context.Context, name string) *SliceCmd {\n+\tcmd := NewSliceCmd(ctx, \"sentinel\", \"slaves\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// CkQuorum checks if the current Sentinel configuration is able to reach the\n+// quorum needed to failover a master, and the majority needed to authorize the\n+// failover. This command should be used in monitoring systems to check if a\n+// Sentinel deployment is ok.\n+func (c *SentinelClient) CkQuorum(ctx context.Context, name string) *StringCmd {\n+\tcmd := NewStringCmd(ctx, \"sentinel\", \"ckquorum\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Monitor tells the Sentinel to start monitoring a new master with the specified\n+// name, ip, port, and quorum.\n+func (c *SentinelClient) Monitor(ctx context.Context, name, ip, port, quorum string) *StringCmd {\n+\tcmd := NewStringCmd(ctx, \"sentinel\", \"monitor\", name, ip, port, quorum)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Set is used in order to change configuration parameters of a specific master.\n+func (c *SentinelClient) Set(ctx context.Context, name, option, value string) *StringCmd {\n+\tcmd := NewStringCmd(ctx, \"sentinel\", \"set\", name, option, value)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+// Remove is used in order to remove the specified master: the master will no\n+// longer be monitored, and will totally be removed from the internal state of\n+// the Sentinel.\n+func (c *SentinelClient) Remove(ctx context.Context, name string) *StringCmd {\n+\tcmd := NewStringCmd(ctx, \"sentinel\", \"remove\", name)\n+\t_ = c.Process(ctx, cmd)\n+\treturn cmd\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+type sentinelFailover struct {\n+\topt *FailoverOptions\n+\n+\tsentinelAddrs []string\n+\n+\tonFailover func(ctx context.Context, addr string)\n+\tonUpdate   func(ctx context.Context)\n+\n+\tmu          sync.RWMutex\n+\t_masterAddr string\n+\tsentinel    *SentinelClient\n+\tpubsub      *PubSub\n+}\n+\n+func (c *sentinelFailover) Close() error {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tif c.sentinel != nil {\n+\t\treturn c.closeSentinel()\n+\t}\n+\treturn nil\n+}\n+\n+func (c *sentinelFailover) closeSentinel() error {\n+\tfirstErr := c.pubsub.Close()\n+\tc.pubsub = nil\n+\n+\terr := c.sentinel.Close()\n+\tif err != nil && firstErr == nil {\n+\t\tfirstErr = err\n+\t}\n+\tc.sentinel = nil\n+\n+\treturn firstErr\n+}\n+\n+func (c *sentinelFailover) RandomSlaveAddr(ctx context.Context) (string, error) {\n+\tif c.opt == nil {\n+\t\treturn \"\", errors.New(\"opt is nil\")\n+\t}\n+\n+\taddresses, err := c.slaveAddrs(ctx, false)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tif len(addresses) == 0 && c.opt.UseDisconnectedSlaves {\n+\t\taddresses, err = c.slaveAddrs(ctx, true)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\n+\tif len(addresses) == 0 {\n+\t\treturn c.MasterAddr(ctx)\n+\t}\n+\treturn addresses[rand.Intn(len(addresses))], nil\n+}\n+\n+func (c *sentinelFailover) MasterAddr(ctx context.Context) (string, error) {\n+\tc.mu.RLock()\n+\tsentinel := c.sentinel\n+\tc.mu.RUnlock()\n+\n+\tif sentinel != nil {\n+\t\taddr := c.getMasterAddr(ctx, sentinel)\n+\t\tif addr != \"\" {\n+\t\t\treturn addr, nil\n+\t\t}\n+\t}\n+\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tif c.sentinel != nil {\n+\t\taddr := c.getMasterAddr(ctx, c.sentinel)\n+\t\tif addr != \"\" {\n+\t\t\treturn addr, nil\n+\t\t}\n+\t\t_ = c.closeSentinel()\n+\t}\n+\n+\tfor i, sentinelAddr := range c.sentinelAddrs {\n+\t\tsentinel := NewSentinelClient(c.opt.sentinelOptions(sentinelAddr))\n+\n+\t\tmasterAddr, err := sentinel.GetMasterAddrByName(ctx, c.opt.MasterName).Result()\n+\t\tif err != nil {\n+\t\t\tinternal.Logger.Printf(ctx, \"sentinel: GetMasterAddrByName master=%q failed: %s\",\n+\t\t\t\tc.opt.MasterName, err)\n+\t\t\t_ = sentinel.Close()\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Push working sentinel to the top.\n+\t\tc.sentinelAddrs[0], c.sentinelAddrs[i] = c.sentinelAddrs[i], c.sentinelAddrs[0]\n+\t\tc.setSentinel(ctx, sentinel)\n+\n+\t\taddr := net.JoinHostPort(masterAddr[0], masterAddr[1])\n+\t\treturn addr, nil\n+\t}\n+\n+\treturn \"\", errors.New(\"redis: all sentinels specified in configuration are unreachable\")\n+}\n+\n+func (c *sentinelFailover) slaveAddrs(ctx context.Context, useDisconnected bool) ([]string, error) {\n+\tc.mu.RLock()\n+\tsentinel := c.sentinel\n+\tc.mu.RUnlock()\n+\n+\tif sentinel != nil {\n+\t\taddrs := c.getSlaveAddrs(ctx, sentinel)\n+\t\tif len(addrs) > 0 {\n+\t\t\treturn addrs, nil\n+\t\t}\n+\t}\n+\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tif c.sentinel != nil {\n+\t\taddrs := c.getSlaveAddrs(ctx, c.sentinel)\n+\t\tif len(addrs) > 0 {\n+\t\t\treturn addrs, nil\n+\t\t}\n+\t\t_ = c.closeSentinel()\n+\t}\n+\n+\tvar sentinelReachable bool\n+\n+\tfor i, sentinelAddr := range c.sentinelAddrs {\n+\t\tsentinel := NewSentinelClient(c.opt.sentinelOptions(sentinelAddr))\n+\n+\t\tslaves, err := sentinel.Slaves(ctx, c.opt.MasterName).Result()\n+\t\tif err != nil {\n+\t\t\tinternal.Logger.Printf(ctx, \"sentinel: Slaves master=%q failed: %s\",\n+\t\t\t\tc.opt.MasterName, err)\n+\t\t\t_ = sentinel.Close()\n+\t\t\tcontinue\n+\t\t}\n+\t\tsentinelReachable = true\n+\t\taddrs := parseSlaveAddrs(slaves, useDisconnected)\n+\t\tif len(addrs) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Push working sentinel to the top.\n+\t\tc.sentinelAddrs[0], c.sentinelAddrs[i] = c.sentinelAddrs[i], c.sentinelAddrs[0]\n+\t\tc.setSentinel(ctx, sentinel)\n+\n+\t\treturn addrs, nil\n+\t}\n+\n+\tif sentinelReachable {\n+\t\treturn []string{}, nil\n+\t}\n+\treturn []string{}, errors.New(\"redis: all sentinels specified in configuration are unreachable\")\n+}\n+\n+func (c *sentinelFailover) getMasterAddr(ctx context.Context, sentinel *SentinelClient) string {\n+\taddr, err := sentinel.GetMasterAddrByName(ctx, c.opt.MasterName).Result()\n+\tif err != nil {\n+\t\tinternal.Logger.Printf(ctx, \"sentinel: GetMasterAddrByName name=%q failed: %s\",\n+\t\t\tc.opt.MasterName, err)\n+\t\treturn \"\"\n+\t}\n+\treturn net.JoinHostPort(addr[0], addr[1])\n+}\n+\n+func (c *sentinelFailover) getSlaveAddrs(ctx context.Context, sentinel *SentinelClient) []string {\n+\taddrs, err := sentinel.Slaves(ctx, c.opt.MasterName).Result()\n+\tif err != nil {\n+\t\tinternal.Logger.Printf(ctx, \"sentinel: Slaves name=%q failed: %s\",\n+\t\t\tc.opt.MasterName, err)\n+\t\treturn []string{}\n+\t}\n+\treturn parseSlaveAddrs(addrs, false)\n+}\n+\n+func parseSlaveAddrs(addrs []interface{}, keepDisconnected bool) []string {\n+\tnodes := make([]string, 0, len(addrs))\n+\tfor _, node := range addrs {\n+\t\tip := \"\"\n+\t\tport := \"\"\n+\t\tflags := []string{}\n+\t\tlastkey := \"\"\n+\t\tisDown := false\n+\n+\t\tfor _, key := range node.([]interface{}) {\n+\t\t\tswitch lastkey {\n+\t\t\tcase \"ip\":\n+\t\t\t\tip = key.(string)\n+\t\t\tcase \"port\":\n+\t\t\t\tport = key.(string)\n+\t\t\tcase \"flags\":\n+\t\t\t\tflags = strings.Split(key.(string), \",\")\n+\t\t\t}\n+\t\t\tlastkey = key.(string)\n+\t\t}\n+\n+\t\tfor _, flag := range flags {\n+\t\t\tswitch flag {\n+\t\t\tcase \"s_down\", \"o_down\":\n+\t\t\t\tisDown = true\n+\t\t\tcase \"disconnected\":\n+\t\t\t\tif !keepDisconnected {\n+\t\t\t\t\tisDown = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif !isDown {\n+\t\t\tnodes = append(nodes, net.JoinHostPort(ip, port))\n+\t\t}\n+\t}\n+\n+\treturn nodes\n+}\n+\n+func (c *sentinelFailover) trySwitchMaster(ctx context.Context, addr string) {\n+\tc.mu.RLock()\n+\tcurrentAddr := c._masterAddr //nolint:ifshort\n+\tc.mu.RUnlock()\n+\n+\tif addr == currentAddr {\n+\t\treturn\n+\t}\n+\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tif addr == c._masterAddr {\n+\t\treturn\n+\t}\n+\tc._masterAddr = addr\n+\n+\tinternal.Logger.Printf(ctx, \"sentinel: new master=%q addr=%q\",\n+\t\tc.opt.MasterName, addr)\n+\tif c.onFailover != nil {\n+\t\tc.onFailover(ctx, addr)\n+\t}\n+}\n+\n+func (c *sentinelFailover) setSentinel(ctx context.Context, sentinel *SentinelClient) {\n+\tif c.sentinel != nil {\n+\t\tpanic(\"not reached\")\n+\t}\n+\tc.sentinel = sentinel\n+\tc.discoverSentinels(ctx)\n+\n+\tc.pubsub = sentinel.Subscribe(ctx, \"+switch-master\", \"+slave-reconf-done\")\n+\tgo c.listen(c.pubsub)\n+}\n+\n+func (c *sentinelFailover) discoverSentinels(ctx context.Context) {\n+\tsentinels, err := c.sentinel.Sentinels(ctx, c.opt.MasterName).Result()\n+\tif err != nil {\n+\t\tinternal.Logger.Printf(ctx, \"sentinel: Sentinels master=%q failed: %s\", c.opt.MasterName, err)\n+\t\treturn\n+\t}\n+\tfor _, sentinel := range sentinels {\n+\t\tvals := sentinel.([]interface{})\n+\t\tvar ip, port string\n+\t\tfor i := 0; i < len(vals); i += 2 {\n+\t\t\tkey := vals[i].(string)\n+\t\t\tswitch key {\n+\t\t\tcase \"ip\":\n+\t\t\t\tip = vals[i+1].(string)\n+\t\t\tcase \"port\":\n+\t\t\t\tport = vals[i+1].(string)\n+\t\t\t}\n+\t\t}\n+\t\tif ip != \"\" && port != \"\" {\n+\t\t\tsentinelAddr := net.JoinHostPort(ip, port)\n+\t\t\tif !contains(c.sentinelAddrs, sentinelAddr) {\n+\t\t\t\tinternal.Logger.Printf(ctx, \"sentinel: discovered new sentinel=%q for master=%q\",\n+\t\t\t\t\tsentinelAddr, c.opt.MasterName)\n+\t\t\t\tc.sentinelAddrs = append(c.sentinelAddrs, sentinelAddr)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func (c *sentinelFailover) listen(pubsub *PubSub) {\n+\tctx := context.TODO()\n+\n+\tif c.onUpdate != nil {\n+\t\tc.onUpdate(ctx)\n+\t}\n+\n+\tch := pubsub.Channel()\n+\tfor msg := range ch {\n+\t\tif msg.Channel == \"+switch-master\" {\n+\t\t\tparts := strings.Split(msg.Payload, \" \")\n+\t\t\tif parts[0] != c.opt.MasterName {\n+\t\t\t\tinternal.Logger.Printf(pubsub.getContext(), \"sentinel: ignore addr for master=%q\", parts[0])\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\taddr := net.JoinHostPort(parts[3], parts[4])\n+\t\t\tc.trySwitchMaster(pubsub.getContext(), addr)\n+\t\t}\n+\n+\t\tif c.onUpdate != nil {\n+\t\t\tc.onUpdate(ctx)\n+\t\t}\n+\t}\n+}\n+\n+func contains(slice []string, str string) bool {\n+\tfor _, s := range slice {\n+\t\tif s == str {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+//------------------------------------------------------------------------------\n+\n+// NewFailoverClusterClient returns a client that supports routing read-only commands\n+// to a slave node.\n+func NewFailoverClusterClient(failoverOpt *FailoverOptions) *ClusterClient {\n+\tsentinelAddrs := make([]string, len(failoverOpt.SentinelAddrs))\n+\tcopy(sentinelAddrs, failoverOpt.SentinelAddrs)\n+\n+\tfailover := &sentinelFailover{\n+\t\topt:           failoverOpt,\n+\t\tsentinelAddrs: sentinelAddrs,\n+\t}\n+\n+\topt := failoverOpt.clusterOptions()\n+\topt.ClusterSlots = func(ctx context.Context) ([]ClusterSlot, error) {\n+\t\tmasterAddr, err := failover.MasterAddr(ctx)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tnodes := []ClusterNode{{\n+\t\t\tAddr: masterAddr,\n+\t\t}}\n+\n+\t\tslaveAddrs, err := failover.slaveAddrs(ctx, false)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tfor _, slaveAddr := range slaveAddrs {\n+\t\t\tnodes = append(nodes, ClusterNode{\n+\t\t\t\tAddr: slaveAddr,\n+\t\t\t})\n+\t\t}\n+\n+\t\tslots := []ClusterSlot{\n+\t\t\t{\n+\t\t\t\tStart: 0,\n+\t\t\t\tEnd:   16383,\n+\t\t\t\tNodes: nodes,\n+\t\t\t},\n+\t\t}\n+\t\treturn slots, nil\n+\t}\n+\n+\tc := NewClusterClient(opt)\n+\n+\tfailover.mu.Lock()\n+\tfailover.onUpdate = func(ctx context.Context) {\n+\t\tc.ReloadState(ctx)\n+\t}\n+\tfailover.mu.Unlock()\n+\n+\treturn c\n+}"
    },
    {
      "sha": "8c9d87202aed7d2d7b2aa2efa0273c6f07258948",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/tx.go",
      "status": "renamed",
      "additions": 22,
      "deletions": 32,
      "changes": 54,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Ftx.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Ftx.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Ftx.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -3,8 +3,8 @@ package redis\n import (\n \t\"context\"\n \n-\t\"github.com/go-redis/redis/v7/internal/pool\"\n-\t\"github.com/go-redis/redis/v7/internal/proto\"\n+\t\"github.com/go-redis/redis/v8/internal/pool\"\n+\t\"github.com/go-redis/redis/v8/internal/proto\"\n )\n \n // TxFailedErr transaction redis failed.\n@@ -13,7 +13,8 @@ const TxFailedErr = proto.RedisError(\"redis: transaction failed\")\n // Tx implements Redis transactions as described in\n // http://redis.io/topics/transactions. It's NOT safe for concurrent use\n // by multiple goroutines, because Exec resets list of watched keys.\n-// If you don't need WATCH it is better to use Pipeline.\n+//\n+// If you don't need WATCH, use Pipeline instead.\n type Tx struct {\n \tbaseClient\n \tcmdable\n@@ -26,7 +27,7 @@ func (c *Client) newTx(ctx context.Context) *Tx {\n \ttx := Tx{\n \t\tbaseClient: baseClient{\n \t\t\topt:      c.opt,\n-\t\t\tconnPool: pool.NewStickyConnPool(c.connPool.(*pool.ConnPool), true),\n+\t\t\tconnPool: pool.NewStickyConnPool(c.connPool),\n \t\t},\n \t\thooks: c.hooks.clone(),\n \t\tctx:   ctx,\n@@ -55,64 +56,53 @@ func (c *Tx) WithContext(ctx context.Context) *Tx {\n \treturn &clone\n }\n \n-func (c *Tx) Process(cmd Cmder) error {\n-\treturn c.ProcessContext(c.ctx, cmd)\n-}\n-\n-func (c *Tx) ProcessContext(ctx context.Context, cmd Cmder) error {\n+func (c *Tx) Process(ctx context.Context, cmd Cmder) error {\n \treturn c.hooks.process(ctx, cmd, c.baseClient.process)\n }\n \n // Watch prepares a transaction and marks the keys to be watched\n // for conditional execution if there are any keys.\n //\n // The transaction is automatically closed when fn exits.\n-func (c *Client) Watch(fn func(*Tx) error, keys ...string) error {\n-\treturn c.WatchContext(c.ctx, fn, keys...)\n-}\n-\n-func (c *Client) WatchContext(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n+func (c *Client) Watch(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n \ttx := c.newTx(ctx)\n+\tdefer tx.Close(ctx)\n \tif len(keys) > 0 {\n-\t\tif err := tx.Watch(keys...).Err(); err != nil {\n-\t\t\t_ = tx.Close()\n+\t\tif err := tx.Watch(ctx, keys...).Err(); err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n-\n-\terr := fn(tx)\n-\t_ = tx.Close()\n-\treturn err\n+\treturn fn(tx)\n }\n \n // Close closes the transaction, releasing any open resources.\n-func (c *Tx) Close() error {\n-\t_ = c.Unwatch().Err()\n+func (c *Tx) Close(ctx context.Context) error {\n+\t_ = c.Unwatch(ctx).Err()\n \treturn c.baseClient.Close()\n }\n \n // Watch marks the keys to be watched for conditional execution\n // of a transaction.\n-func (c *Tx) Watch(keys ...string) *StatusCmd {\n+func (c *Tx) Watch(ctx context.Context, keys ...string) *StatusCmd {\n \targs := make([]interface{}, 1+len(keys))\n \targs[0] = \"watch\"\n \tfor i, key := range keys {\n \t\targs[1+i] = key\n \t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c.Process(cmd)\n+\tcmd := NewStatusCmd(ctx, args...)\n+\t_ = c.Process(ctx, cmd)\n \treturn cmd\n }\n \n // Unwatch flushes all the previously watched keys for a transaction.\n-func (c *Tx) Unwatch(keys ...string) *StatusCmd {\n+func (c *Tx) Unwatch(ctx context.Context, keys ...string) *StatusCmd {\n \targs := make([]interface{}, 1+len(keys))\n \targs[0] = \"unwatch\"\n \tfor i, key := range keys {\n \t\targs[1+i] = key\n \t}\n-\tcmd := NewStatusCmd(args...)\n-\t_ = c.Process(cmd)\n+\tcmd := NewStatusCmd(ctx, args...)\n+\t_ = c.Process(ctx, cmd)\n \treturn cmd\n }\n \n@@ -130,8 +120,8 @@ func (c *Tx) Pipeline() Pipeliner {\n \n // Pipelined executes commands queued in the fn outside of the transaction.\n // Use TxPipelined if you need transactional behavior.\n-func (c *Tx) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.Pipeline().Pipelined(fn)\n+func (c *Tx) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.Pipeline().Pipelined(ctx, fn)\n }\n \n // TxPipelined executes commands queued in the fn in the transaction.\n@@ -142,8 +132,8 @@ func (c *Tx) Pipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n // Exec always returns list of commands. If transaction fails\n // TxFailedErr is returned. Otherwise Exec returns an error of the first\n // failed command or nil.\n-func (c *Tx) TxPipelined(fn func(Pipeliner) error) ([]Cmder, error) {\n-\treturn c.TxPipeline().Pipelined(fn)\n+func (c *Tx) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n+\treturn c.TxPipeline().Pipelined(ctx, fn)\n }\n \n // TxPipeline creates a pipeline. Usually it is more convenient to use TxPipelined.",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/tx.go"
    },
    {
      "sha": "c89b3e5d7431cffcc32fa1ba88e9a7081503a686",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/universal.go",
      "status": "renamed",
      "additions": 49,
      "deletions": 32,
      "changes": 81,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Funiversal.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Funiversal.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Funiversal.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -20,23 +20,33 @@ type UniversalOptions struct {\n \n \t// Common options.\n \n-\tDialer             func(ctx context.Context, network, addr string) (net.Conn, error)\n-\tOnConnect          func(*Conn) error\n-\tUsername           string\n-\tPassword           string\n-\tMaxRetries         int\n-\tMinRetryBackoff    time.Duration\n-\tMaxRetryBackoff    time.Duration\n-\tDialTimeout        time.Duration\n-\tReadTimeout        time.Duration\n-\tWriteTimeout       time.Duration\n+\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n+\tOnConnect func(ctx context.Context, cn *Conn) error\n+\n+\tUsername         string\n+\tPassword         string\n+\tSentinelUsername string\n+\tSentinelPassword string\n+\n+\tMaxRetries      int\n+\tMinRetryBackoff time.Duration\n+\tMaxRetryBackoff time.Duration\n+\n+\tDialTimeout  time.Duration\n+\tReadTimeout  time.Duration\n+\tWriteTimeout time.Duration\n+\n+\t// PoolFIFO uses FIFO mode for each node connection pool GET/PUT (default LIFO).\n+\tPoolFIFO bool\n+\n \tPoolSize           int\n \tMinIdleConns       int\n \tMaxConnAge         time.Duration\n \tPoolTimeout        time.Duration\n \tIdleTimeout        time.Duration\n \tIdleCheckFrequency time.Duration\n-\tTLSConfig          *tls.Config\n+\n+\tTLSConfig *tls.Config\n \n \t// Only cluster clients.\n \n@@ -47,6 +57,7 @@ type UniversalOptions struct {\n \n \t// The sentinel master name.\n \t// Only failover clients.\n+\n \tMasterName string\n }\n \n@@ -76,6 +87,7 @@ func (o *UniversalOptions) Cluster() *ClusterOptions {\n \t\tDialTimeout:        o.DialTimeout,\n \t\tReadTimeout:        o.ReadTimeout,\n \t\tWriteTimeout:       o.WriteTimeout,\n+\t\tPoolFIFO:           o.PoolFIFO,\n \t\tPoolSize:           o.PoolSize,\n \t\tMinIdleConns:       o.MinIdleConns,\n \t\tMaxConnAge:         o.MaxConnAge,\n@@ -100,9 +112,11 @@ func (o *UniversalOptions) Failover() *FailoverOptions {\n \t\tDialer:    o.Dialer,\n \t\tOnConnect: o.OnConnect,\n \n-\t\tDB:       o.DB,\n-\t\tUsername: o.Username,\n-\t\tPassword: o.Password,\n+\t\tDB:               o.DB,\n+\t\tUsername:         o.Username,\n+\t\tPassword:         o.Password,\n+\t\tSentinelUsername: o.SentinelUsername,\n+\t\tSentinelPassword: o.SentinelPassword,\n \n \t\tMaxRetries:      o.MaxRetries,\n \t\tMinRetryBackoff: o.MinRetryBackoff,\n@@ -112,6 +126,7 @@ func (o *UniversalOptions) Failover() *FailoverOptions {\n \t\tReadTimeout:  o.ReadTimeout,\n \t\tWriteTimeout: o.WriteTimeout,\n \n+\t\tPoolFIFO:           o.PoolFIFO,\n \t\tPoolSize:           o.PoolSize,\n \t\tMinIdleConns:       o.MinIdleConns,\n \t\tMaxConnAge:         o.MaxConnAge,\n@@ -147,6 +162,7 @@ func (o *UniversalOptions) Simple() *Options {\n \t\tReadTimeout:  o.ReadTimeout,\n \t\tWriteTimeout: o.WriteTimeout,\n \n+\t\tPoolFIFO:           o.PoolFIFO,\n \t\tPoolSize:           o.PoolSize,\n \t\tMinIdleConns:       o.MinIdleConns,\n \t\tMaxConnAge:         o.MaxConnAge,\n@@ -161,33 +177,34 @@ func (o *UniversalOptions) Simple() *Options {\n // --------------------------------------------------------------------\n \n // UniversalClient is an abstract client which - based on the provided options -\n-// can connect to either clusters, or sentinel-backed failover instances\n-// or simple single-instance servers. This can be useful for testing\n-// cluster-specific applications locally.\n+// represents either a ClusterClient, a FailoverClient, or a single-node Client.\n+// This can be useful for testing cluster-specific applications locally or having different\n+// clients in different environments.\n type UniversalClient interface {\n \tCmdable\n \tContext() context.Context\n \tAddHook(Hook)\n-\tWatch(fn func(*Tx) error, keys ...string) error\n-\tDo(args ...interface{}) *Cmd\n-\tDoContext(ctx context.Context, args ...interface{}) *Cmd\n-\tProcess(cmd Cmder) error\n-\tProcessContext(ctx context.Context, cmd Cmder) error\n-\tSubscribe(channels ...string) *PubSub\n-\tPSubscribe(channels ...string) *PubSub\n+\tWatch(ctx context.Context, fn func(*Tx) error, keys ...string) error\n+\tDo(ctx context.Context, args ...interface{}) *Cmd\n+\tProcess(ctx context.Context, cmd Cmder) error\n+\tSubscribe(ctx context.Context, channels ...string) *PubSub\n+\tPSubscribe(ctx context.Context, channels ...string) *PubSub\n \tClose() error\n+\tPoolStats() *PoolStats\n }\n \n-var _ UniversalClient = (*Client)(nil)\n-var _ UniversalClient = (*ClusterClient)(nil)\n-var _ UniversalClient = (*Ring)(nil)\n+var (\n+\t_ UniversalClient = (*Client)(nil)\n+\t_ UniversalClient = (*ClusterClient)(nil)\n+\t_ UniversalClient = (*Ring)(nil)\n+)\n \n-// NewUniversalClient returns a new multi client. The type of client returned depends\n-// on the following three conditions:\n+// NewUniversalClient returns a new multi client. The type of the returned client depends\n+// on the following conditions:\n //\n-// 1. if a MasterName is passed a sentinel-backed FailoverClient will be returned\n-// 2. if the number of Addrs is two or more, a ClusterClient will be returned\n-// 3. otherwise, a single-node redis Client will be returned.\n+// 1. If the MasterName option is specified, a sentinel-backed FailoverClient is returned.\n+// 2. if the number of Addrs is two or more, a ClusterClient is returned.\n+// 3. Otherwise, a single-node Client is returned.\n func NewUniversalClient(opts *UniversalOptions) UniversalClient {\n \tif opts.MasterName != \"\" {\n \t\treturn NewFailoverClient(opts.Failover())",
      "previous_filename": "backend/vendor/github.com/go-redis/redis/v7/universal.go"
    },
    {
      "sha": "112c9a2da0e35d79c0d4f6ef850f643d875135d4",
      "filename": "backend/vendor/github.com/go-redis/redis/v8/version.go",
      "status": "added",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fversion.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fversion.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fgo-redis%2Fredis%2Fv8%2Fversion.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -0,0 +1,6 @@\n+package redis\n+\n+// Version is the current release version.\n+func Version() string {\n+\treturn \"8.11.5\"\n+}"
    },
    {
      "sha": "278b711c887cf858e581f4349e3f0a4f6d37b31c",
      "filename": "backend/vendor/github.com/kyokomi/emoji/v2/emoji_codemap.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fkyokomi%2Femoji%2Fv2%2Femoji_codemap.go",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fkyokomi%2Femoji%2Fv2%2Femoji_codemap.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fkyokomi%2Femoji%2Fv2%2Femoji_codemap.go?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -367,7 +367,7 @@ func emojiCode() map[string]string {\n \t\t\t\":bouncing_ball_woman:\":                                    \"\\u26f9\\ufe0f\\u200d\\u2640\\ufe0f\",\n \t\t\t\":bouquet:\":                                                \"\\U0001f490\",\n \t\t\t\":bouvet_island:\":                                          \"\\U0001f1e7\\U0001f1fb\",\n-\t\t\t\":bow:\":                                                    \"\\U0001f647\\u200d\\u2642\\ufe0f\",\n+\t\t\t\":bow:\":                                                    \"\\U0001f647\",\n \t\t\t\":bow_and_arrow:\":                                          \"\\U0001f3f9\",\n \t\t\t\":bowing_man:\":                                             \"\\U0001f647\\u200d\\u2642\\ufe0f\",\n \t\t\t\":bowing_woman:\":                                           \"\\U0001f647\\u200d\\u2640\\ufe0f\",\n@@ -6513,7 +6513,7 @@ func emojiRevCode() map[string][]string {\n \t\t\t\"\\U0001f646\\U0001f3ff\\u200d\\u2642\\ufe0f\":     {\":man_gesturing_ok_tone5:\"},\n \t\t\t\"\\U0001f646\\u200d\\u2640\\ufe0f\":               {\":ok_woman:\", \":woman-gesturing-ok:\", \":woman_gesturing_OK:\", \":woman_gesturing_ok:\"},\n \t\t\t\"\\U0001f646\\u200d\\u2642\\ufe0f\":               {\":ok_man:\", \":man-gesturing-ok:\", \":man_gesturing_OK:\", \":man_gesturing_ok:\"},\n-\t\t\t\"\\U0001f647\":                                 {\":person_bowing:\"},\n+\t\t\t\"\\U0001f647\":                                 {\":bow:\", \":person_bowing:\"},\n \t\t\t\"\\U0001f647\\U0001f3fb\":                       {\":person_bowing_tone1:\"},\n \t\t\t\"\\U0001f647\\U0001f3fb\\u200d\\u2640\\ufe0f\":     {\":woman_bowing_tone1:\"},\n \t\t\t\"\\U0001f647\\U0001f3fb\\u200d\\u2642\\ufe0f\":     {\":man_bowing_tone1:\"},\n@@ -6530,7 +6530,7 @@ func emojiRevCode() map[string][]string {\n \t\t\t\"\\U0001f647\\U0001f3ff\\u200d\\u2640\\ufe0f\":     {\":woman_bowing_tone5:\"},\n \t\t\t\"\\U0001f647\\U0001f3ff\\u200d\\u2642\\ufe0f\":     {\":man_bowing_tone5:\"},\n \t\t\t\"\\U0001f647\\u200d\\u2640\\ufe0f\":               {\":bowing_woman:\", \":woman-bowing:\", \":woman_bowing:\"},\n-\t\t\t\"\\U0001f647\\u200d\\u2642\\ufe0f\":               {\":bow:\", \":bowing_man:\", \":man-bowing:\", \":man_bowing:\"},\n+\t\t\t\"\\U0001f647\\u200d\\u2642\\ufe0f\":               {\":bowing_man:\", \":man-bowing:\", \":man_bowing:\"},\n \t\t\t\"\\U0001f648\":                                 {\":see_no_evil:\", \":see-no-evil_monkey:\"},\n \t\t\t\"\\U0001f649\":                                 {\":hear_no_evil:\", \":hear-no-evil_monkey:\"},\n \t\t\t\"\\U0001f64a\":                                 {\":speak_no_evil:\", \":speak-no-evil_monkey:\"},"
    },
    {
      "sha": "82bd2099391049bb6629b4fa8900fcaf2eb02c4c",
      "filename": "backend/vendor/github.com/kyokomi/emoji/v2/wercker.yml",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fkyokomi%2Femoji%2Fv2%2Fwercker.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fgithub.com%2Fkyokomi%2Femoji%2Fv2%2Fwercker.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fgithub.com%2Fkyokomi%2Femoji%2Fv2%2Fwercker.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -8,8 +8,8 @@ build:\n     - script:\n         name: install tools\n         code: |\n-          go get github.com/mattn/goveralls\n-          GO111MODULE=on go get github.com/golangci/golangci-lint/cmd/golangci-lint\n+          go install github.com/mattn/goveralls@latest\n+          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n     - script:\n         name: go get\n         code: |"
    },
    {
      "sha": "5570b3e876512c4ec0581481055c1d4e2324a741",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 24,
      "deletions": 14,
      "changes": 38,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fmodules.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/backend%2Fvendor%2Fmodules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fvendor%2Fmodules.txt?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -7,6 +7,9 @@ github.com/Depado/bfchroma/v2\n # github.com/PuerkitoBio/goquery v1.8.0\n ## explicit; go 1.13\n github.com/PuerkitoBio/goquery\n+# github.com/ajg/form v1.5.1\n+## explicit\n+github.com/ajg/form\n # github.com/alecthomas/chroma/v2 v2.2.0\n ## explicit; go 1.17\n github.com/alecthomas/chroma/v2\n@@ -20,13 +23,19 @@ github.com/andybalholm/cascadia\n ## explicit\n github.com/aymerick/douceur/css\n github.com/aymerick/douceur/parser\n+# github.com/cespare/xxhash/v2 v2.1.2\n+## explicit; go 1.11\n+github.com/cespare/xxhash/v2\n # github.com/davecgh/go-spew v1.1.1\n ## explicit\n github.com/davecgh/go-spew/spew\n # github.com/dghubble/oauth1 v0.7.1\n ## explicit; go 1.16\n github.com/dghubble/oauth1\n github.com/dghubble/oauth1/twitter\n+# github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f\n+## explicit\n+github.com/dgryski/go-rendezvous\n # github.com/didip/tollbooth/v7 v7.0.0\n ## explicit; go 1.12\n github.com/didip/tollbooth/v7\n@@ -48,15 +57,15 @@ github.com/go-chi/chi/v5/middleware\n # github.com/go-chi/cors v1.2.1\n ## explicit; go 1.14\n github.com/go-chi/cors\n-# github.com/go-chi/render v1.0.1\n-## explicit\n+# github.com/go-chi/render v1.0.2\n+## explicit; go 1.16\n github.com/go-chi/render\n # github.com/go-oauth2/oauth2/v4 v4.4.3\n ## explicit; go 1.13\n github.com/go-oauth2/oauth2/v4\n github.com/go-oauth2/oauth2/v4/errors\n github.com/go-oauth2/oauth2/v4/server\n-# github.com/go-pkgz/auth v1.19.1-0.20220624002401-8b91a0eee69a\n+# github.com/go-pkgz/auth v1.19.1\n ## explicit; go 1.17\n github.com/go-pkgz/auth\n github.com/go-pkgz/auth/avatar\n@@ -74,7 +83,7 @@ github.com/go-pkgz/expirable-cache\n # github.com/go-pkgz/jrpc v0.3.0\n ## explicit; go 1.16\n github.com/go-pkgz/jrpc\n-# github.com/go-pkgz/lcw v0.8.1\n+# github.com/go-pkgz/lcw v1.0.1\n ## explicit; go 1.15\n github.com/go-pkgz/lcw\n github.com/go-pkgz/lcw/eventbus\n@@ -97,15 +106,16 @@ github.com/go-pkgz/rest/realip\n # github.com/go-pkgz/syncs v1.2.0\n ## explicit; go 1.16\n github.com/go-pkgz/syncs\n-# github.com/go-redis/redis/v7 v7.4.1\n-## explicit; go 1.11\n-github.com/go-redis/redis/v7\n-github.com/go-redis/redis/v7/internal\n-github.com/go-redis/redis/v7/internal/consistenthash\n-github.com/go-redis/redis/v7/internal/hashtag\n-github.com/go-redis/redis/v7/internal/pool\n-github.com/go-redis/redis/v7/internal/proto\n-github.com/go-redis/redis/v7/internal/util\n+# github.com/go-redis/redis/v8 v8.11.5\n+## explicit; go 1.17\n+github.com/go-redis/redis/v8\n+github.com/go-redis/redis/v8/internal\n+github.com/go-redis/redis/v8/internal/hashtag\n+github.com/go-redis/redis/v8/internal/hscan\n+github.com/go-redis/redis/v8/internal/pool\n+github.com/go-redis/redis/v8/internal/proto\n+github.com/go-redis/redis/v8/internal/rand\n+github.com/go-redis/redis/v8/internal/util\n # github.com/go-stack/stack v1.8.1\n ## explicit; go 1.17\n github.com/go-stack/stack\n@@ -152,7 +162,7 @@ github.com/klauspost/compress/internal/cpuinfo\n github.com/klauspost/compress/internal/snapref\n github.com/klauspost/compress/zstd\n github.com/klauspost/compress/zstd/internal/xxhash\n-# github.com/kyokomi/emoji/v2 v2.2.9\n+# github.com/kyokomi/emoji/v2 v2.2.10\n ## explicit; go 1.14\n github.com/kyokomi/emoji/v2\n # github.com/microcosm-cc/bluemonday v1.0.19"
    },
    {
      "sha": "2a14fa8610d18417a6751475b7d05b2ebec909ec",
      "filename": "compose-dev-backend.yml",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/compose-dev-backend.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/compose-dev-backend.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/compose-dev-backend.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -33,13 +33,15 @@ services:\n       - \"8084:8084\" # local oauth2 server\n \n     environment:\n-      #            - APP_UID=1000\n-      #            - TIME_ZONE=GMT\n+      # - APP_UID=1000\n+      # - TIME_ZONE=GMT\n+      # REMARK_URL below would be used for the dev auth,\n+      # so that it would work on http://127.0.0.1 but wouldn't on http://localhost\n       - REMARK_URL=http://127.0.0.1:8080\n       - SECRET=12345\n       - DEBUG=true\n       - ADMIN_PASSWD=password\n-      - AUTH_DEV=true # activate local oauth \"dev\"\n+      - AUTH_DEV=true # activate local OAuth \"dev\" on REMARK_URL hostname\n       - ADMIN_SHARED_ID=dev_user # set admin flag for default user on local oauth2\n       - NOTIFY_USERS\n       - NOTIFY_ADMINS"
    },
    {
      "sha": "1908d695eb17f952378341d380982342dd4944e2",
      "filename": "compose-dev-frontend.yml",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/compose-dev-frontend.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/compose-dev-frontend.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/compose-dev-frontend.yml?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -31,11 +31,13 @@ services:\n       - \"8084:8084\" # local oauth2 server\n \n     environment:\n+      # REMARK_URL below would be used for the dev auth,\n+      # so that it would work on http://127.0.0.1 but wouldn't on http://localhost\n       - REMARK_URL=http://127.0.0.1:8080\n       - SECRET=12345\n       - DEBUG=true\n       - ADMIN_PASSWD=password\n-      - AUTH_DEV=true # activate local oauth \"dev\"\n+      - AUTH_DEV=true # activate local OAuth \"dev\" on REMARK_URL hostname\n       - ADMIN_SHARED_ID=dev_user # set admin flag for default user on local oauth2\n       - AUTH_ANON=true\n       - AUTH_EMAIL_ENABLE=true"
    },
    {
      "sha": "00f7eee497a68badbce47abcac46be5c16947c71",
      "filename": "site/src/docs/contributing/backend/index.md",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/site%2Fsrc%2Fdocs%2Fcontributing%2Fbackend%2Findex.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/site%2Fsrc%2Fdocs%2Fcontributing%2Fbackend%2Findex.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/site%2Fsrc%2Fdocs%2Fcontributing%2Fbackend%2Findex.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -16,7 +16,9 @@ docker-compose -f compose-private.yml up --build\n \n It starts Remark42 on `127.0.0.1:8080` and adds local OAuth2 provider \"Dev\". To access the UI demo page go to <http://127.0.0.1:8080/web/>. By default, you would be logged in as `dev_user`, defined as admin. You can tweak any of the [supported parameters](https://remark42.com/docs/configuration/parameters/) in corresponded yml file.\n \n-**Important**: use `127.0.0.1` and not `localhost` to access the server, as otherwise, CORS will prevent your browser from authentication to work correctly.\n+::: note 🚨\n+Please use `127.0.0.1` and not `localhost` to access the server; otherwise, CORS will prevent your browser from authentication to work correctly. You could alter the address for dev auth with the `REMARK_URL` environment variable.\n+:::\n \n Backend Docker Compose config (`compose-dev-backend.yml`) by default skips running frontend related tests. Frontend Docker Compose config (`compose-dev-frontend.yml`) by default skips running backend related tests and sets `NODE_ENV=development` for frontend build.\n "
    },
    {
      "sha": "54016681e0f49d35fdfc9109fc3c41ba513ec38e",
      "filename": "site/src/docs/contributing/frontend/index.md",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/9ad3be2e97c658337a8e05edd744a5863607cf97/site%2Fsrc%2Fdocs%2Fcontributing%2Ffrontend%2Findex.md",
      "raw_url": "https://github.com/umputun/remark42/raw/9ad3be2e97c658337a8e05edd744a5863607cf97/site%2Fsrc%2Fdocs%2Fcontributing%2Ffrontend%2Findex.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/site%2Fsrc%2Fdocs%2Fcontributing%2Ffrontend%2Findex.md?ref=9ad3be2e97c658337a8e05edd744a5863607cf97",
      "patch": "@@ -27,7 +27,7 @@ You must have at least 2GB RAM or swap enabled for building.\n Running `pnpm i` will set up pre-commit hooks into your git repository. They are used to reformat your frontend code using `prettier` and lint with `eslint` and `stylelint` before every commit.\n \n ::: note 🚨\n-Use `127.0.0.1` and not `localhost` to access the server, as otherwise, CORS will prevent your browser from authentication to work correctly.\n+Please use `127.0.0.1` and not `localhost` to access the server; otherwise, CORS will prevent your browser from authentication to work correctly. You could alter the address for dev auth with the `REMARK_URL` environment variable.\n :::\n \n ## Development"
    }
  ]
}

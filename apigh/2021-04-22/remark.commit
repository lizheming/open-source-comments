{
  "sha": "df4b0c80ac2a45f6042102a45c222e7f56515c79",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOmRmNGIwYzgwYWMyYTQ1ZjYwNDIxMDJhNDVjMjIyZTdmNTY1MTVjNzk=",
  "commit": {
    "author": {
      "name": "ronan",
      "email": "ronan.jezequel@gmail.com",
      "date": "2021-03-29T12:09:04Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2021-04-21T17:56:14Z"
    },
    "message": "Support for Slack notifications\n\nSlack notifications: remove debug log\n\nSlack notifications: code lint\n\nSlack notifications: code lint\n\nSlack notifications: code lint\n\nfix according to comments",
    "tree": {
      "sha": "f8ae2b8a927f8f20919fdc81baa78ed0c4756ff8",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/f8ae2b8a927f8f20919fdc81baa78ed0c4756ff8"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/df4b0c80ac2a45f6042102a45c222e7f56515c79",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/df4b0c80ac2a45f6042102a45c222e7f56515c79",
  "html_url": "https://github.com/umputun/remark42/commit/df4b0c80ac2a45f6042102a45c222e7f56515c79",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/df4b0c80ac2a45f6042102a45c222e7f56515c79/comments",
  "author": {
    "login": "ronanj",
    "id": 640401,
    "node_id": "MDQ6VXNlcjY0MDQwMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/640401?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ronanj",
    "html_url": "https://github.com/ronanj",
    "followers_url": "https://api.github.com/users/ronanj/followers",
    "following_url": "https://api.github.com/users/ronanj/following{/other_user}",
    "gists_url": "https://api.github.com/users/ronanj/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ronanj/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ronanj/subscriptions",
    "organizations_url": "https://api.github.com/users/ronanj/orgs",
    "repos_url": "https://api.github.com/users/ronanj/repos",
    "events_url": "https://api.github.com/users/ronanj/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ronanj/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c9841b81e485a58608abfc7159e52da2232539d9",
      "url": "https://api.github.com/repos/umputun/remark42/commits/c9841b81e485a58608abfc7159e52da2232539d9",
      "html_url": "https://github.com/umputun/remark42/commit/c9841b81e485a58608abfc7159e52da2232539d9"
    }
  ],
  "stats": {
    "total": 16113,
    "additions": 16110,
    "deletions": 3
  },
  "files": [
    {
      "sha": "2957393ddffb5044c1c7353d7c844a4511c1afd5",
      "filename": "README.md",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/README.md",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/README.md?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -17,7 +17,8 @@ Remark42 is a self-hosted, lightweight, and simple (yet functional) comment engi\n * Images upload with drag-and-drop\n * Extractor for recent comments, cross-post\n * RSS for all comments and each post\n-* Telegram and email notifications\n+* Telegram, Slack and email notifications for Admins (get notified for each new comment)\n+* Email notifications for users (get notified when someone responds to your comment)\n * Export data to json with automatic backups\n * No external databases, everything embedded in a single data file\n * Fully dockerized and can be deployed in a single command\n@@ -155,11 +156,13 @@ _this is the recommended way to run remark42_\n | auth.email.subj         | AUTH_EMAIL_SUBJ         | `remark42 confirmation`  | email subject                                   |\n | auth.email.content-type | AUTH_EMAIL_CONTENT_TYPE | `text/html`              | email content type                              |\n | auth.email.template     | AUTH_EMAIL_TEMPLATE     | none (predefined)        | custom email message template file              |\n-| notify.type             | NOTIFY_TYPE             | none                     | type of notification (telegram and/or email)    |\n+| notify.type             | NOTIFY_TYPE             | none                     | type of notification (telegram, slack and/or email) |\n | notify.queue            | NOTIFY_QUEUE            | `100`                    | size of notification queue                      |\n | notify.telegram.token   | NOTIFY_TELEGRAM_TOKEN   |                          | telegram token                                  |\n | notify.telegram.chan    | NOTIFY_TELEGRAM_CHAN    |                          | telegram channel                                |\n | notify.telegram.timeout | NOTIFY_TELEGRAM_TIMEOUT | `5s`                     | telegram timeout                                |\n+| notify.slack.token      | NOTIFY_SLACK_TOKEN      |                          | slack token                                     |\n+| notify.slack.chan       | NOTIFY_SLACK_CHAN       | `general`                | slack channel                                   |\n | notify.email.fromAddress | NOTIFY_EMAIL_FROM      |                          | from email address                              |\n | notify.email.verification_subj | NOTIFY_EMAIL_VERIFICATION_SUBJ | `Email verification` | verification message subject          |\n | notify.email.notify_admin | NOTIFY_EMAIL_ADMIN    | `false`                  | notify admin on new comments via ADMIN_SHARED_EMAIL |"
    },
    {
      "sha": "2613ed016e925c4f92d3d90e5cf69e4e94d6964f",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/app/cmd/server.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/app/cmd/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/cmd/server.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -198,7 +198,7 @@ type SMTPGroup struct {\n \n // NotifyGroup defines options for notification\n type NotifyGroup struct {\n-\tType      []string `long:\"type\" env:\"TYPE\" description:\"type of notification\" choice:\"none\" choice:\"telegram\" choice:\"email\" default:\"none\" env-delim:\",\"` //nolint\n+\tType      []string `long:\"type\" env:\"TYPE\" description:\"type of notification\" choice:\"none\" choice:\"telegram\" choice:\"email\" choice:\"slack\" default:\"none\" env-delim:\",\"` //nolint\n \tQueueSize int      `long:\"queue\" env:\"QUEUE\" description:\"size of notification queue\" default:\"100\"`\n \tTelegram  struct {\n \t\tToken   string        `long:\"token\" env:\"TOKEN\" description:\"telegram token\"`\n@@ -211,6 +211,10 @@ type NotifyGroup struct {\n \t\tVerificationSubject string `long:\"verification_subj\" env:\"VERIFICATION_SUBJ\" description:\"verification message subject\"`\n \t\tAdminNotifications  bool   `long:\"notify_admin\" env:\"ADMIN\" description:\"notify admin on new comments via ADMIN_SHARED_EMAIL\"`\n \t} `group:\"email\" namespace:\"email\" env-namespace:\"EMAIL\"`\n+\tSlack  struct {\n+\t\tToken   string        `long:\"token\" env:\"TOKEN\" description:\"slack token\"`\n+\t\tChannel string        `long:\"chan\" env:\"CHAN\" description:\"slack channel\"`\n+\t} `group:\"slack\" namespace:\"slack\" env-namespace:\"SLACK\"`\n }\n \n // SSLGroup defines options group for server ssl params\n@@ -807,6 +811,12 @@ func (s *ServerCommand) makeNotify(dataStore *service.DataStore, authenticator *\n \tvar destinations []notify.Destination\n \tfor _, t := range s.Notify.Type {\n \t\tswitch t {\n+\t\tcase \"slack\":\n+\t\t\tslack, err := notify.NewSlack(s.Notify.Slack.Token, s.Notify.Slack.Channel)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, errors.Wrap(err, \"failed to create slack notification destination\")\n+\t\t\t}\n+\t\t\tdestinations = append(destinations, slack)\n \t\tcase \"telegram\":\n \t\t\ttg, err := notify.NewTelegram(s.Notify.Telegram.Token, s.Notify.Telegram.Channel,\n \t\t\t\ts.Notify.Telegram.Timeout, s.Notify.Telegram.API)"
    },
    {
      "sha": "0addd3cf15ceefa6d89293bfe5c518275d8ac195",
      "filename": "backend/app/notify/slack.go",
      "status": "added",
      "additions": 102,
      "deletions": 0,
      "changes": 102,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/app/notify/slack.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/app/notify/slack.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/notify/slack.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,102 @@\n+package notify\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\tlog \"github.com/go-pkgz/lgr\"\n+\t\"github.com/pkg/errors\"\n+\t\"github.com/slack-go/slack\"\n+)\n+\n+// Slack implements notify.Destination for Slack\n+type Slack struct {\n+\tchannelID   string\n+\tchannelName string\n+\tclient      *slack.Client\n+}\n+\n+// NewSlack makes Slack bot for notifications\n+func NewSlack(token, channelName string, opts ...slack.Option) (*Slack, error) {\n+\n+\tif channelName == \"\" {\n+\t\tchannelName = \"general\"\n+\t}\n+\n+\tclient := slack.New(token, opts...)\n+\tres := &Slack{client: client, channelName: channelName}\n+\n+\tchannelID, err := res.findChannelIDByName(channelName)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"can not find slack channel '\"+channelName+\"'\")\n+\t}\n+\n+\tres.channelID = channelID\n+\tlog.Printf(\"[DEBUG] create new slack notifier for chan %s\", channelID)\n+\n+\treturn res, nil\n+}\n+\n+// Send to Slack channel\n+func (t *Slack) Send(ctx context.Context, req Request) error {\n+\n+\tlog.Printf(\"[DEBUG] send slack notification, comment id %s\", req.Comment.ID)\n+\n+\tuser := req.Comment.User.Name\n+\tif req.Comment.ParentID != \"\" {\n+\t\tuser += \" → \" + req.parent.User.Name\n+\t}\n+\n+\ttitle := fmt.Sprintf(\"↦ original comment\")\n+\tif req.Comment.PostTitle != \"\" {\n+\t\ttitle = \"↦ \" + req.Comment.PostTitle\n+\t}\n+\n+\t_, _, err := t.client.PostMessageContext(ctx, t.channelID,\n+\t\tslack.MsgOptionText(\"New comment from \"+user, false),\n+\t\tslack.MsgOptionAttachments(\n+\t\t\tslack.Attachment{\n+\t\t\t\tTitleLink: req.Comment.Locator.URL + uiNav + req.Comment.ID,\n+\t\t\t\tTitle:     title,\n+\t\t\t\tText:      req.Comment.Orig,\n+\t\t\t},\n+\t\t),\n+\t)\n+\n+\treturn err\n+\n+}\n+\n+// SendVerification is not implemented for Slack\n+func (t *Slack) SendVerification(_ context.Context, _ VerificationRequest) error {\n+\treturn nil\n+}\n+\n+func (t *Slack) String() string {\n+\treturn \"slack: \" + t.channelName + \" (\" + t.channelID + \")\"\n+}\n+\n+func (t *Slack) findChannelIDByName(name string) (string, error) {\n+\n+\tparams := slack.GetConversationsParameters{}\n+\tfor {\n+\n+\t\tchans, next, err := t.client.GetConversations(&params)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\n+\t\tfor _, channel := range chans {\n+\t\t\tif channel.Name == name {\n+\t\t\t\treturn channel.ID, nil\n+\t\t\t}\n+\t\t}\n+\n+\t\tif next == \"\" {\n+\t\t\tbreak\n+\t\t}\n+\t\tparams.Cursor = next\n+\n+\t}\n+\treturn \"\", errors.New(\"no such channel\")\n+}"
    },
    {
      "sha": "5726b2e49bde62a8a1376b4c45f54413277eae96",
      "filename": "backend/app/notify/slack_test.go",
      "status": "added",
      "additions": 170,
      "deletions": 0,
      "changes": 170,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/app/notify/slack_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/app/notify/slack_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/notify/slack_test.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,170 @@\n+package notify\n+\n+import (\n+\t\"context\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n+\t\"testing\"\n+\n+\t\"github.com/go-chi/chi\"\n+\t\"github.com/slack-go/slack\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/umputun/remark42/backend/app/store\"\n+)\n+\n+func TestSlack_New(t *testing.T) {\n+\n+\tts := newMockSlackServer()\n+\tdefer ts.Close()\n+\n+\ttb, err := ts.newClient(\"general\")\n+\tassert.NoError(t, err)\n+\tassert.NotNil(t, tb)\n+\tassert.Equal(t, \"C12345678\", tb.channelID)\n+\n+\t_, err = ts.newClient(\"unknown-channel\")\n+\trequire.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"no such channel\")\n+\n+}\n+\n+func TestSlack_Send(t *testing.T) {\n+\n+\tts := newMockSlackServer()\n+\tdefer ts.Close()\n+\n+\ttb, err := ts.newClient(\"general\")\n+\tassert.NoError(t, err)\n+\tassert.NotNil(t, tb)\n+\n+\tc := store.Comment{Text: \"some text\", ParentID: \"1\", ID: \"999\"}\n+\tc.User.Name = \"from\"\n+\tcp := store.Comment{Text: \"some parent text\"}\n+\tcp.User.Name = \"to\"\n+\n+\terr = tb.Send(context.TODO(), Request{Comment: c, parent: cp})\n+\tassert.NoError(t, err)\n+\tc.PostTitle = \"test title\"\n+\terr = tb.Send(context.TODO(), Request{Comment: c, parent: cp})\n+\tassert.NoError(t, err)\n+\n+\terr = tb.Send(context.TODO(), Request{Comment: c, parent: cp})\n+\tassert.NoError(t, err)\n+\tc.PostTitle = \"[test title]\"\n+\terr = tb.Send(context.TODO(), Request{Comment: c, parent: cp})\n+\tassert.NoError(t, err)\n+\n+\ttb, err = ts.newClient(\"general\")\n+\tassert.NoError(t, err)\n+\tts.isServerDown = true\n+\terr = tb.Send(context.TODO(), Request{Comment: c, parent: cp})\n+\trequire.Error(t, err)\n+\tassert.Contains(t, err.Error(), \"slack server error\", \"send on broken client\")\n+\n+}\n+\n+func TestSlack_Name(t *testing.T) {\n+\tts := newMockSlackServer()\n+\tdefer ts.Close()\n+\n+\ttb, err := ts.newClient(\"general\")\n+\tassert.NoError(t, err)\n+\tassert.NotNil(t, tb)\n+\tassert.Equal(t, \"slack: general (C12345678)\", tb.String())\n+}\n+\n+func TestSlack_SendVerification(t *testing.T) {\n+\tts := newMockSlackServer()\n+\tdefer ts.Close()\n+\n+\ttb, err := ts.newClient(\"general\")\n+\tassert.NoError(t, err)\n+\tassert.NotNil(t, tb)\n+\n+\terr = tb.SendVerification(context.TODO(), VerificationRequest{})\n+\tassert.NoError(t, err)\n+}\n+\n+type mockSlackServer struct {\n+\t*httptest.Server\n+\tisServerDown bool\n+}\n+\n+func (ts *mockSlackServer) newClient(channelName string) (*Slack, error) {\n+\treturn NewSlack(\"any-token\", channelName, slack.OptionAPIURL(ts.URL+\"/\"))\n+}\n+\n+func newMockSlackServer() *mockSlackServer {\n+\n+\tmockServer := mockSlackServer{}\n+\trouter := chi.NewRouter()\n+\trouter.Post(\"/conversations.list\", func(w http.ResponseWriter, r *http.Request) {\n+\t\ts := `{\n+\t\t    \"ok\": true,\n+\t\t    \"channels\": [\n+\t\t        {\n+\t\t            \"id\": \"C12345678\",\n+\t\t            \"name\": \"general\",\n+\t\t            \"is_channel\": true,\n+\t\t            \"is_group\": false,\n+\t\t            \"is_im\": false,\n+\t\t            \"created\": 1503888888,\n+\t\t            \"is_archived\": false,\n+\t\t            \"is_general\": false,\n+\t\t            \"unlinked\": 0,\n+\t\t            \"name_normalized\": \"random\",\n+\t\t            \"is_shared\": false,\n+\t\t            \"parent_conversation\": null,\n+\t\t            \"creator\": \"U12345678\",\n+\t\t            \"is_ext_shared\": false,\n+\t\t            \"is_org_shared\": false,\n+\t\t            \"pending_shared\": [],\n+\t\t            \"pending_connected_team_ids\": [],\n+\t\t            \"is_pending_ext_shared\": false,\n+\t\t            \"is_member\": false,\n+\t\t            \"is_private\": false,\n+\t\t            \"is_mpim\": false,\n+\t\t            \"previous_names\": [],\n+\t\t            \"num_members\": 1\n+\t\t        }\n+\t\t    ],\n+\t\t    \"response_metadata\": {\n+\t\t        \"next_cursor\": \"\"\n+\t\t    }\n+\t\t}`\n+\t\t_, _ = w.Write([]byte(s))\n+\t})\n+\n+\trouter.Post(\"/chat.postMessage\", func(w http.ResponseWriter, r *http.Request) {\n+\n+\t\tif mockServer.isServerDown {\n+\t\t\tw.WriteHeader(500)\n+\n+\t\t} else {\n+\t\t\ts := `{\n+\t\t\t    \"ok\": true,\n+\t\t\t    \"channel\": \"C12345678\",\n+\t\t\t    \"ts\": \"1617008342.000100\",\n+\t\t\t    \"message\": {\n+\t\t\t        \"type\": \"message\",\n+\t\t\t        \"subtype\": \"bot_message\",\n+\t\t\t        \"text\": \"wowo\",\n+\t\t\t        \"ts\": \"1617008342.000100\",\n+\t\t\t        \"username\": \"slackbot\",\n+\t\t\t        \"bot_id\": \"B12345678\"\n+\t\t\t    }\n+\t\t\t}`\n+\t\t\t_, _ = w.Write([]byte(s))\n+\t\t}\n+\t})\n+\n+\trouter.NotFound(func(w http.ResponseWriter, r *http.Request) {\n+\t\tlog.Printf(\"..... 404 for %s .....\\n\", r.URL)\n+\t})\n+\n+\tmockServer.Server = httptest.NewServer(router)\n+\treturn &mockServer\n+}"
    },
    {
      "sha": "5ec971d0994df412fdf8d2715af7bd963e6384a2",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/go.mod?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -28,6 +28,7 @@ require (\n \tgithub.com/rakyll/statik v0.1.7\n \tgithub.com/rs/xid v1.2.1\n \tgithub.com/russross/blackfriday/v2 v2.1.0\n+\tgithub.com/slack-go/slack v0.8.2\n \tgithub.com/stretchr/testify v1.6.1\n \tgithub.com/umputun/go-flags v1.5.1\n \tgo.etcd.io/bbolt v1.3.5"
    },
    {
      "sha": "675e464fdb300f726c9671827c35d3c42edb45e8",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/go.sum?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -88,6 +88,7 @@ github.com/go-session/session v3.1.2+incompatible/go.mod h1:8B3iivBQjrz/JtC68Np2\n github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=\n github.com/go-stack/stack v1.8.0 h1:5SgMzNM5HxrEjV0ww2lTmX6E2Izsfxas4+YHWRs3Lsk=\n github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\n+github.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\n github.com/gobuffalo/attrs v0.0.0-20190224210810-a9411de4debd/go.mod h1:4duuawTqi2wkkpB4ePgWMaai6/Kc6WEz83bhFwpHzj0=\n github.com/gobuffalo/depgen v0.0.0-20190329151759-d478694a28d3/go.mod h1:3STtPUQYuzV0gBVOY3vy6CfMm/ljR4pABfrTeHNLHUY=\n github.com/gobuffalo/depgen v0.1.0/go.mod h1:+ifsuy7fhi15RWncXQQKjWS9JPkdah5sZvtHc2RXGlg=\n@@ -133,6 +134,8 @@ github.com/gorilla/feeds v1.1.1 h1:HwKXxqzcRNg9to+BbvJog4+f3s/xzvtZXICcQGutYfY=\n github.com/gorilla/feeds v1.1.1/go.mod h1:Nk0jZrvPFZX1OBe5NPiddPw7CfwF6Q9eqzaBbaightA=\n github.com/gorilla/websocket v1.4.1 h1:q7AeDBpnBk8AogcD4DSag/Ukw/KV+YhzLj2bP5HvKCM=\n github.com/gorilla/websocket v1.4.1/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\n+github.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\n+github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\n github.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=\n github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n github.com/hashicorp/go-multierror v1.1.0 h1:B9UzwGQJehnUY1yNrnwREHc3fGbC2xefo8g4TbElacI=\n@@ -216,6 +219,8 @@ github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeV\n github.com/sirupsen/logrus v1.4.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\n github.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=\n github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\n+github.com/slack-go/slack v0.8.2 h1:D7jNu0AInBfdQ4QyKPtVSp+ZxQes3EzWW17RZ/va4JE=\n+github.com/slack-go/slack v0.8.2/go.mod h1:FGqNzJBmxIsZURAxh2a8D21AnOVvvXZvGligs4npPUM=\n github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=\n github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\n github.com/smartystreets/goconvey v1.6.4 h1:fv0U8FUIMPNf1L9lnHLvLhgicrIVChEkdzIKYqbNC9s="
    },
    {
      "sha": "cd3fcd1ef72a7f780f5b916369a9fff458876ae9",
      "filename": "backend/vendor/github.com/gorilla/websocket/.gitignore",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/.gitignore?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,25 @@\n+# Compiled Object files, Static and Dynamic libs (Shared Objects)\n+*.o\n+*.a\n+*.so\n+\n+# Folders\n+_obj\n+_test\n+\n+# Architecture specific extensions/prefixes\n+*.[568vq]\n+[568vq].out\n+\n+*.cgo1.go\n+*.cgo2.c\n+_cgo_defun.c\n+_cgo_gotypes.go\n+_cgo_export.*\n+\n+_testmain.go\n+\n+*.exe\n+\n+.idea/\n+*.iml"
    },
    {
      "sha": "1931f400682c373b02db547c1fdc4315b804b2eb",
      "filename": "backend/vendor/github.com/gorilla/websocket/AUTHORS",
      "status": "added",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/AUTHORS",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/AUTHORS",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/AUTHORS?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,9 @@\n+# This is the official list of Gorilla WebSocket authors for copyright\n+# purposes.\n+#\n+# Please keep the list sorted.\n+\n+Gary Burd <gary@beagledreams.com>\n+Google LLC (https://opensource.google.com/)\n+Joachim Bauch <mail@joachim-bauch.de>\n+"
    },
    {
      "sha": "9171c972252257cf416925ddff4be6cb73973a82",
      "filename": "backend/vendor/github.com/gorilla/websocket/LICENSE",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/LICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/LICENSE?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,22 @@\n+Copyright (c) 2013 The Gorilla WebSocket Authors. All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+  Redistributions of source code must retain the above copyright notice, this\n+  list of conditions and the following disclaimer.\n+\n+  Redistributions in binary form must reproduce the above copyright notice,\n+  this list of conditions and the following disclaimer in the documentation\n+  and/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
    },
    {
      "sha": "19aa2e75c82413cf81c9ae8a7df8214a35632c21",
      "filename": "backend/vendor/github.com/gorilla/websocket/README.md",
      "status": "added",
      "additions": 64,
      "deletions": 0,
      "changes": 64,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/README.md",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/README.md?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,64 @@\n+# Gorilla WebSocket\n+\n+[![GoDoc](https://godoc.org/github.com/gorilla/websocket?status.svg)](https://godoc.org/github.com/gorilla/websocket)\n+[![CircleCI](https://circleci.com/gh/gorilla/websocket.svg?style=svg)](https://circleci.com/gh/gorilla/websocket)\n+\n+Gorilla WebSocket is a [Go](http://golang.org/) implementation of the\n+[WebSocket](http://www.rfc-editor.org/rfc/rfc6455.txt) protocol.\n+\n+### Documentation\n+\n+* [API Reference](https://pkg.go.dev/github.com/gorilla/websocket?tab=doc)\n+* [Chat example](https://github.com/gorilla/websocket/tree/master/examples/chat)\n+* [Command example](https://github.com/gorilla/websocket/tree/master/examples/command)\n+* [Client and server example](https://github.com/gorilla/websocket/tree/master/examples/echo)\n+* [File watch example](https://github.com/gorilla/websocket/tree/master/examples/filewatch)\n+\n+### Status\n+\n+The Gorilla WebSocket package provides a complete and tested implementation of\n+the [WebSocket](http://www.rfc-editor.org/rfc/rfc6455.txt) protocol. The\n+package API is stable.\n+\n+### Installation\n+\n+    go get github.com/gorilla/websocket\n+\n+### Protocol Compliance\n+\n+The Gorilla WebSocket package passes the server tests in the [Autobahn Test\n+Suite](https://github.com/crossbario/autobahn-testsuite) using the application in the [examples/autobahn\n+subdirectory](https://github.com/gorilla/websocket/tree/master/examples/autobahn).\n+\n+### Gorilla WebSocket compared with other packages\n+\n+<table>\n+<tr>\n+<th></th>\n+<th><a href=\"http://godoc.org/github.com/gorilla/websocket\">github.com/gorilla</a></th>\n+<th><a href=\"http://godoc.org/golang.org/x/net/websocket\">golang.org/x/net</a></th>\n+</tr>\n+<tr>\n+<tr><td colspan=\"3\"><a href=\"http://tools.ietf.org/html/rfc6455\">RFC 6455</a> Features</td></tr>\n+<tr><td>Passes <a href=\"https://github.com/crossbario/autobahn-testsuite\">Autobahn Test Suite</a></td><td><a href=\"https://github.com/gorilla/websocket/tree/master/examples/autobahn\">Yes</a></td><td>No</td></tr>\n+<tr><td>Receive <a href=\"https://tools.ietf.org/html/rfc6455#section-5.4\">fragmented</a> message<td>Yes</td><td><a href=\"https://code.google.com/p/go/issues/detail?id=7632\">No</a>, see note 1</td></tr>\n+<tr><td>Send <a href=\"https://tools.ietf.org/html/rfc6455#section-5.5.1\">close</a> message</td><td><a href=\"http://godoc.org/github.com/gorilla/websocket#hdr-Control_Messages\">Yes</a></td><td><a href=\"https://code.google.com/p/go/issues/detail?id=4588\">No</a></td></tr>\n+<tr><td>Send <a href=\"https://tools.ietf.org/html/rfc6455#section-5.5.2\">pings</a> and receive <a href=\"https://tools.ietf.org/html/rfc6455#section-5.5.3\">pongs</a></td><td><a href=\"http://godoc.org/github.com/gorilla/websocket#hdr-Control_Messages\">Yes</a></td><td>No</td></tr>\n+<tr><td>Get the <a href=\"https://tools.ietf.org/html/rfc6455#section-5.6\">type</a> of a received data message</td><td>Yes</td><td>Yes, see note 2</td></tr>\n+<tr><td colspan=\"3\">Other Features</tr></td>\n+<tr><td><a href=\"https://tools.ietf.org/html/rfc7692\">Compression Extensions</a></td><td>Experimental</td><td>No</td></tr>\n+<tr><td>Read message using io.Reader</td><td><a href=\"http://godoc.org/github.com/gorilla/websocket#Conn.NextReader\">Yes</a></td><td>No, see note 3</td></tr>\n+<tr><td>Write message using io.WriteCloser</td><td><a href=\"http://godoc.org/github.com/gorilla/websocket#Conn.NextWriter\">Yes</a></td><td>No, see note 3</td></tr>\n+</table>\n+\n+Notes:\n+\n+1. Large messages are fragmented in [Chrome's new WebSocket implementation](http://www.ietf.org/mail-archive/web/hybi/current/msg10503.html).\n+2. The application can get the type of a received data message by implementing\n+   a [Codec marshal](http://godoc.org/golang.org/x/net/websocket#Codec.Marshal)\n+   function.\n+3. The go.net io.Reader and io.Writer operate across WebSocket frame boundaries.\n+  Read returns when the input buffer is full or a frame boundary is\n+  encountered. Each call to Write sends a single frame message. The Gorilla\n+  io.Reader and io.WriteCloser operate on a single WebSocket message.\n+"
    },
    {
      "sha": "962c06a391c237b6a7cdc6766e7cf5541b96bd8b",
      "filename": "backend/vendor/github.com/gorilla/websocket/client.go",
      "status": "added",
      "additions": 395,
      "deletions": 0,
      "changes": 395,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/client.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/client.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/client.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,395 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/http/httptrace\"\n+\t\"net/url\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// ErrBadHandshake is returned when the server response to opening handshake is\n+// invalid.\n+var ErrBadHandshake = errors.New(\"websocket: bad handshake\")\n+\n+var errInvalidCompression = errors.New(\"websocket: invalid compression negotiation\")\n+\n+// NewClient creates a new client connection using the given net connection.\n+// The URL u specifies the host and request URI. Use requestHeader to specify\n+// the origin (Origin), subprotocols (Sec-WebSocket-Protocol) and cookies\n+// (Cookie). Use the response.Header to get the selected subprotocol\n+// (Sec-WebSocket-Protocol) and cookies (Set-Cookie).\n+//\n+// If the WebSocket handshake fails, ErrBadHandshake is returned along with a\n+// non-nil *http.Response so that callers can handle redirects, authentication,\n+// etc.\n+//\n+// Deprecated: Use Dialer instead.\n+func NewClient(netConn net.Conn, u *url.URL, requestHeader http.Header, readBufSize, writeBufSize int) (c *Conn, response *http.Response, err error) {\n+\td := Dialer{\n+\t\tReadBufferSize:  readBufSize,\n+\t\tWriteBufferSize: writeBufSize,\n+\t\tNetDial: func(net, addr string) (net.Conn, error) {\n+\t\t\treturn netConn, nil\n+\t\t},\n+\t}\n+\treturn d.Dial(u.String(), requestHeader)\n+}\n+\n+// A Dialer contains options for connecting to WebSocket server.\n+type Dialer struct {\n+\t// NetDial specifies the dial function for creating TCP connections. If\n+\t// NetDial is nil, net.Dial is used.\n+\tNetDial func(network, addr string) (net.Conn, error)\n+\n+\t// NetDialContext specifies the dial function for creating TCP connections. If\n+\t// NetDialContext is nil, net.DialContext is used.\n+\tNetDialContext func(ctx context.Context, network, addr string) (net.Conn, error)\n+\n+\t// Proxy specifies a function to return a proxy for a given\n+\t// Request. If the function returns a non-nil error, the\n+\t// request is aborted with the provided error.\n+\t// If Proxy is nil or returns a nil *URL, no proxy is used.\n+\tProxy func(*http.Request) (*url.URL, error)\n+\n+\t// TLSClientConfig specifies the TLS configuration to use with tls.Client.\n+\t// If nil, the default configuration is used.\n+\tTLSClientConfig *tls.Config\n+\n+\t// HandshakeTimeout specifies the duration for the handshake to complete.\n+\tHandshakeTimeout time.Duration\n+\n+\t// ReadBufferSize and WriteBufferSize specify I/O buffer sizes in bytes. If a buffer\n+\t// size is zero, then a useful default size is used. The I/O buffer sizes\n+\t// do not limit the size of the messages that can be sent or received.\n+\tReadBufferSize, WriteBufferSize int\n+\n+\t// WriteBufferPool is a pool of buffers for write operations. If the value\n+\t// is not set, then write buffers are allocated to the connection for the\n+\t// lifetime of the connection.\n+\t//\n+\t// A pool is most useful when the application has a modest volume of writes\n+\t// across a large number of connections.\n+\t//\n+\t// Applications should use a single pool for each unique value of\n+\t// WriteBufferSize.\n+\tWriteBufferPool BufferPool\n+\n+\t// Subprotocols specifies the client's requested subprotocols.\n+\tSubprotocols []string\n+\n+\t// EnableCompression specifies if the client should attempt to negotiate\n+\t// per message compression (RFC 7692). Setting this value to true does not\n+\t// guarantee that compression will be supported. Currently only \"no context\n+\t// takeover\" modes are supported.\n+\tEnableCompression bool\n+\n+\t// Jar specifies the cookie jar.\n+\t// If Jar is nil, cookies are not sent in requests and ignored\n+\t// in responses.\n+\tJar http.CookieJar\n+}\n+\n+// Dial creates a new client connection by calling DialContext with a background context.\n+func (d *Dialer) Dial(urlStr string, requestHeader http.Header) (*Conn, *http.Response, error) {\n+\treturn d.DialContext(context.Background(), urlStr, requestHeader)\n+}\n+\n+var errMalformedURL = errors.New(\"malformed ws or wss URL\")\n+\n+func hostPortNoPort(u *url.URL) (hostPort, hostNoPort string) {\n+\thostPort = u.Host\n+\thostNoPort = u.Host\n+\tif i := strings.LastIndex(u.Host, \":\"); i > strings.LastIndex(u.Host, \"]\") {\n+\t\thostNoPort = hostNoPort[:i]\n+\t} else {\n+\t\tswitch u.Scheme {\n+\t\tcase \"wss\":\n+\t\t\thostPort += \":443\"\n+\t\tcase \"https\":\n+\t\t\thostPort += \":443\"\n+\t\tdefault:\n+\t\t\thostPort += \":80\"\n+\t\t}\n+\t}\n+\treturn hostPort, hostNoPort\n+}\n+\n+// DefaultDialer is a dialer with all fields set to the default values.\n+var DefaultDialer = &Dialer{\n+\tProxy:            http.ProxyFromEnvironment,\n+\tHandshakeTimeout: 45 * time.Second,\n+}\n+\n+// nilDialer is dialer to use when receiver is nil.\n+var nilDialer = *DefaultDialer\n+\n+// DialContext creates a new client connection. Use requestHeader to specify the\n+// origin (Origin), subprotocols (Sec-WebSocket-Protocol) and cookies (Cookie).\n+// Use the response.Header to get the selected subprotocol\n+// (Sec-WebSocket-Protocol) and cookies (Set-Cookie).\n+//\n+// The context will be used in the request and in the Dialer.\n+//\n+// If the WebSocket handshake fails, ErrBadHandshake is returned along with a\n+// non-nil *http.Response so that callers can handle redirects, authentication,\n+// etcetera. The response body may not contain the entire response and does not\n+// need to be closed by the application.\n+func (d *Dialer) DialContext(ctx context.Context, urlStr string, requestHeader http.Header) (*Conn, *http.Response, error) {\n+\tif d == nil {\n+\t\td = &nilDialer\n+\t}\n+\n+\tchallengeKey, err := generateChallengeKey()\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tu, err := url.Parse(urlStr)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tswitch u.Scheme {\n+\tcase \"ws\":\n+\t\tu.Scheme = \"http\"\n+\tcase \"wss\":\n+\t\tu.Scheme = \"https\"\n+\tdefault:\n+\t\treturn nil, nil, errMalformedURL\n+\t}\n+\n+\tif u.User != nil {\n+\t\t// User name and password are not allowed in websocket URIs.\n+\t\treturn nil, nil, errMalformedURL\n+\t}\n+\n+\treq := &http.Request{\n+\t\tMethod:     \"GET\",\n+\t\tURL:        u,\n+\t\tProto:      \"HTTP/1.1\",\n+\t\tProtoMajor: 1,\n+\t\tProtoMinor: 1,\n+\t\tHeader:     make(http.Header),\n+\t\tHost:       u.Host,\n+\t}\n+\treq = req.WithContext(ctx)\n+\n+\t// Set the cookies present in the cookie jar of the dialer\n+\tif d.Jar != nil {\n+\t\tfor _, cookie := range d.Jar.Cookies(u) {\n+\t\t\treq.AddCookie(cookie)\n+\t\t}\n+\t}\n+\n+\t// Set the request headers using the capitalization for names and values in\n+\t// RFC examples. Although the capitalization shouldn't matter, there are\n+\t// servers that depend on it. The Header.Set method is not used because the\n+\t// method canonicalizes the header names.\n+\treq.Header[\"Upgrade\"] = []string{\"websocket\"}\n+\treq.Header[\"Connection\"] = []string{\"Upgrade\"}\n+\treq.Header[\"Sec-WebSocket-Key\"] = []string{challengeKey}\n+\treq.Header[\"Sec-WebSocket-Version\"] = []string{\"13\"}\n+\tif len(d.Subprotocols) > 0 {\n+\t\treq.Header[\"Sec-WebSocket-Protocol\"] = []string{strings.Join(d.Subprotocols, \", \")}\n+\t}\n+\tfor k, vs := range requestHeader {\n+\t\tswitch {\n+\t\tcase k == \"Host\":\n+\t\t\tif len(vs) > 0 {\n+\t\t\t\treq.Host = vs[0]\n+\t\t\t}\n+\t\tcase k == \"Upgrade\" ||\n+\t\t\tk == \"Connection\" ||\n+\t\t\tk == \"Sec-Websocket-Key\" ||\n+\t\t\tk == \"Sec-Websocket-Version\" ||\n+\t\t\tk == \"Sec-Websocket-Extensions\" ||\n+\t\t\t(k == \"Sec-Websocket-Protocol\" && len(d.Subprotocols) > 0):\n+\t\t\treturn nil, nil, errors.New(\"websocket: duplicate header not allowed: \" + k)\n+\t\tcase k == \"Sec-Websocket-Protocol\":\n+\t\t\treq.Header[\"Sec-WebSocket-Protocol\"] = vs\n+\t\tdefault:\n+\t\t\treq.Header[k] = vs\n+\t\t}\n+\t}\n+\n+\tif d.EnableCompression {\n+\t\treq.Header[\"Sec-WebSocket-Extensions\"] = []string{\"permessage-deflate; server_no_context_takeover; client_no_context_takeover\"}\n+\t}\n+\n+\tif d.HandshakeTimeout != 0 {\n+\t\tvar cancel func()\n+\t\tctx, cancel = context.WithTimeout(ctx, d.HandshakeTimeout)\n+\t\tdefer cancel()\n+\t}\n+\n+\t// Get network dial function.\n+\tvar netDial func(network, add string) (net.Conn, error)\n+\n+\tif d.NetDialContext != nil {\n+\t\tnetDial = func(network, addr string) (net.Conn, error) {\n+\t\t\treturn d.NetDialContext(ctx, network, addr)\n+\t\t}\n+\t} else if d.NetDial != nil {\n+\t\tnetDial = d.NetDial\n+\t} else {\n+\t\tnetDialer := &net.Dialer{}\n+\t\tnetDial = func(network, addr string) (net.Conn, error) {\n+\t\t\treturn netDialer.DialContext(ctx, network, addr)\n+\t\t}\n+\t}\n+\n+\t// If needed, wrap the dial function to set the connection deadline.\n+\tif deadline, ok := ctx.Deadline(); ok {\n+\t\tforwardDial := netDial\n+\t\tnetDial = func(network, addr string) (net.Conn, error) {\n+\t\t\tc, err := forwardDial(network, addr)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\terr = c.SetDeadline(deadline)\n+\t\t\tif err != nil {\n+\t\t\t\tc.Close()\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\treturn c, nil\n+\t\t}\n+\t}\n+\n+\t// If needed, wrap the dial function to connect through a proxy.\n+\tif d.Proxy != nil {\n+\t\tproxyURL, err := d.Proxy(req)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tif proxyURL != nil {\n+\t\t\tdialer, err := proxy_FromURL(proxyURL, netDialerFunc(netDial))\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\t\t\tnetDial = dialer.Dial\n+\t\t}\n+\t}\n+\n+\thostPort, hostNoPort := hostPortNoPort(u)\n+\ttrace := httptrace.ContextClientTrace(ctx)\n+\tif trace != nil && trace.GetConn != nil {\n+\t\ttrace.GetConn(hostPort)\n+\t}\n+\n+\tnetConn, err := netDial(\"tcp\", hostPort)\n+\tif trace != nil && trace.GotConn != nil {\n+\t\ttrace.GotConn(httptrace.GotConnInfo{\n+\t\t\tConn: netConn,\n+\t\t})\n+\t}\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tdefer func() {\n+\t\tif netConn != nil {\n+\t\t\tnetConn.Close()\n+\t\t}\n+\t}()\n+\n+\tif u.Scheme == \"https\" {\n+\t\tcfg := cloneTLSConfig(d.TLSClientConfig)\n+\t\tif cfg.ServerName == \"\" {\n+\t\t\tcfg.ServerName = hostNoPort\n+\t\t}\n+\t\ttlsConn := tls.Client(netConn, cfg)\n+\t\tnetConn = tlsConn\n+\n+\t\tvar err error\n+\t\tif trace != nil {\n+\t\t\terr = doHandshakeWithTrace(trace, tlsConn, cfg)\n+\t\t} else {\n+\t\t\terr = doHandshake(tlsConn, cfg)\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t}\n+\n+\tconn := newConn(netConn, false, d.ReadBufferSize, d.WriteBufferSize, d.WriteBufferPool, nil, nil)\n+\n+\tif err := req.Write(netConn); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tif trace != nil && trace.GotFirstResponseByte != nil {\n+\t\tif peek, err := conn.br.Peek(1); err == nil && len(peek) == 1 {\n+\t\t\ttrace.GotFirstResponseByte()\n+\t\t}\n+\t}\n+\n+\tresp, err := http.ReadResponse(conn.br, req)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tif d.Jar != nil {\n+\t\tif rc := resp.Cookies(); len(rc) > 0 {\n+\t\t\td.Jar.SetCookies(u, rc)\n+\t\t}\n+\t}\n+\n+\tif resp.StatusCode != 101 ||\n+\t\t!strings.EqualFold(resp.Header.Get(\"Upgrade\"), \"websocket\") ||\n+\t\t!strings.EqualFold(resp.Header.Get(\"Connection\"), \"upgrade\") ||\n+\t\tresp.Header.Get(\"Sec-Websocket-Accept\") != computeAcceptKey(challengeKey) {\n+\t\t// Before closing the network connection on return from this\n+\t\t// function, slurp up some of the response to aid application\n+\t\t// debugging.\n+\t\tbuf := make([]byte, 1024)\n+\t\tn, _ := io.ReadFull(resp.Body, buf)\n+\t\tresp.Body = ioutil.NopCloser(bytes.NewReader(buf[:n]))\n+\t\treturn nil, resp, ErrBadHandshake\n+\t}\n+\n+\tfor _, ext := range parseExtensions(resp.Header) {\n+\t\tif ext[\"\"] != \"permessage-deflate\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\t_, snct := ext[\"server_no_context_takeover\"]\n+\t\t_, cnct := ext[\"client_no_context_takeover\"]\n+\t\tif !snct || !cnct {\n+\t\t\treturn nil, resp, errInvalidCompression\n+\t\t}\n+\t\tconn.newCompressionWriter = compressNoContextTakeover\n+\t\tconn.newDecompressionReader = decompressNoContextTakeover\n+\t\tbreak\n+\t}\n+\n+\tresp.Body = ioutil.NopCloser(bytes.NewReader([]byte{}))\n+\tconn.subprotocol = resp.Header.Get(\"Sec-Websocket-Protocol\")\n+\n+\tnetConn.SetDeadline(time.Time{})\n+\tnetConn = nil // to avoid close in defer.\n+\treturn conn, resp, nil\n+}\n+\n+func doHandshake(tlsConn *tls.Conn, cfg *tls.Config) error {\n+\tif err := tlsConn.Handshake(); err != nil {\n+\t\treturn err\n+\t}\n+\tif !cfg.InsecureSkipVerify {\n+\t\tif err := tlsConn.VerifyHostname(cfg.ServerName); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}"
    },
    {
      "sha": "4f0d943723a9d094c1693892812377a51f6791bb",
      "filename": "backend/vendor/github.com/gorilla/websocket/client_clone.go",
      "status": "added",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/client_clone.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/client_clone.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/client_clone.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build go1.8\n+\n+package websocket\n+\n+import \"crypto/tls\"\n+\n+func cloneTLSConfig(cfg *tls.Config) *tls.Config {\n+\tif cfg == nil {\n+\t\treturn &tls.Config{}\n+\t}\n+\treturn cfg.Clone()\n+}"
    },
    {
      "sha": "babb007fb4144ac456faeb685e24b62186c7c517",
      "filename": "backend/vendor/github.com/gorilla/websocket/client_clone_legacy.go",
      "status": "added",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/client_clone_legacy.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/client_clone_legacy.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/client_clone_legacy.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !go1.8\n+\n+package websocket\n+\n+import \"crypto/tls\"\n+\n+// cloneTLSConfig clones all public fields except the fields\n+// SessionTicketsDisabled and SessionTicketKey. This avoids copying the\n+// sync.Mutex in the sync.Once and makes it safe to call cloneTLSConfig on a\n+// config in active use.\n+func cloneTLSConfig(cfg *tls.Config) *tls.Config {\n+\tif cfg == nil {\n+\t\treturn &tls.Config{}\n+\t}\n+\treturn &tls.Config{\n+\t\tRand:                     cfg.Rand,\n+\t\tTime:                     cfg.Time,\n+\t\tCertificates:             cfg.Certificates,\n+\t\tNameToCertificate:        cfg.NameToCertificate,\n+\t\tGetCertificate:           cfg.GetCertificate,\n+\t\tRootCAs:                  cfg.RootCAs,\n+\t\tNextProtos:               cfg.NextProtos,\n+\t\tServerName:               cfg.ServerName,\n+\t\tClientAuth:               cfg.ClientAuth,\n+\t\tClientCAs:                cfg.ClientCAs,\n+\t\tInsecureSkipVerify:       cfg.InsecureSkipVerify,\n+\t\tCipherSuites:             cfg.CipherSuites,\n+\t\tPreferServerCipherSuites: cfg.PreferServerCipherSuites,\n+\t\tClientSessionCache:       cfg.ClientSessionCache,\n+\t\tMinVersion:               cfg.MinVersion,\n+\t\tMaxVersion:               cfg.MaxVersion,\n+\t\tCurvePreferences:         cfg.CurvePreferences,\n+\t}\n+}"
    },
    {
      "sha": "813ffb1e84336da415256244366e09bcd65b6765",
      "filename": "backend/vendor/github.com/gorilla/websocket/compression.go",
      "status": "added",
      "additions": 148,
      "deletions": 0,
      "changes": 148,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/compression.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/compression.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/compression.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2017 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"compress/flate\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+const (\n+\tminCompressionLevel     = -2 // flate.HuffmanOnly not defined in Go < 1.6\n+\tmaxCompressionLevel     = flate.BestCompression\n+\tdefaultCompressionLevel = 1\n+)\n+\n+var (\n+\tflateWriterPools [maxCompressionLevel - minCompressionLevel + 1]sync.Pool\n+\tflateReaderPool  = sync.Pool{New: func() interface{} {\n+\t\treturn flate.NewReader(nil)\n+\t}}\n+)\n+\n+func decompressNoContextTakeover(r io.Reader) io.ReadCloser {\n+\tconst tail =\n+\t// Add four bytes as specified in RFC\n+\t\"\\x00\\x00\\xff\\xff\" +\n+\t\t// Add final block to squelch unexpected EOF error from flate reader.\n+\t\t\"\\x01\\x00\\x00\\xff\\xff\"\n+\n+\tfr, _ := flateReaderPool.Get().(io.ReadCloser)\n+\tfr.(flate.Resetter).Reset(io.MultiReader(r, strings.NewReader(tail)), nil)\n+\treturn &flateReadWrapper{fr}\n+}\n+\n+func isValidCompressionLevel(level int) bool {\n+\treturn minCompressionLevel <= level && level <= maxCompressionLevel\n+}\n+\n+func compressNoContextTakeover(w io.WriteCloser, level int) io.WriteCloser {\n+\tp := &flateWriterPools[level-minCompressionLevel]\n+\ttw := &truncWriter{w: w}\n+\tfw, _ := p.Get().(*flate.Writer)\n+\tif fw == nil {\n+\t\tfw, _ = flate.NewWriter(tw, level)\n+\t} else {\n+\t\tfw.Reset(tw)\n+\t}\n+\treturn &flateWriteWrapper{fw: fw, tw: tw, p: p}\n+}\n+\n+// truncWriter is an io.Writer that writes all but the last four bytes of the\n+// stream to another io.Writer.\n+type truncWriter struct {\n+\tw io.WriteCloser\n+\tn int\n+\tp [4]byte\n+}\n+\n+func (w *truncWriter) Write(p []byte) (int, error) {\n+\tn := 0\n+\n+\t// fill buffer first for simplicity.\n+\tif w.n < len(w.p) {\n+\t\tn = copy(w.p[w.n:], p)\n+\t\tp = p[n:]\n+\t\tw.n += n\n+\t\tif len(p) == 0 {\n+\t\t\treturn n, nil\n+\t\t}\n+\t}\n+\n+\tm := len(p)\n+\tif m > len(w.p) {\n+\t\tm = len(w.p)\n+\t}\n+\n+\tif nn, err := w.w.Write(w.p[:m]); err != nil {\n+\t\treturn n + nn, err\n+\t}\n+\n+\tcopy(w.p[:], w.p[m:])\n+\tcopy(w.p[len(w.p)-m:], p[len(p)-m:])\n+\tnn, err := w.w.Write(p[:len(p)-m])\n+\treturn n + nn, err\n+}\n+\n+type flateWriteWrapper struct {\n+\tfw *flate.Writer\n+\ttw *truncWriter\n+\tp  *sync.Pool\n+}\n+\n+func (w *flateWriteWrapper) Write(p []byte) (int, error) {\n+\tif w.fw == nil {\n+\t\treturn 0, errWriteClosed\n+\t}\n+\treturn w.fw.Write(p)\n+}\n+\n+func (w *flateWriteWrapper) Close() error {\n+\tif w.fw == nil {\n+\t\treturn errWriteClosed\n+\t}\n+\terr1 := w.fw.Flush()\n+\tw.p.Put(w.fw)\n+\tw.fw = nil\n+\tif w.tw.p != [4]byte{0, 0, 0xff, 0xff} {\n+\t\treturn errors.New(\"websocket: internal error, unexpected bytes at end of flate stream\")\n+\t}\n+\terr2 := w.tw.w.Close()\n+\tif err1 != nil {\n+\t\treturn err1\n+\t}\n+\treturn err2\n+}\n+\n+type flateReadWrapper struct {\n+\tfr io.ReadCloser\n+}\n+\n+func (r *flateReadWrapper) Read(p []byte) (int, error) {\n+\tif r.fr == nil {\n+\t\treturn 0, io.ErrClosedPipe\n+\t}\n+\tn, err := r.fr.Read(p)\n+\tif err == io.EOF {\n+\t\t// Preemptively place the reader back in the pool. This helps with\n+\t\t// scenarios where the application does not call NextReader() soon after\n+\t\t// this final read.\n+\t\tr.Close()\n+\t}\n+\treturn n, err\n+}\n+\n+func (r *flateReadWrapper) Close() error {\n+\tif r.fr == nil {\n+\t\treturn io.ErrClosedPipe\n+\t}\n+\terr := r.fr.Close()\n+\tflateReaderPool.Put(r.fr)\n+\tr.fr = nil\n+\treturn err\n+}"
    },
    {
      "sha": "ca46d2f793c24eb7593d6ee6ba834d4f437c53da",
      "filename": "backend/vendor/github.com/gorilla/websocket/conn.go",
      "status": "added",
      "additions": 1201,
      "deletions": 0,
      "changes": 1201,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/conn.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/conn.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/conn.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,1201 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"bufio\"\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"math/rand\"\n+\t\"net\"\n+\t\"strconv\"\n+\t\"sync\"\n+\t\"time\"\n+\t\"unicode/utf8\"\n+)\n+\n+const (\n+\t// Frame header byte 0 bits from Section 5.2 of RFC 6455\n+\tfinalBit = 1 << 7\n+\trsv1Bit  = 1 << 6\n+\trsv2Bit  = 1 << 5\n+\trsv3Bit  = 1 << 4\n+\n+\t// Frame header byte 1 bits from Section 5.2 of RFC 6455\n+\tmaskBit = 1 << 7\n+\n+\tmaxFrameHeaderSize         = 2 + 8 + 4 // Fixed header + length + mask\n+\tmaxControlFramePayloadSize = 125\n+\n+\twriteWait = time.Second\n+\n+\tdefaultReadBufferSize  = 4096\n+\tdefaultWriteBufferSize = 4096\n+\n+\tcontinuationFrame = 0\n+\tnoFrame           = -1\n+)\n+\n+// Close codes defined in RFC 6455, section 11.7.\n+const (\n+\tCloseNormalClosure           = 1000\n+\tCloseGoingAway               = 1001\n+\tCloseProtocolError           = 1002\n+\tCloseUnsupportedData         = 1003\n+\tCloseNoStatusReceived        = 1005\n+\tCloseAbnormalClosure         = 1006\n+\tCloseInvalidFramePayloadData = 1007\n+\tClosePolicyViolation         = 1008\n+\tCloseMessageTooBig           = 1009\n+\tCloseMandatoryExtension      = 1010\n+\tCloseInternalServerErr       = 1011\n+\tCloseServiceRestart          = 1012\n+\tCloseTryAgainLater           = 1013\n+\tCloseTLSHandshake            = 1015\n+)\n+\n+// The message types are defined in RFC 6455, section 11.8.\n+const (\n+\t// TextMessage denotes a text data message. The text message payload is\n+\t// interpreted as UTF-8 encoded text data.\n+\tTextMessage = 1\n+\n+\t// BinaryMessage denotes a binary data message.\n+\tBinaryMessage = 2\n+\n+\t// CloseMessage denotes a close control message. The optional message\n+\t// payload contains a numeric code and text. Use the FormatCloseMessage\n+\t// function to format a close message payload.\n+\tCloseMessage = 8\n+\n+\t// PingMessage denotes a ping control message. The optional message payload\n+\t// is UTF-8 encoded text.\n+\tPingMessage = 9\n+\n+\t// PongMessage denotes a pong control message. The optional message payload\n+\t// is UTF-8 encoded text.\n+\tPongMessage = 10\n+)\n+\n+// ErrCloseSent is returned when the application writes a message to the\n+// connection after sending a close message.\n+var ErrCloseSent = errors.New(\"websocket: close sent\")\n+\n+// ErrReadLimit is returned when reading a message that is larger than the\n+// read limit set for the connection.\n+var ErrReadLimit = errors.New(\"websocket: read limit exceeded\")\n+\n+// netError satisfies the net Error interface.\n+type netError struct {\n+\tmsg       string\n+\ttemporary bool\n+\ttimeout   bool\n+}\n+\n+func (e *netError) Error() string   { return e.msg }\n+func (e *netError) Temporary() bool { return e.temporary }\n+func (e *netError) Timeout() bool   { return e.timeout }\n+\n+// CloseError represents a close message.\n+type CloseError struct {\n+\t// Code is defined in RFC 6455, section 11.7.\n+\tCode int\n+\n+\t// Text is the optional text payload.\n+\tText string\n+}\n+\n+func (e *CloseError) Error() string {\n+\ts := []byte(\"websocket: close \")\n+\ts = strconv.AppendInt(s, int64(e.Code), 10)\n+\tswitch e.Code {\n+\tcase CloseNormalClosure:\n+\t\ts = append(s, \" (normal)\"...)\n+\tcase CloseGoingAway:\n+\t\ts = append(s, \" (going away)\"...)\n+\tcase CloseProtocolError:\n+\t\ts = append(s, \" (protocol error)\"...)\n+\tcase CloseUnsupportedData:\n+\t\ts = append(s, \" (unsupported data)\"...)\n+\tcase CloseNoStatusReceived:\n+\t\ts = append(s, \" (no status)\"...)\n+\tcase CloseAbnormalClosure:\n+\t\ts = append(s, \" (abnormal closure)\"...)\n+\tcase CloseInvalidFramePayloadData:\n+\t\ts = append(s, \" (invalid payload data)\"...)\n+\tcase ClosePolicyViolation:\n+\t\ts = append(s, \" (policy violation)\"...)\n+\tcase CloseMessageTooBig:\n+\t\ts = append(s, \" (message too big)\"...)\n+\tcase CloseMandatoryExtension:\n+\t\ts = append(s, \" (mandatory extension missing)\"...)\n+\tcase CloseInternalServerErr:\n+\t\ts = append(s, \" (internal server error)\"...)\n+\tcase CloseTLSHandshake:\n+\t\ts = append(s, \" (TLS handshake error)\"...)\n+\t}\n+\tif e.Text != \"\" {\n+\t\ts = append(s, \": \"...)\n+\t\ts = append(s, e.Text...)\n+\t}\n+\treturn string(s)\n+}\n+\n+// IsCloseError returns boolean indicating whether the error is a *CloseError\n+// with one of the specified codes.\n+func IsCloseError(err error, codes ...int) bool {\n+\tif e, ok := err.(*CloseError); ok {\n+\t\tfor _, code := range codes {\n+\t\t\tif e.Code == code {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// IsUnexpectedCloseError returns boolean indicating whether the error is a\n+// *CloseError with a code not in the list of expected codes.\n+func IsUnexpectedCloseError(err error, expectedCodes ...int) bool {\n+\tif e, ok := err.(*CloseError); ok {\n+\t\tfor _, code := range expectedCodes {\n+\t\t\tif e.Code == code {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t}\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+var (\n+\terrWriteTimeout        = &netError{msg: \"websocket: write timeout\", timeout: true, temporary: true}\n+\terrUnexpectedEOF       = &CloseError{Code: CloseAbnormalClosure, Text: io.ErrUnexpectedEOF.Error()}\n+\terrBadWriteOpCode      = errors.New(\"websocket: bad write message type\")\n+\terrWriteClosed         = errors.New(\"websocket: write closed\")\n+\terrInvalidControlFrame = errors.New(\"websocket: invalid control frame\")\n+)\n+\n+func newMaskKey() [4]byte {\n+\tn := rand.Uint32()\n+\treturn [4]byte{byte(n), byte(n >> 8), byte(n >> 16), byte(n >> 24)}\n+}\n+\n+func hideTempErr(err error) error {\n+\tif e, ok := err.(net.Error); ok && e.Temporary() {\n+\t\terr = &netError{msg: e.Error(), timeout: e.Timeout()}\n+\t}\n+\treturn err\n+}\n+\n+func isControl(frameType int) bool {\n+\treturn frameType == CloseMessage || frameType == PingMessage || frameType == PongMessage\n+}\n+\n+func isData(frameType int) bool {\n+\treturn frameType == TextMessage || frameType == BinaryMessage\n+}\n+\n+var validReceivedCloseCodes = map[int]bool{\n+\t// see http://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number\n+\n+\tCloseNormalClosure:           true,\n+\tCloseGoingAway:               true,\n+\tCloseProtocolError:           true,\n+\tCloseUnsupportedData:         true,\n+\tCloseNoStatusReceived:        false,\n+\tCloseAbnormalClosure:         false,\n+\tCloseInvalidFramePayloadData: true,\n+\tClosePolicyViolation:         true,\n+\tCloseMessageTooBig:           true,\n+\tCloseMandatoryExtension:      true,\n+\tCloseInternalServerErr:       true,\n+\tCloseServiceRestart:          true,\n+\tCloseTryAgainLater:           true,\n+\tCloseTLSHandshake:            false,\n+}\n+\n+func isValidReceivedCloseCode(code int) bool {\n+\treturn validReceivedCloseCodes[code] || (code >= 3000 && code <= 4999)\n+}\n+\n+// BufferPool represents a pool of buffers. The *sync.Pool type satisfies this\n+// interface.  The type of the value stored in a pool is not specified.\n+type BufferPool interface {\n+\t// Get gets a value from the pool or returns nil if the pool is empty.\n+\tGet() interface{}\n+\t// Put adds a value to the pool.\n+\tPut(interface{})\n+}\n+\n+// writePoolData is the type added to the write buffer pool. This wrapper is\n+// used to prevent applications from peeking at and depending on the values\n+// added to the pool.\n+type writePoolData struct{ buf []byte }\n+\n+// The Conn type represents a WebSocket connection.\n+type Conn struct {\n+\tconn        net.Conn\n+\tisServer    bool\n+\tsubprotocol string\n+\n+\t// Write fields\n+\tmu            chan struct{} // used as mutex to protect write to conn\n+\twriteBuf      []byte        // frame is constructed in this buffer.\n+\twritePool     BufferPool\n+\twriteBufSize  int\n+\twriteDeadline time.Time\n+\twriter        io.WriteCloser // the current writer returned to the application\n+\tisWriting     bool           // for best-effort concurrent write detection\n+\n+\twriteErrMu sync.Mutex\n+\twriteErr   error\n+\n+\tenableWriteCompression bool\n+\tcompressionLevel       int\n+\tnewCompressionWriter   func(io.WriteCloser, int) io.WriteCloser\n+\n+\t// Read fields\n+\treader  io.ReadCloser // the current reader returned to the application\n+\treadErr error\n+\tbr      *bufio.Reader\n+\t// bytes remaining in current frame.\n+\t// set setReadRemaining to safely update this value and prevent overflow\n+\treadRemaining int64\n+\treadFinal     bool  // true the current message has more frames.\n+\treadLength    int64 // Message size.\n+\treadLimit     int64 // Maximum message size.\n+\treadMaskPos   int\n+\treadMaskKey   [4]byte\n+\thandlePong    func(string) error\n+\thandlePing    func(string) error\n+\thandleClose   func(int, string) error\n+\treadErrCount  int\n+\tmessageReader *messageReader // the current low-level reader\n+\n+\treadDecompress         bool // whether last read frame had RSV1 set\n+\tnewDecompressionReader func(io.Reader) io.ReadCloser\n+}\n+\n+func newConn(conn net.Conn, isServer bool, readBufferSize, writeBufferSize int, writeBufferPool BufferPool, br *bufio.Reader, writeBuf []byte) *Conn {\n+\n+\tif br == nil {\n+\t\tif readBufferSize == 0 {\n+\t\t\treadBufferSize = defaultReadBufferSize\n+\t\t} else if readBufferSize < maxControlFramePayloadSize {\n+\t\t\t// must be large enough for control frame\n+\t\t\treadBufferSize = maxControlFramePayloadSize\n+\t\t}\n+\t\tbr = bufio.NewReaderSize(conn, readBufferSize)\n+\t}\n+\n+\tif writeBufferSize <= 0 {\n+\t\twriteBufferSize = defaultWriteBufferSize\n+\t}\n+\twriteBufferSize += maxFrameHeaderSize\n+\n+\tif writeBuf == nil && writeBufferPool == nil {\n+\t\twriteBuf = make([]byte, writeBufferSize)\n+\t}\n+\n+\tmu := make(chan struct{}, 1)\n+\tmu <- struct{}{}\n+\tc := &Conn{\n+\t\tisServer:               isServer,\n+\t\tbr:                     br,\n+\t\tconn:                   conn,\n+\t\tmu:                     mu,\n+\t\treadFinal:              true,\n+\t\twriteBuf:               writeBuf,\n+\t\twritePool:              writeBufferPool,\n+\t\twriteBufSize:           writeBufferSize,\n+\t\tenableWriteCompression: true,\n+\t\tcompressionLevel:       defaultCompressionLevel,\n+\t}\n+\tc.SetCloseHandler(nil)\n+\tc.SetPingHandler(nil)\n+\tc.SetPongHandler(nil)\n+\treturn c\n+}\n+\n+// setReadRemaining tracks the number of bytes remaining on the connection. If n\n+// overflows, an ErrReadLimit is returned.\n+func (c *Conn) setReadRemaining(n int64) error {\n+\tif n < 0 {\n+\t\treturn ErrReadLimit\n+\t}\n+\n+\tc.readRemaining = n\n+\treturn nil\n+}\n+\n+// Subprotocol returns the negotiated protocol for the connection.\n+func (c *Conn) Subprotocol() string {\n+\treturn c.subprotocol\n+}\n+\n+// Close closes the underlying network connection without sending or waiting\n+// for a close message.\n+func (c *Conn) Close() error {\n+\treturn c.conn.Close()\n+}\n+\n+// LocalAddr returns the local network address.\n+func (c *Conn) LocalAddr() net.Addr {\n+\treturn c.conn.LocalAddr()\n+}\n+\n+// RemoteAddr returns the remote network address.\n+func (c *Conn) RemoteAddr() net.Addr {\n+\treturn c.conn.RemoteAddr()\n+}\n+\n+// Write methods\n+\n+func (c *Conn) writeFatal(err error) error {\n+\terr = hideTempErr(err)\n+\tc.writeErrMu.Lock()\n+\tif c.writeErr == nil {\n+\t\tc.writeErr = err\n+\t}\n+\tc.writeErrMu.Unlock()\n+\treturn err\n+}\n+\n+func (c *Conn) read(n int) ([]byte, error) {\n+\tp, err := c.br.Peek(n)\n+\tif err == io.EOF {\n+\t\terr = errUnexpectedEOF\n+\t}\n+\tc.br.Discard(len(p))\n+\treturn p, err\n+}\n+\n+func (c *Conn) write(frameType int, deadline time.Time, buf0, buf1 []byte) error {\n+\t<-c.mu\n+\tdefer func() { c.mu <- struct{}{} }()\n+\n+\tc.writeErrMu.Lock()\n+\terr := c.writeErr\n+\tc.writeErrMu.Unlock()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tc.conn.SetWriteDeadline(deadline)\n+\tif len(buf1) == 0 {\n+\t\t_, err = c.conn.Write(buf0)\n+\t} else {\n+\t\terr = c.writeBufs(buf0, buf1)\n+\t}\n+\tif err != nil {\n+\t\treturn c.writeFatal(err)\n+\t}\n+\tif frameType == CloseMessage {\n+\t\tc.writeFatal(ErrCloseSent)\n+\t}\n+\treturn nil\n+}\n+\n+// WriteControl writes a control message with the given deadline. The allowed\n+// message types are CloseMessage, PingMessage and PongMessage.\n+func (c *Conn) WriteControl(messageType int, data []byte, deadline time.Time) error {\n+\tif !isControl(messageType) {\n+\t\treturn errBadWriteOpCode\n+\t}\n+\tif len(data) > maxControlFramePayloadSize {\n+\t\treturn errInvalidControlFrame\n+\t}\n+\n+\tb0 := byte(messageType) | finalBit\n+\tb1 := byte(len(data))\n+\tif !c.isServer {\n+\t\tb1 |= maskBit\n+\t}\n+\n+\tbuf := make([]byte, 0, maxFrameHeaderSize+maxControlFramePayloadSize)\n+\tbuf = append(buf, b0, b1)\n+\n+\tif c.isServer {\n+\t\tbuf = append(buf, data...)\n+\t} else {\n+\t\tkey := newMaskKey()\n+\t\tbuf = append(buf, key[:]...)\n+\t\tbuf = append(buf, data...)\n+\t\tmaskBytes(key, 0, buf[6:])\n+\t}\n+\n+\td := 1000 * time.Hour\n+\tif !deadline.IsZero() {\n+\t\td = deadline.Sub(time.Now())\n+\t\tif d < 0 {\n+\t\t\treturn errWriteTimeout\n+\t\t}\n+\t}\n+\n+\ttimer := time.NewTimer(d)\n+\tselect {\n+\tcase <-c.mu:\n+\t\ttimer.Stop()\n+\tcase <-timer.C:\n+\t\treturn errWriteTimeout\n+\t}\n+\tdefer func() { c.mu <- struct{}{} }()\n+\n+\tc.writeErrMu.Lock()\n+\terr := c.writeErr\n+\tc.writeErrMu.Unlock()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tc.conn.SetWriteDeadline(deadline)\n+\t_, err = c.conn.Write(buf)\n+\tif err != nil {\n+\t\treturn c.writeFatal(err)\n+\t}\n+\tif messageType == CloseMessage {\n+\t\tc.writeFatal(ErrCloseSent)\n+\t}\n+\treturn err\n+}\n+\n+// beginMessage prepares a connection and message writer for a new message.\n+func (c *Conn) beginMessage(mw *messageWriter, messageType int) error {\n+\t// Close previous writer if not already closed by the application. It's\n+\t// probably better to return an error in this situation, but we cannot\n+\t// change this without breaking existing applications.\n+\tif c.writer != nil {\n+\t\tc.writer.Close()\n+\t\tc.writer = nil\n+\t}\n+\n+\tif !isControl(messageType) && !isData(messageType) {\n+\t\treturn errBadWriteOpCode\n+\t}\n+\n+\tc.writeErrMu.Lock()\n+\terr := c.writeErr\n+\tc.writeErrMu.Unlock()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tmw.c = c\n+\tmw.frameType = messageType\n+\tmw.pos = maxFrameHeaderSize\n+\n+\tif c.writeBuf == nil {\n+\t\twpd, ok := c.writePool.Get().(writePoolData)\n+\t\tif ok {\n+\t\t\tc.writeBuf = wpd.buf\n+\t\t} else {\n+\t\t\tc.writeBuf = make([]byte, c.writeBufSize)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// NextWriter returns a writer for the next message to send. The writer's Close\n+// method flushes the complete message to the network.\n+//\n+// There can be at most one open writer on a connection. NextWriter closes the\n+// previous writer if the application has not already done so.\n+//\n+// All message types (TextMessage, BinaryMessage, CloseMessage, PingMessage and\n+// PongMessage) are supported.\n+func (c *Conn) NextWriter(messageType int) (io.WriteCloser, error) {\n+\tvar mw messageWriter\n+\tif err := c.beginMessage(&mw, messageType); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tc.writer = &mw\n+\tif c.newCompressionWriter != nil && c.enableWriteCompression && isData(messageType) {\n+\t\tw := c.newCompressionWriter(c.writer, c.compressionLevel)\n+\t\tmw.compress = true\n+\t\tc.writer = w\n+\t}\n+\treturn c.writer, nil\n+}\n+\n+type messageWriter struct {\n+\tc         *Conn\n+\tcompress  bool // whether next call to flushFrame should set RSV1\n+\tpos       int  // end of data in writeBuf.\n+\tframeType int  // type of the current frame.\n+\terr       error\n+}\n+\n+func (w *messageWriter) endMessage(err error) error {\n+\tif w.err != nil {\n+\t\treturn err\n+\t}\n+\tc := w.c\n+\tw.err = err\n+\tc.writer = nil\n+\tif c.writePool != nil {\n+\t\tc.writePool.Put(writePoolData{buf: c.writeBuf})\n+\t\tc.writeBuf = nil\n+\t}\n+\treturn err\n+}\n+\n+// flushFrame writes buffered data and extra as a frame to the network. The\n+// final argument indicates that this is the last frame in the message.\n+func (w *messageWriter) flushFrame(final bool, extra []byte) error {\n+\tc := w.c\n+\tlength := w.pos - maxFrameHeaderSize + len(extra)\n+\n+\t// Check for invalid control frames.\n+\tif isControl(w.frameType) &&\n+\t\t(!final || length > maxControlFramePayloadSize) {\n+\t\treturn w.endMessage(errInvalidControlFrame)\n+\t}\n+\n+\tb0 := byte(w.frameType)\n+\tif final {\n+\t\tb0 |= finalBit\n+\t}\n+\tif w.compress {\n+\t\tb0 |= rsv1Bit\n+\t}\n+\tw.compress = false\n+\n+\tb1 := byte(0)\n+\tif !c.isServer {\n+\t\tb1 |= maskBit\n+\t}\n+\n+\t// Assume that the frame starts at beginning of c.writeBuf.\n+\tframePos := 0\n+\tif c.isServer {\n+\t\t// Adjust up if mask not included in the header.\n+\t\tframePos = 4\n+\t}\n+\n+\tswitch {\n+\tcase length >= 65536:\n+\t\tc.writeBuf[framePos] = b0\n+\t\tc.writeBuf[framePos+1] = b1 | 127\n+\t\tbinary.BigEndian.PutUint64(c.writeBuf[framePos+2:], uint64(length))\n+\tcase length > 125:\n+\t\tframePos += 6\n+\t\tc.writeBuf[framePos] = b0\n+\t\tc.writeBuf[framePos+1] = b1 | 126\n+\t\tbinary.BigEndian.PutUint16(c.writeBuf[framePos+2:], uint16(length))\n+\tdefault:\n+\t\tframePos += 8\n+\t\tc.writeBuf[framePos] = b0\n+\t\tc.writeBuf[framePos+1] = b1 | byte(length)\n+\t}\n+\n+\tif !c.isServer {\n+\t\tkey := newMaskKey()\n+\t\tcopy(c.writeBuf[maxFrameHeaderSize-4:], key[:])\n+\t\tmaskBytes(key, 0, c.writeBuf[maxFrameHeaderSize:w.pos])\n+\t\tif len(extra) > 0 {\n+\t\t\treturn w.endMessage(c.writeFatal(errors.New(\"websocket: internal error, extra used in client mode\")))\n+\t\t}\n+\t}\n+\n+\t// Write the buffers to the connection with best-effort detection of\n+\t// concurrent writes. See the concurrency section in the package\n+\t// documentation for more info.\n+\n+\tif c.isWriting {\n+\t\tpanic(\"concurrent write to websocket connection\")\n+\t}\n+\tc.isWriting = true\n+\n+\terr := c.write(w.frameType, c.writeDeadline, c.writeBuf[framePos:w.pos], extra)\n+\n+\tif !c.isWriting {\n+\t\tpanic(\"concurrent write to websocket connection\")\n+\t}\n+\tc.isWriting = false\n+\n+\tif err != nil {\n+\t\treturn w.endMessage(err)\n+\t}\n+\n+\tif final {\n+\t\tw.endMessage(errWriteClosed)\n+\t\treturn nil\n+\t}\n+\n+\t// Setup for next frame.\n+\tw.pos = maxFrameHeaderSize\n+\tw.frameType = continuationFrame\n+\treturn nil\n+}\n+\n+func (w *messageWriter) ncopy(max int) (int, error) {\n+\tn := len(w.c.writeBuf) - w.pos\n+\tif n <= 0 {\n+\t\tif err := w.flushFrame(false, nil); err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tn = len(w.c.writeBuf) - w.pos\n+\t}\n+\tif n > max {\n+\t\tn = max\n+\t}\n+\treturn n, nil\n+}\n+\n+func (w *messageWriter) Write(p []byte) (int, error) {\n+\tif w.err != nil {\n+\t\treturn 0, w.err\n+\t}\n+\n+\tif len(p) > 2*len(w.c.writeBuf) && w.c.isServer {\n+\t\t// Don't buffer large messages.\n+\t\terr := w.flushFrame(false, p)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\treturn len(p), nil\n+\t}\n+\n+\tnn := len(p)\n+\tfor len(p) > 0 {\n+\t\tn, err := w.ncopy(len(p))\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tcopy(w.c.writeBuf[w.pos:], p[:n])\n+\t\tw.pos += n\n+\t\tp = p[n:]\n+\t}\n+\treturn nn, nil\n+}\n+\n+func (w *messageWriter) WriteString(p string) (int, error) {\n+\tif w.err != nil {\n+\t\treturn 0, w.err\n+\t}\n+\n+\tnn := len(p)\n+\tfor len(p) > 0 {\n+\t\tn, err := w.ncopy(len(p))\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tcopy(w.c.writeBuf[w.pos:], p[:n])\n+\t\tw.pos += n\n+\t\tp = p[n:]\n+\t}\n+\treturn nn, nil\n+}\n+\n+func (w *messageWriter) ReadFrom(r io.Reader) (nn int64, err error) {\n+\tif w.err != nil {\n+\t\treturn 0, w.err\n+\t}\n+\tfor {\n+\t\tif w.pos == len(w.c.writeBuf) {\n+\t\t\terr = w.flushFrame(false, nil)\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tvar n int\n+\t\tn, err = r.Read(w.c.writeBuf[w.pos:])\n+\t\tw.pos += n\n+\t\tnn += int64(n)\n+\t\tif err != nil {\n+\t\t\tif err == io.EOF {\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn nn, err\n+}\n+\n+func (w *messageWriter) Close() error {\n+\tif w.err != nil {\n+\t\treturn w.err\n+\t}\n+\treturn w.flushFrame(true, nil)\n+}\n+\n+// WritePreparedMessage writes prepared message into connection.\n+func (c *Conn) WritePreparedMessage(pm *PreparedMessage) error {\n+\tframeType, frameData, err := pm.frame(prepareKey{\n+\t\tisServer:         c.isServer,\n+\t\tcompress:         c.newCompressionWriter != nil && c.enableWriteCompression && isData(pm.messageType),\n+\t\tcompressionLevel: c.compressionLevel,\n+\t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif c.isWriting {\n+\t\tpanic(\"concurrent write to websocket connection\")\n+\t}\n+\tc.isWriting = true\n+\terr = c.write(frameType, c.writeDeadline, frameData, nil)\n+\tif !c.isWriting {\n+\t\tpanic(\"concurrent write to websocket connection\")\n+\t}\n+\tc.isWriting = false\n+\treturn err\n+}\n+\n+// WriteMessage is a helper method for getting a writer using NextWriter,\n+// writing the message and closing the writer.\n+func (c *Conn) WriteMessage(messageType int, data []byte) error {\n+\n+\tif c.isServer && (c.newCompressionWriter == nil || !c.enableWriteCompression) {\n+\t\t// Fast path with no allocations and single frame.\n+\n+\t\tvar mw messageWriter\n+\t\tif err := c.beginMessage(&mw, messageType); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tn := copy(c.writeBuf[mw.pos:], data)\n+\t\tmw.pos += n\n+\t\tdata = data[n:]\n+\t\treturn mw.flushFrame(true, data)\n+\t}\n+\n+\tw, err := c.NextWriter(messageType)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err = w.Write(data); err != nil {\n+\t\treturn err\n+\t}\n+\treturn w.Close()\n+}\n+\n+// SetWriteDeadline sets the write deadline on the underlying network\n+// connection. After a write has timed out, the websocket state is corrupt and\n+// all future writes will return an error. A zero value for t means writes will\n+// not time out.\n+func (c *Conn) SetWriteDeadline(t time.Time) error {\n+\tc.writeDeadline = t\n+\treturn nil\n+}\n+\n+// Read methods\n+\n+func (c *Conn) advanceFrame() (int, error) {\n+\t// 1. Skip remainder of previous frame.\n+\n+\tif c.readRemaining > 0 {\n+\t\tif _, err := io.CopyN(ioutil.Discard, c.br, c.readRemaining); err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\t}\n+\n+\t// 2. Read and parse first two bytes of frame header.\n+\n+\tp, err := c.read(2)\n+\tif err != nil {\n+\t\treturn noFrame, err\n+\t}\n+\n+\tfinal := p[0]&finalBit != 0\n+\tframeType := int(p[0] & 0xf)\n+\tmask := p[1]&maskBit != 0\n+\tc.setReadRemaining(int64(p[1] & 0x7f))\n+\n+\tc.readDecompress = false\n+\tif c.newDecompressionReader != nil && (p[0]&rsv1Bit) != 0 {\n+\t\tc.readDecompress = true\n+\t\tp[0] &^= rsv1Bit\n+\t}\n+\n+\tif rsv := p[0] & (rsv1Bit | rsv2Bit | rsv3Bit); rsv != 0 {\n+\t\treturn noFrame, c.handleProtocolError(\"unexpected reserved bits 0x\" + strconv.FormatInt(int64(rsv), 16))\n+\t}\n+\n+\tswitch frameType {\n+\tcase CloseMessage, PingMessage, PongMessage:\n+\t\tif c.readRemaining > maxControlFramePayloadSize {\n+\t\t\treturn noFrame, c.handleProtocolError(\"control frame length > 125\")\n+\t\t}\n+\t\tif !final {\n+\t\t\treturn noFrame, c.handleProtocolError(\"control frame not final\")\n+\t\t}\n+\tcase TextMessage, BinaryMessage:\n+\t\tif !c.readFinal {\n+\t\t\treturn noFrame, c.handleProtocolError(\"message start before final message frame\")\n+\t\t}\n+\t\tc.readFinal = final\n+\tcase continuationFrame:\n+\t\tif c.readFinal {\n+\t\t\treturn noFrame, c.handleProtocolError(\"continuation after final message frame\")\n+\t\t}\n+\t\tc.readFinal = final\n+\tdefault:\n+\t\treturn noFrame, c.handleProtocolError(\"unknown opcode \" + strconv.Itoa(frameType))\n+\t}\n+\n+\t// 3. Read and parse frame length as per\n+\t// https://tools.ietf.org/html/rfc6455#section-5.2\n+\t//\n+\t// The length of the \"Payload data\", in bytes: if 0-125, that is the payload\n+\t// length.\n+\t// - If 126, the following 2 bytes interpreted as a 16-bit unsigned\n+\t// integer are the payload length.\n+\t// - If 127, the following 8 bytes interpreted as\n+\t// a 64-bit unsigned integer (the most significant bit MUST be 0) are the\n+\t// payload length. Multibyte length quantities are expressed in network byte\n+\t// order.\n+\n+\tswitch c.readRemaining {\n+\tcase 126:\n+\t\tp, err := c.read(2)\n+\t\tif err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\n+\t\tif err := c.setReadRemaining(int64(binary.BigEndian.Uint16(p))); err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\tcase 127:\n+\t\tp, err := c.read(8)\n+\t\tif err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\n+\t\tif err := c.setReadRemaining(int64(binary.BigEndian.Uint64(p))); err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\t}\n+\n+\t// 4. Handle frame masking.\n+\n+\tif mask != c.isServer {\n+\t\treturn noFrame, c.handleProtocolError(\"incorrect mask flag\")\n+\t}\n+\n+\tif mask {\n+\t\tc.readMaskPos = 0\n+\t\tp, err := c.read(len(c.readMaskKey))\n+\t\tif err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\t\tcopy(c.readMaskKey[:], p)\n+\t}\n+\n+\t// 5. For text and binary messages, enforce read limit and return.\n+\n+\tif frameType == continuationFrame || frameType == TextMessage || frameType == BinaryMessage {\n+\n+\t\tc.readLength += c.readRemaining\n+\t\t// Don't allow readLength to overflow in the presence of a large readRemaining\n+\t\t// counter.\n+\t\tif c.readLength < 0 {\n+\t\t\treturn noFrame, ErrReadLimit\n+\t\t}\n+\n+\t\tif c.readLimit > 0 && c.readLength > c.readLimit {\n+\t\t\tc.WriteControl(CloseMessage, FormatCloseMessage(CloseMessageTooBig, \"\"), time.Now().Add(writeWait))\n+\t\t\treturn noFrame, ErrReadLimit\n+\t\t}\n+\n+\t\treturn frameType, nil\n+\t}\n+\n+\t// 6. Read control frame payload.\n+\n+\tvar payload []byte\n+\tif c.readRemaining > 0 {\n+\t\tpayload, err = c.read(int(c.readRemaining))\n+\t\tc.setReadRemaining(0)\n+\t\tif err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\t\tif c.isServer {\n+\t\t\tmaskBytes(c.readMaskKey, 0, payload)\n+\t\t}\n+\t}\n+\n+\t// 7. Process control frame payload.\n+\n+\tswitch frameType {\n+\tcase PongMessage:\n+\t\tif err := c.handlePong(string(payload)); err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\tcase PingMessage:\n+\t\tif err := c.handlePing(string(payload)); err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\tcase CloseMessage:\n+\t\tcloseCode := CloseNoStatusReceived\n+\t\tcloseText := \"\"\n+\t\tif len(payload) >= 2 {\n+\t\t\tcloseCode = int(binary.BigEndian.Uint16(payload))\n+\t\t\tif !isValidReceivedCloseCode(closeCode) {\n+\t\t\t\treturn noFrame, c.handleProtocolError(\"invalid close code\")\n+\t\t\t}\n+\t\t\tcloseText = string(payload[2:])\n+\t\t\tif !utf8.ValidString(closeText) {\n+\t\t\t\treturn noFrame, c.handleProtocolError(\"invalid utf8 payload in close frame\")\n+\t\t\t}\n+\t\t}\n+\t\tif err := c.handleClose(closeCode, closeText); err != nil {\n+\t\t\treturn noFrame, err\n+\t\t}\n+\t\treturn noFrame, &CloseError{Code: closeCode, Text: closeText}\n+\t}\n+\n+\treturn frameType, nil\n+}\n+\n+func (c *Conn) handleProtocolError(message string) error {\n+\tc.WriteControl(CloseMessage, FormatCloseMessage(CloseProtocolError, message), time.Now().Add(writeWait))\n+\treturn errors.New(\"websocket: \" + message)\n+}\n+\n+// NextReader returns the next data message received from the peer. The\n+// returned messageType is either TextMessage or BinaryMessage.\n+//\n+// There can be at most one open reader on a connection. NextReader discards\n+// the previous message if the application has not already consumed it.\n+//\n+// Applications must break out of the application's read loop when this method\n+// returns a non-nil error value. Errors returned from this method are\n+// permanent. Once this method returns a non-nil error, all subsequent calls to\n+// this method return the same error.\n+func (c *Conn) NextReader() (messageType int, r io.Reader, err error) {\n+\t// Close previous reader, only relevant for decompression.\n+\tif c.reader != nil {\n+\t\tc.reader.Close()\n+\t\tc.reader = nil\n+\t}\n+\n+\tc.messageReader = nil\n+\tc.readLength = 0\n+\n+\tfor c.readErr == nil {\n+\t\tframeType, err := c.advanceFrame()\n+\t\tif err != nil {\n+\t\t\tc.readErr = hideTempErr(err)\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif frameType == TextMessage || frameType == BinaryMessage {\n+\t\t\tc.messageReader = &messageReader{c}\n+\t\t\tc.reader = c.messageReader\n+\t\t\tif c.readDecompress {\n+\t\t\t\tc.reader = c.newDecompressionReader(c.reader)\n+\t\t\t}\n+\t\t\treturn frameType, c.reader, nil\n+\t\t}\n+\t}\n+\n+\t// Applications that do handle the error returned from this method spin in\n+\t// tight loop on connection failure. To help application developers detect\n+\t// this error, panic on repeated reads to the failed connection.\n+\tc.readErrCount++\n+\tif c.readErrCount >= 1000 {\n+\t\tpanic(\"repeated read on failed websocket connection\")\n+\t}\n+\n+\treturn noFrame, nil, c.readErr\n+}\n+\n+type messageReader struct{ c *Conn }\n+\n+func (r *messageReader) Read(b []byte) (int, error) {\n+\tc := r.c\n+\tif c.messageReader != r {\n+\t\treturn 0, io.EOF\n+\t}\n+\n+\tfor c.readErr == nil {\n+\n+\t\tif c.readRemaining > 0 {\n+\t\t\tif int64(len(b)) > c.readRemaining {\n+\t\t\t\tb = b[:c.readRemaining]\n+\t\t\t}\n+\t\t\tn, err := c.br.Read(b)\n+\t\t\tc.readErr = hideTempErr(err)\n+\t\t\tif c.isServer {\n+\t\t\t\tc.readMaskPos = maskBytes(c.readMaskKey, c.readMaskPos, b[:n])\n+\t\t\t}\n+\t\t\trem := c.readRemaining\n+\t\t\trem -= int64(n)\n+\t\t\tc.setReadRemaining(rem)\n+\t\t\tif c.readRemaining > 0 && c.readErr == io.EOF {\n+\t\t\t\tc.readErr = errUnexpectedEOF\n+\t\t\t}\n+\t\t\treturn n, c.readErr\n+\t\t}\n+\n+\t\tif c.readFinal {\n+\t\t\tc.messageReader = nil\n+\t\t\treturn 0, io.EOF\n+\t\t}\n+\n+\t\tframeType, err := c.advanceFrame()\n+\t\tswitch {\n+\t\tcase err != nil:\n+\t\t\tc.readErr = hideTempErr(err)\n+\t\tcase frameType == TextMessage || frameType == BinaryMessage:\n+\t\t\tc.readErr = errors.New(\"websocket: internal error, unexpected text or binary in Reader\")\n+\t\t}\n+\t}\n+\n+\terr := c.readErr\n+\tif err == io.EOF && c.messageReader == r {\n+\t\terr = errUnexpectedEOF\n+\t}\n+\treturn 0, err\n+}\n+\n+func (r *messageReader) Close() error {\n+\treturn nil\n+}\n+\n+// ReadMessage is a helper method for getting a reader using NextReader and\n+// reading from that reader to a buffer.\n+func (c *Conn) ReadMessage() (messageType int, p []byte, err error) {\n+\tvar r io.Reader\n+\tmessageType, r, err = c.NextReader()\n+\tif err != nil {\n+\t\treturn messageType, nil, err\n+\t}\n+\tp, err = ioutil.ReadAll(r)\n+\treturn messageType, p, err\n+}\n+\n+// SetReadDeadline sets the read deadline on the underlying network connection.\n+// After a read has timed out, the websocket connection state is corrupt and\n+// all future reads will return an error. A zero value for t means reads will\n+// not time out.\n+func (c *Conn) SetReadDeadline(t time.Time) error {\n+\treturn c.conn.SetReadDeadline(t)\n+}\n+\n+// SetReadLimit sets the maximum size in bytes for a message read from the peer. If a\n+// message exceeds the limit, the connection sends a close message to the peer\n+// and returns ErrReadLimit to the application.\n+func (c *Conn) SetReadLimit(limit int64) {\n+\tc.readLimit = limit\n+}\n+\n+// CloseHandler returns the current close handler\n+func (c *Conn) CloseHandler() func(code int, text string) error {\n+\treturn c.handleClose\n+}\n+\n+// SetCloseHandler sets the handler for close messages received from the peer.\n+// The code argument to h is the received close code or CloseNoStatusReceived\n+// if the close message is empty. The default close handler sends a close\n+// message back to the peer.\n+//\n+// The handler function is called from the NextReader, ReadMessage and message\n+// reader Read methods. The application must read the connection to process\n+// close messages as described in the section on Control Messages above.\n+//\n+// The connection read methods return a CloseError when a close message is\n+// received. Most applications should handle close messages as part of their\n+// normal error handling. Applications should only set a close handler when the\n+// application must perform some action before sending a close message back to\n+// the peer.\n+func (c *Conn) SetCloseHandler(h func(code int, text string) error) {\n+\tif h == nil {\n+\t\th = func(code int, text string) error {\n+\t\t\tmessage := FormatCloseMessage(code, \"\")\n+\t\t\tc.WriteControl(CloseMessage, message, time.Now().Add(writeWait))\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\tc.handleClose = h\n+}\n+\n+// PingHandler returns the current ping handler\n+func (c *Conn) PingHandler() func(appData string) error {\n+\treturn c.handlePing\n+}\n+\n+// SetPingHandler sets the handler for ping messages received from the peer.\n+// The appData argument to h is the PING message application data. The default\n+// ping handler sends a pong to the peer.\n+//\n+// The handler function is called from the NextReader, ReadMessage and message\n+// reader Read methods. The application must read the connection to process\n+// ping messages as described in the section on Control Messages above.\n+func (c *Conn) SetPingHandler(h func(appData string) error) {\n+\tif h == nil {\n+\t\th = func(message string) error {\n+\t\t\terr := c.WriteControl(PongMessage, []byte(message), time.Now().Add(writeWait))\n+\t\t\tif err == ErrCloseSent {\n+\t\t\t\treturn nil\n+\t\t\t} else if e, ok := err.(net.Error); ok && e.Temporary() {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tc.handlePing = h\n+}\n+\n+// PongHandler returns the current pong handler\n+func (c *Conn) PongHandler() func(appData string) error {\n+\treturn c.handlePong\n+}\n+\n+// SetPongHandler sets the handler for pong messages received from the peer.\n+// The appData argument to h is the PONG message application data. The default\n+// pong handler does nothing.\n+//\n+// The handler function is called from the NextReader, ReadMessage and message\n+// reader Read methods. The application must read the connection to process\n+// pong messages as described in the section on Control Messages above.\n+func (c *Conn) SetPongHandler(h func(appData string) error) {\n+\tif h == nil {\n+\t\th = func(string) error { return nil }\n+\t}\n+\tc.handlePong = h\n+}\n+\n+// UnderlyingConn returns the internal net.Conn. This can be used to further\n+// modifications to connection specific flags.\n+func (c *Conn) UnderlyingConn() net.Conn {\n+\treturn c.conn\n+}\n+\n+// EnableWriteCompression enables and disables write compression of\n+// subsequent text and binary messages. This function is a noop if\n+// compression was not negotiated with the peer.\n+func (c *Conn) EnableWriteCompression(enable bool) {\n+\tc.enableWriteCompression = enable\n+}\n+\n+// SetCompressionLevel sets the flate compression level for subsequent text and\n+// binary messages. This function is a noop if compression was not negotiated\n+// with the peer. See the compress/flate package for a description of\n+// compression levels.\n+func (c *Conn) SetCompressionLevel(level int) error {\n+\tif !isValidCompressionLevel(level) {\n+\t\treturn errors.New(\"websocket: invalid compression level\")\n+\t}\n+\tc.compressionLevel = level\n+\treturn nil\n+}\n+\n+// FormatCloseMessage formats closeCode and text as a WebSocket close message.\n+// An empty message is returned for code CloseNoStatusReceived.\n+func FormatCloseMessage(closeCode int, text string) []byte {\n+\tif closeCode == CloseNoStatusReceived {\n+\t\t// Return empty message because it's illegal to send\n+\t\t// CloseNoStatusReceived. Return non-nil value in case application\n+\t\t// checks for nil.\n+\t\treturn []byte{}\n+\t}\n+\tbuf := make([]byte, 2+len(text))\n+\tbinary.BigEndian.PutUint16(buf, uint16(closeCode))\n+\tcopy(buf[2:], text)\n+\treturn buf\n+}"
    },
    {
      "sha": "a509a21f87af3e30ef0b18520d47e6cf21e9174d",
      "filename": "backend/vendor/github.com/gorilla/websocket/conn_write.go",
      "status": "added",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/conn_write.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/conn_write.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/conn_write.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build go1.8\n+\n+package websocket\n+\n+import \"net\"\n+\n+func (c *Conn) writeBufs(bufs ...[]byte) error {\n+\tb := net.Buffers(bufs)\n+\t_, err := b.WriteTo(c.conn)\n+\treturn err\n+}"
    },
    {
      "sha": "37edaff5a578a0cd7c5f2fc09c459a50044cde23",
      "filename": "backend/vendor/github.com/gorilla/websocket/conn_write_legacy.go",
      "status": "added",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/conn_write_legacy.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/conn_write_legacy.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/conn_write_legacy.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !go1.8\n+\n+package websocket\n+\n+func (c *Conn) writeBufs(bufs ...[]byte) error {\n+\tfor _, buf := range bufs {\n+\t\tif len(buf) > 0 {\n+\t\t\tif _, err := c.conn.Write(buf); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}"
    },
    {
      "sha": "8db0cef95a29ac123a97c0a573e81ab89d930a6e",
      "filename": "backend/vendor/github.com/gorilla/websocket/doc.go",
      "status": "added",
      "additions": 227,
      "deletions": 0,
      "changes": 227,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/doc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/doc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/doc.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package websocket implements the WebSocket protocol defined in RFC 6455.\n+//\n+// Overview\n+//\n+// The Conn type represents a WebSocket connection. A server application calls\n+// the Upgrader.Upgrade method from an HTTP request handler to get a *Conn:\n+//\n+//  var upgrader = websocket.Upgrader{\n+//      ReadBufferSize:  1024,\n+//      WriteBufferSize: 1024,\n+//  }\n+//\n+//  func handler(w http.ResponseWriter, r *http.Request) {\n+//      conn, err := upgrader.Upgrade(w, r, nil)\n+//      if err != nil {\n+//          log.Println(err)\n+//          return\n+//      }\n+//      ... Use conn to send and receive messages.\n+//  }\n+//\n+// Call the connection's WriteMessage and ReadMessage methods to send and\n+// receive messages as a slice of bytes. This snippet of code shows how to echo\n+// messages using these methods:\n+//\n+//  for {\n+//      messageType, p, err := conn.ReadMessage()\n+//      if err != nil {\n+//          log.Println(err)\n+//          return\n+//      }\n+//      if err := conn.WriteMessage(messageType, p); err != nil {\n+//          log.Println(err)\n+//          return\n+//      }\n+//  }\n+//\n+// In above snippet of code, p is a []byte and messageType is an int with value\n+// websocket.BinaryMessage or websocket.TextMessage.\n+//\n+// An application can also send and receive messages using the io.WriteCloser\n+// and io.Reader interfaces. To send a message, call the connection NextWriter\n+// method to get an io.WriteCloser, write the message to the writer and close\n+// the writer when done. To receive a message, call the connection NextReader\n+// method to get an io.Reader and read until io.EOF is returned. This snippet\n+// shows how to echo messages using the NextWriter and NextReader methods:\n+//\n+//  for {\n+//      messageType, r, err := conn.NextReader()\n+//      if err != nil {\n+//          return\n+//      }\n+//      w, err := conn.NextWriter(messageType)\n+//      if err != nil {\n+//          return err\n+//      }\n+//      if _, err := io.Copy(w, r); err != nil {\n+//          return err\n+//      }\n+//      if err := w.Close(); err != nil {\n+//          return err\n+//      }\n+//  }\n+//\n+// Data Messages\n+//\n+// The WebSocket protocol distinguishes between text and binary data messages.\n+// Text messages are interpreted as UTF-8 encoded text. The interpretation of\n+// binary messages is left to the application.\n+//\n+// This package uses the TextMessage and BinaryMessage integer constants to\n+// identify the two data message types. The ReadMessage and NextReader methods\n+// return the type of the received message. The messageType argument to the\n+// WriteMessage and NextWriter methods specifies the type of a sent message.\n+//\n+// It is the application's responsibility to ensure that text messages are\n+// valid UTF-8 encoded text.\n+//\n+// Control Messages\n+//\n+// The WebSocket protocol defines three types of control messages: close, ping\n+// and pong. Call the connection WriteControl, WriteMessage or NextWriter\n+// methods to send a control message to the peer.\n+//\n+// Connections handle received close messages by calling the handler function\n+// set with the SetCloseHandler method and by returning a *CloseError from the\n+// NextReader, ReadMessage or the message Read method. The default close\n+// handler sends a close message to the peer.\n+//\n+// Connections handle received ping messages by calling the handler function\n+// set with the SetPingHandler method. The default ping handler sends a pong\n+// message to the peer.\n+//\n+// Connections handle received pong messages by calling the handler function\n+// set with the SetPongHandler method. The default pong handler does nothing.\n+// If an application sends ping messages, then the application should set a\n+// pong handler to receive the corresponding pong.\n+//\n+// The control message handler functions are called from the NextReader,\n+// ReadMessage and message reader Read methods. The default close and ping\n+// handlers can block these methods for a short time when the handler writes to\n+// the connection.\n+//\n+// The application must read the connection to process close, ping and pong\n+// messages sent from the peer. If the application is not otherwise interested\n+// in messages from the peer, then the application should start a goroutine to\n+// read and discard messages from the peer. A simple example is:\n+//\n+//  func readLoop(c *websocket.Conn) {\n+//      for {\n+//          if _, _, err := c.NextReader(); err != nil {\n+//              c.Close()\n+//              break\n+//          }\n+//      }\n+//  }\n+//\n+// Concurrency\n+//\n+// Connections support one concurrent reader and one concurrent writer.\n+//\n+// Applications are responsible for ensuring that no more than one goroutine\n+// calls the write methods (NextWriter, SetWriteDeadline, WriteMessage,\n+// WriteJSON, EnableWriteCompression, SetCompressionLevel) concurrently and\n+// that no more than one goroutine calls the read methods (NextReader,\n+// SetReadDeadline, ReadMessage, ReadJSON, SetPongHandler, SetPingHandler)\n+// concurrently.\n+//\n+// The Close and WriteControl methods can be called concurrently with all other\n+// methods.\n+//\n+// Origin Considerations\n+//\n+// Web browsers allow Javascript applications to open a WebSocket connection to\n+// any host. It's up to the server to enforce an origin policy using the Origin\n+// request header sent by the browser.\n+//\n+// The Upgrader calls the function specified in the CheckOrigin field to check\n+// the origin. If the CheckOrigin function returns false, then the Upgrade\n+// method fails the WebSocket handshake with HTTP status 403.\n+//\n+// If the CheckOrigin field is nil, then the Upgrader uses a safe default: fail\n+// the handshake if the Origin request header is present and the Origin host is\n+// not equal to the Host request header.\n+//\n+// The deprecated package-level Upgrade function does not perform origin\n+// checking. The application is responsible for checking the Origin header\n+// before calling the Upgrade function.\n+//\n+// Buffers\n+//\n+// Connections buffer network input and output to reduce the number\n+// of system calls when reading or writing messages.\n+//\n+// Write buffers are also used for constructing WebSocket frames. See RFC 6455,\n+// Section 5 for a discussion of message framing. A WebSocket frame header is\n+// written to the network each time a write buffer is flushed to the network.\n+// Decreasing the size of the write buffer can increase the amount of framing\n+// overhead on the connection.\n+//\n+// The buffer sizes in bytes are specified by the ReadBufferSize and\n+// WriteBufferSize fields in the Dialer and Upgrader. The Dialer uses a default\n+// size of 4096 when a buffer size field is set to zero. The Upgrader reuses\n+// buffers created by the HTTP server when a buffer size field is set to zero.\n+// The HTTP server buffers have a size of 4096 at the time of this writing.\n+//\n+// The buffer sizes do not limit the size of a message that can be read or\n+// written by a connection.\n+//\n+// Buffers are held for the lifetime of the connection by default. If the\n+// Dialer or Upgrader WriteBufferPool field is set, then a connection holds the\n+// write buffer only when writing a message.\n+//\n+// Applications should tune the buffer sizes to balance memory use and\n+// performance. Increasing the buffer size uses more memory, but can reduce the\n+// number of system calls to read or write the network. In the case of writing,\n+// increasing the buffer size can reduce the number of frame headers written to\n+// the network.\n+//\n+// Some guidelines for setting buffer parameters are:\n+//\n+// Limit the buffer sizes to the maximum expected message size. Buffers larger\n+// than the largest message do not provide any benefit.\n+//\n+// Depending on the distribution of message sizes, setting the buffer size to\n+// a value less than the maximum expected message size can greatly reduce memory\n+// use with a small impact on performance. Here's an example: If 99% of the\n+// messages are smaller than 256 bytes and the maximum message size is 512\n+// bytes, then a buffer size of 256 bytes will result in 1.01 more system calls\n+// than a buffer size of 512 bytes. The memory savings is 50%.\n+//\n+// A write buffer pool is useful when the application has a modest number\n+// writes over a large number of connections. when buffers are pooled, a larger\n+// buffer size has a reduced impact on total memory use and has the benefit of\n+// reducing system calls and frame overhead.\n+//\n+// Compression EXPERIMENTAL\n+//\n+// Per message compression extensions (RFC 7692) are experimentally supported\n+// by this package in a limited capacity. Setting the EnableCompression option\n+// to true in Dialer or Upgrader will attempt to negotiate per message deflate\n+// support.\n+//\n+//  var upgrader = websocket.Upgrader{\n+//      EnableCompression: true,\n+//  }\n+//\n+// If compression was successfully negotiated with the connection's peer, any\n+// message received in compressed form will be automatically decompressed.\n+// All Read methods will return uncompressed bytes.\n+//\n+// Per message compression of messages written to a connection can be enabled\n+// or disabled by calling the corresponding Conn method:\n+//\n+//  conn.EnableWriteCompression(false)\n+//\n+// Currently this package does not support compression with \"context takeover\".\n+// This means that messages must be compressed and decompressed in isolation,\n+// without retaining sliding window or dictionary state across messages. For\n+// more details refer to RFC 7692.\n+//\n+// Use of compression is experimental and may result in decreased performance.\n+package websocket"
    },
    {
      "sha": "1a7afd5028a7ab2ffbaeb854266f0ed023d9c697",
      "filename": "backend/vendor/github.com/gorilla/websocket/go.mod",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/go.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/go.mod?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,3 @@\n+module github.com/gorilla/websocket\n+\n+go 1.12"
    },
    {
      "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
      "filename": "backend/vendor/github.com/gorilla/websocket/go.sum",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/go.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/go.sum?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79"
    },
    {
      "sha": "c64f8c82901a3e17964df24f9b45151d7e6a5deb",
      "filename": "backend/vendor/github.com/gorilla/websocket/join.go",
      "status": "added",
      "additions": 42,
      "deletions": 0,
      "changes": 42,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/join.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/join.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/join.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2019 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"io\"\n+\t\"strings\"\n+)\n+\n+// JoinMessages concatenates received messages to create a single io.Reader.\n+// The string term is appended to each message. The returned reader does not\n+// support concurrent calls to the Read method.\n+func JoinMessages(c *Conn, term string) io.Reader {\n+\treturn &joinReader{c: c, term: term}\n+}\n+\n+type joinReader struct {\n+\tc    *Conn\n+\tterm string\n+\tr    io.Reader\n+}\n+\n+func (r *joinReader) Read(p []byte) (int, error) {\n+\tif r.r == nil {\n+\t\tvar err error\n+\t\t_, r.r, err = r.c.NextReader()\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tif r.term != \"\" {\n+\t\t\tr.r = io.MultiReader(r.r, strings.NewReader(r.term))\n+\t\t}\n+\t}\n+\tn, err := r.r.Read(p)\n+\tif err == io.EOF {\n+\t\terr = nil\n+\t\tr.r = nil\n+\t}\n+\treturn n, err\n+}"
    },
    {
      "sha": "dc2c1f6415ff8714c333f4be363b9be0756812dc",
      "filename": "backend/vendor/github.com/gorilla/websocket/json.go",
      "status": "added",
      "additions": 60,
      "deletions": 0,
      "changes": 60,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/json.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/json.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/json.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"encoding/json\"\n+\t\"io\"\n+)\n+\n+// WriteJSON writes the JSON encoding of v as a message.\n+//\n+// Deprecated: Use c.WriteJSON instead.\n+func WriteJSON(c *Conn, v interface{}) error {\n+\treturn c.WriteJSON(v)\n+}\n+\n+// WriteJSON writes the JSON encoding of v as a message.\n+//\n+// See the documentation for encoding/json Marshal for details about the\n+// conversion of Go values to JSON.\n+func (c *Conn) WriteJSON(v interface{}) error {\n+\tw, err := c.NextWriter(TextMessage)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr1 := json.NewEncoder(w).Encode(v)\n+\terr2 := w.Close()\n+\tif err1 != nil {\n+\t\treturn err1\n+\t}\n+\treturn err2\n+}\n+\n+// ReadJSON reads the next JSON-encoded message from the connection and stores\n+// it in the value pointed to by v.\n+//\n+// Deprecated: Use c.ReadJSON instead.\n+func ReadJSON(c *Conn, v interface{}) error {\n+\treturn c.ReadJSON(v)\n+}\n+\n+// ReadJSON reads the next JSON-encoded message from the connection and stores\n+// it in the value pointed to by v.\n+//\n+// See the documentation for the encoding/json Unmarshal function for details\n+// about the conversion of JSON to a Go value.\n+func (c *Conn) ReadJSON(v interface{}) error {\n+\t_, r, err := c.NextReader()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = json.NewDecoder(r).Decode(v)\n+\tif err == io.EOF {\n+\t\t// One value is expected in the message.\n+\t\terr = io.ErrUnexpectedEOF\n+\t}\n+\treturn err\n+}"
    },
    {
      "sha": "577fce9efd7204a820b403f0db3a709cc934b1f7",
      "filename": "backend/vendor/github.com/gorilla/websocket/mask.go",
      "status": "added",
      "additions": 54,
      "deletions": 0,
      "changes": 54,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/mask.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/mask.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/mask.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Gorilla WebSocket Authors. All rights reserved.  Use of\n+// this source code is governed by a BSD-style license that can be found in the\n+// LICENSE file.\n+\n+// +build !appengine\n+\n+package websocket\n+\n+import \"unsafe\"\n+\n+const wordSize = int(unsafe.Sizeof(uintptr(0)))\n+\n+func maskBytes(key [4]byte, pos int, b []byte) int {\n+\t// Mask one byte at a time for small buffers.\n+\tif len(b) < 2*wordSize {\n+\t\tfor i := range b {\n+\t\t\tb[i] ^= key[pos&3]\n+\t\t\tpos++\n+\t\t}\n+\t\treturn pos & 3\n+\t}\n+\n+\t// Mask one byte at a time to word boundary.\n+\tif n := int(uintptr(unsafe.Pointer(&b[0]))) % wordSize; n != 0 {\n+\t\tn = wordSize - n\n+\t\tfor i := range b[:n] {\n+\t\t\tb[i] ^= key[pos&3]\n+\t\t\tpos++\n+\t\t}\n+\t\tb = b[n:]\n+\t}\n+\n+\t// Create aligned word size key.\n+\tvar k [wordSize]byte\n+\tfor i := range k {\n+\t\tk[i] = key[(pos+i)&3]\n+\t}\n+\tkw := *(*uintptr)(unsafe.Pointer(&k))\n+\n+\t// Mask one word at a time.\n+\tn := (len(b) / wordSize) * wordSize\n+\tfor i := 0; i < n; i += wordSize {\n+\t\t*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&b[0])) + uintptr(i))) ^= kw\n+\t}\n+\n+\t// Mask one byte at a time for remaining bytes.\n+\tb = b[n:]\n+\tfor i := range b {\n+\t\tb[i] ^= key[pos&3]\n+\t\tpos++\n+\t}\n+\n+\treturn pos & 3\n+}"
    },
    {
      "sha": "2aac060e52e7093d2dce5051d639a31560f6c4e8",
      "filename": "backend/vendor/github.com/gorilla/websocket/mask_safe.go",
      "status": "added",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/mask_safe.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/mask_safe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/mask_safe.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Gorilla WebSocket Authors. All rights reserved.  Use of\n+// this source code is governed by a BSD-style license that can be found in the\n+// LICENSE file.\n+\n+// +build appengine\n+\n+package websocket\n+\n+func maskBytes(key [4]byte, pos int, b []byte) int {\n+\tfor i := range b {\n+\t\tb[i] ^= key[pos&3]\n+\t\tpos++\n+\t}\n+\treturn pos & 3\n+}"
    },
    {
      "sha": "c854225e9676fa71c7e1d7e33b1c23a6f138b5af",
      "filename": "backend/vendor/github.com/gorilla/websocket/prepared.go",
      "status": "added",
      "additions": 102,
      "deletions": 0,
      "changes": 102,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/prepared.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/prepared.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/prepared.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2017 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"bytes\"\n+\t\"net\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+// PreparedMessage caches on the wire representations of a message payload.\n+// Use PreparedMessage to efficiently send a message payload to multiple\n+// connections. PreparedMessage is especially useful when compression is used\n+// because the CPU and memory expensive compression operation can be executed\n+// once for a given set of compression options.\n+type PreparedMessage struct {\n+\tmessageType int\n+\tdata        []byte\n+\tmu          sync.Mutex\n+\tframes      map[prepareKey]*preparedFrame\n+}\n+\n+// prepareKey defines a unique set of options to cache prepared frames in PreparedMessage.\n+type prepareKey struct {\n+\tisServer         bool\n+\tcompress         bool\n+\tcompressionLevel int\n+}\n+\n+// preparedFrame contains data in wire representation.\n+type preparedFrame struct {\n+\tonce sync.Once\n+\tdata []byte\n+}\n+\n+// NewPreparedMessage returns an initialized PreparedMessage. You can then send\n+// it to connection using WritePreparedMessage method. Valid wire\n+// representation will be calculated lazily only once for a set of current\n+// connection options.\n+func NewPreparedMessage(messageType int, data []byte) (*PreparedMessage, error) {\n+\tpm := &PreparedMessage{\n+\t\tmessageType: messageType,\n+\t\tframes:      make(map[prepareKey]*preparedFrame),\n+\t\tdata:        data,\n+\t}\n+\n+\t// Prepare a plain server frame.\n+\t_, frameData, err := pm.frame(prepareKey{isServer: true, compress: false})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// To protect against caller modifying the data argument, remember the data\n+\t// copied to the plain server frame.\n+\tpm.data = frameData[len(frameData)-len(data):]\n+\treturn pm, nil\n+}\n+\n+func (pm *PreparedMessage) frame(key prepareKey) (int, []byte, error) {\n+\tpm.mu.Lock()\n+\tframe, ok := pm.frames[key]\n+\tif !ok {\n+\t\tframe = &preparedFrame{}\n+\t\tpm.frames[key] = frame\n+\t}\n+\tpm.mu.Unlock()\n+\n+\tvar err error\n+\tframe.once.Do(func() {\n+\t\t// Prepare a frame using a 'fake' connection.\n+\t\t// TODO: Refactor code in conn.go to allow more direct construction of\n+\t\t// the frame.\n+\t\tmu := make(chan struct{}, 1)\n+\t\tmu <- struct{}{}\n+\t\tvar nc prepareConn\n+\t\tc := &Conn{\n+\t\t\tconn:                   &nc,\n+\t\t\tmu:                     mu,\n+\t\t\tisServer:               key.isServer,\n+\t\t\tcompressionLevel:       key.compressionLevel,\n+\t\t\tenableWriteCompression: true,\n+\t\t\twriteBuf:               make([]byte, defaultWriteBufferSize+maxFrameHeaderSize),\n+\t\t}\n+\t\tif key.compress {\n+\t\t\tc.newCompressionWriter = compressNoContextTakeover\n+\t\t}\n+\t\terr = c.WriteMessage(pm.messageType, pm.data)\n+\t\tframe.data = nc.buf.Bytes()\n+\t})\n+\treturn pm.messageType, frame.data, err\n+}\n+\n+type prepareConn struct {\n+\tbuf bytes.Buffer\n+\tnet.Conn\n+}\n+\n+func (pc *prepareConn) Write(p []byte) (int, error)        { return pc.buf.Write(p) }\n+func (pc *prepareConn) SetWriteDeadline(t time.Time) error { return nil }"
    },
    {
      "sha": "e87a8c9f0c96ea3dda2f14f1f371a884471c7d61",
      "filename": "backend/vendor/github.com/gorilla/websocket/proxy.go",
      "status": "added",
      "additions": 77,
      "deletions": 0,
      "changes": 77,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/proxy.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/proxy.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/proxy.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2017 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"bufio\"\n+\t\"encoding/base64\"\n+\t\"errors\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"strings\"\n+)\n+\n+type netDialerFunc func(network, addr string) (net.Conn, error)\n+\n+func (fn netDialerFunc) Dial(network, addr string) (net.Conn, error) {\n+\treturn fn(network, addr)\n+}\n+\n+func init() {\n+\tproxy_RegisterDialerType(\"http\", func(proxyURL *url.URL, forwardDialer proxy_Dialer) (proxy_Dialer, error) {\n+\t\treturn &httpProxyDialer{proxyURL: proxyURL, forwardDial: forwardDialer.Dial}, nil\n+\t})\n+}\n+\n+type httpProxyDialer struct {\n+\tproxyURL    *url.URL\n+\tforwardDial func(network, addr string) (net.Conn, error)\n+}\n+\n+func (hpd *httpProxyDialer) Dial(network string, addr string) (net.Conn, error) {\n+\thostPort, _ := hostPortNoPort(hpd.proxyURL)\n+\tconn, err := hpd.forwardDial(network, hostPort)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tconnectHeader := make(http.Header)\n+\tif user := hpd.proxyURL.User; user != nil {\n+\t\tproxyUser := user.Username()\n+\t\tif proxyPassword, passwordSet := user.Password(); passwordSet {\n+\t\t\tcredential := base64.StdEncoding.EncodeToString([]byte(proxyUser + \":\" + proxyPassword))\n+\t\t\tconnectHeader.Set(\"Proxy-Authorization\", \"Basic \"+credential)\n+\t\t}\n+\t}\n+\n+\tconnectReq := &http.Request{\n+\t\tMethod: \"CONNECT\",\n+\t\tURL:    &url.URL{Opaque: addr},\n+\t\tHost:   addr,\n+\t\tHeader: connectHeader,\n+\t}\n+\n+\tif err := connectReq.Write(conn); err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\t// Read response. It's OK to use and discard buffered reader here becaue\n+\t// the remote server does not speak until spoken to.\n+\tbr := bufio.NewReader(conn)\n+\tresp, err := http.ReadResponse(br, connectReq)\n+\tif err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\tif resp.StatusCode != 200 {\n+\t\tconn.Close()\n+\t\tf := strings.SplitN(resp.Status, \" \", 2)\n+\t\treturn nil, errors.New(f[1])\n+\t}\n+\treturn conn, nil\n+}"
    },
    {
      "sha": "887d558918c721b38257b9dc908e7f73736dd8b0",
      "filename": "backend/vendor/github.com/gorilla/websocket/server.go",
      "status": "added",
      "additions": 363,
      "deletions": 0,
      "changes": 363,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/server.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/server.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,363 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"bufio\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// HandshakeError describes an error with the handshake from the peer.\n+type HandshakeError struct {\n+\tmessage string\n+}\n+\n+func (e HandshakeError) Error() string { return e.message }\n+\n+// Upgrader specifies parameters for upgrading an HTTP connection to a\n+// WebSocket connection.\n+type Upgrader struct {\n+\t// HandshakeTimeout specifies the duration for the handshake to complete.\n+\tHandshakeTimeout time.Duration\n+\n+\t// ReadBufferSize and WriteBufferSize specify I/O buffer sizes in bytes. If a buffer\n+\t// size is zero, then buffers allocated by the HTTP server are used. The\n+\t// I/O buffer sizes do not limit the size of the messages that can be sent\n+\t// or received.\n+\tReadBufferSize, WriteBufferSize int\n+\n+\t// WriteBufferPool is a pool of buffers for write operations. If the value\n+\t// is not set, then write buffers are allocated to the connection for the\n+\t// lifetime of the connection.\n+\t//\n+\t// A pool is most useful when the application has a modest volume of writes\n+\t// across a large number of connections.\n+\t//\n+\t// Applications should use a single pool for each unique value of\n+\t// WriteBufferSize.\n+\tWriteBufferPool BufferPool\n+\n+\t// Subprotocols specifies the server's supported protocols in order of\n+\t// preference. If this field is not nil, then the Upgrade method negotiates a\n+\t// subprotocol by selecting the first match in this list with a protocol\n+\t// requested by the client. If there's no match, then no protocol is\n+\t// negotiated (the Sec-Websocket-Protocol header is not included in the\n+\t// handshake response).\n+\tSubprotocols []string\n+\n+\t// Error specifies the function for generating HTTP error responses. If Error\n+\t// is nil, then http.Error is used to generate the HTTP response.\n+\tError func(w http.ResponseWriter, r *http.Request, status int, reason error)\n+\n+\t// CheckOrigin returns true if the request Origin header is acceptable. If\n+\t// CheckOrigin is nil, then a safe default is used: return false if the\n+\t// Origin request header is present and the origin host is not equal to\n+\t// request Host header.\n+\t//\n+\t// A CheckOrigin function should carefully validate the request origin to\n+\t// prevent cross-site request forgery.\n+\tCheckOrigin func(r *http.Request) bool\n+\n+\t// EnableCompression specify if the server should attempt to negotiate per\n+\t// message compression (RFC 7692). Setting this value to true does not\n+\t// guarantee that compression will be supported. Currently only \"no context\n+\t// takeover\" modes are supported.\n+\tEnableCompression bool\n+}\n+\n+func (u *Upgrader) returnError(w http.ResponseWriter, r *http.Request, status int, reason string) (*Conn, error) {\n+\terr := HandshakeError{reason}\n+\tif u.Error != nil {\n+\t\tu.Error(w, r, status, err)\n+\t} else {\n+\t\tw.Header().Set(\"Sec-Websocket-Version\", \"13\")\n+\t\thttp.Error(w, http.StatusText(status), status)\n+\t}\n+\treturn nil, err\n+}\n+\n+// checkSameOrigin returns true if the origin is not set or is equal to the request host.\n+func checkSameOrigin(r *http.Request) bool {\n+\torigin := r.Header[\"Origin\"]\n+\tif len(origin) == 0 {\n+\t\treturn true\n+\t}\n+\tu, err := url.Parse(origin[0])\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\treturn equalASCIIFold(u.Host, r.Host)\n+}\n+\n+func (u *Upgrader) selectSubprotocol(r *http.Request, responseHeader http.Header) string {\n+\tif u.Subprotocols != nil {\n+\t\tclientProtocols := Subprotocols(r)\n+\t\tfor _, serverProtocol := range u.Subprotocols {\n+\t\t\tfor _, clientProtocol := range clientProtocols {\n+\t\t\t\tif clientProtocol == serverProtocol {\n+\t\t\t\t\treturn clientProtocol\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t} else if responseHeader != nil {\n+\t\treturn responseHeader.Get(\"Sec-Websocket-Protocol\")\n+\t}\n+\treturn \"\"\n+}\n+\n+// Upgrade upgrades the HTTP server connection to the WebSocket protocol.\n+//\n+// The responseHeader is included in the response to the client's upgrade\n+// request. Use the responseHeader to specify cookies (Set-Cookie) and the\n+// application negotiated subprotocol (Sec-WebSocket-Protocol).\n+//\n+// If the upgrade fails, then Upgrade replies to the client with an HTTP error\n+// response.\n+func (u *Upgrader) Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header) (*Conn, error) {\n+\tconst badHandshake = \"websocket: the client is not using the websocket protocol: \"\n+\n+\tif !tokenListContainsValue(r.Header, \"Connection\", \"upgrade\") {\n+\t\treturn u.returnError(w, r, http.StatusBadRequest, badHandshake+\"'upgrade' token not found in 'Connection' header\")\n+\t}\n+\n+\tif !tokenListContainsValue(r.Header, \"Upgrade\", \"websocket\") {\n+\t\treturn u.returnError(w, r, http.StatusBadRequest, badHandshake+\"'websocket' token not found in 'Upgrade' header\")\n+\t}\n+\n+\tif r.Method != \"GET\" {\n+\t\treturn u.returnError(w, r, http.StatusMethodNotAllowed, badHandshake+\"request method is not GET\")\n+\t}\n+\n+\tif !tokenListContainsValue(r.Header, \"Sec-Websocket-Version\", \"13\") {\n+\t\treturn u.returnError(w, r, http.StatusBadRequest, \"websocket: unsupported version: 13 not found in 'Sec-Websocket-Version' header\")\n+\t}\n+\n+\tif _, ok := responseHeader[\"Sec-Websocket-Extensions\"]; ok {\n+\t\treturn u.returnError(w, r, http.StatusInternalServerError, \"websocket: application specific 'Sec-WebSocket-Extensions' headers are unsupported\")\n+\t}\n+\n+\tcheckOrigin := u.CheckOrigin\n+\tif checkOrigin == nil {\n+\t\tcheckOrigin = checkSameOrigin\n+\t}\n+\tif !checkOrigin(r) {\n+\t\treturn u.returnError(w, r, http.StatusForbidden, \"websocket: request origin not allowed by Upgrader.CheckOrigin\")\n+\t}\n+\n+\tchallengeKey := r.Header.Get(\"Sec-Websocket-Key\")\n+\tif challengeKey == \"\" {\n+\t\treturn u.returnError(w, r, http.StatusBadRequest, \"websocket: not a websocket handshake: 'Sec-WebSocket-Key' header is missing or blank\")\n+\t}\n+\n+\tsubprotocol := u.selectSubprotocol(r, responseHeader)\n+\n+\t// Negotiate PMCE\n+\tvar compress bool\n+\tif u.EnableCompression {\n+\t\tfor _, ext := range parseExtensions(r.Header) {\n+\t\t\tif ext[\"\"] != \"permessage-deflate\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcompress = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\th, ok := w.(http.Hijacker)\n+\tif !ok {\n+\t\treturn u.returnError(w, r, http.StatusInternalServerError, \"websocket: response does not implement http.Hijacker\")\n+\t}\n+\tvar brw *bufio.ReadWriter\n+\tnetConn, brw, err := h.Hijack()\n+\tif err != nil {\n+\t\treturn u.returnError(w, r, http.StatusInternalServerError, err.Error())\n+\t}\n+\n+\tif brw.Reader.Buffered() > 0 {\n+\t\tnetConn.Close()\n+\t\treturn nil, errors.New(\"websocket: client sent data before handshake is complete\")\n+\t}\n+\n+\tvar br *bufio.Reader\n+\tif u.ReadBufferSize == 0 && bufioReaderSize(netConn, brw.Reader) > 256 {\n+\t\t// Reuse hijacked buffered reader as connection reader.\n+\t\tbr = brw.Reader\n+\t}\n+\n+\tbuf := bufioWriterBuffer(netConn, brw.Writer)\n+\n+\tvar writeBuf []byte\n+\tif u.WriteBufferPool == nil && u.WriteBufferSize == 0 && len(buf) >= maxFrameHeaderSize+256 {\n+\t\t// Reuse hijacked write buffer as connection buffer.\n+\t\twriteBuf = buf\n+\t}\n+\n+\tc := newConn(netConn, true, u.ReadBufferSize, u.WriteBufferSize, u.WriteBufferPool, br, writeBuf)\n+\tc.subprotocol = subprotocol\n+\n+\tif compress {\n+\t\tc.newCompressionWriter = compressNoContextTakeover\n+\t\tc.newDecompressionReader = decompressNoContextTakeover\n+\t}\n+\n+\t// Use larger of hijacked buffer and connection write buffer for header.\n+\tp := buf\n+\tif len(c.writeBuf) > len(p) {\n+\t\tp = c.writeBuf\n+\t}\n+\tp = p[:0]\n+\n+\tp = append(p, \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: \"...)\n+\tp = append(p, computeAcceptKey(challengeKey)...)\n+\tp = append(p, \"\\r\\n\"...)\n+\tif c.subprotocol != \"\" {\n+\t\tp = append(p, \"Sec-WebSocket-Protocol: \"...)\n+\t\tp = append(p, c.subprotocol...)\n+\t\tp = append(p, \"\\r\\n\"...)\n+\t}\n+\tif compress {\n+\t\tp = append(p, \"Sec-WebSocket-Extensions: permessage-deflate; server_no_context_takeover; client_no_context_takeover\\r\\n\"...)\n+\t}\n+\tfor k, vs := range responseHeader {\n+\t\tif k == \"Sec-Websocket-Protocol\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, v := range vs {\n+\t\t\tp = append(p, k...)\n+\t\t\tp = append(p, \": \"...)\n+\t\t\tfor i := 0; i < len(v); i++ {\n+\t\t\t\tb := v[i]\n+\t\t\t\tif b <= 31 {\n+\t\t\t\t\t// prevent response splitting.\n+\t\t\t\t\tb = ' '\n+\t\t\t\t}\n+\t\t\t\tp = append(p, b)\n+\t\t\t}\n+\t\t\tp = append(p, \"\\r\\n\"...)\n+\t\t}\n+\t}\n+\tp = append(p, \"\\r\\n\"...)\n+\n+\t// Clear deadlines set by HTTP server.\n+\tnetConn.SetDeadline(time.Time{})\n+\n+\tif u.HandshakeTimeout > 0 {\n+\t\tnetConn.SetWriteDeadline(time.Now().Add(u.HandshakeTimeout))\n+\t}\n+\tif _, err = netConn.Write(p); err != nil {\n+\t\tnetConn.Close()\n+\t\treturn nil, err\n+\t}\n+\tif u.HandshakeTimeout > 0 {\n+\t\tnetConn.SetWriteDeadline(time.Time{})\n+\t}\n+\n+\treturn c, nil\n+}\n+\n+// Upgrade upgrades the HTTP server connection to the WebSocket protocol.\n+//\n+// Deprecated: Use websocket.Upgrader instead.\n+//\n+// Upgrade does not perform origin checking. The application is responsible for\n+// checking the Origin header before calling Upgrade. An example implementation\n+// of the same origin policy check is:\n+//\n+//\tif req.Header.Get(\"Origin\") != \"http://\"+req.Host {\n+//\t\thttp.Error(w, \"Origin not allowed\", http.StatusForbidden)\n+//\t\treturn\n+//\t}\n+//\n+// If the endpoint supports subprotocols, then the application is responsible\n+// for negotiating the protocol used on the connection. Use the Subprotocols()\n+// function to get the subprotocols requested by the client. Use the\n+// Sec-Websocket-Protocol response header to specify the subprotocol selected\n+// by the application.\n+//\n+// The responseHeader is included in the response to the client's upgrade\n+// request. Use the responseHeader to specify cookies (Set-Cookie) and the\n+// negotiated subprotocol (Sec-Websocket-Protocol).\n+//\n+// The connection buffers IO to the underlying network connection. The\n+// readBufSize and writeBufSize parameters specify the size of the buffers to\n+// use. Messages can be larger than the buffers.\n+//\n+// If the request is not a valid WebSocket handshake, then Upgrade returns an\n+// error of type HandshakeError. Applications should handle this error by\n+// replying to the client with an HTTP error response.\n+func Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header, readBufSize, writeBufSize int) (*Conn, error) {\n+\tu := Upgrader{ReadBufferSize: readBufSize, WriteBufferSize: writeBufSize}\n+\tu.Error = func(w http.ResponseWriter, r *http.Request, status int, reason error) {\n+\t\t// don't return errors to maintain backwards compatibility\n+\t}\n+\tu.CheckOrigin = func(r *http.Request) bool {\n+\t\t// allow all connections by default\n+\t\treturn true\n+\t}\n+\treturn u.Upgrade(w, r, responseHeader)\n+}\n+\n+// Subprotocols returns the subprotocols requested by the client in the\n+// Sec-Websocket-Protocol header.\n+func Subprotocols(r *http.Request) []string {\n+\th := strings.TrimSpace(r.Header.Get(\"Sec-Websocket-Protocol\"))\n+\tif h == \"\" {\n+\t\treturn nil\n+\t}\n+\tprotocols := strings.Split(h, \",\")\n+\tfor i := range protocols {\n+\t\tprotocols[i] = strings.TrimSpace(protocols[i])\n+\t}\n+\treturn protocols\n+}\n+\n+// IsWebSocketUpgrade returns true if the client requested upgrade to the\n+// WebSocket protocol.\n+func IsWebSocketUpgrade(r *http.Request) bool {\n+\treturn tokenListContainsValue(r.Header, \"Connection\", \"upgrade\") &&\n+\t\ttokenListContainsValue(r.Header, \"Upgrade\", \"websocket\")\n+}\n+\n+// bufioReaderSize size returns the size of a bufio.Reader.\n+func bufioReaderSize(originalReader io.Reader, br *bufio.Reader) int {\n+\t// This code assumes that peek on a reset reader returns\n+\t// bufio.Reader.buf[:0].\n+\t// TODO: Use bufio.Reader.Size() after Go 1.10\n+\tbr.Reset(originalReader)\n+\tif p, err := br.Peek(0); err == nil {\n+\t\treturn cap(p)\n+\t}\n+\treturn 0\n+}\n+\n+// writeHook is an io.Writer that records the last slice passed to it vio\n+// io.Writer.Write.\n+type writeHook struct {\n+\tp []byte\n+}\n+\n+func (wh *writeHook) Write(p []byte) (int, error) {\n+\twh.p = p\n+\treturn len(p), nil\n+}\n+\n+// bufioWriterBuffer grabs the buffer from a bufio.Writer.\n+func bufioWriterBuffer(originalWriter io.Writer, bw *bufio.Writer) []byte {\n+\t// This code assumes that bufio.Writer.buf[:1] is passed to the\n+\t// bufio.Writer's underlying writer.\n+\tvar wh writeHook\n+\tbw.Reset(&wh)\n+\tbw.WriteByte(0)\n+\tbw.Flush()\n+\n+\tbw.Reset(originalWriter)\n+\n+\treturn wh.p[:cap(wh.p)]\n+}"
    },
    {
      "sha": "834f122a00dbeb04e4edde617ea3a3896e51bc69",
      "filename": "backend/vendor/github.com/gorilla/websocket/trace.go",
      "status": "added",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/trace.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/trace.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/trace.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,19 @@\n+// +build go1.8\n+\n+package websocket\n+\n+import (\n+\t\"crypto/tls\"\n+\t\"net/http/httptrace\"\n+)\n+\n+func doHandshakeWithTrace(trace *httptrace.ClientTrace, tlsConn *tls.Conn, cfg *tls.Config) error {\n+\tif trace.TLSHandshakeStart != nil {\n+\t\ttrace.TLSHandshakeStart()\n+\t}\n+\terr := doHandshake(tlsConn, cfg)\n+\tif trace.TLSHandshakeDone != nil {\n+\t\ttrace.TLSHandshakeDone(tlsConn.ConnectionState(), err)\n+\t}\n+\treturn err\n+}"
    },
    {
      "sha": "77d05a0b5748c8d1bc220acfdb375ebad151bf6d",
      "filename": "backend/vendor/github.com/gorilla/websocket/trace_17.go",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/trace_17.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/trace_17.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/trace_17.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,12 @@\n+// +build !go1.8\n+\n+package websocket\n+\n+import (\n+\t\"crypto/tls\"\n+\t\"net/http/httptrace\"\n+)\n+\n+func doHandshakeWithTrace(trace *httptrace.ClientTrace, tlsConn *tls.Conn, cfg *tls.Config) error {\n+\treturn doHandshake(tlsConn, cfg)\n+}"
    },
    {
      "sha": "7bf2f66c6747d5fd1d08e652e7df747fb229f5bd",
      "filename": "backend/vendor/github.com/gorilla/websocket/util.go",
      "status": "added",
      "additions": 283,
      "deletions": 0,
      "changes": 283,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/util.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/util.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/util.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package websocket\n+\n+import (\n+\t\"crypto/rand\"\n+\t\"crypto/sha1\"\n+\t\"encoding/base64\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"strings\"\n+\t\"unicode/utf8\"\n+)\n+\n+var keyGUID = []byte(\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")\n+\n+func computeAcceptKey(challengeKey string) string {\n+\th := sha1.New()\n+\th.Write([]byte(challengeKey))\n+\th.Write(keyGUID)\n+\treturn base64.StdEncoding.EncodeToString(h.Sum(nil))\n+}\n+\n+func generateChallengeKey() (string, error) {\n+\tp := make([]byte, 16)\n+\tif _, err := io.ReadFull(rand.Reader, p); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn base64.StdEncoding.EncodeToString(p), nil\n+}\n+\n+// Token octets per RFC 2616.\n+var isTokenOctet = [256]bool{\n+\t'!':  true,\n+\t'#':  true,\n+\t'$':  true,\n+\t'%':  true,\n+\t'&':  true,\n+\t'\\'': true,\n+\t'*':  true,\n+\t'+':  true,\n+\t'-':  true,\n+\t'.':  true,\n+\t'0':  true,\n+\t'1':  true,\n+\t'2':  true,\n+\t'3':  true,\n+\t'4':  true,\n+\t'5':  true,\n+\t'6':  true,\n+\t'7':  true,\n+\t'8':  true,\n+\t'9':  true,\n+\t'A':  true,\n+\t'B':  true,\n+\t'C':  true,\n+\t'D':  true,\n+\t'E':  true,\n+\t'F':  true,\n+\t'G':  true,\n+\t'H':  true,\n+\t'I':  true,\n+\t'J':  true,\n+\t'K':  true,\n+\t'L':  true,\n+\t'M':  true,\n+\t'N':  true,\n+\t'O':  true,\n+\t'P':  true,\n+\t'Q':  true,\n+\t'R':  true,\n+\t'S':  true,\n+\t'T':  true,\n+\t'U':  true,\n+\t'W':  true,\n+\t'V':  true,\n+\t'X':  true,\n+\t'Y':  true,\n+\t'Z':  true,\n+\t'^':  true,\n+\t'_':  true,\n+\t'`':  true,\n+\t'a':  true,\n+\t'b':  true,\n+\t'c':  true,\n+\t'd':  true,\n+\t'e':  true,\n+\t'f':  true,\n+\t'g':  true,\n+\t'h':  true,\n+\t'i':  true,\n+\t'j':  true,\n+\t'k':  true,\n+\t'l':  true,\n+\t'm':  true,\n+\t'n':  true,\n+\t'o':  true,\n+\t'p':  true,\n+\t'q':  true,\n+\t'r':  true,\n+\t's':  true,\n+\t't':  true,\n+\t'u':  true,\n+\t'v':  true,\n+\t'w':  true,\n+\t'x':  true,\n+\t'y':  true,\n+\t'z':  true,\n+\t'|':  true,\n+\t'~':  true,\n+}\n+\n+// skipSpace returns a slice of the string s with all leading RFC 2616 linear\n+// whitespace removed.\n+func skipSpace(s string) (rest string) {\n+\ti := 0\n+\tfor ; i < len(s); i++ {\n+\t\tif b := s[i]; b != ' ' && b != '\\t' {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn s[i:]\n+}\n+\n+// nextToken returns the leading RFC 2616 token of s and the string following\n+// the token.\n+func nextToken(s string) (token, rest string) {\n+\ti := 0\n+\tfor ; i < len(s); i++ {\n+\t\tif !isTokenOctet[s[i]] {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn s[:i], s[i:]\n+}\n+\n+// nextTokenOrQuoted returns the leading token or quoted string per RFC 2616\n+// and the string following the token or quoted string.\n+func nextTokenOrQuoted(s string) (value string, rest string) {\n+\tif !strings.HasPrefix(s, \"\\\"\") {\n+\t\treturn nextToken(s)\n+\t}\n+\ts = s[1:]\n+\tfor i := 0; i < len(s); i++ {\n+\t\tswitch s[i] {\n+\t\tcase '\"':\n+\t\t\treturn s[:i], s[i+1:]\n+\t\tcase '\\\\':\n+\t\t\tp := make([]byte, len(s)-1)\n+\t\t\tj := copy(p, s[:i])\n+\t\t\tescape := true\n+\t\t\tfor i = i + 1; i < len(s); i++ {\n+\t\t\t\tb := s[i]\n+\t\t\t\tswitch {\n+\t\t\t\tcase escape:\n+\t\t\t\t\tescape = false\n+\t\t\t\t\tp[j] = b\n+\t\t\t\t\tj++\n+\t\t\t\tcase b == '\\\\':\n+\t\t\t\t\tescape = true\n+\t\t\t\tcase b == '\"':\n+\t\t\t\t\treturn string(p[:j]), s[i+1:]\n+\t\t\t\tdefault:\n+\t\t\t\t\tp[j] = b\n+\t\t\t\t\tj++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn \"\", \"\"\n+\t\t}\n+\t}\n+\treturn \"\", \"\"\n+}\n+\n+// equalASCIIFold returns true if s is equal to t with ASCII case folding as\n+// defined in RFC 4790.\n+func equalASCIIFold(s, t string) bool {\n+\tfor s != \"\" && t != \"\" {\n+\t\tsr, size := utf8.DecodeRuneInString(s)\n+\t\ts = s[size:]\n+\t\ttr, size := utf8.DecodeRuneInString(t)\n+\t\tt = t[size:]\n+\t\tif sr == tr {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif 'A' <= sr && sr <= 'Z' {\n+\t\t\tsr = sr + 'a' - 'A'\n+\t\t}\n+\t\tif 'A' <= tr && tr <= 'Z' {\n+\t\t\ttr = tr + 'a' - 'A'\n+\t\t}\n+\t\tif sr != tr {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn s == t\n+}\n+\n+// tokenListContainsValue returns true if the 1#token header with the given\n+// name contains a token equal to value with ASCII case folding.\n+func tokenListContainsValue(header http.Header, name string, value string) bool {\n+headers:\n+\tfor _, s := range header[name] {\n+\t\tfor {\n+\t\t\tvar t string\n+\t\t\tt, s = nextToken(skipSpace(s))\n+\t\t\tif t == \"\" {\n+\t\t\t\tcontinue headers\n+\t\t\t}\n+\t\t\ts = skipSpace(s)\n+\t\t\tif s != \"\" && s[0] != ',' {\n+\t\t\t\tcontinue headers\n+\t\t\t}\n+\t\t\tif equalASCIIFold(t, value) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tif s == \"\" {\n+\t\t\t\tcontinue headers\n+\t\t\t}\n+\t\t\ts = s[1:]\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// parseExtensions parses WebSocket extensions from a header.\n+func parseExtensions(header http.Header) []map[string]string {\n+\t// From RFC 6455:\n+\t//\n+\t//  Sec-WebSocket-Extensions = extension-list\n+\t//  extension-list = 1#extension\n+\t//  extension = extension-token *( \";\" extension-param )\n+\t//  extension-token = registered-token\n+\t//  registered-token = token\n+\t//  extension-param = token [ \"=\" (token | quoted-string) ]\n+\t//     ;When using the quoted-string syntax variant, the value\n+\t//     ;after quoted-string unescaping MUST conform to the\n+\t//     ;'token' ABNF.\n+\n+\tvar result []map[string]string\n+headers:\n+\tfor _, s := range header[\"Sec-Websocket-Extensions\"] {\n+\t\tfor {\n+\t\t\tvar t string\n+\t\t\tt, s = nextToken(skipSpace(s))\n+\t\t\tif t == \"\" {\n+\t\t\t\tcontinue headers\n+\t\t\t}\n+\t\t\text := map[string]string{\"\": t}\n+\t\t\tfor {\n+\t\t\t\ts = skipSpace(s)\n+\t\t\t\tif !strings.HasPrefix(s, \";\") {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tvar k string\n+\t\t\t\tk, s = nextToken(skipSpace(s[1:]))\n+\t\t\t\tif k == \"\" {\n+\t\t\t\t\tcontinue headers\n+\t\t\t\t}\n+\t\t\t\ts = skipSpace(s)\n+\t\t\t\tvar v string\n+\t\t\t\tif strings.HasPrefix(s, \"=\") {\n+\t\t\t\t\tv, s = nextTokenOrQuoted(skipSpace(s[1:]))\n+\t\t\t\t\ts = skipSpace(s)\n+\t\t\t\t}\n+\t\t\t\tif s != \"\" && s[0] != ',' && s[0] != ';' {\n+\t\t\t\t\tcontinue headers\n+\t\t\t\t}\n+\t\t\t\text[k] = v\n+\t\t\t}\n+\t\t\tif s != \"\" && s[0] != ',' {\n+\t\t\t\tcontinue headers\n+\t\t\t}\n+\t\t\tresult = append(result, ext)\n+\t\t\tif s == \"\" {\n+\t\t\t\tcontinue headers\n+\t\t\t}\n+\t\t\ts = s[1:]\n+\t\t}\n+\t}\n+\treturn result\n+}"
    },
    {
      "sha": "2e668f6b8821e4129856122630dc5691e2f1612a",
      "filename": "backend/vendor/github.com/gorilla/websocket/x_net_proxy.go",
      "status": "added",
      "additions": 473,
      "deletions": 0,
      "changes": 473,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/x_net_proxy.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/gorilla/websocket/x_net_proxy.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/gorilla/websocket/x_net_proxy.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,473 @@\n+// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.\n+//go:generate bundle -o x_net_proxy.go golang.org/x/net/proxy\n+\n+// Package proxy provides support for a variety of protocols to proxy network\n+// data.\n+//\n+\n+package websocket\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"net\"\n+\t\"net/url\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+type proxy_direct struct{}\n+\n+// Direct is a direct proxy: one that makes network connections directly.\n+var proxy_Direct = proxy_direct{}\n+\n+func (proxy_direct) Dial(network, addr string) (net.Conn, error) {\n+\treturn net.Dial(network, addr)\n+}\n+\n+// A PerHost directs connections to a default Dialer unless the host name\n+// requested matches one of a number of exceptions.\n+type proxy_PerHost struct {\n+\tdef, bypass proxy_Dialer\n+\n+\tbypassNetworks []*net.IPNet\n+\tbypassIPs      []net.IP\n+\tbypassZones    []string\n+\tbypassHosts    []string\n+}\n+\n+// NewPerHost returns a PerHost Dialer that directs connections to either\n+// defaultDialer or bypass, depending on whether the connection matches one of\n+// the configured rules.\n+func proxy_NewPerHost(defaultDialer, bypass proxy_Dialer) *proxy_PerHost {\n+\treturn &proxy_PerHost{\n+\t\tdef:    defaultDialer,\n+\t\tbypass: bypass,\n+\t}\n+}\n+\n+// Dial connects to the address addr on the given network through either\n+// defaultDialer or bypass.\n+func (p *proxy_PerHost) Dial(network, addr string) (c net.Conn, err error) {\n+\thost, _, err := net.SplitHostPort(addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn p.dialerForRequest(host).Dial(network, addr)\n+}\n+\n+func (p *proxy_PerHost) dialerForRequest(host string) proxy_Dialer {\n+\tif ip := net.ParseIP(host); ip != nil {\n+\t\tfor _, net := range p.bypassNetworks {\n+\t\t\tif net.Contains(ip) {\n+\t\t\t\treturn p.bypass\n+\t\t\t}\n+\t\t}\n+\t\tfor _, bypassIP := range p.bypassIPs {\n+\t\t\tif bypassIP.Equal(ip) {\n+\t\t\t\treturn p.bypass\n+\t\t\t}\n+\t\t}\n+\t\treturn p.def\n+\t}\n+\n+\tfor _, zone := range p.bypassZones {\n+\t\tif strings.HasSuffix(host, zone) {\n+\t\t\treturn p.bypass\n+\t\t}\n+\t\tif host == zone[1:] {\n+\t\t\t// For a zone \".example.com\", we match \"example.com\"\n+\t\t\t// too.\n+\t\t\treturn p.bypass\n+\t\t}\n+\t}\n+\tfor _, bypassHost := range p.bypassHosts {\n+\t\tif bypassHost == host {\n+\t\t\treturn p.bypass\n+\t\t}\n+\t}\n+\treturn p.def\n+}\n+\n+// AddFromString parses a string that contains comma-separated values\n+// specifying hosts that should use the bypass proxy. Each value is either an\n+// IP address, a CIDR range, a zone (*.example.com) or a host name\n+// (localhost). A best effort is made to parse the string and errors are\n+// ignored.\n+func (p *proxy_PerHost) AddFromString(s string) {\n+\thosts := strings.Split(s, \",\")\n+\tfor _, host := range hosts {\n+\t\thost = strings.TrimSpace(host)\n+\t\tif len(host) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.Contains(host, \"/\") {\n+\t\t\t// We assume that it's a CIDR address like 127.0.0.0/8\n+\t\t\tif _, net, err := net.ParseCIDR(host); err == nil {\n+\t\t\t\tp.AddNetwork(net)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif ip := net.ParseIP(host); ip != nil {\n+\t\t\tp.AddIP(ip)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(host, \"*.\") {\n+\t\t\tp.AddZone(host[1:])\n+\t\t\tcontinue\n+\t\t}\n+\t\tp.AddHost(host)\n+\t}\n+}\n+\n+// AddIP specifies an IP address that will use the bypass proxy. Note that\n+// this will only take effect if a literal IP address is dialed. A connection\n+// to a named host will never match an IP.\n+func (p *proxy_PerHost) AddIP(ip net.IP) {\n+\tp.bypassIPs = append(p.bypassIPs, ip)\n+}\n+\n+// AddNetwork specifies an IP range that will use the bypass proxy. Note that\n+// this will only take effect if a literal IP address is dialed. A connection\n+// to a named host will never match.\n+func (p *proxy_PerHost) AddNetwork(net *net.IPNet) {\n+\tp.bypassNetworks = append(p.bypassNetworks, net)\n+}\n+\n+// AddZone specifies a DNS suffix that will use the bypass proxy. A zone of\n+// \"example.com\" matches \"example.com\" and all of its subdomains.\n+func (p *proxy_PerHost) AddZone(zone string) {\n+\tif strings.HasSuffix(zone, \".\") {\n+\t\tzone = zone[:len(zone)-1]\n+\t}\n+\tif !strings.HasPrefix(zone, \".\") {\n+\t\tzone = \".\" + zone\n+\t}\n+\tp.bypassZones = append(p.bypassZones, zone)\n+}\n+\n+// AddHost specifies a host name that will use the bypass proxy.\n+func (p *proxy_PerHost) AddHost(host string) {\n+\tif strings.HasSuffix(host, \".\") {\n+\t\thost = host[:len(host)-1]\n+\t}\n+\tp.bypassHosts = append(p.bypassHosts, host)\n+}\n+\n+// A Dialer is a means to establish a connection.\n+type proxy_Dialer interface {\n+\t// Dial connects to the given address via the proxy.\n+\tDial(network, addr string) (c net.Conn, err error)\n+}\n+\n+// Auth contains authentication parameters that specific Dialers may require.\n+type proxy_Auth struct {\n+\tUser, Password string\n+}\n+\n+// FromEnvironment returns the dialer specified by the proxy related variables in\n+// the environment.\n+func proxy_FromEnvironment() proxy_Dialer {\n+\tallProxy := proxy_allProxyEnv.Get()\n+\tif len(allProxy) == 0 {\n+\t\treturn proxy_Direct\n+\t}\n+\n+\tproxyURL, err := url.Parse(allProxy)\n+\tif err != nil {\n+\t\treturn proxy_Direct\n+\t}\n+\tproxy, err := proxy_FromURL(proxyURL, proxy_Direct)\n+\tif err != nil {\n+\t\treturn proxy_Direct\n+\t}\n+\n+\tnoProxy := proxy_noProxyEnv.Get()\n+\tif len(noProxy) == 0 {\n+\t\treturn proxy\n+\t}\n+\n+\tperHost := proxy_NewPerHost(proxy, proxy_Direct)\n+\tperHost.AddFromString(noProxy)\n+\treturn perHost\n+}\n+\n+// proxySchemes is a map from URL schemes to a function that creates a Dialer\n+// from a URL with such a scheme.\n+var proxy_proxySchemes map[string]func(*url.URL, proxy_Dialer) (proxy_Dialer, error)\n+\n+// RegisterDialerType takes a URL scheme and a function to generate Dialers from\n+// a URL with that scheme and a forwarding Dialer. Registered schemes are used\n+// by FromURL.\n+func proxy_RegisterDialerType(scheme string, f func(*url.URL, proxy_Dialer) (proxy_Dialer, error)) {\n+\tif proxy_proxySchemes == nil {\n+\t\tproxy_proxySchemes = make(map[string]func(*url.URL, proxy_Dialer) (proxy_Dialer, error))\n+\t}\n+\tproxy_proxySchemes[scheme] = f\n+}\n+\n+// FromURL returns a Dialer given a URL specification and an underlying\n+// Dialer for it to make network requests.\n+func proxy_FromURL(u *url.URL, forward proxy_Dialer) (proxy_Dialer, error) {\n+\tvar auth *proxy_Auth\n+\tif u.User != nil {\n+\t\tauth = new(proxy_Auth)\n+\t\tauth.User = u.User.Username()\n+\t\tif p, ok := u.User.Password(); ok {\n+\t\t\tauth.Password = p\n+\t\t}\n+\t}\n+\n+\tswitch u.Scheme {\n+\tcase \"socks5\":\n+\t\treturn proxy_SOCKS5(\"tcp\", u.Host, auth, forward)\n+\t}\n+\n+\t// If the scheme doesn't match any of the built-in schemes, see if it\n+\t// was registered by another package.\n+\tif proxy_proxySchemes != nil {\n+\t\tif f, ok := proxy_proxySchemes[u.Scheme]; ok {\n+\t\t\treturn f(u, forward)\n+\t\t}\n+\t}\n+\n+\treturn nil, errors.New(\"proxy: unknown scheme: \" + u.Scheme)\n+}\n+\n+var (\n+\tproxy_allProxyEnv = &proxy_envOnce{\n+\t\tnames: []string{\"ALL_PROXY\", \"all_proxy\"},\n+\t}\n+\tproxy_noProxyEnv = &proxy_envOnce{\n+\t\tnames: []string{\"NO_PROXY\", \"no_proxy\"},\n+\t}\n+)\n+\n+// envOnce looks up an environment variable (optionally by multiple\n+// names) once. It mitigates expensive lookups on some platforms\n+// (e.g. Windows).\n+// (Borrowed from net/http/transport.go)\n+type proxy_envOnce struct {\n+\tnames []string\n+\tonce  sync.Once\n+\tval   string\n+}\n+\n+func (e *proxy_envOnce) Get() string {\n+\te.once.Do(e.init)\n+\treturn e.val\n+}\n+\n+func (e *proxy_envOnce) init() {\n+\tfor _, n := range e.names {\n+\t\te.val = os.Getenv(n)\n+\t\tif e.val != \"\" {\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+// SOCKS5 returns a Dialer that makes SOCKSv5 connections to the given address\n+// with an optional username and password. See RFC 1928 and RFC 1929.\n+func proxy_SOCKS5(network, addr string, auth *proxy_Auth, forward proxy_Dialer) (proxy_Dialer, error) {\n+\ts := &proxy_socks5{\n+\t\tnetwork: network,\n+\t\taddr:    addr,\n+\t\tforward: forward,\n+\t}\n+\tif auth != nil {\n+\t\ts.user = auth.User\n+\t\ts.password = auth.Password\n+\t}\n+\n+\treturn s, nil\n+}\n+\n+type proxy_socks5 struct {\n+\tuser, password string\n+\tnetwork, addr  string\n+\tforward        proxy_Dialer\n+}\n+\n+const proxy_socks5Version = 5\n+\n+const (\n+\tproxy_socks5AuthNone     = 0\n+\tproxy_socks5AuthPassword = 2\n+)\n+\n+const proxy_socks5Connect = 1\n+\n+const (\n+\tproxy_socks5IP4    = 1\n+\tproxy_socks5Domain = 3\n+\tproxy_socks5IP6    = 4\n+)\n+\n+var proxy_socks5Errors = []string{\n+\t\"\",\n+\t\"general failure\",\n+\t\"connection forbidden\",\n+\t\"network unreachable\",\n+\t\"host unreachable\",\n+\t\"connection refused\",\n+\t\"TTL expired\",\n+\t\"command not supported\",\n+\t\"address type not supported\",\n+}\n+\n+// Dial connects to the address addr on the given network via the SOCKS5 proxy.\n+func (s *proxy_socks5) Dial(network, addr string) (net.Conn, error) {\n+\tswitch network {\n+\tcase \"tcp\", \"tcp6\", \"tcp4\":\n+\tdefault:\n+\t\treturn nil, errors.New(\"proxy: no support for SOCKS5 proxy connections of type \" + network)\n+\t}\n+\n+\tconn, err := s.forward.Dial(s.network, s.addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := s.connect(conn, addr); err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\treturn conn, nil\n+}\n+\n+// connect takes an existing connection to a socks5 proxy server,\n+// and commands the server to extend that connection to target,\n+// which must be a canonical address with a host and port.\n+func (s *proxy_socks5) connect(conn net.Conn, target string) error {\n+\thost, portStr, err := net.SplitHostPort(target)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn errors.New(\"proxy: failed to parse port number: \" + portStr)\n+\t}\n+\tif port < 1 || port > 0xffff {\n+\t\treturn errors.New(\"proxy: port number out of range: \" + portStr)\n+\t}\n+\n+\t// the size here is just an estimate\n+\tbuf := make([]byte, 0, 6+len(host))\n+\n+\tbuf = append(buf, proxy_socks5Version)\n+\tif len(s.user) > 0 && len(s.user) < 256 && len(s.password) < 256 {\n+\t\tbuf = append(buf, 2 /* num auth methods */, proxy_socks5AuthNone, proxy_socks5AuthPassword)\n+\t} else {\n+\t\tbuf = append(buf, 1 /* num auth methods */, proxy_socks5AuthNone)\n+\t}\n+\n+\tif _, err := conn.Write(buf); err != nil {\n+\t\treturn errors.New(\"proxy: failed to write greeting to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tif _, err := io.ReadFull(conn, buf[:2]); err != nil {\n+\t\treturn errors.New(\"proxy: failed to read greeting from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\tif buf[0] != 5 {\n+\t\treturn errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" has unexpected version \" + strconv.Itoa(int(buf[0])))\n+\t}\n+\tif buf[1] == 0xff {\n+\t\treturn errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" requires authentication\")\n+\t}\n+\n+\t// See RFC 1929\n+\tif buf[1] == proxy_socks5AuthPassword {\n+\t\tbuf = buf[:0]\n+\t\tbuf = append(buf, 1 /* password protocol version */)\n+\t\tbuf = append(buf, uint8(len(s.user)))\n+\t\tbuf = append(buf, s.user...)\n+\t\tbuf = append(buf, uint8(len(s.password)))\n+\t\tbuf = append(buf, s.password...)\n+\n+\t\tif _, err := conn.Write(buf); err != nil {\n+\t\t\treturn errors.New(\"proxy: failed to write authentication request to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t\t}\n+\n+\t\tif _, err := io.ReadFull(conn, buf[:2]); err != nil {\n+\t\t\treturn errors.New(\"proxy: failed to read authentication reply from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t\t}\n+\n+\t\tif buf[1] != 0 {\n+\t\t\treturn errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" rejected username/password\")\n+\t\t}\n+\t}\n+\n+\tbuf = buf[:0]\n+\tbuf = append(buf, proxy_socks5Version, proxy_socks5Connect, 0 /* reserved */)\n+\n+\tif ip := net.ParseIP(host); ip != nil {\n+\t\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t\tbuf = append(buf, proxy_socks5IP4)\n+\t\t\tip = ip4\n+\t\t} else {\n+\t\t\tbuf = append(buf, proxy_socks5IP6)\n+\t\t}\n+\t\tbuf = append(buf, ip...)\n+\t} else {\n+\t\tif len(host) > 255 {\n+\t\t\treturn errors.New(\"proxy: destination host name too long: \" + host)\n+\t\t}\n+\t\tbuf = append(buf, proxy_socks5Domain)\n+\t\tbuf = append(buf, byte(len(host)))\n+\t\tbuf = append(buf, host...)\n+\t}\n+\tbuf = append(buf, byte(port>>8), byte(port))\n+\n+\tif _, err := conn.Write(buf); err != nil {\n+\t\treturn errors.New(\"proxy: failed to write connect request to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tif _, err := io.ReadFull(conn, buf[:4]); err != nil {\n+\t\treturn errors.New(\"proxy: failed to read connect reply from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tfailure := \"unknown error\"\n+\tif int(buf[1]) < len(proxy_socks5Errors) {\n+\t\tfailure = proxy_socks5Errors[buf[1]]\n+\t}\n+\n+\tif len(failure) > 0 {\n+\t\treturn errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" failed to connect: \" + failure)\n+\t}\n+\n+\tbytesToDiscard := 0\n+\tswitch buf[3] {\n+\tcase proxy_socks5IP4:\n+\t\tbytesToDiscard = net.IPv4len\n+\tcase proxy_socks5IP6:\n+\t\tbytesToDiscard = net.IPv6len\n+\tcase proxy_socks5Domain:\n+\t\t_, err := io.ReadFull(conn, buf[:1])\n+\t\tif err != nil {\n+\t\t\treturn errors.New(\"proxy: failed to read domain length from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t\t}\n+\t\tbytesToDiscard = int(buf[0])\n+\tdefault:\n+\t\treturn errors.New(\"proxy: got unknown address type \" + strconv.Itoa(int(buf[3])) + \" from SOCKS5 proxy at \" + s.addr)\n+\t}\n+\n+\tif cap(buf) < bytesToDiscard {\n+\t\tbuf = make([]byte, bytesToDiscard)\n+\t} else {\n+\t\tbuf = buf[:bytesToDiscard]\n+\t}\n+\tif _, err := io.ReadFull(conn, buf); err != nil {\n+\t\treturn errors.New(\"proxy: failed to read address from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\t// Also need to discard the port number\n+\tif _, err := io.ReadFull(conn, buf[:2]); err != nil {\n+\t\treturn errors.New(\"proxy: failed to read port from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\treturn nil\n+}"
    },
    {
      "sha": "ac6f3eeb3ef0636ec3bcc96a91a487d95112fada",
      "filename": "backend/vendor/github.com/slack-go/slack/.gitignore",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/.gitignore",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/.gitignore?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,3 @@\n+*.test\n+*~\n+.idea/"
    },
    {
      "sha": "c16f5389a3a0819dc3b5331a12edb3824c2e3664",
      "filename": "backend/vendor/github.com/slack-go/slack/.golangci.yml",
      "status": "added",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/.golangci.yml",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/.golangci.yml?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,14 @@\n+run:\n+  timeout: 6m\n+  issues-exit-code: 1\n+linters:\n+  disable-all: true\n+  enable:\n+    - goimports\n+    - govet\n+    - interfacer\n+    - misspell\n+    - structcheck\n+    - unconvert\n+issues:\n+  new: true"
    },
    {
      "sha": "32da687bb0f135003ffd63753c1f8fa339da2c37",
      "filename": "backend/vendor/github.com/slack-go/slack/CHANGELOG.md",
      "status": "added",
      "additions": 103,
      "deletions": 0,
      "changes": 103,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/CHANGELOG.md",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/CHANGELOG.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/CHANGELOG.md?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,103 @@\n+### v0.7.0 - October 2, 2020\r\n+full differences can be viewed using `git log --oneline --decorate --color v0.6.6..v0.7.0`\r\n+Thank you for many contributions!\r\n+\r\n+#### Breaking Changes\r\n+- Add ScheduledMessage type ([#753])\r\n+- Add description field to option block object ([#783])\r\n+- Fix wrong conditional branch ([#782])\r\n+  - The behavior of the user's application may change.(The current behavior is incorrect)\r\n+\r\n+#### Highlights\r\n+- example: fix to start up a server ([#773])\r\n+- example: Add explanation how the message could be sent in a proper way ([#787])\r\n+- example: fix typo in error log ([#779])\r\n+- refactor: Make GetConversationsParameters.ExcludeArchived optional ([#791])\r\n+- refactor: Unify variables to \"config\" ([#800])\r\n+- refactor: Rename wrong file name ([#810])\r\n+- feature: Add SetUserRealName for change user's realName([#755])\r\n+- feature: Add response metadata to slack response ([#772])\r\n+- feature: Add response metadata to slack response ([#778])\r\n+- feature: Add select block element conversations filter field ([#790])\r\n+- feature: Add Root field to MessageEvent to support thread_broadcast subtype ([#793])\r\n+- feature: Add bot_profile to messages ([#794])\r\n+- doc: Add logo to README ([#813])\r\n+- doc: Update current project status and Add changelog for v0.7.0 ([#814])\r\n+\r\n+[#753]: https://github.com/slack-go/slack/pull/753\r\n+[#755]: https://github.com/slack-go/slack/pull/755\r\n+[#772]: https://github.com/slack-go/slack/pull/772\r\n+[#773]: https://github.com/slack-go/slack/pull/773\r\n+[#778]: https://github.com/slack-go/slack/pull/778\r\n+[#779]: https://github.com/slack-go/slack/pull/779\r\n+[#782]: https://github.com/slack-go/slack/pull/782\r\n+[#783]: https://github.com/slack-go/slack/pull/783\r\n+[#787]: https://github.com/slack-go/slack/pull/787\r\n+[#790]: https://github.com/slack-go/slack/pull/790\r\n+[#791]: https://github.com/slack-go/slack/pull/791\r\n+[#793]: https://github.com/slack-go/slack/pull/793\r\n+[#794]: https://github.com/slack-go/slack/pull/794\r\n+[#800]: https://github.com/slack-go/slack/pull/800\r\n+[#810]: https://github.com/slack-go/slack/pull/810\r\n+[#813]: https://github.com/slack-go/slack/pull/813\r\n+[#814]: https://github.com/slack-go/slack/pull/814\r\n+\r\n+### v0.6.0 - August 31, 2019\r\n+full differences can be viewed using `git log --oneline --decorate --color v0.5.0..v0.6.0`\r\n+thanks to everyone who has contributed since January!\r\n+\r\n+\r\n+#### Breaking Changes:\r\n+- Info struct has had fields removed related to deprecated functionality by slack.\r\n+- minor adjustments to some structs.\r\n+- some internal default values have changed, usually to be more inline with slack defaults or to correct inability to set a particular value. (Message Parse for example.)\r\n+\r\n+##### Highlights:\r\n+- new slacktest package easy mocking for slack client. use, enjoy, please submit PRs for improvements and default behaviours! shamelessly taken from the [slack-test repo](https://github.com/lusis/slack-test) thank you lusis for letting us use it and bring it into the slack repo.\r\n+- blocks, blocks, blocks.\r\n+- RTM ManagedConnection has undergone a significant cleanup.\r\n+in particular handles backoffs gracefully, removed many deadlocks,\r\n+and Disconnect is now much more responsive.\r\n+\r\n+### v0.5.0 - January 20, 2019\r\n+full differences can be viewed using `git log --oneline --decorate --color v0.4.0..v0.5.0`\r\n+- Breaking changes: various old struct fields have been removed or updated to match slack's api.\r\n+- deadlock fix in RTM disconnect.\r\n+\r\n+### v0.4.0 - October 06, 2018\r\n+full differences can be viewed using `git log --oneline --decorate --color v0.3.0..v0.4.0`\r\n+- Breaking Change: renamed ApplyMessageOption, to mark it as unsafe,\r\n+this means it may break without warning in the future.\r\n+- Breaking: Msg structure files field changed to an array.\r\n+- General: implementation for new security headers.\r\n+- RTM: deadlock fix between connect/disconnect.\r\n+- Events: various new fields added.\r\n+- Web: various fixes, new fields exposed, new methods added.\r\n+- Interactions: minor additions expect breaking changes in next release for dialogs/button clicks.\r\n+- Utils: new methods added.\r\n+\r\n+### v0.3.0 - July 30, 2018\r\n+full differences can be viewed using `git log --oneline --decorate --color v0.2.0..v0.3.0`\r\n+- slack events initial support added. (still considered experimental and undergoing changes, stability not promised)\r\n+- vendored depedencies using dep, ensure using up to date tooling before filing issues.\r\n+- RTM has improved its ability to identify dead connections and reconnect automatically (worth calling out in case it has unintended side effects).\r\n+- bug fixes (various timestamp handling, error handling, RTM locking, etc).\r\n+\r\n+### v0.2.0 - Feb 10, 2018\r\n+\r\n+Release adds a bunch of functionality and improvements, mainly to give people a recent version to vendor against.\r\n+\r\n+Please check [0.2.0](https://github.com/nlopes/slack/releases/tag/v0.2.0)\r\n+\r\n+### v0.1.0 - May 28, 2017\r\n+\r\n+This is released before adding context support.\r\n+As the used context package is the one from Go 1.7 this will be the last\r\n+compatible with Go < 1.7.\r\n+\r\n+Please check [0.1.0](https://github.com/nlopes/slack/releases/tag/v0.1.0)\r\n+\r\n+### v0.0.1 - Jul 26, 2015\r\n+\r\n+If you just updated from master and it broke your implementation, please\r\n+check [0.0.1](https://github.com/nlopes/slack/releases/tag/v0.0.1)\r"
    },
    {
      "sha": "5145171f1d31a7e3eb25df781fcffcadd19feee2",
      "filename": "backend/vendor/github.com/slack-go/slack/LICENSE",
      "status": "added",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/LICENSE",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/LICENSE?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,23 @@\n+Copyright (c) 2015, Norberto Lopes\n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without modification,\n+are permitted provided that the following conditions are met:\n+\n+1. Redistributions of source code must retain the above copyright notice, this\n+list of conditions and the following disclaimer.\n+\n+2. Redistributions in binary form must reproduce the above copyright notice,\n+this list of conditions and the following disclaimer in the documentation and/or\n+other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
    },
    {
      "sha": "72796401642af65697a718da4eb392e7516ae855",
      "filename": "backend/vendor/github.com/slack-go/slack/Makefile",
      "status": "added",
      "additions": 36,
      "deletions": 0,
      "changes": 36,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/Makefile",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/Makefile",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/Makefile?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,36 @@\n+.PHONY: help deps fmt lint test test-race test-integration\n+\n+help:\n+\t@echo \"\"\n+\t@echo \"Welcome to slack-go/slack make.\"\n+\t@echo \"The following commands are available:\"\n+\t@echo \"\"\n+\t@echo \"    make deps              : Fetch all dependencies\"\n+\t@echo \"    make fmt               : Run go fmt to fix any formatting issues\"\n+\t@echo \"    make lint              : Use go vet to check for linting issues\"\n+\t@echo \"    make test              : Run all short tests\"\n+\t@echo \"    make test-race         : Run all tests with race condition checking\"\n+\t@echo \"    make test-integration  : Run all tests without limiting to short\"\n+\t@echo \"\"\n+\t@echo \"    make pr-prep           : Run this before making a PR to run fmt, lint and tests\"\n+\t@echo \"\"\n+\n+deps:\n+\t@go mod tidy\n+\n+fmt:\n+\t@go fmt .\n+\n+lint:\n+\t@go vet .\n+\n+test:\n+\t@go test -v -count=1 -timeout 300s -short ./...\n+\n+test-race:\n+\t@go test -v -count=1 -timeout 300s -short -race ./...\n+\n+test-integration:\n+\t@go test -v -count=1 -timeout 600s ./...\n+\n+pr-prep: fmt lint test-race test-integration"
    },
    {
      "sha": "7be8906641ecf98f3451ecc8c8013f3c8bbc5161",
      "filename": "backend/vendor/github.com/slack-go/slack/README.md",
      "status": "added",
      "additions": 97,
      "deletions": 0,
      "changes": 97,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/README.md",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/README.md?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,97 @@\n+Slack API in Go [![GoDoc](https://godoc.org/github.com/slack-go/slack?status.svg)](https://godoc.org/github.com/slack-go/slack) [![Build Status](https://travis-ci.org/slack-go/slack.svg)](https://travis-ci.org/slack-go/slack)\n+===============\n+This is the original Slack library for Go created by Norberto Lopes, transferred to a Github organization.\n+\n+[![Join the chat at https://gitter.im/go-slack/Lobby](https://badges.gitter.im/go-slack/Lobby.svg)](https://gitter.im/go-slack/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n+\n+![logo](logo.png \"icon\")\n+\n+This library supports most if not all of the `api.slack.com` REST\n+calls, as well as the Real-Time Messaging protocol over websocket, in\n+a fully managed way.\n+\n+## Project Status\n+There is currently no major version released.\n+Therefore, minor version releases may include backward incompatible changes.\n+\n+See [CHANGELOG.md](https://github.com/slack-go/slack/blob/master/CHANGELOG.md) for more information about the changes.\n+\n+## Installing\n+\n+### *go get*\n+\n+    $ go get -u github.com/slack-go/slack\n+\n+## Example\n+\n+### Getting all groups\n+\n+```golang\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/slack-go/slack\"\n+)\n+\n+func main() {\n+\tapi := slack.New(\"YOUR_TOKEN_HERE\")\n+\t// If you set debugging, it will log all requests to the console\n+\t// Useful when encountering issues\n+\t// slack.New(\"YOUR_TOKEN_HERE\", slack.OptionDebug(true))\n+\tgroups, err := api.GetGroups(false)\n+\tif err != nil {\n+\t\tfmt.Printf(\"%s\\n\", err)\n+\t\treturn\n+\t}\n+\tfor _, group := range groups {\n+\t\tfmt.Printf(\"ID: %s, Name: %s\\n\", group.ID, group.Name)\n+\t}\n+}\n+```\n+\n+### Getting User Information\n+\n+```golang\n+import (\n+    \"fmt\"\n+\n+    \"github.com/slack-go/slack\"\n+)\n+\n+func main() {\n+    api := slack.New(\"YOUR_TOKEN_HERE\")\n+    user, err := api.GetUserInfo(\"U023BECGF\")\n+    if err != nil {\n+\t    fmt.Printf(\"%s\\n\", err)\n+\t    return\n+    }\n+    fmt.Printf(\"ID: %s, Fullname: %s, Email: %s\\n\", user.ID, user.Profile.RealName, user.Profile.Email)\n+}\n+```\n+\n+## Minimal RTM usage:\n+\n+See https://github.com/slack-go/slack/blob/master/examples/websocket/websocket.go\n+\n+\n+## Minimal EventsAPI usage:\n+\n+See https://github.com/slack-go/slack/blob/master/examples/eventsapi/events.go\n+\n+\n+## Contributing\n+\n+You are more than welcome to contribute to this project.  Fork and\n+make a Pull Request, or create an Issue if you see any problem.\n+\n+Before making any Pull Request please run the following:\n+\n+```\n+make pr-prep\n+```\n+\n+This will check/update code formatting, linting and then run all tests\n+\n+## License\n+\n+BSD 2 Clause license"
    },
    {
      "sha": "8607960b86d7986a3be011ddb606a28c76dad099",
      "filename": "backend/vendor/github.com/slack-go/slack/TODO.txt",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/TODO.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/TODO.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/TODO.txt?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,3 @@\n+- Add more tests!!!\n+- Add support to have markdown hints\n+  - See section Message Formatting at https://api.slack.com/docs/formatting"
    },
    {
      "sha": "d51426b565779778d758855ff1bd23a62e0b4efa",
      "filename": "backend/vendor/github.com/slack-go/slack/admin.go",
      "status": "added",
      "additions": 207,
      "deletions": 0,
      "changes": 207,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/admin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/admin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/admin.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,207 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/url\"\n+\t\"strings\"\n+)\n+\n+func (api *Client) adminRequest(ctx context.Context, method string, teamName string, values url.Values) error {\n+\tresp := &SlackResponse{}\n+\terr := parseAdminResponse(ctx, api.httpclient, method, teamName, values, resp, api)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn resp.Err()\n+}\n+\n+// DisableUser disabled a user account, given a user ID\n+func (api *Client) DisableUser(teamName string, uid string) error {\n+\treturn api.DisableUserContext(context.Background(), teamName, uid)\n+}\n+\n+// DisableUserContext disabled a user account, given a user ID with a custom context\n+func (api *Client) DisableUserContext(ctx context.Context, teamName string, uid string) error {\n+\tvalues := url.Values{\n+\t\t\"user\":       {uid},\n+\t\t\"token\":      {api.token},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t}\n+\n+\tif err := api.adminRequest(ctx, \"setInactive\", teamName, values); err != nil {\n+\t\treturn fmt.Errorf(\"failed to disable user with id '%s': %s\", uid, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// InviteGuest invites a user to Slack as a single-channel guest\n+func (api *Client) InviteGuest(teamName, channel, firstName, lastName, emailAddress string) error {\n+\treturn api.InviteGuestContext(context.Background(), teamName, channel, firstName, lastName, emailAddress)\n+}\n+\n+// InviteGuestContext invites a user to Slack as a single-channel guest with a custom context\n+func (api *Client) InviteGuestContext(ctx context.Context, teamName, channel, firstName, lastName, emailAddress string) error {\n+\tvalues := url.Values{\n+\t\t\"email\":            {emailAddress},\n+\t\t\"channels\":         {channel},\n+\t\t\"first_name\":       {firstName},\n+\t\t\"last_name\":        {lastName},\n+\t\t\"ultra_restricted\": {\"1\"},\n+\t\t\"token\":            {api.token},\n+\t\t\"resend\":           {\"true\"},\n+\t\t\"set_active\":       {\"true\"},\n+\t\t\"_attempts\":        {\"1\"},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"invite\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"Failed to invite single-channel guest: %s\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// InviteRestricted invites a user to Slack as a restricted account\n+func (api *Client) InviteRestricted(teamName, channel, firstName, lastName, emailAddress string) error {\n+\treturn api.InviteRestrictedContext(context.Background(), teamName, channel, firstName, lastName, emailAddress)\n+}\n+\n+// InviteRestrictedContext invites a user to Slack as a restricted account with a custom context\n+func (api *Client) InviteRestrictedContext(ctx context.Context, teamName, channel, firstName, lastName, emailAddress string) error {\n+\tvalues := url.Values{\n+\t\t\"email\":      {emailAddress},\n+\t\t\"channels\":   {channel},\n+\t\t\"first_name\": {firstName},\n+\t\t\"last_name\":  {lastName},\n+\t\t\"restricted\": {\"1\"},\n+\t\t\"token\":      {api.token},\n+\t\t\"resend\":     {\"true\"},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"invite\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"Failed to restricted account: %s\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// InviteToTeam invites a user to a Slack team\n+func (api *Client) InviteToTeam(teamName, firstName, lastName, emailAddress string) error {\n+\treturn api.InviteToTeamContext(context.Background(), teamName, firstName, lastName, emailAddress)\n+}\n+\n+// InviteToTeamContext invites a user to a Slack team with a custom context\n+func (api *Client) InviteToTeamContext(ctx context.Context, teamName, firstName, lastName, emailAddress string) error {\n+\tvalues := url.Values{\n+\t\t\"email\":      {emailAddress},\n+\t\t\"first_name\": {firstName},\n+\t\t\"last_name\":  {lastName},\n+\t\t\"token\":      {api.token},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"invite\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"Failed to invite to team: %s\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// SetRegular enables the specified user\n+func (api *Client) SetRegular(teamName, user string) error {\n+\treturn api.SetRegularContext(context.Background(), teamName, user)\n+}\n+\n+// SetRegularContext enables the specified user with a custom context\n+func (api *Client) SetRegularContext(ctx context.Context, teamName, user string) error {\n+\tvalues := url.Values{\n+\t\t\"user\":       {user},\n+\t\t\"token\":      {api.token},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"setRegular\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"Failed to change the user (%s) to a regular user: %s\", user, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// SendSSOBindingEmail sends an SSO binding email to the specified user\n+func (api *Client) SendSSOBindingEmail(teamName, user string) error {\n+\treturn api.SendSSOBindingEmailContext(context.Background(), teamName, user)\n+}\n+\n+// SendSSOBindingEmailContext sends an SSO binding email to the specified user with a custom context\n+func (api *Client) SendSSOBindingEmailContext(ctx context.Context, teamName, user string) error {\n+\tvalues := url.Values{\n+\t\t\"user\":       {user},\n+\t\t\"token\":      {api.token},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"sendSSOBind\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"Failed to send SSO binding email for user (%s): %s\", user, err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// SetUltraRestricted converts a user into a single-channel guest\n+func (api *Client) SetUltraRestricted(teamName, uid, channel string) error {\n+\treturn api.SetUltraRestrictedContext(context.Background(), teamName, uid, channel)\n+}\n+\n+// SetUltraRestrictedContext converts a user into a single-channel guest with a custom context\n+func (api *Client) SetUltraRestrictedContext(ctx context.Context, teamName, uid, channel string) error {\n+\tvalues := url.Values{\n+\t\t\"user\":       {uid},\n+\t\t\"channel\":    {channel},\n+\t\t\"token\":      {api.token},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"setUltraRestricted\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"Failed to ultra-restrict account: %s\", err)\n+\t}\n+\n+\treturn nil\n+}\n+\n+// SetRestricted converts a user into a restricted account\n+func (api *Client) SetRestricted(teamName, uid string, channelIds ...string) error {\n+\treturn api.SetRestrictedContext(context.Background(), teamName, uid, channelIds...)\n+}\n+\n+// SetRestrictedContext converts a user into a restricted account with a custom context\n+func (api *Client) SetRestrictedContext(ctx context.Context, teamName, uid string, channelIds ...string) error {\n+\tvalues := url.Values{\n+\t\t\"user\":       {uid},\n+\t\t\"token\":      {api.token},\n+\t\t\"set_active\": {\"true\"},\n+\t\t\"_attempts\":  {\"1\"},\n+\t\t\"channels\":   {strings.Join(channelIds, \",\")},\n+\t}\n+\n+\terr := api.adminRequest(ctx, \"setRestricted\", teamName, values)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to restrict account: %s\", err)\n+\t}\n+\n+\treturn nil\n+}"
    },
    {
      "sha": "d9749438d70b61b5b452416910f81d7e058fae38",
      "filename": "backend/vendor/github.com/slack-go/slack/apps.go",
      "status": "added",
      "additions": 61,
      "deletions": 0,
      "changes": 61,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/apps.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/apps.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/apps.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,61 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"net/url\"\n+)\n+\n+type listEventAuthorizationsResponse struct {\n+\tSlackResponse\n+\tAuthorizations []EventAuthorization `json:\"authorizations\"`\n+}\n+\n+type EventAuthorization struct {\n+\tEnterpriseID        string `json:\"enterprise_id\"`\n+\tTeamID              string `json:\"team_id\"`\n+\tUserID              string `json:\"user_id\"`\n+\tIsBot               bool   `json:\"is_bot\"`\n+\tIsEnterpriseInstall bool   `json:\"is_enterprise_install\"`\n+}\n+\n+func (api *Client) ListEventAuthorizations(eventContext string) ([]EventAuthorization, error) {\n+\treturn api.ListEventAuthorizationsContext(context.Background(), eventContext)\n+}\n+\n+// ListEventAuthorizationsContext lists authed users and teams for the given event_context. You must provide an app-level token to the client using OptionAppLevelToken. More info: https://api.slack.com/methods/apps.event.authorizations.list\n+func (api *Client) ListEventAuthorizationsContext(ctx context.Context, eventContext string) ([]EventAuthorization, error) {\n+\tresp := &listEventAuthorizationsResponse{}\n+\n+\trequest, _ := json.Marshal(map[string]string{\n+\t\t\"event_context\": eventContext,\n+\t})\n+\n+\terr := postJSON(ctx, api.httpclient, api.endpoint+\"apps.event.authorizations.list\", api.appLevelToken, request, &resp, api)\n+\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif !resp.Ok {\n+\t\treturn nil, resp.Err()\n+\t}\n+\n+\treturn resp.Authorizations, nil\n+}\n+\n+func (api *Client) UninstallApp(clientID, clientSecret string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":         {api.token},\n+\t\t\"client_id\":     {clientID},\n+\t\t\"client_secret\": {clientSecret},\n+\t}\n+\n+\tresponse := SlackResponse{}\n+\n+\terr := api.getMethod(context.Background(), \"apps.uninstall\", values, &response)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}"
    },
    {
      "sha": "69b223a29051ce9918e02726563d93e96e9a5a17",
      "filename": "backend/vendor/github.com/slack-go/slack/attachments.go",
      "status": "added",
      "additions": 98,
      "deletions": 0,
      "changes": 98,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/attachments.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/attachments.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/attachments.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,98 @@\n+package slack\n+\n+import \"encoding/json\"\n+\n+// AttachmentField contains information for an attachment field\n+// An Attachment can contain multiple of these\n+type AttachmentField struct {\n+\tTitle string `json:\"title\"`\n+\tValue string `json:\"value\"`\n+\tShort bool   `json:\"short\"`\n+}\n+\n+// AttachmentAction is a button or menu to be included in the attachment. Required when\n+// using message buttons or menus and otherwise not useful. A maximum of 5 actions may be\n+// provided per attachment.\n+type AttachmentAction struct {\n+\tName            string                        `json:\"name\"`                       // Required.\n+\tText            string                        `json:\"text\"`                       // Required.\n+\tStyle           string                        `json:\"style,omitempty\"`            // Optional. Allowed values: \"default\", \"primary\", \"danger\".\n+\tType            actionType                    `json:\"type\"`                       // Required. Must be set to \"button\" or \"select\".\n+\tValue           string                        `json:\"value,omitempty\"`            // Optional.\n+\tDataSource      string                        `json:\"data_source,omitempty\"`      // Optional.\n+\tMinQueryLength  int                           `json:\"min_query_length,omitempty\"` // Optional. Default value is 1.\n+\tOptions         []AttachmentActionOption      `json:\"options,omitempty\"`          // Optional. Maximum of 100 options can be provided in each menu.\n+\tSelectedOptions []AttachmentActionOption      `json:\"selected_options,omitempty\"` // Optional. The first element of this array will be set as the pre-selected option for this menu.\n+\tOptionGroups    []AttachmentActionOptionGroup `json:\"option_groups,omitempty\"`    // Optional.\n+\tConfirm         *ConfirmationField            `json:\"confirm,omitempty\"`          // Optional.\n+\tURL             string                        `json:\"url,omitempty\"`              // Optional.\n+}\n+\n+// actionType returns the type of the action\n+func (a AttachmentAction) actionType() actionType {\n+\treturn a.Type\n+}\n+\n+// AttachmentActionOption the individual option to appear in action menu.\n+type AttachmentActionOption struct {\n+\tText        string `json:\"text\"`                  // Required.\n+\tValue       string `json:\"value\"`                 // Required.\n+\tDescription string `json:\"description,omitempty\"` // Optional. Up to 30 characters.\n+}\n+\n+// AttachmentActionOptionGroup is a semi-hierarchal way to list available options to appear in action menu.\n+type AttachmentActionOptionGroup struct {\n+\tText    string                   `json:\"text\"`    // Required.\n+\tOptions []AttachmentActionOption `json:\"options\"` // Required.\n+}\n+\n+// AttachmentActionCallback is sent from Slack when a user clicks a button in an interactive message (aka AttachmentAction)\n+// DEPRECATED: use InteractionCallback\n+type AttachmentActionCallback InteractionCallback\n+\n+// ConfirmationField are used to ask users to confirm actions\n+type ConfirmationField struct {\n+\tTitle       string `json:\"title,omitempty\"`        // Optional.\n+\tText        string `json:\"text\"`                   // Required.\n+\tOkText      string `json:\"ok_text,omitempty\"`      // Optional. Defaults to \"Okay\"\n+\tDismissText string `json:\"dismiss_text,omitempty\"` // Optional. Defaults to \"Cancel\"\n+}\n+\n+// Attachment contains all the information for an attachment\n+type Attachment struct {\n+\tColor    string `json:\"color,omitempty\"`\n+\tFallback string `json:\"fallback,omitempty\"`\n+\n+\tCallbackID string `json:\"callback_id,omitempty\"`\n+\tID         int    `json:\"id,omitempty\"`\n+\n+\tAuthorID      string `json:\"author_id,omitempty\"`\n+\tAuthorName    string `json:\"author_name,omitempty\"`\n+\tAuthorSubname string `json:\"author_subname,omitempty\"`\n+\tAuthorLink    string `json:\"author_link,omitempty\"`\n+\tAuthorIcon    string `json:\"author_icon,omitempty\"`\n+\n+\tTitle     string `json:\"title,omitempty\"`\n+\tTitleLink string `json:\"title_link,omitempty\"`\n+\tPretext   string `json:\"pretext,omitempty\"`\n+\tText      string `json:\"text,omitempty\"`\n+\n+\tImageURL string `json:\"image_url,omitempty\"`\n+\tThumbURL string `json:\"thumb_url,omitempty\"`\n+\n+\tServiceName string `json:\"service_name,omitempty\"`\n+\tServiceIcon string `json:\"service_icon,omitempty\"`\n+\tFromURL     string `json:\"from_url,omitempty\"`\n+\tOriginalURL string `json:\"original_url,omitempty\"`\n+\n+\tFields     []AttachmentField  `json:\"fields,omitempty\"`\n+\tActions    []AttachmentAction `json:\"actions,omitempty\"`\n+\tMarkdownIn []string           `json:\"mrkdwn_in,omitempty\"`\n+\n+\tBlocks Blocks `json:\"blocks,omitempty\"`\n+\n+\tFooter     string `json:\"footer,omitempty\"`\n+\tFooterIcon string `json:\"footer_icon,omitempty\"`\n+\n+\tTs json.Number `json:\"ts,omitempty\"`\n+}"
    },
    {
      "sha": "f4f7f003ac24812819ac2a961f0700132c2a6946",
      "filename": "backend/vendor/github.com/slack-go/slack/auth.go",
      "status": "added",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/auth.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/auth.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/auth.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,40 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+)\n+\n+// AuthRevokeResponse contains our Auth response from the auth.revoke endpoint\n+type AuthRevokeResponse struct {\n+\tSlackResponse      // Contains the \"ok\", and \"Error\", if any\n+\tRevoked       bool `json:\"revoked,omitempty\"`\n+}\n+\n+// authRequest sends the actual request, and unmarshals the response\n+func (api *Client) authRequest(ctx context.Context, path string, values url.Values) (*AuthRevokeResponse, error) {\n+\tresponse := &AuthRevokeResponse{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// SendAuthRevoke will send a revocation for our token\n+func (api *Client) SendAuthRevoke(token string) (*AuthRevokeResponse, error) {\n+\treturn api.SendAuthRevokeContext(context.Background(), token)\n+}\n+\n+// SendAuthRevokeContext will send a revocation request for our token to api.revoke with context\n+func (api *Client) SendAuthRevokeContext(ctx context.Context, token string) (*AuthRevokeResponse, error) {\n+\tif token == \"\" {\n+\t\ttoken = api.token\n+\t}\n+\tvalues := url.Values{\n+\t\t\"token\": {token},\n+\t}\n+\n+\treturn api.authRequest(ctx, \"auth.revoke\", values)\n+}"
    },
    {
      "sha": "9946a2943b8f29d3f2c8d7909f314915f4da7390",
      "filename": "backend/vendor/github.com/slack-go/slack/block.go",
      "status": "added",
      "additions": 80,
      "deletions": 0,
      "changes": 80,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,80 @@\n+package slack\n+\n+// @NOTE: Blocks are in beta and subject to change.\n+\n+// More Information: https://api.slack.com/block-kit\n+\n+// MessageBlockType defines a named string type to define each block type\n+// as a constant for use within the package.\n+type MessageBlockType string\n+\n+const (\n+\tMBTSection MessageBlockType = \"section\"\n+\tMBTDivider MessageBlockType = \"divider\"\n+\tMBTImage   MessageBlockType = \"image\"\n+\tMBTAction  MessageBlockType = \"actions\"\n+\tMBTContext MessageBlockType = \"context\"\n+\tMBTFile    MessageBlockType = \"file\"\n+\tMBTInput   MessageBlockType = \"input\"\n+\tMBTHeader  MessageBlockType = \"header\"\n+)\n+\n+// Block defines an interface all block types should implement\n+// to ensure consistency between blocks.\n+type Block interface {\n+\tBlockType() MessageBlockType\n+}\n+\n+// Blocks is a convenience struct defined to allow dynamic unmarshalling of\n+// the \"blocks\" value in Slack's JSON response, which varies depending on block type\n+type Blocks struct {\n+\tBlockSet []Block `json:\"blocks,omitempty\"`\n+}\n+\n+// BlockAction is the action callback sent when a block is interacted with\n+type BlockAction struct {\n+\tActionID              string              `json:\"action_id\"`\n+\tBlockID               string              `json:\"block_id\"`\n+\tType                  actionType          `json:\"type\"`\n+\tText                  TextBlockObject     `json:\"text\"`\n+\tValue                 string              `json:\"value\"`\n+\tActionTs              string              `json:\"action_ts\"`\n+\tSelectedOption        OptionBlockObject   `json:\"selected_option\"`\n+\tSelectedOptions       []OptionBlockObject `json:\"selected_options\"`\n+\tSelectedUser          string              `json:\"selected_user\"`\n+\tSelectedUsers         []string            `json:\"selected_users\"`\n+\tSelectedChannel       string              `json:\"selected_channel\"`\n+\tSelectedChannels      []string            `json:\"selected_channels\"`\n+\tSelectedConversation  string              `json:\"selected_conversation\"`\n+\tSelectedConversations []string            `json:\"selected_conversations\"`\n+\tSelectedDate          string              `json:\"selected_date\"`\n+\tSelectedTime          string              `json:\"selected_time\"`\n+\tInitialOption         OptionBlockObject   `json:\"initial_option\"`\n+\tInitialUser           string              `json:\"initial_user\"`\n+\tInitialChannel        string              `json:\"initial_channel\"`\n+\tInitialConversation   string              `json:\"initial_conversation\"`\n+\tInitialDate           string              `json:\"initial_date\"`\n+\tInitialTime           string              `json:\"initial_time\"`\n+}\n+\n+// actionType returns the type of the action\n+func (b BlockAction) actionType() actionType {\n+\treturn b.Type\n+}\n+\n+// NewBlockMessage creates a new Message that contains one or more blocks to be displayed\n+func NewBlockMessage(blocks ...Block) Message {\n+\treturn Message{\n+\t\tMsg: Msg{\n+\t\t\tBlocks: Blocks{\n+\t\t\t\tBlockSet: blocks,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+// AddBlockMessage appends a block to the end of the existing list of blocks\n+func AddBlockMessage(message Message, newBlk Block) Message {\n+\tmessage.Msg.Blocks.BlockSet = append(message.Msg.Blocks.BlockSet, newBlk)\n+\treturn message\n+}"
    },
    {
      "sha": "c15e4a3f7acb2af76ebb87cbe8363f73a70287cb",
      "filename": "backend/vendor/github.com/slack-go/slack/block_action.go",
      "status": "added",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_action.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_action.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_action.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,26 @@\n+package slack\n+\n+// ActionBlock defines data that is used to hold interactive elements.\n+//\n+// More Information: https://api.slack.com/reference/messaging/blocks#actions\n+type ActionBlock struct {\n+\tType     MessageBlockType `json:\"type\"`\n+\tBlockID  string           `json:\"block_id,omitempty\"`\n+\tElements *BlockElements   `json:\"elements\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s ActionBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// NewActionBlock returns a new instance of an Action Block\n+func NewActionBlock(blockID string, elements ...BlockElement) *ActionBlock {\n+\treturn &ActionBlock{\n+\t\tType:    MBTAction,\n+\t\tBlockID: blockID,\n+\t\tElements: &BlockElements{\n+\t\t\tElementSet: elements,\n+\t\t},\n+\t}\n+}"
    },
    {
      "sha": "c37bf27e986bf0402e438bf5c8d75f5361b5e3b9",
      "filename": "backend/vendor/github.com/slack-go/slack/block_context.go",
      "status": "added",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_context.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_context.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_context.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,32 @@\n+package slack\n+\n+// ContextBlock defines data that is used to display message context, which can\n+// include both images and text.\n+//\n+// More Information: https://api.slack.com/reference/messaging/blocks#actions\n+type ContextBlock struct {\n+\tType            MessageBlockType `json:\"type\"`\n+\tBlockID         string           `json:\"block_id,omitempty\"`\n+\tContextElements ContextElements  `json:\"elements\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s ContextBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+type ContextElements struct {\n+\tElements []MixedElement\n+}\n+\n+// NewContextBlock returns a new instance of a context block\n+func NewContextBlock(blockID string, mixedElements ...MixedElement) *ContextBlock {\n+\telements := ContextElements{\n+\t\tElements: mixedElements,\n+\t}\n+\treturn &ContextBlock{\n+\t\tType:            MBTContext,\n+\t\tBlockID:         blockID,\n+\t\tContextElements: elements,\n+\t}\n+}"
    },
    {
      "sha": "f2d744c49bfecde78bd288ad745844f47e2e9616",
      "filename": "backend/vendor/github.com/slack-go/slack/block_conv.go",
      "status": "added",
      "additions": 417,
      "deletions": 0,
      "changes": 417,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_conv.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_conv.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_conv.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,417 @@\n+package slack\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\n+\t\"github.com/pkg/errors\"\n+)\n+\n+type sumtype struct {\n+\tTypeVal string `json:\"type\"`\n+}\n+\n+// MarshalJSON implements the Marshaller interface for Blocks so that any JSON\n+// marshalling is delegated and proper type determination can be made before marshal\n+func (b Blocks) MarshalJSON() ([]byte, error) {\n+\tbytes, err := json.Marshal(b.BlockSet)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn bytes, nil\n+}\n+\n+// UnmarshalJSON implements the Unmarshaller interface for Blocks, so that any JSON\n+// unmarshalling is delegated and proper type determination can be made before unmarshal\n+func (b *Blocks) UnmarshalJSON(data []byte) error {\n+\tvar raw []json.RawMessage\n+\n+\tif string(data) == \"{}\" {\n+\t\treturn nil\n+\t}\n+\n+\terr := json.Unmarshal(data, &raw)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar blocks Blocks\n+\tfor _, r := range raw {\n+\t\ts := sumtype{}\n+\t\terr := json.Unmarshal(r, &s)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tvar blockType string\n+\t\tif s.TypeVal != \"\" {\n+\t\t\tblockType = s.TypeVal\n+\t\t}\n+\n+\t\tvar block Block\n+\t\tswitch blockType {\n+\t\tcase \"actions\":\n+\t\t\tblock = &ActionBlock{}\n+\t\tcase \"context\":\n+\t\t\tblock = &ContextBlock{}\n+\t\tcase \"divider\":\n+\t\t\tblock = &DividerBlock{}\n+\t\tcase \"file\":\n+\t\t\tblock = &FileBlock{}\n+\t\tcase \"header\":\n+\t\t\tblock = &HeaderBlock{}\n+\t\tcase \"image\":\n+\t\t\tblock = &ImageBlock{}\n+\t\tcase \"input\":\n+\t\t\tblock = &InputBlock{}\n+\t\tcase \"section\":\n+\t\t\tblock = &SectionBlock{}\n+\t\tdefault:\n+\t\t\tblock = &UnknownBlock{}\n+\t\t}\n+\n+\t\terr = json.Unmarshal(r, block)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tblocks.BlockSet = append(blocks.BlockSet, block)\n+\t}\n+\n+\t*b = blocks\n+\treturn nil\n+}\n+\n+// UnmarshalJSON implements the Unmarshaller interface for InputBlock, so that any JSON\n+// unmarshalling is delegated and proper type determination can be made before unmarshal\n+func (b *InputBlock) UnmarshalJSON(data []byte) error {\n+\ttype alias InputBlock\n+\ta := struct {\n+\t\tElement json.RawMessage `json:\"element\"`\n+\t\t*alias\n+\t}{\n+\t\talias: (*alias)(b),\n+\t}\n+\n+\tif err := json.Unmarshal(data, &a); err != nil {\n+\t\treturn err\n+\t}\n+\n+\ts := sumtype{}\n+\tif err := json.Unmarshal(a.Element, &s); err != nil {\n+\t\treturn nil\n+\t}\n+\n+\tvar e BlockElement\n+\tswitch s.TypeVal {\n+\tcase \"datepicker\":\n+\t\te = &DatePickerBlockElement{}\n+\tcase \"timepicker\":\n+\t\te = &TimePickerBlockElement{}\n+\tcase \"plain_text_input\":\n+\t\te = &PlainTextInputBlockElement{}\n+\tcase \"static_select\", \"external_select\", \"users_select\", \"conversations_select\", \"channels_select\":\n+\t\te = &SelectBlockElement{}\n+\tcase \"multi_static_select\", \"multi_external_select\", \"multi_users_select\", \"multi_conversations_select\", \"multi_channels_select\":\n+\t\te = &MultiSelectBlockElement{}\n+\tcase \"checkboxes\":\n+\t\te = &CheckboxGroupsBlockElement{}\n+\tcase \"overflow\":\n+\t\te = &OverflowBlockElement{}\n+\tcase \"radio_buttons\":\n+\t\te = &RadioButtonsBlockElement{}\n+\tdefault:\n+\t\treturn errors.New(\"unsupported block element type\")\n+\t}\n+\n+\tif err := json.Unmarshal(a.Element, e); err != nil {\n+\t\treturn err\n+\t}\n+\tb.Element = e\n+\n+\treturn nil\n+}\n+\n+// MarshalJSON implements the Marshaller interface for BlockElements so that any JSON\n+// marshalling is delegated and proper type determination can be made before marshal\n+func (b *BlockElements) MarshalJSON() ([]byte, error) {\n+\tbytes, err := json.Marshal(b.ElementSet)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn bytes, nil\n+}\n+\n+// UnmarshalJSON implements the Unmarshaller interface for BlockElements, so that any JSON\n+// unmarshalling is delegated and proper type determination can be made before unmarshal\n+func (b *BlockElements) UnmarshalJSON(data []byte) error {\n+\tvar raw []json.RawMessage\n+\n+\tif string(data) == \"{}\" {\n+\t\treturn nil\n+\t}\n+\n+\terr := json.Unmarshal(data, &raw)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar blockElements BlockElements\n+\tfor _, r := range raw {\n+\t\ts := sumtype{}\n+\t\terr := json.Unmarshal(r, &s)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tvar blockElementType string\n+\t\tif s.TypeVal != \"\" {\n+\t\t\tblockElementType = s.TypeVal\n+\t\t}\n+\n+\t\tvar blockElement BlockElement\n+\t\tswitch blockElementType {\n+\t\tcase \"image\":\n+\t\t\tblockElement = &ImageBlockElement{}\n+\t\tcase \"button\":\n+\t\t\tblockElement = &ButtonBlockElement{}\n+\t\tcase \"overflow\":\n+\t\t\tblockElement = &OverflowBlockElement{}\n+\t\tcase \"datepicker\":\n+\t\t\tblockElement = &DatePickerBlockElement{}\n+\t\tcase \"plain_text_input\":\n+\t\t\tblockElement = &PlainTextInputBlockElement{}\n+\t\tcase \"checkboxes\":\n+\t\t\tblockElement = &CheckboxGroupsBlockElement{}\n+\t\tcase \"radio_buttons\":\n+\t\t\tblockElement = &RadioButtonsBlockElement{}\n+\t\tcase \"static_select\", \"external_select\", \"users_select\", \"conversations_select\", \"channels_select\":\n+\t\t\tblockElement = &SelectBlockElement{}\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"unsupported block element type %v\", blockElementType)\n+\t\t}\n+\n+\t\terr = json.Unmarshal(r, blockElement)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tblockElements.ElementSet = append(blockElements.ElementSet, blockElement)\n+\t}\n+\n+\t*b = blockElements\n+\treturn nil\n+}\n+\n+// MarshalJSON implements the Marshaller interface for Accessory so that any JSON\n+// marshalling is delegated and proper type determination can be made before marshal\n+func (a *Accessory) MarshalJSON() ([]byte, error) {\n+\tbytes, err := json.Marshal(toBlockElement(a))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn bytes, nil\n+}\n+\n+// UnmarshalJSON implements the Unmarshaller interface for Accessory, so that any JSON\n+// unmarshalling is delegated and proper type determination can be made before unmarshal\n+func (a *Accessory) UnmarshalJSON(data []byte) error {\n+\tvar r json.RawMessage\n+\n+\tif string(data) == \"{\\\"accessory\\\":null}\" {\n+\t\treturn nil\n+\t}\n+\n+\terr := json.Unmarshal(data, &r)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\ts := sumtype{}\n+\terr = json.Unmarshal(r, &s)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar blockElementType string\n+\tif s.TypeVal != \"\" {\n+\t\tblockElementType = s.TypeVal\n+\t}\n+\n+\tswitch blockElementType {\n+\tcase \"image\":\n+\t\telement, err := unmarshalBlockElement(r, &ImageBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.ImageElement = element.(*ImageBlockElement)\n+\tcase \"button\":\n+\t\telement, err := unmarshalBlockElement(r, &ButtonBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.ButtonElement = element.(*ButtonBlockElement)\n+\tcase \"overflow\":\n+\t\telement, err := unmarshalBlockElement(r, &OverflowBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.OverflowElement = element.(*OverflowBlockElement)\n+\tcase \"datepicker\":\n+\t\telement, err := unmarshalBlockElement(r, &DatePickerBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.DatePickerElement = element.(*DatePickerBlockElement)\n+\tcase \"timepicker\":\n+\t\telement, err := unmarshalBlockElement(r, &TimePickerBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.TimePickerElement = element.(*TimePickerBlockElement)\n+\tcase \"plain_text_input\":\n+\t\telement, err := unmarshalBlockElement(r, &PlainTextInputBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.PlainTextInputElement = element.(*PlainTextInputBlockElement)\n+\tcase \"radio_buttons\":\n+\t\telement, err := unmarshalBlockElement(r, &RadioButtonsBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.RadioButtonsElement = element.(*RadioButtonsBlockElement)\n+\tcase \"static_select\", \"external_select\", \"users_select\", \"conversations_select\", \"channels_select\":\n+\t\telement, err := unmarshalBlockElement(r, &SelectBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.SelectElement = element.(*SelectBlockElement)\n+\tcase \"multi_static_select\", \"multi_external_select\", \"multi_users_select\", \"multi_conversations_select\", \"multi_channels_select\":\n+\t\telement, err := unmarshalBlockElement(r, &MultiSelectBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.MultiSelectElement = element.(*MultiSelectBlockElement)\n+\tcase \"checkboxes\":\n+\t\telement, err := unmarshalBlockElement(r, &CheckboxGroupsBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.CheckboxGroupsBlockElement = element.(*CheckboxGroupsBlockElement)\n+\tdefault:\n+\t\telement, err := unmarshalBlockElement(r, &UnknownBlockElement{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.UnknownElement = element.(*UnknownBlockElement)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func unmarshalBlockElement(r json.RawMessage, element BlockElement) (BlockElement, error) {\n+\terr := json.Unmarshal(r, element)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn element, nil\n+}\n+\n+func toBlockElement(element *Accessory) BlockElement {\n+\tif element.ImageElement != nil {\n+\t\treturn element.ImageElement\n+\t}\n+\tif element.ButtonElement != nil {\n+\t\treturn element.ButtonElement\n+\t}\n+\tif element.OverflowElement != nil {\n+\t\treturn element.OverflowElement\n+\t}\n+\tif element.DatePickerElement != nil {\n+\t\treturn element.DatePickerElement\n+\t}\n+\tif element.TimePickerElement != nil {\n+\t\treturn element.TimePickerElement\n+\t}\n+\tif element.PlainTextInputElement != nil {\n+\t\treturn element.PlainTextInputElement\n+\t}\n+\tif element.RadioButtonsElement != nil {\n+\t\treturn element.RadioButtonsElement\n+\t}\n+\tif element.CheckboxGroupsBlockElement != nil {\n+\t\treturn element.CheckboxGroupsBlockElement\n+\t}\n+\tif element.SelectElement != nil {\n+\t\treturn element.SelectElement\n+\t}\n+\tif element.MultiSelectElement != nil {\n+\t\treturn element.MultiSelectElement\n+\t}\n+\n+\treturn nil\n+}\n+\n+// MarshalJSON implements the Marshaller interface for ContextElements so that any JSON\n+// marshalling is delegated and proper type determination can be made before marshal\n+func (e *ContextElements) MarshalJSON() ([]byte, error) {\n+\tbytes, err := json.Marshal(e.Elements)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn bytes, nil\n+}\n+\n+// UnmarshalJSON implements the Unmarshaller interface for ContextElements, so that any JSON\n+// unmarshalling is delegated and proper type determination can be made before unmarshal\n+func (e *ContextElements) UnmarshalJSON(data []byte) error {\n+\tvar raw []json.RawMessage\n+\n+\tif string(data) == \"{\\\"elements\\\":null}\" {\n+\t\treturn nil\n+\t}\n+\n+\terr := json.Unmarshal(data, &raw)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor _, r := range raw {\n+\t\ts := sumtype{}\n+\t\terr := json.Unmarshal(r, &s)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tvar contextElementType string\n+\t\tif s.TypeVal != \"\" {\n+\t\t\tcontextElementType = s.TypeVal\n+\t\t}\n+\n+\t\tswitch contextElementType {\n+\t\tcase PlainTextType, MarkdownType:\n+\t\t\telem, err := unmarshalBlockObject(r, &TextBlockObject{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\te.Elements = append(e.Elements, elem.(*TextBlockObject))\n+\t\tcase \"image\":\n+\t\t\telem, err := unmarshalBlockElement(r, &ImageBlockElement{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\te.Elements = append(e.Elements, elem.(*ImageBlockElement))\n+\t\tdefault:\n+\t\t\treturn errors.New(\"unsupported context element type\")\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}"
    },
    {
      "sha": "2d442ba118db4f7b0190614ce4acdd89220db6da",
      "filename": "backend/vendor/github.com/slack-go/slack/block_divider.go",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_divider.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_divider.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_divider.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,22 @@\n+package slack\n+\n+// DividerBlock for displaying a divider line between blocks (similar to <hr> tag in html)\n+//\n+// More Information: https://api.slack.com/reference/messaging/blocks#divider\n+type DividerBlock struct {\n+\tType    MessageBlockType `json:\"type\"`\n+\tBlockID string           `json:\"block_id,omitempty\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s DividerBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// NewDividerBlock returns a new instance of a divider block\n+func NewDividerBlock() *DividerBlock {\n+\treturn &DividerBlock{\n+\t\tType: MBTDivider,\n+\t}\n+\n+}"
    },
    {
      "sha": "bf06844087807233d09b63e6e5e04bad5d2d3d56",
      "filename": "backend/vendor/github.com/slack-go/slack/block_element.go",
      "status": "added",
      "additions": 466,
      "deletions": 0,
      "changes": 466,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_element.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_element.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_element.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,466 @@\n+package slack\n+\n+// https://api.slack.com/reference/messaging/block-elements\n+\n+const (\n+\tMETCheckboxGroups MessageElementType = \"checkboxes\"\n+\tMETImage          MessageElementType = \"image\"\n+\tMETButton         MessageElementType = \"button\"\n+\tMETOverflow       MessageElementType = \"overflow\"\n+\tMETDatepicker     MessageElementType = \"datepicker\"\n+\tMETTimepicker     MessageElementType = \"timepicker\"\n+\tMETPlainTextInput MessageElementType = \"plain_text_input\"\n+\tMETRadioButtons   MessageElementType = \"radio_buttons\"\n+\n+\tMixedElementImage MixedElementType = \"mixed_image\"\n+\tMixedElementText  MixedElementType = \"mixed_text\"\n+\n+\tOptTypeStatic        string = \"static_select\"\n+\tOptTypeExternal      string = \"external_select\"\n+\tOptTypeUser          string = \"users_select\"\n+\tOptTypeConversations string = \"conversations_select\"\n+\tOptTypeChannels      string = \"channels_select\"\n+\n+\tMultiOptTypeStatic        string = \"multi_static_select\"\n+\tMultiOptTypeExternal      string = \"multi_external_select\"\n+\tMultiOptTypeUser          string = \"multi_users_select\"\n+\tMultiOptTypeConversations string = \"multi_conversations_select\"\n+\tMultiOptTypeChannels      string = \"multi_channels_select\"\n+)\n+\n+type MessageElementType string\n+type MixedElementType string\n+\n+// BlockElement defines an interface that all block element types should implement.\n+type BlockElement interface {\n+\tElementType() MessageElementType\n+}\n+\n+type MixedElement interface {\n+\tMixedElementType() MixedElementType\n+}\n+\n+type Accessory struct {\n+\tImageElement               *ImageBlockElement\n+\tButtonElement              *ButtonBlockElement\n+\tOverflowElement            *OverflowBlockElement\n+\tDatePickerElement          *DatePickerBlockElement\n+\tTimePickerElement          *TimePickerBlockElement\n+\tPlainTextInputElement      *PlainTextInputBlockElement\n+\tRadioButtonsElement        *RadioButtonsBlockElement\n+\tSelectElement              *SelectBlockElement\n+\tMultiSelectElement         *MultiSelectBlockElement\n+\tCheckboxGroupsBlockElement *CheckboxGroupsBlockElement\n+\tUnknownElement             *UnknownBlockElement\n+}\n+\n+// NewAccessory returns a new Accessory for a given block element\n+func NewAccessory(element BlockElement) *Accessory {\n+\tswitch element.(type) {\n+\tcase *ImageBlockElement:\n+\t\treturn &Accessory{ImageElement: element.(*ImageBlockElement)}\n+\tcase *ButtonBlockElement:\n+\t\treturn &Accessory{ButtonElement: element.(*ButtonBlockElement)}\n+\tcase *OverflowBlockElement:\n+\t\treturn &Accessory{OverflowElement: element.(*OverflowBlockElement)}\n+\tcase *DatePickerBlockElement:\n+\t\treturn &Accessory{DatePickerElement: element.(*DatePickerBlockElement)}\n+\tcase *TimePickerBlockElement:\n+\t\treturn &Accessory{TimePickerElement: element.(*TimePickerBlockElement)}\n+\tcase *PlainTextInputBlockElement:\n+\t\treturn &Accessory{PlainTextInputElement: element.(*PlainTextInputBlockElement)}\n+\tcase *RadioButtonsBlockElement:\n+\t\treturn &Accessory{RadioButtonsElement: element.(*RadioButtonsBlockElement)}\n+\tcase *SelectBlockElement:\n+\t\treturn &Accessory{SelectElement: element.(*SelectBlockElement)}\n+\tcase *MultiSelectBlockElement:\n+\t\treturn &Accessory{MultiSelectElement: element.(*MultiSelectBlockElement)}\n+\tcase *CheckboxGroupsBlockElement:\n+\t\treturn &Accessory{CheckboxGroupsBlockElement: element.(*CheckboxGroupsBlockElement)}\n+\tdefault:\n+\t\treturn &Accessory{UnknownElement: element.(*UnknownBlockElement)}\n+\t}\n+}\n+\n+// BlockElements is a convenience struct defined to allow dynamic unmarshalling of\n+// the \"elements\" value in Slack's JSON response, which varies depending on BlockElement type\n+type BlockElements struct {\n+\tElementSet []BlockElement `json:\"elements,omitempty\"`\n+}\n+\n+// UnknownBlockElement any block element that this library does not directly support.\n+// See the \"Rich Elements\" section at the following URL:\n+// https://api.slack.com/changelog/2019-09-what-they-see-is-what-you-get-and-more-and-less\n+// New block element types may be introduced by Slack at any time; this is a catch-all for any such block elements.\n+type UnknownBlockElement struct {\n+\tType     MessageElementType `json:\"type\"`\n+\tElements BlockElements\n+}\n+\n+// ElementType returns the type of the Element\n+func (s UnknownBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// ImageBlockElement An element to insert an image - this element can be used\n+// in section and context blocks only. If you want a block with only an image\n+// in it, you're looking for the image block.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#image\n+type ImageBlockElement struct {\n+\tType     MessageElementType `json:\"type\"`\n+\tImageURL string             `json:\"image_url\"`\n+\tAltText  string             `json:\"alt_text\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s ImageBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+func (s ImageBlockElement) MixedElementType() MixedElementType {\n+\treturn MixedElementImage\n+}\n+\n+// NewImageBlockElement returns a new instance of an image block element\n+func NewImageBlockElement(imageURL, altText string) *ImageBlockElement {\n+\treturn &ImageBlockElement{\n+\t\tType:     METImage,\n+\t\tImageURL: imageURL,\n+\t\tAltText:  altText,\n+\t}\n+}\n+\n+// Style is a style of Button element\n+// https://api.slack.com/reference/block-kit/block-elements#button__fields\n+type Style string\n+\n+const (\n+\tStyleDefault Style = \"\"\n+\tStylePrimary Style = \"primary\"\n+\tStyleDanger  Style = \"danger\"\n+)\n+\n+// ButtonBlockElement defines an interactive element that inserts a button. The\n+// button can be a trigger for anything from opening a simple link to starting\n+// a complex workflow.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#button\n+type ButtonBlockElement struct {\n+\tType     MessageElementType       `json:\"type,omitempty\"`\n+\tText     *TextBlockObject         `json:\"text\"`\n+\tActionID string                   `json:\"action_id,omitempty\"`\n+\tURL      string                   `json:\"url,omitempty\"`\n+\tValue    string                   `json:\"value,omitempty\"`\n+\tConfirm  *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n+\tStyle    Style                    `json:\"style,omitempty\"`\n+}\n+\n+// ElementType returns the type of the element\n+func (s ButtonBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// WithStyle adds styling to the button object and returns the modified ButtonBlockElement\n+func (s *ButtonBlockElement) WithStyle(style Style) *ButtonBlockElement {\n+\ts.Style = style\n+\treturn s\n+}\n+\n+// NewButtonBlockElement returns an instance of a new button element to be used within a block\n+func NewButtonBlockElement(actionID, value string, text *TextBlockObject) *ButtonBlockElement {\n+\treturn &ButtonBlockElement{\n+\t\tType:     METButton,\n+\t\tActionID: actionID,\n+\t\tText:     text,\n+\t\tValue:    value,\n+\t}\n+}\n+\n+// OptionsResponse defines the response used for select block typahead.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/block-elements#external_multi_select\n+type OptionsResponse struct {\n+\tOptions []*OptionBlockObject `json:\"options,omitempty\"`\n+}\n+\n+// OptionGroupsResponse defines the response used for select block typahead.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/block-elements#external_multi_select\n+type OptionGroupsResponse struct {\n+\tOptionGroups []*OptionGroupBlockObject `json:\"option_groups,omitempty\"`\n+}\n+\n+// SelectBlockElement defines the simplest form of select menu, with a static list\n+// of options passed in when defining the element.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#select\n+type SelectBlockElement struct {\n+\tType                         string                    `json:\"type,omitempty\"`\n+\tPlaceholder                  *TextBlockObject          `json:\"placeholder,omitempty\"`\n+\tActionID                     string                    `json:\"action_id,omitempty\"`\n+\tOptions                      []*OptionBlockObject      `json:\"options,omitempty\"`\n+\tOptionGroups                 []*OptionGroupBlockObject `json:\"option_groups,omitempty\"`\n+\tInitialOption                *OptionBlockObject        `json:\"initial_option,omitempty\"`\n+\tInitialUser                  string                    `json:\"initial_user,omitempty\"`\n+\tInitialConversation          string                    `json:\"initial_conversation,omitempty\"`\n+\tInitialChannel               string                    `json:\"initial_channel,omitempty\"`\n+\tDefaultToCurrentConversation bool                      `json:\"default_to_current_conversation,omitempty\"`\n+\tResponseURLEnabled           bool                      `json:\"response_url_enabled,omitempty\"`\n+\tFilter                       *SelectBlockElementFilter `json:\"filter,omitempty\"`\n+\tMinQueryLength               *int                      `json:\"min_query_length,omitempty\"`\n+\tConfirm                      *ConfirmationBlockObject  `json:\"confirm,omitempty\"`\n+}\n+\n+// SelectBlockElementFilter allows to filter select element conversation options by type.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/composition-objects#filter_conversations\n+type SelectBlockElementFilter struct {\n+\tInclude                       []string `json:\"include,omitempty\"`\n+\tExcludeExternalSharedChannels bool     `json:\"exclude_external_shared_channels,omitempty\"`\n+\tExcludeBotUsers               bool     `json:\"exclude_bot_users,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s SelectBlockElement) ElementType() MessageElementType {\n+\treturn MessageElementType(s.Type)\n+}\n+\n+// NewOptionsSelectBlockElement returns a new instance of SelectBlockElement for use with\n+// the Options object only.\n+func NewOptionsSelectBlockElement(optType string, placeholder *TextBlockObject, actionID string, options ...*OptionBlockObject) *SelectBlockElement {\n+\treturn &SelectBlockElement{\n+\t\tType:        optType,\n+\t\tPlaceholder: placeholder,\n+\t\tActionID:    actionID,\n+\t\tOptions:     options,\n+\t}\n+}\n+\n+// NewOptionsGroupSelectBlockElement returns a new instance of SelectBlockElement for use with\n+// the Options object only.\n+func NewOptionsGroupSelectBlockElement(\n+\toptType string,\n+\tplaceholder *TextBlockObject,\n+\tactionID string,\n+\toptGroups ...*OptionGroupBlockObject,\n+) *SelectBlockElement {\n+\treturn &SelectBlockElement{\n+\t\tType:         optType,\n+\t\tPlaceholder:  placeholder,\n+\t\tActionID:     actionID,\n+\t\tOptionGroups: optGroups,\n+\t}\n+}\n+\n+// MultiSelectBlockElement defines a multiselect menu, with a static list\n+// of options passed in when defining the element.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#multi_select\n+type MultiSelectBlockElement struct {\n+\tType                 string                    `json:\"type,omitempty\"`\n+\tPlaceholder          *TextBlockObject          `json:\"placeholder,omitempty\"`\n+\tActionID             string                    `json:\"action_id,omitempty\"`\n+\tOptions              []*OptionBlockObject      `json:\"options,omitempty\"`\n+\tOptionGroups         []*OptionGroupBlockObject `json:\"option_groups,omitempty\"`\n+\tInitialOptions       []*OptionBlockObject      `json:\"initial_options,omitempty\"`\n+\tInitialUsers         []string                  `json:\"initial_users,omitempty\"`\n+\tInitialConversations []string                  `json:\"initial_conversations,omitempty\"`\n+\tInitialChannels      []string                  `json:\"initial_channels,omitempty\"`\n+\tMinQueryLength       *int                      `json:\"min_query_length,omitempty\"`\n+\tMaxSelectedItems     *int                      `json:\"max_selected_items,omitempty\"`\n+\tConfirm              *ConfirmationBlockObject  `json:\"confirm,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s MultiSelectBlockElement) ElementType() MessageElementType {\n+\treturn MessageElementType(s.Type)\n+}\n+\n+// NewOptionsMultiSelectBlockElement returns a new instance of SelectBlockElement for use with\n+// the Options object only.\n+func NewOptionsMultiSelectBlockElement(optType string, placeholder *TextBlockObject, actionID string, options ...*OptionBlockObject) *MultiSelectBlockElement {\n+\treturn &MultiSelectBlockElement{\n+\t\tType:        optType,\n+\t\tPlaceholder: placeholder,\n+\t\tActionID:    actionID,\n+\t\tOptions:     options,\n+\t}\n+}\n+\n+// NewOptionsGroupMultiSelectBlockElement returns a new instance of MultiSelectBlockElement for use with\n+// the Options object only.\n+func NewOptionsGroupMultiSelectBlockElement(\n+\toptType string,\n+\tplaceholder *TextBlockObject,\n+\tactionID string,\n+\toptGroups ...*OptionGroupBlockObject,\n+) *MultiSelectBlockElement {\n+\treturn &MultiSelectBlockElement{\n+\t\tType:         optType,\n+\t\tPlaceholder:  placeholder,\n+\t\tActionID:     actionID,\n+\t\tOptionGroups: optGroups,\n+\t}\n+}\n+\n+// OverflowBlockElement defines the fields needed to use an overflow element.\n+// And Overflow Element is like a cross between a button and a select menu -\n+// when a user clicks on this overflow button, they will be presented with a\n+// list of options to choose from.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#overflow\n+type OverflowBlockElement struct {\n+\tType     MessageElementType       `json:\"type\"`\n+\tActionID string                   `json:\"action_id,omitempty\"`\n+\tOptions  []*OptionBlockObject     `json:\"options\"`\n+\tConfirm  *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s OverflowBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// NewOverflowBlockElement returns an instance of a new Overflow Block Element\n+func NewOverflowBlockElement(actionID string, options ...*OptionBlockObject) *OverflowBlockElement {\n+\treturn &OverflowBlockElement{\n+\t\tType:     METOverflow,\n+\t\tActionID: actionID,\n+\t\tOptions:  options,\n+\t}\n+}\n+\n+// DatePickerBlockElement defines an element which lets users easily select a\n+// date from a calendar style UI. Date picker elements can be used inside of\n+// section and actions blocks.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#datepicker\n+type DatePickerBlockElement struct {\n+\tType        MessageElementType       `json:\"type\"`\n+\tActionID    string                   `json:\"action_id,omitempty\"`\n+\tPlaceholder *TextBlockObject         `json:\"placeholder,omitempty\"`\n+\tInitialDate string                   `json:\"initial_date,omitempty\"`\n+\tConfirm     *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s DatePickerBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// NewDatePickerBlockElement returns an instance of a date picker element\n+func NewDatePickerBlockElement(actionID string) *DatePickerBlockElement {\n+\treturn &DatePickerBlockElement{\n+\t\tType:     METDatepicker,\n+\t\tActionID: actionID,\n+\t}\n+}\n+\n+// TimePickerBlockElement defines an element which lets users easily select a\n+// time from nice UI. Time picker elements can be used inside of\n+// section and actions blocks.\n+//\n+// More Information: https://api.slack.com/reference/messaging/block-elements#timepicker\n+type TimePickerBlockElement struct {\n+\tType        MessageElementType       `json:\"type\"`\n+\tActionID    string                   `json:\"action_id,omitempty\"`\n+\tPlaceholder *TextBlockObject         `json:\"placeholder,omitempty\"`\n+\tInitialTime string                   `json:\"initial_time,omitempty\"`\n+\tConfirm     *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s TimePickerBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// NewTimePickerBlockElement returns an instance of a date picker element\n+func NewTimePickerBlockElement(actionID string) *TimePickerBlockElement {\n+\treturn &TimePickerBlockElement{\n+\t\tType:     METTimepicker,\n+\t\tActionID: actionID,\n+\t}\n+}\n+\n+// PlainTextInputBlockElement creates a field where a user can enter freeform\n+// data.\n+// Plain-text input elements are currently only available in modals.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/block-elements#input\n+type PlainTextInputBlockElement struct {\n+\tType         MessageElementType `json:\"type\"`\n+\tActionID     string             `json:\"action_id,omitempty\"`\n+\tPlaceholder  *TextBlockObject   `json:\"placeholder,omitempty\"`\n+\tInitialValue string             `json:\"initial_value,omitempty\"`\n+\tMultiline    bool               `json:\"multiline,omitempty\"`\n+\tMinLength    int                `json:\"min_length,omitempty\"`\n+\tMaxLength    int                `json:\"max_length,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s PlainTextInputBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// NewPlainTextInputBlockElement returns an instance of a plain-text input\n+// element\n+func NewPlainTextInputBlockElement(placeholder *TextBlockObject, actionID string) *PlainTextInputBlockElement {\n+\treturn &PlainTextInputBlockElement{\n+\t\tType:        METPlainTextInput,\n+\t\tActionID:    actionID,\n+\t\tPlaceholder: placeholder,\n+\t}\n+}\n+\n+// CheckboxGroupsBlockElement defines an element which allows users to choose\n+// one or more items from a list of possible options.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/block-elements#checkboxes\n+type CheckboxGroupsBlockElement struct {\n+\tType           MessageElementType       `json:\"type\"`\n+\tActionID       string                   `json:\"action_id,omitempty\"`\n+\tOptions        []*OptionBlockObject     `json:\"options\"`\n+\tInitialOptions []*OptionBlockObject     `json:\"initial_options,omitempty\"`\n+\tConfirm        *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (c CheckboxGroupsBlockElement) ElementType() MessageElementType {\n+\treturn c.Type\n+}\n+\n+// NewCheckboxGroupsBlockElement returns an instance of a checkbox-group block element\n+func NewCheckboxGroupsBlockElement(actionID string, options ...*OptionBlockObject) *CheckboxGroupsBlockElement {\n+\treturn &CheckboxGroupsBlockElement{\n+\t\tType:     METCheckboxGroups,\n+\t\tActionID: actionID,\n+\t\tOptions:  options,\n+\t}\n+}\n+\n+// RadioButtonsBlockElement defines an element which lets users choose one item\n+// from a list of possible options.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/block-elements#radio\n+type RadioButtonsBlockElement struct {\n+\tType          MessageElementType       `json:\"type\"`\n+\tActionID      string                   `json:\"action_id,omitempty\"`\n+\tOptions       []*OptionBlockObject     `json:\"options\"`\n+\tInitialOption *OptionBlockObject       `json:\"initial_option,omitempty\"`\n+\tConfirm       *ConfirmationBlockObject `json:\"confirm,omitempty\"`\n+}\n+\n+// ElementType returns the type of the Element\n+func (s RadioButtonsBlockElement) ElementType() MessageElementType {\n+\treturn s.Type\n+}\n+\n+// NewRadioButtonsBlockElement returns an instance of a radio buttons element.\n+func NewRadioButtonsBlockElement(actionID string, options ...*OptionBlockObject) *RadioButtonsBlockElement {\n+\treturn &RadioButtonsBlockElement{\n+\t\tType:     METRadioButtons,\n+\t\tActionID: actionID,\n+\t\tOptions:  options,\n+\t}\n+}"
    },
    {
      "sha": "ac4453f79e1b2c7bd163c7d6f7c6016360fad980",
      "filename": "backend/vendor/github.com/slack-go/slack/block_file.go",
      "status": "added",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_file.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_file.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_file.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,26 @@\n+package slack\n+\n+// FileBlock defines data that is used to display a remote file.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/blocks#file\n+type FileBlock struct {\n+\tType       MessageBlockType `json:\"type\"`\n+\tBlockID    string           `json:\"block_id,omitempty\"`\n+\tExternalID string           `json:\"external_id\"`\n+\tSource     string           `json:\"source\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s FileBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// NewFileBlock returns a new instance of a file block\n+func NewFileBlock(blockID string, externalID string, source string) *FileBlock {\n+\treturn &FileBlock{\n+\t\tType:       MBTFile,\n+\t\tBlockID:    blockID,\n+\t\tExternalID: externalID,\n+\t\tSource:     source,\n+\t}\n+}"
    },
    {
      "sha": "6dff4b8834981050dc88d07f9240ffaa87821ab9",
      "filename": "backend/vendor/github.com/slack-go/slack/block_header.go",
      "status": "added",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_header.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_header.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_header.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,38 @@\n+package slack\n+\n+// HeaderBlock defines a new block of type header\n+//\n+// More Information: https://api.slack.com/reference/messaging/blocks#header\n+type HeaderBlock struct {\n+\tType    MessageBlockType `json:\"type\"`\n+\tText    *TextBlockObject `json:\"text,omitempty\"`\n+\tBlockID string           `json:\"block_id,omitempty\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s HeaderBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// HeaderBlockOption allows configuration of options for a new header block\n+type HeaderBlockOption func(*HeaderBlock)\n+\n+func HeaderBlockOptionBlockID(blockID string) HeaderBlockOption {\n+\treturn func(block *HeaderBlock) {\n+\t\tblock.BlockID = blockID\n+\t}\n+}\n+\n+// NewHeaderBlock returns a new instance of a header block to be rendered\n+func NewHeaderBlock(textObj *TextBlockObject, options ...HeaderBlockOption) *HeaderBlock {\n+\tblock := HeaderBlock{\n+\t\tType: MBTHeader,\n+\t\tText: textObj,\n+\t}\n+\n+\tfor _, option := range options {\n+\t\toption(&block)\n+\t}\n+\n+\treturn &block\n+}"
    },
    {
      "sha": "90cbd14e4d710b8153ed3f969b4d1fd78e93338a",
      "filename": "backend/vendor/github.com/slack-go/slack/block_image.go",
      "status": "added",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_image.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_image.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_image.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,28 @@\n+package slack\n+\n+// ImageBlock defines data required to display an image as a block element\n+//\n+// More Information: https://api.slack.com/reference/messaging/blocks#image\n+type ImageBlock struct {\n+\tType     MessageBlockType `json:\"type\"`\n+\tImageURL string           `json:\"image_url\"`\n+\tAltText  string           `json:\"alt_text\"`\n+\tBlockID  string           `json:\"block_id,omitempty\"`\n+\tTitle    *TextBlockObject `json:\"title,omitempty\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s ImageBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// NewImageBlock returns an instance of a new Image Block type\n+func NewImageBlock(imageURL, altText, blockID string, title *TextBlockObject) *ImageBlock {\n+\treturn &ImageBlock{\n+\t\tType:     MBTImage,\n+\t\tImageURL: imageURL,\n+\t\tAltText:  altText,\n+\t\tBlockID:  blockID,\n+\t\tTitle:    title,\n+\t}\n+}"
    },
    {
      "sha": "087571af4975d992a6d846de693db2831c209c0d",
      "filename": "backend/vendor/github.com/slack-go/slack/block_input.go",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_input.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_input.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_input.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,29 @@\n+package slack\n+\n+// InputBlock defines data that is used to display user input fields.\n+//\n+// More Information: https://api.slack.com/reference/block-kit/blocks#input\n+type InputBlock struct {\n+\tType           MessageBlockType `json:\"type\"`\n+\tBlockID        string           `json:\"block_id,omitempty\"`\n+\tLabel          *TextBlockObject `json:\"label\"`\n+\tElement        BlockElement     `json:\"element\"`\n+\tHint           *TextBlockObject `json:\"hint,omitempty\"`\n+\tOptional       bool             `json:\"optional,omitempty\"`\n+\tDispatchAction bool             `json:\"dispatch_action,omitempty\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s InputBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// NewInputBlock returns a new instance of an input block\n+func NewInputBlock(blockID string, label *TextBlockObject, element BlockElement) *InputBlock {\n+\treturn &InputBlock{\n+\t\tType:    MBTInput,\n+\t\tBlockID: blockID,\n+\t\tLabel:   label,\n+\t\tElement: element,\n+\t}\n+}"
    },
    {
      "sha": "5ced7f92a8444a63f0396c4f5fa86ad775e61256",
      "filename": "backend/vendor/github.com/slack-go/slack/block_object.go",
      "status": "added",
      "additions": 247,
      "deletions": 0,
      "changes": 247,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_object.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_object.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_object.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,247 @@\n+package slack\n+\n+import (\n+\t\"encoding/json\"\n+\t\"errors\"\n+)\n+\n+// Block Objects are also known as Composition Objects\n+//\n+// For more information: https://api.slack.com/reference/messaging/composition-objects\n+\n+// BlockObject defines an interface that all block object types should\n+// implement.\n+// @TODO: Is this interface needed?\n+\n+// blockObject object types\n+const (\n+\tMarkdownType  = \"mrkdwn\"\n+\tPlainTextType = \"plain_text\"\n+\t// The following objects don't actually have types and their corresponding\n+\t// const values are just for internal use\n+\tmotConfirmation = \"confirm\"\n+\tmotOption       = \"option\"\n+\tmotOptionGroup  = \"option_group\"\n+)\n+\n+type MessageObjectType string\n+\n+type blockObject interface {\n+\tvalidateType() MessageObjectType\n+}\n+\n+type BlockObjects struct {\n+\tTextObjects         []*TextBlockObject\n+\tConfirmationObjects []*ConfirmationBlockObject\n+\tOptionObjects       []*OptionBlockObject\n+\tOptionGroupObjects  []*OptionGroupBlockObject\n+}\n+\n+// UnmarshalJSON implements the Unmarshaller interface for BlockObjects, so that any JSON\n+// unmarshalling is delegated and proper type determination can be made before unmarshal\n+func (b *BlockObjects) UnmarshalJSON(data []byte) error {\n+\tvar raw []json.RawMessage\n+\terr := json.Unmarshal(data, &raw)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor _, r := range raw {\n+\t\tvar obj map[string]interface{}\n+\t\terr := json.Unmarshal(r, &obj)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tblockObjectType := getBlockObjectType(obj)\n+\n+\t\tswitch blockObjectType {\n+\t\tcase PlainTextType, MarkdownType:\n+\t\t\tobject, err := unmarshalBlockObject(r, &TextBlockObject{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tb.TextObjects = append(b.TextObjects, object.(*TextBlockObject))\n+\t\tcase motConfirmation:\n+\t\t\tobject, err := unmarshalBlockObject(r, &ConfirmationBlockObject{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tb.ConfirmationObjects = append(b.ConfirmationObjects, object.(*ConfirmationBlockObject))\n+\t\tcase motOption:\n+\t\t\tobject, err := unmarshalBlockObject(r, &OptionBlockObject{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tb.OptionObjects = append(b.OptionObjects, object.(*OptionBlockObject))\n+\t\tcase motOptionGroup:\n+\t\t\tobject, err := unmarshalBlockObject(r, &OptionGroupBlockObject{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tb.OptionGroupObjects = append(b.OptionGroupObjects, object.(*OptionGroupBlockObject))\n+\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Ideally would have a better way to identify the block objects for\n+// type casting at time of unmarshalling, should be adapted if possible\n+// to accomplish in a more reliable manner.\n+func getBlockObjectType(obj map[string]interface{}) string {\n+\tif t, ok := obj[\"type\"].(string); ok {\n+\t\treturn t\n+\t}\n+\tif _, ok := obj[\"confirm\"].(string); ok {\n+\t\treturn \"confirm\"\n+\t}\n+\tif _, ok := obj[\"options\"].(string); ok {\n+\t\treturn \"option_group\"\n+\t}\n+\tif _, ok := obj[\"text\"].(string); ok {\n+\t\tif _, ok := obj[\"value\"].(string); ok {\n+\t\t\treturn \"option\"\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func unmarshalBlockObject(r json.RawMessage, object blockObject) (blockObject, error) {\n+\terr := json.Unmarshal(r, object)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn object, nil\n+}\n+\n+// TextBlockObject defines a text element object to be used with blocks\n+//\n+// More Information: https://api.slack.com/reference/messaging/composition-objects#text\n+type TextBlockObject struct {\n+\tType     string `json:\"type\"`\n+\tText     string `json:\"text\"`\n+\tEmoji    bool   `json:\"emoji,omitempty\"`\n+\tVerbatim bool   `json:\"verbatim,omitempty\"`\n+}\n+\n+// validateType enforces block objects for element and block parameters\n+func (s TextBlockObject) validateType() MessageObjectType {\n+\treturn MessageObjectType(s.Type)\n+}\n+\n+// validateType enforces block objects for element and block parameters\n+func (s TextBlockObject) MixedElementType() MixedElementType {\n+\treturn MixedElementText\n+}\n+\n+// Validate checks if TextBlockObject has valid values\n+func (s TextBlockObject) Validate() error {\n+\tif s.Type != \"plain_text\" && s.Type != \"mrkdwn\" {\n+\t\treturn errors.New(\"type must be either of plain_text or mrkdwn\")\n+\t}\n+\n+\t// https://github.com/slack-go/slack/issues/881\n+\tif s.Type == \"mrkdwn\" && s.Emoji {\n+\t\treturn errors.New(\"emoji cannot be true in mrkdown\")\n+\t}\n+\n+\treturn nil\n+}\n+\n+// NewTextBlockObject returns an instance of a new Text Block Object\n+func NewTextBlockObject(elementType, text string, emoji, verbatim bool) *TextBlockObject {\n+\treturn &TextBlockObject{\n+\t\tType:     elementType,\n+\t\tText:     text,\n+\t\tEmoji:    emoji,\n+\t\tVerbatim: verbatim,\n+\t}\n+}\n+\n+// BlockType returns the type of the block\n+func (t TextBlockObject) BlockType() MessageBlockType {\n+\tif t.Type == \"mrkdwn\" {\n+\t\treturn MarkdownType\n+\t}\n+\treturn PlainTextType\n+}\n+\n+// ConfirmationBlockObject defines a dialog that provides a confirmation step to\n+// any interactive element. This dialog will ask the user to confirm their action by\n+// offering a confirm and deny buttons.\n+//\n+// More Information: https://api.slack.com/reference/messaging/composition-objects#confirm\n+type ConfirmationBlockObject struct {\n+\tTitle   *TextBlockObject `json:\"title\"`\n+\tText    *TextBlockObject `json:\"text\"`\n+\tConfirm *TextBlockObject `json:\"confirm\"`\n+\tDeny    *TextBlockObject `json:\"deny\"`\n+\tStyle   Style            `json:\"style,omitempty\"`\n+}\n+\n+// validateType enforces block objects for element and block parameters\n+func (s ConfirmationBlockObject) validateType() MessageObjectType {\n+\treturn motConfirmation\n+}\n+\n+// WithStyle add styling to confirmation object\n+func (s *ConfirmationBlockObject) WithStyle(style Style) {\n+\ts.Style = style\n+}\n+\n+// NewConfirmationBlockObject returns an instance of a new Confirmation Block Object\n+func NewConfirmationBlockObject(title, text, confirm, deny *TextBlockObject) *ConfirmationBlockObject {\n+\treturn &ConfirmationBlockObject{\n+\t\tTitle:   title,\n+\t\tText:    text,\n+\t\tConfirm: confirm,\n+\t\tDeny:    deny,\n+\t}\n+}\n+\n+// OptionBlockObject represents a single selectable item in a select menu\n+//\n+// More Information: https://api.slack.com/reference/messaging/composition-objects#option\n+type OptionBlockObject struct {\n+\tText        *TextBlockObject `json:\"text\"`\n+\tValue       string           `json:\"value\"`\n+\tDescription *TextBlockObject `json:\"description,omitempty\"`\n+\tURL         string           `json:\"url,omitempty\"`\n+}\n+\n+// NewOptionBlockObject returns an instance of a new Option Block Element\n+func NewOptionBlockObject(value string, text, description *TextBlockObject) *OptionBlockObject {\n+\treturn &OptionBlockObject{\n+\t\tText:        text,\n+\t\tValue:       value,\n+\t\tDescription: description,\n+\t}\n+}\n+\n+// validateType enforces block objects for element and block parameters\n+func (s OptionBlockObject) validateType() MessageObjectType {\n+\treturn motOption\n+}\n+\n+// OptionGroupBlockObject Provides a way to group options in a select menu.\n+//\n+// More Information: https://api.slack.com/reference/messaging/composition-objects#option-group\n+type OptionGroupBlockObject struct {\n+\tLabel   *TextBlockObject     `json:\"label,omitempty\"`\n+\tOptions []*OptionBlockObject `json:\"options\"`\n+}\n+\n+// validateType enforces block objects for element and block parameters\n+func (s OptionGroupBlockObject) validateType() MessageObjectType {\n+\treturn motOptionGroup\n+}\n+\n+// NewOptionGroupBlockElement returns an instance of a new option group block element\n+func NewOptionGroupBlockElement(label *TextBlockObject, options ...*OptionBlockObject) *OptionGroupBlockObject {\n+\treturn &OptionGroupBlockObject{\n+\t\tLabel:   label,\n+\t\tOptions: options,\n+\t}\n+}"
    },
    {
      "sha": "01ffd5a1d38a26640658842e50de284bebe19154",
      "filename": "backend/vendor/github.com/slack-go/slack/block_section.go",
      "status": "added",
      "additions": 42,
      "deletions": 0,
      "changes": 42,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_section.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_section.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_section.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,42 @@\n+package slack\n+\n+// SectionBlock defines a new block of type section\n+//\n+// More Information: https://api.slack.com/reference/messaging/blocks#section\n+type SectionBlock struct {\n+\tType      MessageBlockType   `json:\"type\"`\n+\tText      *TextBlockObject   `json:\"text,omitempty\"`\n+\tBlockID   string             `json:\"block_id,omitempty\"`\n+\tFields    []*TextBlockObject `json:\"fields,omitempty\"`\n+\tAccessory *Accessory         `json:\"accessory,omitempty\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (s SectionBlock) BlockType() MessageBlockType {\n+\treturn s.Type\n+}\n+\n+// SectionBlockOption allows configuration of options for a new section block\n+type SectionBlockOption func(*SectionBlock)\n+\n+func SectionBlockOptionBlockID(blockID string) SectionBlockOption {\n+\treturn func(block *SectionBlock) {\n+\t\tblock.BlockID = blockID\n+\t}\n+}\n+\n+// NewSectionBlock returns a new instance of a section block to be rendered\n+func NewSectionBlock(textObj *TextBlockObject, fields []*TextBlockObject, accessory *Accessory, options ...SectionBlockOption) *SectionBlock {\n+\tblock := SectionBlock{\n+\t\tType:      MBTSection,\n+\t\tText:      textObj,\n+\t\tFields:    fields,\n+\t\tAccessory: accessory,\n+\t}\n+\n+\tfor _, option := range options {\n+\t\toption(&block)\n+\t}\n+\n+\treturn &block\n+}"
    },
    {
      "sha": "97054c73e349a0a40e408e8323ccb1f52c9bcde1",
      "filename": "backend/vendor/github.com/slack-go/slack/block_unknown.go",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_unknown.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/block_unknown.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/block_unknown.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,13 @@\n+package slack\n+\n+// UnknownBlock represents a block type that is not yet known. This block type exists to prevent Slack from introducing\n+// new and unknown block types that break this library.\n+type UnknownBlock struct {\n+\tType    MessageBlockType `json:\"type\"`\n+\tBlockID string           `json:\"block_id,omitempty\"`\n+}\n+\n+// BlockType returns the type of the block\n+func (b UnknownBlock) BlockType() MessageBlockType {\n+\treturn b.Type\n+}"
    },
    {
      "sha": "da21ba0c9431ce42baac9552787372ea2f4e3738",
      "filename": "backend/vendor/github.com/slack-go/slack/bots.go",
      "status": "added",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/bots.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/bots.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/bots.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,58 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+)\n+\n+// Bot contains information about a bot\n+type Bot struct {\n+\tID      string   `json:\"id\"`\n+\tName    string   `json:\"name\"`\n+\tDeleted bool     `json:\"deleted\"`\n+\tUserID  string   `json:\"user_id\"`\n+\tAppID   string   `json:\"app_id\"`\n+\tUpdated JSONTime `json:\"updated\"`\n+\tIcons   Icons    `json:\"icons\"`\n+}\n+\n+type botResponseFull struct {\n+\tBot `json:\"bot,omitempty\"` // GetBotInfo\n+\tSlackResponse\n+}\n+\n+func (api *Client) botRequest(ctx context.Context, path string, values url.Values) (*botResponseFull, error) {\n+\tresponse := &botResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := response.Err(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, nil\n+}\n+\n+// GetBotInfo will retrieve the complete bot information\n+func (api *Client) GetBotInfo(bot string) (*Bot, error) {\n+\treturn api.GetBotInfoContext(context.Background(), bot)\n+}\n+\n+// GetBotInfoContext will retrieve the complete bot information using a custom context\n+func (api *Client) GetBotInfoContext(ctx context.Context, bot string) (*Bot, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\tif bot != \"\" {\n+\t\tvalues.Add(\"bot\", bot)\n+\t}\n+\n+\tresponse, err := api.botRequest(ctx, \"bots.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Bot, nil\n+}"
    },
    {
      "sha": "c05521d0f35449fbc5a17371115191e4bd20af19",
      "filename": "backend/vendor/github.com/slack-go/slack/channels.go",
      "status": "added",
      "additions": 714,
      "deletions": 0,
      "changes": 714,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/channels.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/channels.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/channels.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,714 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"time\"\n+)\n+\n+type channelResponseFull struct {\n+\tChannel      Channel   `json:\"channel\"`\n+\tChannels     []Channel `json:\"channels\"`\n+\tPurpose      string    `json:\"purpose\"`\n+\tTopic        string    `json:\"topic\"`\n+\tNotInChannel bool      `json:\"not_in_channel\"`\n+\tHistory\n+\tSlackResponse\n+\tMetadata ResponseMetadata `json:\"response_metadata\"`\n+}\n+\n+// Channel contains information about the channel\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+type Channel struct {\n+\tGroupConversation\n+\tIsChannel bool   `json:\"is_channel\"`\n+\tIsGeneral bool   `json:\"is_general\"`\n+\tIsMember  bool   `json:\"is_member\"`\n+\tLocale    string `json:\"locale\"`\n+}\n+\n+func (api *Client) channelRequest(ctx context.Context, path string, values url.Values) (*channelResponseFull, error) {\n+\tresponse := &channelResponseFull{}\n+\terr := postForm(ctx, api.httpclient, api.endpoint+path, values, response, api)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// GetChannelsOption option provided when getting channels.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+type GetChannelsOption func(*ChannelPagination) error\n+\n+// GetChannelsOptionExcludeMembers excludes the members collection from each channel.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func GetChannelsOptionExcludeMembers() GetChannelsOption {\n+\treturn func(p *ChannelPagination) error {\n+\t\tp.excludeMembers = true\n+\t\treturn nil\n+\t}\n+}\n+\n+// GetChannelsOptionExcludeArchived excludes archived channels from results.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func GetChannelsOptionExcludeArchived() GetChannelsOption {\n+\treturn func(p *ChannelPagination) error {\n+\t\tp.excludeArchived = true\n+\t\treturn nil\n+\t}\n+}\n+\n+// ArchiveChannel archives the given channel\n+// see https://api.slack.com/methods/channels.archive\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) ArchiveChannel(channelID string) error {\n+\treturn api.ArchiveChannelContext(context.Background(), channelID)\n+}\n+\n+// ArchiveChannelContext archives the given channel with a custom context\n+// see https://api.slack.com/methods/channels.archive\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) ArchiveChannelContext(ctx context.Context, channelID string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\n+\t_, err = api.channelRequest(ctx, \"channels.archive\", values)\n+\treturn err\n+}\n+\n+// UnarchiveChannel unarchives the given channel\n+// see https://api.slack.com/methods/channels.unarchive\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) UnarchiveChannel(channelID string) error {\n+\treturn api.UnarchiveChannelContext(context.Background(), channelID)\n+}\n+\n+// UnarchiveChannelContext unarchives the given channel with a custom context\n+// see https://api.slack.com/methods/channels.unarchive\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) UnarchiveChannelContext(ctx context.Context, channelID string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\n+\t_, err = api.channelRequest(ctx, \"channels.unarchive\", values)\n+\treturn err\n+}\n+\n+// CreateChannel creates a channel with the given name and returns a *Channel\n+// see https://api.slack.com/methods/channels.create\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CreateChannel(channelName string) (*Channel, error) {\n+\treturn api.CreateChannelContext(context.Background(), channelName)\n+}\n+\n+// CreateChannelContext creates a channel with the given name and returns a *Channel with a custom context\n+// see https://api.slack.com/methods/channels.create\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CreateChannelContext(ctx context.Context, channelName string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"name\":  {channelName},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.create\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Channel, nil\n+}\n+\n+// GetChannelHistory retrieves the channel history\n+// see https://api.slack.com/methods/channels.history\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelHistory(channelID string, params HistoryParameters) (*History, error) {\n+\treturn api.GetChannelHistoryContext(context.Background(), channelID, params)\n+}\n+\n+// GetChannelHistoryContext retrieves the channel history with a custom context\n+// see https://api.slack.com/methods/channels.history\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelHistoryContext(ctx context.Context, channelID string, params HistoryParameters) (*History, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\tif params.Latest != DEFAULT_HISTORY_LATEST {\n+\t\tvalues.Add(\"latest\", params.Latest)\n+\t}\n+\tif params.Oldest != DEFAULT_HISTORY_OLDEST {\n+\t\tvalues.Add(\"oldest\", params.Oldest)\n+\t}\n+\tif params.Count != DEFAULT_HISTORY_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Inclusive != DEFAULT_HISTORY_INCLUSIVE {\n+\t\tif params.Inclusive {\n+\t\t\tvalues.Add(\"inclusive\", \"1\")\n+\t\t} else {\n+\t\t\tvalues.Add(\"inclusive\", \"0\")\n+\t\t}\n+\t}\n+\n+\tif params.Unreads != DEFAULT_HISTORY_UNREADS {\n+\t\tif params.Unreads {\n+\t\t\tvalues.Add(\"unreads\", \"1\")\n+\t\t} else {\n+\t\t\tvalues.Add(\"unreads\", \"0\")\n+\t\t}\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.history\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.History, nil\n+}\n+\n+// GetChannelInfo retrieves the given channel\n+// see https://api.slack.com/methods/channels.info\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelInfo(channelID string) (*Channel, error) {\n+\treturn api.GetChannelInfoContext(context.Background(), channelID)\n+}\n+\n+// GetChannelInfoContext retrieves the given channel with a custom context\n+// see https://api.slack.com/methods/channels.info\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelInfoContext(ctx context.Context, channelID string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":          {api.token},\n+\t\t\"channel\":        {channelID},\n+\t\t\"include_locale\": {strconv.FormatBool(true)},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Channel, nil\n+}\n+\n+// InviteUserToChannel invites a user to a given channel and returns a *Channel\n+// see https://api.slack.com/methods/channels.invite\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) InviteUserToChannel(channelID, user string) (*Channel, error) {\n+\treturn api.InviteUserToChannelContext(context.Background(), channelID, user)\n+}\n+\n+// InviteUserToChannelContext invites a user to a given channel and returns a *Channel with a custom context\n+// see https://api.slack.com/methods/channels.invite\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) InviteUserToChannelContext(ctx context.Context, channelID, user string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"user\":    {user},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.invite\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Channel, nil\n+}\n+\n+// JoinChannel joins the currently authenticated user to a channel\n+// see https://api.slack.com/methods/channels.join\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) JoinChannel(channelName string) (*Channel, error) {\n+\treturn api.JoinChannelContext(context.Background(), channelName)\n+}\n+\n+// JoinChannelContext joins the currently authenticated user to a channel with a custom context\n+// see https://api.slack.com/methods/channels.join\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) JoinChannelContext(ctx context.Context, channelName string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"name\":  {channelName},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.join\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Channel, nil\n+}\n+\n+// LeaveChannel makes the authenticated user leave the given channel\n+// see https://api.slack.com/methods/channels.leave\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) LeaveChannel(channelID string) (bool, error) {\n+\treturn api.LeaveChannelContext(context.Background(), channelID)\n+}\n+\n+// LeaveChannelContext makes the authenticated user leave the given channel with a custom context\n+// see https://api.slack.com/methods/channels.leave\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) LeaveChannelContext(ctx context.Context, channelID string) (bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.leave\", values)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\treturn response.NotInChannel, nil\n+}\n+\n+// KickUserFromChannel kicks a user from a given channel\n+// see https://api.slack.com/methods/channels.kick\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) KickUserFromChannel(channelID, user string) error {\n+\treturn api.KickUserFromChannelContext(context.Background(), channelID, user)\n+}\n+\n+// KickUserFromChannelContext kicks a user from a given channel with a custom context\n+// see https://api.slack.com/methods/channels.kick\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) KickUserFromChannelContext(ctx context.Context, channelID, user string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"user\":    {user},\n+\t}\n+\n+\t_, err = api.channelRequest(ctx, \"channels.kick\", values)\n+\treturn err\n+}\n+\n+func newChannelPagination(c *Client, options ...GetChannelsOption) (cp ChannelPagination) {\n+\tcp = ChannelPagination{\n+\t\tc:     c,\n+\t\tlimit: 200, // per slack api documentation.\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\topt(&cp)\n+\t}\n+\n+\treturn cp\n+}\n+\n+// ChannelPagination allows for paginating over the channels\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+type ChannelPagination struct {\n+\tChannels        []Channel\n+\tlimit           int\n+\texcludeArchived bool\n+\texcludeMembers  bool\n+\tpreviousResp    *ResponseMetadata\n+\tc               *Client\n+}\n+\n+// Done checks if the pagination has completed\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (ChannelPagination) Done(err error) bool {\n+\treturn err == errPaginationComplete\n+}\n+\n+// Failure checks if pagination failed.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (t ChannelPagination) Failure(err error) error {\n+\tif t.Done(err) {\n+\t\treturn nil\n+\t}\n+\n+\treturn err\n+}\n+\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (t ChannelPagination) Next(ctx context.Context) (_ ChannelPagination, err error) {\n+\tvar (\n+\t\tresp *channelResponseFull\n+\t)\n+\n+\tif t.c == nil || (t.previousResp != nil && t.previousResp.Cursor == \"\") {\n+\t\treturn t, errPaginationComplete\n+\t}\n+\n+\tt.previousResp = t.previousResp.initialize()\n+\n+\tvalues := url.Values{\n+\t\t\"limit\":            {strconv.Itoa(t.limit)},\n+\t\t\"exclude_archived\": {strconv.FormatBool(t.excludeArchived)},\n+\t\t\"exclude_members\":  {strconv.FormatBool(t.excludeMembers)},\n+\t\t\"token\":            {t.c.token},\n+\t\t\"cursor\":           {t.previousResp.Cursor},\n+\t}\n+\n+\tif resp, err = t.c.channelRequest(ctx, \"channels.list\", values); err != nil {\n+\t\treturn t, err\n+\t}\n+\n+\tt.c.Debugf(\"GetChannelsContext: got %d channels; metadata %v\", len(resp.Channels), resp.Metadata)\n+\tt.Channels = resp.Channels\n+\tt.previousResp = &resp.Metadata\n+\n+\treturn t, nil\n+}\n+\n+// GetChannelsPaginated fetches channels in a paginated fashion, see GetChannelsContext for usage.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelsPaginated(options ...GetChannelsOption) ChannelPagination {\n+\treturn newChannelPagination(api, options...)\n+}\n+\n+// GetChannels retrieves all the channels\n+// see https://api.slack.com/methods/channels.list\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannels(excludeArchived bool, options ...GetChannelsOption) ([]Channel, error) {\n+\treturn api.GetChannelsContext(context.Background(), excludeArchived, options...)\n+}\n+\n+// GetChannelsContext retrieves all the channels with a custom context\n+// see https://api.slack.com/methods/channels.list\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelsContext(ctx context.Context, excludeArchived bool, options ...GetChannelsOption) (results []Channel, err error) {\n+\tif excludeArchived {\n+\t\toptions = append(options, GetChannelsOptionExcludeArchived())\n+\t}\n+\n+\tp := api.GetChannelsPaginated(options...)\n+\tfor err == nil {\n+\t\tp, err = p.Next(ctx)\n+\t\tif err == nil {\n+\t\t\tresults = append(results, p.Channels...)\n+\t\t} else if rateLimitedError, ok := err.(*RateLimitedError); ok {\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\terr = ctx.Err()\n+\t\t\tcase <-time.After(rateLimitedError.RetryAfter):\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn results, p.Failure(err)\n+}\n+\n+// SetChannelReadMark sets the read mark of a given channel to a specific point\n+// Clients should try to avoid making this call too often. When needing to mark a read position, a client should set a\n+// timer before making the call. In this way, any further updates needed during the timeout will not generate extra calls\n+// (just one per channel). This is useful for when reading scroll-back history, or following a busy live channel. A\n+// timeout of 5 seconds is a good starting point. Be sure to flush these calls on shutdown/logout.\n+// see https://api.slack.com/methods/channels.mark\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetChannelReadMark(channelID, ts string) error {\n+\treturn api.SetChannelReadMarkContext(context.Background(), channelID, ts)\n+}\n+\n+// SetChannelReadMarkContext sets the read mark of a given channel to a specific point with a custom context\n+// For more details see SetChannelReadMark documentation\n+// see https://api.slack.com/methods/channels.mark\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetChannelReadMarkContext(ctx context.Context, channelID, ts string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"ts\":      {ts},\n+\t}\n+\n+\t_, err = api.channelRequest(ctx, \"channels.mark\", values)\n+\treturn err\n+}\n+\n+// RenameChannel renames a given channel\n+// see https://api.slack.com/methods/channels.rename\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) RenameChannel(channelID, name string) (*Channel, error) {\n+\treturn api.RenameChannelContext(context.Background(), channelID, name)\n+}\n+\n+// RenameChannelContext renames a given channel with a custom context\n+// see https://api.slack.com/methods/channels.rename\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) RenameChannelContext(ctx context.Context, channelID, name string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"name\":    {name},\n+\t}\n+\n+\t// XXX: the created entry in this call returns a string instead of a number\n+\t// so I may have to do some workaround to solve it.\n+\tresponse, err := api.channelRequest(ctx, \"channels.rename\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Channel, nil\n+}\n+\n+// SetChannelPurpose sets the channel purpose and returns the purpose that was successfully set\n+// see https://api.slack.com/methods/channels.setPurpose\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetChannelPurpose(channelID, purpose string) (string, error) {\n+\treturn api.SetChannelPurposeContext(context.Background(), channelID, purpose)\n+}\n+\n+// SetChannelPurposeContext sets the channel purpose and returns the purpose that was successfully set with a custom context\n+// see https://api.slack.com/methods/channels.setPurpose\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetChannelPurposeContext(ctx context.Context, channelID, purpose string) (string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"purpose\": {purpose},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.setPurpose\", values)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn response.Purpose, nil\n+}\n+\n+// SetChannelTopic sets the channel topic and returns the topic that was successfully set\n+// see https://api.slack.com/methods/channels.setTopic\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetChannelTopic(channelID, topic string) (string, error) {\n+\treturn api.SetChannelTopicContext(context.Background(), channelID, topic)\n+}\n+\n+// SetChannelTopicContext sets the channel topic and returns the topic that was successfully set with a custom context\n+// see https://api.slack.com/methods/channels.setTopic\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetChannelTopicContext(ctx context.Context, channelID, topic string) (string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"topic\":   {topic},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"channels.setTopic\", values)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn response.Topic, nil\n+}\n+\n+// GetChannelReplies gets an entire thread (a message plus all the messages in reply to it).\n+// see https://api.slack.com/methods/channels.replies\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelReplies(channelID, thread_ts string) ([]Message, error) {\n+\treturn api.GetChannelRepliesContext(context.Background(), channelID, thread_ts)\n+}\n+\n+// GetChannelRepliesContext gets an entire thread (a message plus all the messages in reply to it) with a custom context\n+// see https://api.slack.com/methods/channels.replies\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetChannelRepliesContext(ctx context.Context, channelID, thread_ts string) ([]Message, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"channel\":   {channelID},\n+\t\t\"thread_ts\": {thread_ts},\n+\t}\n+\tresponse, err := api.channelRequest(ctx, \"channels.replies\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response.History.Messages, nil\n+}"
    },
    {
      "sha": "f5b80346be8f6a2012965493822cf4a7a089eb88",
      "filename": "backend/vendor/github.com/slack-go/slack/chat.go",
      "status": "added",
      "additions": 840,
      "deletions": 0,
      "changes": 840,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/chat.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/chat.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/chat.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,840 @@\n+package slack\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"io/ioutil\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\n+\t\"github.com/slack-go/slack/slackutilsx\"\n+)\n+\n+const (\n+\tDEFAULT_MESSAGE_USERNAME         = \"\"\n+\tDEFAULT_MESSAGE_REPLY_BROADCAST  = false\n+\tDEFAULT_MESSAGE_ASUSER           = false\n+\tDEFAULT_MESSAGE_PARSE            = \"\"\n+\tDEFAULT_MESSAGE_THREAD_TIMESTAMP = \"\"\n+\tDEFAULT_MESSAGE_LINK_NAMES       = 0\n+\tDEFAULT_MESSAGE_UNFURL_LINKS     = false\n+\tDEFAULT_MESSAGE_UNFURL_MEDIA     = true\n+\tDEFAULT_MESSAGE_ICON_URL         = \"\"\n+\tDEFAULT_MESSAGE_ICON_EMOJI       = \"\"\n+\tDEFAULT_MESSAGE_MARKDOWN         = true\n+\tDEFAULT_MESSAGE_ESCAPE_TEXT      = true\n+)\n+\n+type chatResponseFull struct {\n+\tChannel            string `json:\"channel\"`\n+\tTimestamp          string `json:\"ts\"`                             //Regular message timestamp\n+\tMessageTimeStamp   string `json:\"message_ts\"`                     //Ephemeral message timestamp\n+\tScheduledMessageID string `json:\"scheduled_message_id,omitempty\"` //Scheduled message id\n+\tText               string `json:\"text\"`\n+\tSlackResponse\n+}\n+\n+// getMessageTimestamp will inspect the `chatResponseFull` to ruturn a timestamp value\n+// in `chat.postMessage` its under `ts`\n+// in `chat.postEphemeral` its under `message_ts`\n+func (c chatResponseFull) getMessageTimestamp() string {\n+\tif len(c.Timestamp) > 0 {\n+\t\treturn c.Timestamp\n+\t}\n+\treturn c.MessageTimeStamp\n+}\n+\n+// PostMessageParameters contains all the parameters necessary (including the optional ones) for a PostMessage() request\n+type PostMessageParameters struct {\n+\tUsername        string `json:\"username\"`\n+\tAsUser          bool   `json:\"as_user\"`\n+\tParse           string `json:\"parse\"`\n+\tThreadTimestamp string `json:\"thread_ts\"`\n+\tReplyBroadcast  bool   `json:\"reply_broadcast\"`\n+\tLinkNames       int    `json:\"link_names\"`\n+\tUnfurlLinks     bool   `json:\"unfurl_links\"`\n+\tUnfurlMedia     bool   `json:\"unfurl_media\"`\n+\tIconURL         string `json:\"icon_url\"`\n+\tIconEmoji       string `json:\"icon_emoji\"`\n+\tMarkdown        bool   `json:\"mrkdwn,omitempty\"`\n+\tEscapeText      bool   `json:\"escape_text\"`\n+\n+\t// chat.postEphemeral support\n+\tChannel string `json:\"channel\"`\n+\tUser    string `json:\"user\"`\n+}\n+\n+// NewPostMessageParameters provides an instance of PostMessageParameters with all the sane default values set\n+func NewPostMessageParameters() PostMessageParameters {\n+\treturn PostMessageParameters{\n+\t\tUsername:        DEFAULT_MESSAGE_USERNAME,\n+\t\tUser:            DEFAULT_MESSAGE_USERNAME,\n+\t\tAsUser:          DEFAULT_MESSAGE_ASUSER,\n+\t\tParse:           DEFAULT_MESSAGE_PARSE,\n+\t\tThreadTimestamp: DEFAULT_MESSAGE_THREAD_TIMESTAMP,\n+\t\tLinkNames:       DEFAULT_MESSAGE_LINK_NAMES,\n+\t\tUnfurlLinks:     DEFAULT_MESSAGE_UNFURL_LINKS,\n+\t\tUnfurlMedia:     DEFAULT_MESSAGE_UNFURL_MEDIA,\n+\t\tIconURL:         DEFAULT_MESSAGE_ICON_URL,\n+\t\tIconEmoji:       DEFAULT_MESSAGE_ICON_EMOJI,\n+\t\tMarkdown:        DEFAULT_MESSAGE_MARKDOWN,\n+\t\tEscapeText:      DEFAULT_MESSAGE_ESCAPE_TEXT,\n+\t}\n+}\n+\n+// DeleteMessage deletes a message in a channel\n+func (api *Client) DeleteMessage(channel, messageTimestamp string) (string, string, error) {\n+\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n+\t\tcontext.Background(),\n+\t\tchannel,\n+\t\tMsgOptionDelete(messageTimestamp),\n+\t)\n+\treturn respChannel, respTimestamp, err\n+}\n+\n+// DeleteMessageContext deletes a message in a channel with a custom context\n+func (api *Client) DeleteMessageContext(ctx context.Context, channel, messageTimestamp string) (string, string, error) {\n+\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n+\t\tctx,\n+\t\tchannel,\n+\t\tMsgOptionDelete(messageTimestamp),\n+\t)\n+\treturn respChannel, respTimestamp, err\n+}\n+\n+// ScheduleMessage sends a message to a channel.\n+// Message is escaped by default according to https://api.slack.com/docs/formatting\n+// Use http://davestevens.github.io/slack-message-builder/ to help crafting your message.\n+func (api *Client) ScheduleMessage(channelID, postAt string, options ...MsgOption) (string, string, error) {\n+\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n+\t\tcontext.Background(),\n+\t\tchannelID,\n+\t\tMsgOptionSchedule(postAt),\n+\t\tMsgOptionCompose(options...),\n+\t)\n+\treturn respChannel, respTimestamp, err\n+}\n+\n+// PostMessage sends a message to a channel.\n+// Message is escaped by default according to https://api.slack.com/docs/formatting\n+// Use http://davestevens.github.io/slack-message-builder/ to help crafting your message.\n+func (api *Client) PostMessage(channelID string, options ...MsgOption) (string, string, error) {\n+\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n+\t\tcontext.Background(),\n+\t\tchannelID,\n+\t\tMsgOptionPost(),\n+\t\tMsgOptionCompose(options...),\n+\t)\n+\treturn respChannel, respTimestamp, err\n+}\n+\n+// PostMessageContext sends a message to a channel with a custom context\n+// For more details, see PostMessage documentation.\n+func (api *Client) PostMessageContext(ctx context.Context, channelID string, options ...MsgOption) (string, string, error) {\n+\trespChannel, respTimestamp, _, err := api.SendMessageContext(\n+\t\tctx,\n+\t\tchannelID,\n+\t\tMsgOptionPost(),\n+\t\tMsgOptionCompose(options...),\n+\t)\n+\treturn respChannel, respTimestamp, err\n+}\n+\n+// PostEphemeral sends an ephemeral message to a user in a channel.\n+// Message is escaped by default according to https://api.slack.com/docs/formatting\n+// Use http://davestevens.github.io/slack-message-builder/ to help crafting your message.\n+func (api *Client) PostEphemeral(channelID, userID string, options ...MsgOption) (string, error) {\n+\treturn api.PostEphemeralContext(\n+\t\tcontext.Background(),\n+\t\tchannelID,\n+\t\tuserID,\n+\t\toptions...,\n+\t)\n+}\n+\n+// PostEphemeralContext sends an ephemeal message to a user in a channel with a custom context\n+// For more details, see PostEphemeral documentation\n+func (api *Client) PostEphemeralContext(ctx context.Context, channelID, userID string, options ...MsgOption) (timestamp string, err error) {\n+\t_, timestamp, _, err = api.SendMessageContext(\n+\t\tctx,\n+\t\tchannelID,\n+\t\tMsgOptionPostEphemeral(userID),\n+\t\tMsgOptionCompose(options...),\n+\t)\n+\treturn timestamp, err\n+}\n+\n+// UpdateMessage updates a message in a channel\n+func (api *Client) UpdateMessage(channelID, timestamp string, options ...MsgOption) (string, string, string, error) {\n+\treturn api.SendMessageContext(\n+\t\tcontext.Background(),\n+\t\tchannelID,\n+\t\tMsgOptionUpdate(timestamp),\n+\t\tMsgOptionCompose(options...),\n+\t)\n+}\n+\n+// UpdateMessageContext updates a message in a channel\n+func (api *Client) UpdateMessageContext(ctx context.Context, channelID, timestamp string, options ...MsgOption) (string, string, string, error) {\n+\treturn api.SendMessageContext(\n+\t\tctx,\n+\t\tchannelID,\n+\t\tMsgOptionUpdate(timestamp),\n+\t\tMsgOptionCompose(options...),\n+\t)\n+}\n+\n+// UnfurlMessage unfurls a message in a channel\n+func (api *Client) UnfurlMessage(channelID, timestamp string, unfurls map[string]Attachment, options ...MsgOption) (string, string, string, error) {\n+\treturn api.SendMessageContext(context.Background(), channelID, MsgOptionUnfurl(timestamp, unfurls), MsgOptionCompose(options...))\n+}\n+\n+// UnfurlMessageWithAuthURL sends an unfurl request containing an\n+// authentication URL.\n+// For more details see:\n+// https://api.slack.com/reference/messaging/link-unfurling#authenticated_unfurls\n+func (api *Client) UnfurlMessageWithAuthURL(channelID, timestamp string, userAuthURL string, options ...MsgOption) (string, string, string, error) {\n+\treturn api.UnfurlMessageWithAuthURLContext(context.Background(), channelID, timestamp, userAuthURL, options...)\n+}\n+\n+// UnfurlMessageWithAuthURLContext sends an unfurl request containing an\n+// authentication URL.\n+// For more details see:\n+// https://api.slack.com/reference/messaging/link-unfurling#authenticated_unfurls\n+func (api *Client) UnfurlMessageWithAuthURLContext(ctx context.Context, channelID, timestamp string, userAuthURL string, options ...MsgOption) (string, string, string, error) {\n+\treturn api.SendMessageContext(ctx, channelID, MsgOptionUnfurlAuthURL(timestamp, userAuthURL), MsgOptionCompose(options...))\n+}\n+\n+// SendMessage more flexible method for configuring messages.\n+func (api *Client) SendMessage(channel string, options ...MsgOption) (string, string, string, error) {\n+\treturn api.SendMessageContext(context.Background(), channel, options...)\n+}\n+\n+// SendMessageContext more flexible method for configuring messages with a custom context.\n+func (api *Client) SendMessageContext(ctx context.Context, channelID string, options ...MsgOption) (_channel string, _timestamp string, _text string, err error) {\n+\tvar (\n+\t\treq      *http.Request\n+\t\tparser   func(*chatResponseFull) responseParser\n+\t\tresponse chatResponseFull\n+\t)\n+\n+\tif req, parser, err = buildSender(api.endpoint, options...).BuildRequest(api.token, channelID); err != nil {\n+\t\treturn \"\", \"\", \"\", err\n+\t}\n+\n+\tif api.Debug() {\n+\t\treqBody, err := ioutil.ReadAll(req.Body)\n+\t\tif err != nil {\n+\t\t\treturn \"\", \"\", \"\", err\n+\t\t}\n+\t\treq.Body = ioutil.NopCloser(bytes.NewBuffer(reqBody))\n+\t\tapi.Debugf(\"Sending request: %s\", string(reqBody))\n+\t}\n+\n+\tif err = doPost(ctx, api.httpclient, req, parser(&response), api); err != nil {\n+\t\treturn \"\", \"\", \"\", err\n+\t}\n+\n+\treturn response.Channel, response.getMessageTimestamp(), response.Text, response.Err()\n+}\n+\n+// UnsafeApplyMsgOptions utility function for debugging/testing chat requests.\n+// NOTE: USE AT YOUR OWN RISK: No issues relating to the use of this function\n+// will be supported by the library.\n+func UnsafeApplyMsgOptions(token, channel, apiurl string, options ...MsgOption) (string, url.Values, error) {\n+\tconfig, err := applyMsgOptions(token, channel, apiurl, options...)\n+\treturn config.endpoint, config.values, err\n+}\n+\n+func applyMsgOptions(token, channel, apiurl string, options ...MsgOption) (sendConfig, error) {\n+\tconfig := sendConfig{\n+\t\tapiurl:   apiurl,\n+\t\tendpoint: apiurl + string(chatPostMessage),\n+\t\tvalues: url.Values{\n+\t\t\t\"token\":   {token},\n+\t\t\t\"channel\": {channel},\n+\t\t},\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\tif err := opt(&config); err != nil {\n+\t\t\treturn config, err\n+\t\t}\n+\t}\n+\n+\treturn config, nil\n+}\n+\n+func buildSender(apiurl string, options ...MsgOption) sendConfig {\n+\treturn sendConfig{\n+\t\tapiurl:  apiurl,\n+\t\toptions: options,\n+\t}\n+}\n+\n+type sendMode string\n+\n+const (\n+\tchatUpdate          sendMode = \"chat.update\"\n+\tchatPostMessage     sendMode = \"chat.postMessage\"\n+\tchatScheduleMessage sendMode = \"chat.scheduleMessage\"\n+\tchatDelete          sendMode = \"chat.delete\"\n+\tchatPostEphemeral   sendMode = \"chat.postEphemeral\"\n+\tchatResponse        sendMode = \"chat.responseURL\"\n+\tchatMeMessage       sendMode = \"chat.meMessage\"\n+\tchatUnfurl          sendMode = \"chat.unfurl\"\n+)\n+\n+type sendConfig struct {\n+\tapiurl          string\n+\toptions         []MsgOption\n+\tmode            sendMode\n+\tendpoint        string\n+\tvalues          url.Values\n+\tattachments     []Attachment\n+\tblocks          Blocks\n+\tresponseType    string\n+\treplaceOriginal bool\n+\tdeleteOriginal  bool\n+}\n+\n+func (t sendConfig) BuildRequest(token, channelID string) (req *http.Request, _ func(*chatResponseFull) responseParser, err error) {\n+\tif t, err = applyMsgOptions(token, channelID, t.apiurl, t.options...); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tswitch t.mode {\n+\tcase chatResponse:\n+\t\treturn responseURLSender{\n+\t\t\tendpoint:        t.endpoint,\n+\t\t\tvalues:          t.values,\n+\t\t\tattachments:     t.attachments,\n+\t\t\tblocks:          t.blocks,\n+\t\t\tresponseType:    t.responseType,\n+\t\t\treplaceOriginal: t.replaceOriginal,\n+\t\t\tdeleteOriginal:  t.deleteOriginal,\n+\t\t}.BuildRequest()\n+\tdefault:\n+\t\treturn formSender{endpoint: t.endpoint, values: t.values}.BuildRequest()\n+\t}\n+}\n+\n+type formSender struct {\n+\tendpoint string\n+\tvalues   url.Values\n+}\n+\n+func (t formSender) BuildRequest() (*http.Request, func(*chatResponseFull) responseParser, error) {\n+\treq, err := formReq(t.endpoint, t.values)\n+\treturn req, func(resp *chatResponseFull) responseParser {\n+\t\treturn newJSONParser(resp)\n+\t}, err\n+}\n+\n+type responseURLSender struct {\n+\tendpoint        string\n+\tvalues          url.Values\n+\tattachments     []Attachment\n+\tblocks          Blocks\n+\tresponseType    string\n+\treplaceOriginal bool\n+\tdeleteOriginal  bool\n+}\n+\n+func (t responseURLSender) BuildRequest() (*http.Request, func(*chatResponseFull) responseParser, error) {\n+\treq, err := jsonReq(t.endpoint, Msg{\n+\t\tText:            t.values.Get(\"text\"),\n+\t\tTimestamp:       t.values.Get(\"ts\"),\n+\t\tAttachments:     t.attachments,\n+\t\tBlocks:          t.blocks,\n+\t\tResponseType:    t.responseType,\n+\t\tReplaceOriginal: t.replaceOriginal,\n+\t\tDeleteOriginal:  t.deleteOriginal,\n+\t})\n+\treturn req, func(resp *chatResponseFull) responseParser {\n+\t\treturn newContentTypeParser(resp)\n+\t}, err\n+}\n+\n+// MsgOption option provided when sending a message.\n+type MsgOption func(*sendConfig) error\n+\n+// MsgOptionSchedule schedules a messages.\n+func MsgOptionSchedule(postAt string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatScheduleMessage)\n+\t\tconfig.values.Add(\"post_at\", postAt)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionPost posts a messages, this is the default.\n+func MsgOptionPost() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatPostMessage)\n+\t\tconfig.values.Del(\"ts\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionPostEphemeral - posts an ephemeral message to the provided user.\n+func MsgOptionPostEphemeral(userID string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatPostEphemeral)\n+\t\tMsgOptionUser(userID)(config)\n+\t\tconfig.values.Del(\"ts\")\n+\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionMeMessage posts a \"me message\" type from the calling user\n+func MsgOptionMeMessage() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatMeMessage)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionUpdate updates a message based on the timestamp.\n+func MsgOptionUpdate(timestamp string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatUpdate)\n+\t\tconfig.values.Add(\"ts\", timestamp)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionDelete deletes a message based on the timestamp.\n+func MsgOptionDelete(timestamp string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatDelete)\n+\t\tconfig.values.Add(\"ts\", timestamp)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionUnfurl unfurls a message based on the timestamp.\n+func MsgOptionUnfurl(timestamp string, unfurls map[string]Attachment) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n+\t\tconfig.values.Add(\"ts\", timestamp)\n+\t\tunfurlsStr, err := json.Marshal(unfurls)\n+\t\tif err == nil {\n+\t\t\tconfig.values.Add(\"unfurls\", string(unfurlsStr))\n+\t\t}\n+\t\treturn err\n+\t}\n+}\n+\n+// MsgOptionUnfurlAuthURL unfurls a message using an auth url based on the timestamp.\n+func MsgOptionUnfurlAuthURL(timestamp string, userAuthURL string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n+\t\tconfig.values.Add(\"ts\", timestamp)\n+\t\tconfig.values.Add(\"user_auth_url\", userAuthURL)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionUnfurlAuthRequired requests that the user installs the\n+// Slack app for unfurling.\n+func MsgOptionUnfurlAuthRequired(timestamp string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n+\t\tconfig.values.Add(\"ts\", timestamp)\n+\t\tconfig.values.Add(\"user_auth_required\", \"true\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionUnfurlAuthMessage attaches a message inviting the user to\n+// authenticate.\n+func MsgOptionUnfurlAuthMessage(timestamp string, msg string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = config.apiurl + string(chatUnfurl)\n+\t\tconfig.values.Add(\"ts\", timestamp)\n+\t\tconfig.values.Add(\"user_auth_message\", msg)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionResponseURL supplies a url to use as the endpoint.\n+func MsgOptionResponseURL(url string, responseType string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.mode = chatResponse\n+\t\tconfig.endpoint = url\n+\t\tconfig.responseType = responseType\n+\t\tconfig.values.Del(\"ts\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionReplaceOriginal replaces original message with response url\n+func MsgOptionReplaceOriginal(responseURL string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.mode = chatResponse\n+\t\tconfig.endpoint = responseURL\n+\t\tconfig.replaceOriginal = true\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionDeleteOriginal deletes original message with response url\n+func MsgOptionDeleteOriginal(responseURL string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.mode = chatResponse\n+\t\tconfig.endpoint = responseURL\n+\t\tconfig.deleteOriginal = true\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionAsUser whether or not to send the message as the user.\n+func MsgOptionAsUser(b bool) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tif b != DEFAULT_MESSAGE_ASUSER {\n+\t\t\tconfig.values.Set(\"as_user\", \"true\")\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionUser set the user for the message.\n+func MsgOptionUser(userID string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"user\", userID)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionUsername set the username for the message.\n+func MsgOptionUsername(username string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"username\", username)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionText provide the text for the message, optionally escape the provided\n+// text.\n+func MsgOptionText(text string, escape bool) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tif escape {\n+\t\t\ttext = slackutilsx.EscapeMessage(text)\n+\t\t}\n+\t\tconfig.values.Add(\"text\", text)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionAttachments provide attachments for the message.\n+func MsgOptionAttachments(attachments ...Attachment) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tif attachments == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tconfig.attachments = attachments\n+\n+\t\t// FIXME: We are setting the attachments on the message twice: above for\n+\t\t// the json version, and below for the html version.  The marshalled bytes\n+\t\t// we put into config.values below don't work directly in the Msg version.\n+\n+\t\tattachmentBytes, err := json.Marshal(attachments)\n+\t\tif err == nil {\n+\t\t\tconfig.values.Set(\"attachments\", string(attachmentBytes))\n+\t\t}\n+\n+\t\treturn err\n+\t}\n+}\n+\n+// MsgOptionBlocks sets blocks for the message\n+func MsgOptionBlocks(blocks ...Block) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tif blocks == nil {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\tconfig.blocks.BlockSet = append(config.blocks.BlockSet, blocks...)\n+\n+\t\tblocks, err := json.Marshal(blocks)\n+\t\tif err == nil {\n+\t\t\tconfig.values.Set(\"blocks\", string(blocks))\n+\t\t}\n+\t\treturn err\n+\t}\n+}\n+\n+// MsgOptionEnableLinkUnfurl enables link unfurling\n+func MsgOptionEnableLinkUnfurl() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"unfurl_links\", \"true\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionDisableLinkUnfurl disables link unfurling\n+func MsgOptionDisableLinkUnfurl() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"unfurl_links\", \"false\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionDisableMediaUnfurl disables media unfurling.\n+func MsgOptionDisableMediaUnfurl() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"unfurl_media\", \"false\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionDisableMarkdown disables markdown.\n+func MsgOptionDisableMarkdown() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"mrkdwn\", \"false\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionTS sets the thread TS of the message to enable creating or replying to a thread\n+func MsgOptionTS(ts string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"thread_ts\", ts)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionBroadcast sets reply_broadcast to true\n+func MsgOptionBroadcast() MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"reply_broadcast\", \"true\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionCompose combines multiple options into a single option.\n+func MsgOptionCompose(options ...MsgOption) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tfor _, opt := range options {\n+\t\t\tif err := opt(config); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionParse set parse option.\n+func MsgOptionParse(b bool) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tvar v string\n+\t\tif b {\n+\t\t\tv = \"full\"\n+\t\t} else {\n+\t\t\tv = \"none\"\n+\t\t}\n+\t\tconfig.values.Set(\"parse\", v)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionIconURL sets an icon URL\n+func MsgOptionIconURL(iconURL string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"icon_url\", iconURL)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionIconEmoji sets an icon emoji\n+func MsgOptionIconEmoji(iconEmoji string) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.values.Set(\"icon_emoji\", iconEmoji)\n+\t\treturn nil\n+\t}\n+}\n+\n+// UnsafeMsgOptionEndpoint deliver the message to the specified endpoint.\n+// NOTE: USE AT YOUR OWN RISK: No issues relating to the use of this Option\n+// will be supported by the library, it is subject to change without notice that\n+// may result in compilation errors or runtime behaviour changes.\n+func UnsafeMsgOptionEndpoint(endpoint string, update func(url.Values)) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tconfig.endpoint = endpoint\n+\t\tupdate(config.values)\n+\t\treturn nil\n+\t}\n+}\n+\n+// MsgOptionPostMessageParameters maintain backwards compatibility.\n+func MsgOptionPostMessageParameters(params PostMessageParameters) MsgOption {\n+\treturn func(config *sendConfig) error {\n+\t\tif params.Username != DEFAULT_MESSAGE_USERNAME {\n+\t\t\tconfig.values.Set(\"username\", params.Username)\n+\t\t}\n+\n+\t\t// chat.postEphemeral support\n+\t\tif params.User != DEFAULT_MESSAGE_USERNAME {\n+\t\t\tconfig.values.Set(\"user\", params.User)\n+\t\t}\n+\n+\t\t// never generates an error.\n+\t\tMsgOptionAsUser(params.AsUser)(config)\n+\n+\t\tif params.Parse != DEFAULT_MESSAGE_PARSE {\n+\t\t\tconfig.values.Set(\"parse\", params.Parse)\n+\t\t}\n+\t\tif params.LinkNames != DEFAULT_MESSAGE_LINK_NAMES {\n+\t\t\tconfig.values.Set(\"link_names\", \"1\")\n+\t\t}\n+\n+\t\tif params.UnfurlLinks != DEFAULT_MESSAGE_UNFURL_LINKS {\n+\t\t\tconfig.values.Set(\"unfurl_links\", \"true\")\n+\t\t}\n+\n+\t\t// I want to send a message with explicit `as_user` `true` and `unfurl_links` `false` in request.\n+\t\t// Because setting `as_user` to `true` will change the default value for `unfurl_links` to `true` on Slack API side.\n+\t\tif params.AsUser != DEFAULT_MESSAGE_ASUSER && params.UnfurlLinks == DEFAULT_MESSAGE_UNFURL_LINKS {\n+\t\t\tconfig.values.Set(\"unfurl_links\", \"false\")\n+\t\t}\n+\t\tif params.UnfurlMedia != DEFAULT_MESSAGE_UNFURL_MEDIA {\n+\t\t\tconfig.values.Set(\"unfurl_media\", \"false\")\n+\t\t}\n+\t\tif params.IconURL != DEFAULT_MESSAGE_ICON_URL {\n+\t\t\tconfig.values.Set(\"icon_url\", params.IconURL)\n+\t\t}\n+\t\tif params.IconEmoji != DEFAULT_MESSAGE_ICON_EMOJI {\n+\t\t\tconfig.values.Set(\"icon_emoji\", params.IconEmoji)\n+\t\t}\n+\t\tif params.Markdown != DEFAULT_MESSAGE_MARKDOWN {\n+\t\t\tconfig.values.Set(\"mrkdwn\", \"false\")\n+\t\t}\n+\n+\t\tif params.ThreadTimestamp != DEFAULT_MESSAGE_THREAD_TIMESTAMP {\n+\t\t\tconfig.values.Set(\"thread_ts\", params.ThreadTimestamp)\n+\t\t}\n+\t\tif params.ReplyBroadcast != DEFAULT_MESSAGE_REPLY_BROADCAST {\n+\t\t\tconfig.values.Set(\"reply_broadcast\", \"true\")\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+}\n+\n+// PermalinkParameters are the parameters required to get a permalink to a\n+// message. Slack documentation can be found here:\n+// https://api.slack.com/methods/chat.getPermalink\n+type PermalinkParameters struct {\n+\tChannel string\n+\tTs      string\n+}\n+\n+// GetPermalink returns the permalink for a message. It takes\n+// PermalinkParameters and returns a string containing the permalink. It\n+// returns an error if unable to retrieve the permalink.\n+func (api *Client) GetPermalink(params *PermalinkParameters) (string, error) {\n+\treturn api.GetPermalinkContext(context.Background(), params)\n+}\n+\n+// GetPermalinkContext returns the permalink for a message using a custom context.\n+func (api *Client) GetPermalinkContext(ctx context.Context, params *PermalinkParameters) (string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":      {api.token},\n+\t\t\"channel\":    {params.Channel},\n+\t\t\"message_ts\": {params.Ts},\n+\t}\n+\n+\tresponse := struct {\n+\t\tChannel   string `json:\"channel\"`\n+\t\tPermalink string `json:\"permalink\"`\n+\t\tSlackResponse\n+\t}{}\n+\terr := api.getMethod(ctx, \"chat.getPermalink\", values, &response)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn response.Permalink, response.Err()\n+}\n+\n+type GetScheduledMessagesParameters struct {\n+\tChannel string\n+\tCursor  string\n+\tLatest  string\n+\tLimit   int\n+\tOldest  string\n+}\n+\n+// GetScheduledMessages returns the list of scheduled messages based on params\n+func (api *Client) GetScheduledMessages(params *GetScheduledMessagesParameters) (channels []ScheduledMessage, nextCursor string, err error) {\n+\treturn api.GetScheduledMessagesContext(context.Background(), params)\n+}\n+\n+// GetScheduledMessagesContext returns the list of scheduled messages in a Slack team with a custom context\n+func (api *Client) GetScheduledMessagesContext(ctx context.Context, params *GetScheduledMessagesParameters) (channels []ScheduledMessage, nextCursor string, err error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.Channel != \"\" {\n+\t\tvalues.Add(\"channel\", params.Channel)\n+\t}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\tif params.Limit != 0 {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tif params.Latest != \"\" {\n+\t\tvalues.Add(\"latest\", params.Latest)\n+\t}\n+\tif params.Oldest != \"\" {\n+\t\tvalues.Add(\"oldest\", params.Oldest)\n+\t}\n+\tresponse := struct {\n+\t\tMessages         []ScheduledMessage `json:\"scheduled_messages\"`\n+\t\tResponseMetaData responseMetaData   `json:\"response_metadata\"`\n+\t\tSlackResponse\n+\t}{}\n+\n+\terr = api.postMethod(ctx, \"chat.scheduledMessages.list\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\treturn response.Messages, response.ResponseMetaData.NextCursor, response.Err()\n+}\n+\n+type DeleteScheduledMessageParameters struct {\n+\tChannel            string\n+\tScheduledMessageID string\n+\tAsUser             bool\n+}\n+\n+// DeleteScheduledMessage returns the list of scheduled messages based on params\n+func (api *Client) DeleteScheduledMessage(params *DeleteScheduledMessageParameters) (bool, error) {\n+\treturn api.DeleteScheduledMessageContext(context.Background(), params)\n+}\n+\n+// DeleteScheduledMessageContext returns the list of scheduled messages in a Slack team with a custom context\n+func (api *Client) DeleteScheduledMessageContext(ctx context.Context, params *DeleteScheduledMessageParameters) (bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":                {api.token},\n+\t\t\"channel\":              {params.Channel},\n+\t\t\"scheduled_message_id\": {params.ScheduledMessageID},\n+\t\t\"as_user\":              {strconv.FormatBool(params.AsUser)},\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"chat.deleteScheduledMessage\", values, &response)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\treturn response.Ok, response.Err()\n+}"
    },
    {
      "sha": "7d1c0d4eb2e2ad3c4eb4ccc02c9aed2c54aa8329",
      "filename": "backend/vendor/github.com/slack-go/slack/comment.go",
      "status": "added",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/comment.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/comment.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/comment.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,10 @@\n+package slack\n+\n+// Comment contains all the information relative to a comment\n+type Comment struct {\n+\tID        string   `json:\"id,omitempty\"`\n+\tCreated   JSONTime `json:\"created,omitempty\"`\n+\tTimestamp JSONTime `json:\"timestamp,omitempty\"`\n+\tUser      string   `json:\"user,omitempty\"`\n+\tComment   string   `json:\"comment,omitempty\"`\n+}"
    },
    {
      "sha": "6fc4a0839d04fa2140c5528396ca7e561b151c98",
      "filename": "backend/vendor/github.com/slack-go/slack/conversation.go",
      "status": "added",
      "additions": 645,
      "deletions": 0,
      "changes": 645,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/conversation.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/conversation.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/conversation.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,645 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+// Conversation is the foundation for IM and BaseGroupConversation\n+type Conversation struct {\n+\tID                 string   `json:\"id\"`\n+\tCreated            JSONTime `json:\"created\"`\n+\tIsOpen             bool     `json:\"is_open\"`\n+\tLastRead           string   `json:\"last_read,omitempty\"`\n+\tLatest             *Message `json:\"latest,omitempty\"`\n+\tUnreadCount        int      `json:\"unread_count,omitempty\"`\n+\tUnreadCountDisplay int      `json:\"unread_count_display,omitempty\"`\n+\tIsGroup            bool     `json:\"is_group\"`\n+\tIsShared           bool     `json:\"is_shared\"`\n+\tIsIM               bool     `json:\"is_im\"`\n+\tIsExtShared        bool     `json:\"is_ext_shared\"`\n+\tIsOrgShared        bool     `json:\"is_org_shared\"`\n+\tIsPendingExtShared bool     `json:\"is_pending_ext_shared\"`\n+\tIsPrivate          bool     `json:\"is_private\"`\n+\tIsMpIM             bool     `json:\"is_mpim\"`\n+\tUnlinked           int      `json:\"unlinked\"`\n+\tNameNormalized     string   `json:\"name_normalized\"`\n+\tNumMembers         int      `json:\"num_members\"`\n+\tPriority           float64  `json:\"priority\"`\n+\tUser               string   `json:\"user\"`\n+\n+\t// TODO support pending_shared\n+\t// TODO support previous_names\n+}\n+\n+// GroupConversation is the foundation for Group and Channel\n+type GroupConversation struct {\n+\tConversation\n+\tName       string   `json:\"name\"`\n+\tCreator    string   `json:\"creator\"`\n+\tIsArchived bool     `json:\"is_archived\"`\n+\tMembers    []string `json:\"members\"`\n+\tTopic      Topic    `json:\"topic\"`\n+\tPurpose    Purpose  `json:\"purpose\"`\n+}\n+\n+// Topic contains information about the topic\n+type Topic struct {\n+\tValue   string   `json:\"value\"`\n+\tCreator string   `json:\"creator\"`\n+\tLastSet JSONTime `json:\"last_set\"`\n+}\n+\n+// Purpose contains information about the purpose\n+type Purpose struct {\n+\tValue   string   `json:\"value\"`\n+\tCreator string   `json:\"creator\"`\n+\tLastSet JSONTime `json:\"last_set\"`\n+}\n+\n+type GetUsersInConversationParameters struct {\n+\tChannelID string\n+\tCursor    string\n+\tLimit     int\n+}\n+\n+type GetConversationsForUserParameters struct {\n+\tUserID          string\n+\tCursor          string\n+\tTypes           []string\n+\tLimit           int\n+\tExcludeArchived bool\n+}\n+\n+type responseMetaData struct {\n+\tNextCursor string `json:\"next_cursor\"`\n+}\n+\n+// GetUsersInConversation returns the list of users in a conversation\n+func (api *Client) GetUsersInConversation(params *GetUsersInConversationParameters) ([]string, string, error) {\n+\treturn api.GetUsersInConversationContext(context.Background(), params)\n+}\n+\n+// GetUsersInConversationContext returns the list of users in a conversation with a custom context\n+func (api *Client) GetUsersInConversationContext(ctx context.Context, params *GetUsersInConversationParameters) ([]string, string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {params.ChannelID},\n+\t}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\tif params.Limit != 0 {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tresponse := struct {\n+\t\tMembers          []string         `json:\"members\"`\n+\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n+\t\tSlackResponse\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"conversations.members\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\tif err := response.Err(); err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\treturn response.Members, response.ResponseMetaData.NextCursor, nil\n+}\n+\n+// GetConversationsForUser returns the list conversations for a given user\n+func (api *Client) GetConversationsForUser(params *GetConversationsForUserParameters) (channels []Channel, nextCursor string, err error) {\n+\treturn api.GetConversationsForUserContext(context.Background(), params)\n+}\n+\n+// GetConversationsForUserContext returns the list conversations for a given user with a custom context\n+func (api *Client) GetConversationsForUserContext(ctx context.Context, params *GetConversationsForUserParameters) (channels []Channel, nextCursor string, err error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.UserID != \"\" {\n+\t\tvalues.Add(\"user\", params.UserID)\n+\t}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\tif params.Limit != 0 {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tif params.Types != nil {\n+\t\tvalues.Add(\"types\", strings.Join(params.Types, \",\"))\n+\t}\n+\tif params.ExcludeArchived {\n+\t\tvalues.Add(\"exclude_archived\", \"true\")\n+\t}\n+\tresponse := struct {\n+\t\tChannels         []Channel        `json:\"channels\"`\n+\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n+\t\tSlackResponse\n+\t}{}\n+\terr = api.postMethod(ctx, \"users.conversations\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\treturn response.Channels, response.ResponseMetaData.NextCursor, response.Err()\n+}\n+\n+// ArchiveConversation archives a conversation\n+func (api *Client) ArchiveConversation(channelID string) error {\n+\treturn api.ArchiveConversationContext(context.Background(), channelID)\n+}\n+\n+// ArchiveConversationContext archives a conversation with a custom context\n+func (api *Client) ArchiveConversationContext(ctx context.Context, channelID string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\n+\tresponse := SlackResponse{}\n+\terr := api.postMethod(ctx, \"conversations.archive\", values, &response)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// UnArchiveConversation reverses conversation archival\n+func (api *Client) UnArchiveConversation(channelID string) error {\n+\treturn api.UnArchiveConversationContext(context.Background(), channelID)\n+}\n+\n+// UnArchiveConversationContext reverses conversation archival with a custom context\n+func (api *Client) UnArchiveConversationContext(ctx context.Context, channelID string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\tresponse := SlackResponse{}\n+\terr := api.postMethod(ctx, \"conversations.unarchive\", values, &response)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// SetTopicOfConversation sets the topic for a conversation\n+func (api *Client) SetTopicOfConversation(channelID, topic string) (*Channel, error) {\n+\treturn api.SetTopicOfConversationContext(context.Background(), channelID, topic)\n+}\n+\n+// SetTopicOfConversationContext sets the topic for a conversation with a custom context\n+func (api *Client) SetTopicOfConversationContext(ctx context.Context, channelID, topic string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"topic\":   {topic},\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t\tChannel *Channel `json:\"channel\"`\n+\t}{}\n+\terr := api.postMethod(ctx, \"conversations.setTopic\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response.Channel, response.Err()\n+}\n+\n+// SetPurposeOfConversation sets the purpose for a conversation\n+func (api *Client) SetPurposeOfConversation(channelID, purpose string) (*Channel, error) {\n+\treturn api.SetPurposeOfConversationContext(context.Background(), channelID, purpose)\n+}\n+\n+// SetPurposeOfConversationContext sets the purpose for a conversation with a custom context\n+func (api *Client) SetPurposeOfConversationContext(ctx context.Context, channelID, purpose string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"purpose\": {purpose},\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t\tChannel *Channel `json:\"channel\"`\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"conversations.setPurpose\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response.Channel, response.Err()\n+}\n+\n+// RenameConversation renames a conversation\n+func (api *Client) RenameConversation(channelID, channelName string) (*Channel, error) {\n+\treturn api.RenameConversationContext(context.Background(), channelID, channelName)\n+}\n+\n+// RenameConversationContext renames a conversation with a custom context\n+func (api *Client) RenameConversationContext(ctx context.Context, channelID, channelName string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"name\":    {channelName},\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t\tChannel *Channel `json:\"channel\"`\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"conversations.rename\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response.Channel, response.Err()\n+}\n+\n+// InviteUsersToConversation invites users to a channel\n+func (api *Client) InviteUsersToConversation(channelID string, users ...string) (*Channel, error) {\n+\treturn api.InviteUsersToConversationContext(context.Background(), channelID, users...)\n+}\n+\n+// InviteUsersToConversationContext invites users to a channel with a custom context\n+func (api *Client) InviteUsersToConversationContext(ctx context.Context, channelID string, users ...string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"users\":   {strings.Join(users, \",\")},\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t\tChannel *Channel `json:\"channel\"`\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"conversations.invite\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response.Channel, response.Err()\n+}\n+\n+// KickUserFromConversation removes a user from a conversation\n+func (api *Client) KickUserFromConversation(channelID string, user string) error {\n+\treturn api.KickUserFromConversationContext(context.Background(), channelID, user)\n+}\n+\n+// KickUserFromConversationContext removes a user from a conversation with a custom context\n+func (api *Client) KickUserFromConversationContext(ctx context.Context, channelID string, user string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t\t\"user\":    {user},\n+\t}\n+\n+\tresponse := SlackResponse{}\n+\terr := api.postMethod(ctx, \"conversations.kick\", values, &response)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// CloseConversation closes a direct message or multi-person direct message\n+func (api *Client) CloseConversation(channelID string) (noOp bool, alreadyClosed bool, err error) {\n+\treturn api.CloseConversationContext(context.Background(), channelID)\n+}\n+\n+// CloseConversationContext closes a direct message or multi-person direct message with a custom context\n+func (api *Client) CloseConversationContext(ctx context.Context, channelID string) (noOp bool, alreadyClosed bool, err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t\tNoOp          bool `json:\"no_op\"`\n+\t\tAlreadyClosed bool `json:\"already_closed\"`\n+\t}{}\n+\n+\terr = api.postMethod(ctx, \"conversations.close\", values, &response)\n+\tif err != nil {\n+\t\treturn false, false, err\n+\t}\n+\n+\treturn response.NoOp, response.AlreadyClosed, response.Err()\n+}\n+\n+// CreateConversation initiates a public or private channel-based conversation\n+func (api *Client) CreateConversation(channelName string, isPrivate bool) (*Channel, error) {\n+\treturn api.CreateConversationContext(context.Background(), channelName, isPrivate)\n+}\n+\n+// CreateConversationContext initiates a public or private channel-based conversation with a custom context\n+func (api *Client) CreateConversationContext(ctx context.Context, channelName string, isPrivate bool) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":      {api.token},\n+\t\t\"name\":       {channelName},\n+\t\t\"is_private\": {strconv.FormatBool(isPrivate)},\n+\t}\n+\tresponse, err := api.channelRequest(ctx, \"conversations.create\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response.Channel, nil\n+}\n+\n+// GetConversationInfo retrieves information about a conversation\n+func (api *Client) GetConversationInfo(channelID string, includeLocale bool) (*Channel, error) {\n+\treturn api.GetConversationInfoContext(context.Background(), channelID, includeLocale)\n+}\n+\n+// GetConversationInfoContext retrieves information about a conversation with a custom context\n+func (api *Client) GetConversationInfoContext(ctx context.Context, channelID string, includeLocale bool) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":          {api.token},\n+\t\t\"channel\":        {channelID},\n+\t\t\"include_locale\": {strconv.FormatBool(includeLocale)},\n+\t}\n+\tresponse, err := api.channelRequest(ctx, \"conversations.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response.Channel, response.Err()\n+}\n+\n+// LeaveConversation leaves a conversation\n+func (api *Client) LeaveConversation(channelID string) (bool, error) {\n+\treturn api.LeaveConversationContext(context.Background(), channelID)\n+}\n+\n+// LeaveConversationContext leaves a conversation with a custom context\n+func (api *Client) LeaveConversationContext(ctx context.Context, channelID string) (bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channelID},\n+\t}\n+\n+\tresponse, err := api.channelRequest(ctx, \"conversations.leave\", values)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\treturn response.NotInChannel, err\n+}\n+\n+type GetConversationRepliesParameters struct {\n+\tChannelID string\n+\tTimestamp string\n+\tCursor    string\n+\tInclusive bool\n+\tLatest    string\n+\tLimit     int\n+\tOldest    string\n+}\n+\n+// GetConversationReplies retrieves a thread of messages posted to a conversation\n+func (api *Client) GetConversationReplies(params *GetConversationRepliesParameters) (msgs []Message, hasMore bool, nextCursor string, err error) {\n+\treturn api.GetConversationRepliesContext(context.Background(), params)\n+}\n+\n+// GetConversationRepliesContext retrieves a thread of messages posted to a conversation with a custom context\n+func (api *Client) GetConversationRepliesContext(ctx context.Context, params *GetConversationRepliesParameters) (msgs []Message, hasMore bool, nextCursor string, err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {params.ChannelID},\n+\t\t\"ts\":      {params.Timestamp},\n+\t}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\tif params.Latest != \"\" {\n+\t\tvalues.Add(\"latest\", params.Latest)\n+\t}\n+\tif params.Limit != 0 {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tif params.Oldest != \"\" {\n+\t\tvalues.Add(\"oldest\", params.Oldest)\n+\t}\n+\tif params.Inclusive {\n+\t\tvalues.Add(\"inclusive\", \"1\")\n+\t} else {\n+\t\tvalues.Add(\"inclusive\", \"0\")\n+\t}\n+\tresponse := struct {\n+\t\tSlackResponse\n+\t\tHasMore          bool `json:\"has_more\"`\n+\t\tResponseMetaData struct {\n+\t\t\tNextCursor string `json:\"next_cursor\"`\n+\t\t} `json:\"response_metadata\"`\n+\t\tMessages []Message `json:\"messages\"`\n+\t}{}\n+\n+\terr = api.postMethod(ctx, \"conversations.replies\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, false, \"\", err\n+\t}\n+\n+\treturn response.Messages, response.HasMore, response.ResponseMetaData.NextCursor, response.Err()\n+}\n+\n+type GetConversationsParameters struct {\n+\tCursor          string\n+\tExcludeArchived string\n+\tLimit           int\n+\tTypes           []string\n+}\n+\n+// GetConversations returns the list of channels in a Slack team\n+func (api *Client) GetConversations(params *GetConversationsParameters) (channels []Channel, nextCursor string, err error) {\n+\treturn api.GetConversationsContext(context.Background(), params)\n+}\n+\n+// GetConversationsContext returns the list of channels in a Slack team with a custom context\n+func (api *Client) GetConversationsContext(ctx context.Context, params *GetConversationsParameters) (channels []Channel, nextCursor string, err error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\tif params.Limit != 0 {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tif params.Types != nil {\n+\t\tvalues.Add(\"types\", strings.Join(params.Types, \",\"))\n+\t}\n+\tif params.ExcludeArchived == \"true\" {\n+\t\tvalues.Add(\"exclude_archived\", \"true\")\n+\t}\n+\n+\tresponse := struct {\n+\t\tChannels         []Channel        `json:\"channels\"`\n+\t\tResponseMetaData responseMetaData `json:\"response_metadata\"`\n+\t\tSlackResponse\n+\t}{}\n+\n+\terr = api.postMethod(ctx, \"conversations.list\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\treturn response.Channels, response.ResponseMetaData.NextCursor, response.Err()\n+}\n+\n+type OpenConversationParameters struct {\n+\tChannelID string\n+\tReturnIM  bool\n+\tUsers     []string\n+}\n+\n+// OpenConversation opens or resumes a direct message or multi-person direct message\n+func (api *Client) OpenConversation(params *OpenConversationParameters) (*Channel, bool, bool, error) {\n+\treturn api.OpenConversationContext(context.Background(), params)\n+}\n+\n+// OpenConversationContext opens or resumes a direct message or multi-person direct message with a custom context\n+func (api *Client) OpenConversationContext(ctx context.Context, params *OpenConversationParameters) (*Channel, bool, bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"return_im\": {strconv.FormatBool(params.ReturnIM)},\n+\t}\n+\tif params.ChannelID != \"\" {\n+\t\tvalues.Add(\"channel\", params.ChannelID)\n+\t}\n+\tif params.Users != nil {\n+\t\tvalues.Add(\"users\", strings.Join(params.Users, \",\"))\n+\t}\n+\tresponse := struct {\n+\t\tChannel     *Channel `json:\"channel\"`\n+\t\tNoOp        bool     `json:\"no_op\"`\n+\t\tAlreadyOpen bool     `json:\"already_open\"`\n+\t\tSlackResponse\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"conversations.open\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, false, false, err\n+\t}\n+\n+\treturn response.Channel, response.NoOp, response.AlreadyOpen, response.Err()\n+}\n+\n+// JoinConversation joins an existing conversation\n+func (api *Client) JoinConversation(channelID string) (*Channel, string, []string, error) {\n+\treturn api.JoinConversationContext(context.Background(), channelID)\n+}\n+\n+// JoinConversationContext joins an existing conversation with a custom context\n+func (api *Client) JoinConversationContext(ctx context.Context, channelID string) (*Channel, string, []string, error) {\n+\tvalues := url.Values{\"token\": {api.token}, \"channel\": {channelID}}\n+\tresponse := struct {\n+\t\tChannel          *Channel `json:\"channel\"`\n+\t\tWarning          string   `json:\"warning\"`\n+\t\tResponseMetaData *struct {\n+\t\t\tWarnings []string `json:\"warnings\"`\n+\t\t} `json:\"response_metadata\"`\n+\t\tSlackResponse\n+\t}{}\n+\n+\terr := api.postMethod(ctx, \"conversations.join\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, \"\", nil, err\n+\t}\n+\tif response.Err() != nil {\n+\t\treturn nil, \"\", nil, response.Err()\n+\t}\n+\tvar warnings []string\n+\tif response.ResponseMetaData != nil {\n+\t\twarnings = response.ResponseMetaData.Warnings\n+\t}\n+\treturn response.Channel, response.Warning, warnings, nil\n+}\n+\n+type GetConversationHistoryParameters struct {\n+\tChannelID string\n+\tCursor    string\n+\tInclusive bool\n+\tLatest    string\n+\tLimit     int\n+\tOldest    string\n+}\n+\n+type GetConversationHistoryResponse struct {\n+\tSlackResponse\n+\tHasMore          bool   `json:\"has_more\"`\n+\tPinCount         int    `json:\"pin_count\"`\n+\tLatest           string `json:\"latest\"`\n+\tResponseMetaData struct {\n+\t\tNextCursor string `json:\"next_cursor\"`\n+\t} `json:\"response_metadata\"`\n+\tMessages []Message `json:\"messages\"`\n+}\n+\n+// GetConversationHistory joins an existing conversation\n+func (api *Client) GetConversationHistory(params *GetConversationHistoryParameters) (*GetConversationHistoryResponse, error) {\n+\treturn api.GetConversationHistoryContext(context.Background(), params)\n+}\n+\n+// GetConversationHistoryContext joins an existing conversation with a custom context\n+func (api *Client) GetConversationHistoryContext(ctx context.Context, params *GetConversationHistoryParameters) (*GetConversationHistoryResponse, error) {\n+\tvalues := url.Values{\"token\": {api.token}, \"channel\": {params.ChannelID}}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\tif params.Inclusive {\n+\t\tvalues.Add(\"inclusive\", \"1\")\n+\t} else {\n+\t\tvalues.Add(\"inclusive\", \"0\")\n+\t}\n+\tif params.Latest != \"\" {\n+\t\tvalues.Add(\"latest\", params.Latest)\n+\t}\n+\tif params.Limit != 0 {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tif params.Oldest != \"\" {\n+\t\tvalues.Add(\"oldest\", params.Oldest)\n+\t}\n+\n+\tresponse := GetConversationHistoryResponse{}\n+\n+\terr := api.postMethod(ctx, \"conversations.history\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response, response.Err()\n+}\n+\n+// MarkConversation sets the read mark of a conversation to a specific point\n+func (api *Client) MarkConversation(channel, ts string) (err error) {\n+\treturn api.MarkConversationContext(context.Background(), channel, ts)\n+}\n+\n+// MarkConversationContext sets the read mark of a conversation to a specific point with a custom context\n+func (api *Client) MarkConversationContext(ctx context.Context, channel, ts string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channel},\n+\t\t\"ts\":      {ts},\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\n+\terr := api.postMethod(ctx, \"conversations.mark\", values, response)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn response.Err()\n+}"
    },
    {
      "sha": "f94113f4d11d7a319784218379f244896d81db49",
      "filename": "backend/vendor/github.com/slack-go/slack/dialog.go",
      "status": "added",
      "additions": 120,
      "deletions": 0,
      "changes": 120,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dialog.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dialog.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/dialog.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,120 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"strings\"\n+)\n+\n+// InputType is the type of the dialog input type\n+type InputType string\n+\n+const (\n+\t// InputTypeText textfield input\n+\tInputTypeText InputType = \"text\"\n+\t// InputTypeTextArea textarea input\n+\tInputTypeTextArea InputType = \"textarea\"\n+\t// InputTypeSelect select menus input\n+\tInputTypeSelect InputType = \"select\"\n+)\n+\n+// DialogInput for dialogs input type text or menu\n+type DialogInput struct {\n+\tType        InputType `json:\"type\"`\n+\tLabel       string    `json:\"label\"`\n+\tName        string    `json:\"name\"`\n+\tPlaceholder string    `json:\"placeholder\"`\n+\tOptional    bool      `json:\"optional\"`\n+\tHint        string    `json:\"hint\"`\n+}\n+\n+// DialogTrigger ...\n+type DialogTrigger struct {\n+\tTriggerID string `json:\"trigger_id\"` //Required. Must respond within 3 seconds.\n+\tDialog    Dialog `json:\"dialog\"`     //Required.\n+}\n+\n+// Dialog as in Slack dialogs\n+// https://api.slack.com/dialogs#option_element_attributes#top-level_dialog_attributes\n+type Dialog struct {\n+\tTriggerID      string          `json:\"trigger_id\"`      // Required\n+\tCallbackID     string          `json:\"callback_id\"`     // Required\n+\tState          string          `json:\"state,omitempty\"` // Optional\n+\tTitle          string          `json:\"title\"`\n+\tSubmitLabel    string          `json:\"submit_label,omitempty\"`\n+\tNotifyOnCancel bool            `json:\"notify_on_cancel\"`\n+\tElements       []DialogElement `json:\"elements\"`\n+}\n+\n+// DialogElement abstract type for dialogs.\n+type DialogElement interface{}\n+\n+// DialogCallback DEPRECATED use InteractionCallback\n+type DialogCallback InteractionCallback\n+\n+// DialogSubmissionCallback is sent from Slack when a user submits a form from within a dialog\n+type DialogSubmissionCallback struct {\n+\t// NOTE: State is only used with the dialog_submission type.\n+\t// You should use InteractionCallback.BlockActionsState for block_actions type.\n+\tState      string            `json:\"-\"`\n+\tSubmission map[string]string `json:\"submission\"`\n+}\n+\n+// DialogOpenResponse response from `dialog.open`\n+type DialogOpenResponse struct {\n+\tSlackResponse\n+\tDialogResponseMetadata DialogResponseMetadata `json:\"response_metadata\"`\n+}\n+\n+// DialogResponseMetadata lists the error messages\n+type DialogResponseMetadata struct {\n+\tMessages []string `json:\"messages\"`\n+}\n+\n+// DialogInputValidationError is an error when user inputs incorrect value to form from within a dialog\n+type DialogInputValidationError struct {\n+\tName  string `json:\"name\"`\n+\tError string `json:\"error\"`\n+}\n+\n+// DialogInputValidationErrors lists the name of field and that error messages\n+type DialogInputValidationErrors struct {\n+\tErrors []DialogInputValidationError `json:\"errors\"`\n+}\n+\n+// OpenDialog opens a dialog window where the triggerID originated from.\n+// EXPERIMENTAL: dialog functionality is currently experimental, api is not considered stable.\n+func (api *Client) OpenDialog(triggerID string, dialog Dialog) (err error) {\n+\treturn api.OpenDialogContext(context.Background(), triggerID, dialog)\n+}\n+\n+// OpenDialogContext opens a dialog window where the triggerId originated from with a custom context\n+// EXPERIMENTAL: dialog functionality is currently experimental, api is not considered stable.\n+func (api *Client) OpenDialogContext(ctx context.Context, triggerID string, dialog Dialog) (err error) {\n+\tif triggerID == \"\" {\n+\t\treturn ErrParametersMissing\n+\t}\n+\n+\treq := DialogTrigger{\n+\t\tTriggerID: triggerID,\n+\t\tDialog:    dialog,\n+\t}\n+\n+\tencoded, err := json.Marshal(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tresponse := &DialogOpenResponse{}\n+\tendpoint := api.endpoint + \"dialog.open\"\n+\tif err := postJSON(ctx, api.httpclient, endpoint, api.token, encoded, response, api); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif len(response.DialogResponseMetadata.Messages) > 0 {\n+\t\tresponse.Ok = false\n+\t\tresponse.Error += \"\\n\" + strings.Join(response.DialogResponseMetadata.Messages, \"\\n\")\n+\t}\n+\n+\treturn response.Err()\n+}"
    },
    {
      "sha": "385cef683a4425719368833254b9f705edfce515",
      "filename": "backend/vendor/github.com/slack-go/slack/dialog_select.go",
      "status": "added",
      "additions": 101,
      "deletions": 0,
      "changes": 101,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dialog_select.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dialog_select.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/dialog_select.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,101 @@\n+package slack\n+\n+// SelectDataSource types of select datasource\n+type SelectDataSource string\n+\n+const (\n+\t// DialogDataSourceStatic menu with static Options/OptionGroups\n+\tDialogDataSourceStatic SelectDataSource = \"static\"\n+\t// DialogDataSourceExternal dynamic datasource\n+\tDialogDataSourceExternal SelectDataSource = \"external\"\n+\t// DialogDataSourceConversations provides a list of conversations\n+\tDialogDataSourceConversations SelectDataSource = \"conversations\"\n+\t// DialogDataSourceChannels provides a list of channels\n+\tDialogDataSourceChannels SelectDataSource = \"channels\"\n+\t// DialogDataSourceUsers provides a list of users\n+\tDialogDataSourceUsers SelectDataSource = \"users\"\n+)\n+\n+// DialogInputSelect dialog support for select boxes.\n+type DialogInputSelect struct {\n+\tDialogInput\n+\tValue           string               `json:\"value,omitempty\"`            //Optional.\n+\tDataSource      SelectDataSource     `json:\"data_source,omitempty\"`      //Optional. Allowed values: \"users\", \"channels\", \"conversations\", \"external\".\n+\tSelectedOptions []DialogSelectOption `json:\"selected_options,omitempty\"` //Optional. May hold at most one element, for use with \"external\" only.\n+\tOptions         []DialogSelectOption `json:\"options,omitempty\"`          //One of options or option_groups is required.\n+\tOptionGroups    []DialogOptionGroup  `json:\"option_groups,omitempty\"`    //Provide up to 100 options.\n+\tMinQueryLength  int                  `json:\"min_query_length,omitempty\"` //Optional. minimum characters before query is sent.\n+\tHint            string               `json:\"hint,omitempty\"`             //Optional. Additional hint text.\n+}\n+\n+// DialogSelectOption is an option for the user to select from the menu\n+type DialogSelectOption struct {\n+\tLabel string `json:\"label\"`\n+\tValue string `json:\"value\"`\n+}\n+\n+// DialogOptionGroup is a collection of options for creating a segmented table\n+type DialogOptionGroup struct {\n+\tLabel   string               `json:\"label\"`\n+\tOptions []DialogSelectOption `json:\"options\"`\n+}\n+\n+// NewStaticSelectDialogInput constructor for a `static` datasource menu input\n+func NewStaticSelectDialogInput(name, label string, options []DialogSelectOption) *DialogInputSelect {\n+\treturn &DialogInputSelect{\n+\t\tDialogInput: DialogInput{\n+\t\t\tType:     InputTypeSelect,\n+\t\t\tName:     name,\n+\t\t\tLabel:    label,\n+\t\t\tOptional: true,\n+\t\t},\n+\t\tDataSource: DialogDataSourceStatic,\n+\t\tOptions:    options,\n+\t}\n+}\n+\n+// NewGroupedSelectDialogInput creates grouped options select input for Dialogs.\n+func NewGroupedSelectDialogInput(name, label string, options []DialogOptionGroup) *DialogInputSelect {\n+\treturn &DialogInputSelect{\n+\t\tDialogInput: DialogInput{\n+\t\t\tType:  InputTypeSelect,\n+\t\t\tName:  name,\n+\t\t\tLabel: label,\n+\t\t},\n+\t\tDataSource:   DialogDataSourceStatic,\n+\t\tOptionGroups: options}\n+}\n+\n+// NewDialogOptionGroup creates a DialogOptionGroup from several select options\n+func NewDialogOptionGroup(label string, options ...DialogSelectOption) DialogOptionGroup {\n+\treturn DialogOptionGroup{\n+\t\tLabel:   label,\n+\t\tOptions: options,\n+\t}\n+}\n+\n+// NewConversationsSelect returns a `Conversations` select\n+func NewConversationsSelect(name, label string) *DialogInputSelect {\n+\treturn newPresetSelect(name, label, DialogDataSourceConversations)\n+}\n+\n+// NewChannelsSelect returns a `Channels` select\n+func NewChannelsSelect(name, label string) *DialogInputSelect {\n+\treturn newPresetSelect(name, label, DialogDataSourceChannels)\n+}\n+\n+// NewUsersSelect returns a `Users` select\n+func NewUsersSelect(name, label string) *DialogInputSelect {\n+\treturn newPresetSelect(name, label, DialogDataSourceUsers)\n+}\n+\n+func newPresetSelect(name, label string, dataSourceType SelectDataSource) *DialogInputSelect {\n+\treturn &DialogInputSelect{\n+\t\tDialogInput: DialogInput{\n+\t\t\tType:  InputTypeSelect,\n+\t\t\tLabel: label,\n+\t\t\tName:  name,\n+\t\t},\n+\t\tDataSource: dataSourceType,\n+\t}\n+}"
    },
    {
      "sha": "da06bd6de82216ad383929c32fbf6ffeb88475c4",
      "filename": "backend/vendor/github.com/slack-go/slack/dialog_text.go",
      "status": "added",
      "additions": 59,
      "deletions": 0,
      "changes": 59,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dialog_text.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dialog_text.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/dialog_text.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,59 @@\n+package slack\n+\n+// TextInputSubtype Accepts email, number, tel, or url. In some form factors, optimized input is provided for this subtype.\n+type TextInputSubtype string\n+\n+// TextInputOption handle to extra inputs options.\n+type TextInputOption func(*TextInputElement)\n+\n+const (\n+\t// InputSubtypeEmail email keyboard\n+\tInputSubtypeEmail TextInputSubtype = \"email\"\n+\t// InputSubtypeNumber numeric keyboard\n+\tInputSubtypeNumber TextInputSubtype = \"number\"\n+\t// InputSubtypeTel Phone keyboard\n+\tInputSubtypeTel TextInputSubtype = \"tel\"\n+\t// InputSubtypeURL Phone keyboard\n+\tInputSubtypeURL TextInputSubtype = \"url\"\n+)\n+\n+// TextInputElement subtype of DialogInput\n+//\thttps://api.slack.com/dialogs#option_element_attributes#text_element_attributes\n+type TextInputElement struct {\n+\tDialogInput\n+\tMaxLength int              `json:\"max_length,omitempty\"`\n+\tMinLength int              `json:\"min_length,omitempty\"`\n+\tHint      string           `json:\"hint,omitempty\"`\n+\tSubtype   TextInputSubtype `json:\"subtype\"`\n+\tValue     string           `json:\"value\"`\n+}\n+\n+// NewTextInput constructor for a `text` input\n+func NewTextInput(name, label, text string, options ...TextInputOption) *TextInputElement {\n+\tt := &TextInputElement{\n+\t\tDialogInput: DialogInput{\n+\t\t\tType:  InputTypeText,\n+\t\t\tName:  name,\n+\t\t\tLabel: label,\n+\t\t},\n+\t\tValue: text,\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\topt(t)\n+\t}\n+\n+\treturn t\n+}\n+\n+// NewTextAreaInput constructor for a `textarea` input\n+func NewTextAreaInput(name, label, text string) *TextInputElement {\n+\treturn &TextInputElement{\n+\t\tDialogInput: DialogInput{\n+\t\t\tType:  InputTypeTextArea,\n+\t\t\tName:  name,\n+\t\t\tLabel: label,\n+\t\t},\n+\t\tValue: text,\n+\t}\n+}"
    },
    {
      "sha": "a3aa680cdd13171cb2b711d8adf3b787d5bf3391",
      "filename": "backend/vendor/github.com/slack-go/slack/dnd.go",
      "status": "added",
      "additions": 151,
      "deletions": 0,
      "changes": 151,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dnd.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/dnd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/dnd.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,151 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+type SnoozeDebug struct {\n+\tSnoozeEndDate string `json:\"snooze_end_date\"`\n+}\n+\n+type SnoozeInfo struct {\n+\tSnoozeEnabled   bool        `json:\"snooze_enabled,omitempty\"`\n+\tSnoozeEndTime   int         `json:\"snooze_endtime,omitempty\"`\n+\tSnoozeRemaining int         `json:\"snooze_remaining,omitempty\"`\n+\tSnoozeDebug     SnoozeDebug `json:\"snooze_debug,omitempty\"`\n+}\n+\n+type DNDStatus struct {\n+\tEnabled            bool `json:\"dnd_enabled\"`\n+\tNextStartTimestamp int  `json:\"next_dnd_start_ts\"`\n+\tNextEndTimestamp   int  `json:\"next_dnd_end_ts\"`\n+\tSnoozeInfo\n+}\n+\n+type dndResponseFull struct {\n+\tDNDStatus\n+\tSlackResponse\n+}\n+\n+type dndTeamInfoResponse struct {\n+\tUsers map[string]DNDStatus `json:\"users\"`\n+\tSlackResponse\n+}\n+\n+func (api *Client) dndRequest(ctx context.Context, path string, values url.Values) (*dndResponseFull, error) {\n+\tresponse := &dndResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// EndDND ends the user's scheduled Do Not Disturb session\n+func (api *Client) EndDND() error {\n+\treturn api.EndDNDContext(context.Background())\n+}\n+\n+// EndDNDContext ends the user's scheduled Do Not Disturb session with a custom context\n+func (api *Client) EndDNDContext(ctx context.Context) error {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\n+\tif err := api.postMethod(ctx, \"dnd.endDnd\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// EndSnooze ends the current user's snooze mode\n+func (api *Client) EndSnooze() (*DNDStatus, error) {\n+\treturn api.EndSnoozeContext(context.Background())\n+}\n+\n+// EndSnoozeContext ends the current user's snooze mode with a custom context\n+func (api *Client) EndSnoozeContext(ctx context.Context) (*DNDStatus, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\tresponse, err := api.dndRequest(ctx, \"dnd.endSnooze\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.DNDStatus, nil\n+}\n+\n+// GetDNDInfo provides information about a user's current Do Not Disturb settings.\n+func (api *Client) GetDNDInfo(user *string) (*DNDStatus, error) {\n+\treturn api.GetDNDInfoContext(context.Background(), user)\n+}\n+\n+// GetDNDInfoContext provides information about a user's current Do Not Disturb settings with a custom context.\n+func (api *Client) GetDNDInfoContext(ctx context.Context, user *string) (*DNDStatus, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif user != nil {\n+\t\tvalues.Set(\"user\", *user)\n+\t}\n+\n+\tresponse, err := api.dndRequest(ctx, \"dnd.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.DNDStatus, nil\n+}\n+\n+// GetDNDTeamInfo provides information about a user's current Do Not Disturb settings.\n+func (api *Client) GetDNDTeamInfo(users []string) (map[string]DNDStatus, error) {\n+\treturn api.GetDNDTeamInfoContext(context.Background(), users)\n+}\n+\n+// GetDNDTeamInfoContext provides information about a user's current Do Not Disturb settings with a custom context.\n+func (api *Client) GetDNDTeamInfoContext(ctx context.Context, users []string) (map[string]DNDStatus, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"users\": {strings.Join(users, \",\")},\n+\t}\n+\tresponse := &dndTeamInfoResponse{}\n+\n+\tif err := api.postMethod(ctx, \"dnd.teamInfo\", values, response); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif response.Err() != nil {\n+\t\treturn nil, response.Err()\n+\t}\n+\n+\treturn response.Users, nil\n+}\n+\n+// SetSnooze adjusts the snooze duration for a user's Do Not Disturb\n+// settings. If a snooze session is not already active for the user, invoking\n+// this method will begin one for the specified duration.\n+func (api *Client) SetSnooze(minutes int) (*DNDStatus, error) {\n+\treturn api.SetSnoozeContext(context.Background(), minutes)\n+}\n+\n+// SetSnoozeContext adjusts the snooze duration for a user's Do Not Disturb settings with a custom context.\n+// For more information see the SetSnooze docs\n+func (api *Client) SetSnoozeContext(ctx context.Context, minutes int) (*DNDStatus, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":       {api.token},\n+\t\t\"num_minutes\": {strconv.Itoa(minutes)},\n+\t}\n+\n+\tresponse, err := api.dndRequest(ctx, \"dnd.setSnooze\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.DNDStatus, nil\n+}"
    },
    {
      "sha": "b2b0c6c90d3d0046f2e0a61d245d6bb8bbcb03bd",
      "filename": "backend/vendor/github.com/slack-go/slack/emoji.go",
      "status": "added",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/emoji.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/emoji.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/emoji.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,35 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+)\n+\n+type emojiResponseFull struct {\n+\tEmoji map[string]string `json:\"emoji\"`\n+\tSlackResponse\n+}\n+\n+// GetEmoji retrieves all the emojis\n+func (api *Client) GetEmoji() (map[string]string, error) {\n+\treturn api.GetEmojiContext(context.Background())\n+}\n+\n+// GetEmojiContext retrieves all the emojis with a custom context\n+func (api *Client) GetEmojiContext(ctx context.Context) (map[string]string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tresponse := &emojiResponseFull{}\n+\n+\terr := api.postMethod(ctx, \"emoji.list\", values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif response.Err() != nil {\n+\t\treturn nil, response.Err()\n+\t}\n+\n+\treturn response.Emoji, nil\n+}"
    },
    {
      "sha": "8be22a659db29a9f5807a1e6d11cdcc17bc42eec",
      "filename": "backend/vendor/github.com/slack-go/slack/errors.go",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/errors.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/errors.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/errors.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,21 @@\n+package slack\n+\n+import \"github.com/slack-go/slack/internal/errorsx\"\n+\n+// Errors returned by various methods.\n+const (\n+\tErrAlreadyDisconnected  = errorsx.String(\"Invalid call to Disconnect - Slack API is already disconnected\")\n+\tErrRTMDisconnected      = errorsx.String(\"disconnect received while trying to connect\")\n+\tErrRTMGoodbye           = errorsx.String(\"goodbye detected\")\n+\tErrRTMDeadman           = errorsx.String(\"deadman switch triggered\")\n+\tErrParametersMissing    = errorsx.String(\"received empty parameters\")\n+\tErrBlockIDNotUnique     = errorsx.String(\"Block ID needs to be unique\")\n+\tErrInvalidConfiguration = errorsx.String(\"invalid configuration\")\n+\tErrMissingHeaders       = errorsx.String(\"missing headers\")\n+\tErrExpiredTimestamp     = errorsx.String(\"timestamp is too old\")\n+)\n+\n+// internal errors\n+const (\n+\terrPaginationComplete = errorsx.String(\"pagination complete\")\n+)"
    },
    {
      "sha": "713038f0699c907663b1da8a78d8b6846d57dd06",
      "filename": "backend/vendor/github.com/slack-go/slack/files.go",
      "status": "added",
      "additions": 410,
      "deletions": 0,
      "changes": 410,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/files.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/files.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/files.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,410 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+const (\n+\t// Add here the defaults in the siten\n+\tDEFAULT_FILES_USER        = \"\"\n+\tDEFAULT_FILES_CHANNEL     = \"\"\n+\tDEFAULT_FILES_TS_FROM     = 0\n+\tDEFAULT_FILES_TS_TO       = -1\n+\tDEFAULT_FILES_TYPES       = \"all\"\n+\tDEFAULT_FILES_COUNT       = 100\n+\tDEFAULT_FILES_PAGE        = 1\n+\tDEFAULT_FILES_SHOW_HIDDEN = false\n+)\n+\n+// File contains all the information for a file\n+type File struct {\n+\tID        string   `json:\"id\"`\n+\tCreated   JSONTime `json:\"created\"`\n+\tTimestamp JSONTime `json:\"timestamp\"`\n+\n+\tName              string `json:\"name\"`\n+\tTitle             string `json:\"title\"`\n+\tMimetype          string `json:\"mimetype\"`\n+\tImageExifRotation int    `json:\"image_exif_rotation\"`\n+\tFiletype          string `json:\"filetype\"`\n+\tPrettyType        string `json:\"pretty_type\"`\n+\tUser              string `json:\"user\"`\n+\n+\tMode         string `json:\"mode\"`\n+\tEditable     bool   `json:\"editable\"`\n+\tIsExternal   bool   `json:\"is_external\"`\n+\tExternalType string `json:\"external_type\"`\n+\n+\tSize int `json:\"size\"`\n+\n+\tURL                string `json:\"url\"`          // Deprecated - never set\n+\tURLDownload        string `json:\"url_download\"` // Deprecated - never set\n+\tURLPrivate         string `json:\"url_private\"`\n+\tURLPrivateDownload string `json:\"url_private_download\"`\n+\n+\tOriginalH   int    `json:\"original_h\"`\n+\tOriginalW   int    `json:\"original_w\"`\n+\tThumb64     string `json:\"thumb_64\"`\n+\tThumb80     string `json:\"thumb_80\"`\n+\tThumb160    string `json:\"thumb_160\"`\n+\tThumb360    string `json:\"thumb_360\"`\n+\tThumb360Gif string `json:\"thumb_360_gif\"`\n+\tThumb360W   int    `json:\"thumb_360_w\"`\n+\tThumb360H   int    `json:\"thumb_360_h\"`\n+\tThumb480    string `json:\"thumb_480\"`\n+\tThumb480W   int    `json:\"thumb_480_w\"`\n+\tThumb480H   int    `json:\"thumb_480_h\"`\n+\tThumb720    string `json:\"thumb_720\"`\n+\tThumb720W   int    `json:\"thumb_720_w\"`\n+\tThumb720H   int    `json:\"thumb_720_h\"`\n+\tThumb960    string `json:\"thumb_960\"`\n+\tThumb960W   int    `json:\"thumb_960_w\"`\n+\tThumb960H   int    `json:\"thumb_960_h\"`\n+\tThumb1024   string `json:\"thumb_1024\"`\n+\tThumb1024W  int    `json:\"thumb_1024_w\"`\n+\tThumb1024H  int    `json:\"thumb_1024_h\"`\n+\n+\tPermalink       string `json:\"permalink\"`\n+\tPermalinkPublic string `json:\"permalink_public\"`\n+\n+\tEditLink         string `json:\"edit_link\"`\n+\tPreview          string `json:\"preview\"`\n+\tPreviewHighlight string `json:\"preview_highlight\"`\n+\tLines            int    `json:\"lines\"`\n+\tLinesMore        int    `json:\"lines_more\"`\n+\n+\tIsPublic        bool     `json:\"is_public\"`\n+\tPublicURLShared bool     `json:\"public_url_shared\"`\n+\tChannels        []string `json:\"channels\"`\n+\tGroups          []string `json:\"groups\"`\n+\tIMs             []string `json:\"ims\"`\n+\tInitialComment  Comment  `json:\"initial_comment\"`\n+\tCommentsCount   int      `json:\"comments_count\"`\n+\tNumStars        int      `json:\"num_stars\"`\n+\tIsStarred       bool     `json:\"is_starred\"`\n+\tShares          Share    `json:\"shares\"`\n+}\n+\n+type Share struct {\n+\tPublic  map[string][]ShareFileInfo `json:\"public\"`\n+\tPrivate map[string][]ShareFileInfo `json:\"private\"`\n+}\n+\n+type ShareFileInfo struct {\n+\tReplyUsers      []string `json:\"reply_users\"`\n+\tReplyUsersCount int      `json:\"reply_users_count\"`\n+\tReplyCount      int      `json:\"reply_count\"`\n+\tTs              string   `json:\"ts\"`\n+\tThreadTs        string   `json:\"thread_ts\"`\n+\tLatestReply     string   `json:\"latest_reply\"`\n+\tChannelName     string   `json:\"channel_name\"`\n+\tTeamID          string   `json:\"team_id\"`\n+}\n+\n+// FileUploadParameters contains all the parameters necessary (including the optional ones) for an UploadFile() request.\n+//\n+// There are three ways to upload a file. You can either set Content if file is small, set Reader if file is large,\n+// or provide a local file path in File to upload it from your filesystem.\n+//\n+// Note that when using the Reader option, you *must* specify the Filename, otherwise the Slack API isn't happy.\n+type FileUploadParameters struct {\n+\tFile            string\n+\tContent         string\n+\tReader          io.Reader\n+\tFiletype        string\n+\tFilename        string\n+\tTitle           string\n+\tInitialComment  string\n+\tChannels        []string\n+\tThreadTimestamp string\n+}\n+\n+// GetFilesParameters contains all the parameters necessary (including the optional ones) for a GetFiles() request\n+type GetFilesParameters struct {\n+\tUser          string\n+\tChannel       string\n+\tTimestampFrom JSONTime\n+\tTimestampTo   JSONTime\n+\tTypes         string\n+\tCount         int\n+\tPage          int\n+\tShowHidden    bool\n+}\n+\n+// ListFilesParameters contains all the parameters necessary (including the optional ones) for a ListFiles() request\n+type ListFilesParameters struct {\n+\tLimit   int\n+\tUser    string\n+\tChannel string\n+\tTypes   string\n+\tCursor  string\n+}\n+\n+type fileResponseFull struct {\n+\tFile     `json:\"file\"`\n+\tPaging   `json:\"paging\"`\n+\tComments []Comment        `json:\"comments\"`\n+\tFiles    []File           `json:\"files\"`\n+\tMetadata ResponseMetadata `json:\"response_metadata\"`\n+\n+\tSlackResponse\n+}\n+\n+// NewGetFilesParameters provides an instance of GetFilesParameters with all the sane default values set\n+func NewGetFilesParameters() GetFilesParameters {\n+\treturn GetFilesParameters{\n+\t\tUser:          DEFAULT_FILES_USER,\n+\t\tChannel:       DEFAULT_FILES_CHANNEL,\n+\t\tTimestampFrom: DEFAULT_FILES_TS_FROM,\n+\t\tTimestampTo:   DEFAULT_FILES_TS_TO,\n+\t\tTypes:         DEFAULT_FILES_TYPES,\n+\t\tCount:         DEFAULT_FILES_COUNT,\n+\t\tPage:          DEFAULT_FILES_PAGE,\n+\t\tShowHidden:    DEFAULT_FILES_SHOW_HIDDEN,\n+\t}\n+}\n+\n+func (api *Client) fileRequest(ctx context.Context, path string, values url.Values) (*fileResponseFull, error) {\n+\tresponse := &fileResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// GetFileInfo retrieves a file and related comments\n+func (api *Client) GetFileInfo(fileID string, count, page int) (*File, []Comment, *Paging, error) {\n+\treturn api.GetFileInfoContext(context.Background(), fileID, count, page)\n+}\n+\n+// GetFileInfoContext retrieves a file and related comments with a custom context\n+func (api *Client) GetFileInfoContext(ctx context.Context, fileID string, count, page int) (*File, []Comment, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"file\":  {fileID},\n+\t\t\"count\": {strconv.Itoa(count)},\n+\t\t\"page\":  {strconv.Itoa(page)},\n+\t}\n+\n+\tresponse, err := api.fileRequest(ctx, \"files.info\", values)\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\treturn &response.File, response.Comments, &response.Paging, nil\n+}\n+\n+// GetFile retreives a given file from its private download URL\n+func (api *Client) GetFile(downloadURL string, writer io.Writer) error {\n+\treturn downloadFile(api.httpclient, api.token, downloadURL, writer, api)\n+}\n+\n+// GetFiles retrieves all files according to the parameters given\n+func (api *Client) GetFiles(params GetFilesParameters) ([]File, *Paging, error) {\n+\treturn api.GetFilesContext(context.Background(), params)\n+}\n+\n+// ListFiles retrieves all files according to the parameters given. Uses cursor based pagination.\n+func (api *Client) ListFiles(params ListFilesParameters) ([]File, *ListFilesParameters, error) {\n+\treturn api.ListFilesContext(context.Background(), params)\n+}\n+\n+// ListFilesContext retrieves all files according to the parameters given with a custom context. Uses cursor based pagination.\n+func (api *Client) ListFilesContext(ctx context.Context, params ListFilesParameters) ([]File, *ListFilesParameters, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\tif params.User != DEFAULT_FILES_USER {\n+\t\tvalues.Add(\"user\", params.User)\n+\t}\n+\tif params.Channel != DEFAULT_FILES_CHANNEL {\n+\t\tvalues.Add(\"channel\", params.Channel)\n+\t}\n+\tif params.Limit != DEFAULT_FILES_COUNT {\n+\t\tvalues.Add(\"limit\", strconv.Itoa(params.Limit))\n+\t}\n+\tif params.Cursor != \"\" {\n+\t\tvalues.Add(\"cursor\", params.Cursor)\n+\t}\n+\n+\tresponse, err := api.fileRequest(ctx, \"files.list\", values)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tparams.Cursor = response.Metadata.Cursor\n+\n+\treturn response.Files, &params, nil\n+}\n+\n+// GetFilesContext retrieves all files according to the parameters given with a custom context\n+func (api *Client) GetFilesContext(ctx context.Context, params GetFilesParameters) ([]File, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.User != DEFAULT_FILES_USER {\n+\t\tvalues.Add(\"user\", params.User)\n+\t}\n+\tif params.Channel != DEFAULT_FILES_CHANNEL {\n+\t\tvalues.Add(\"channel\", params.Channel)\n+\t}\n+\tif params.TimestampFrom != DEFAULT_FILES_TS_FROM {\n+\t\tvalues.Add(\"ts_from\", strconv.FormatInt(int64(params.TimestampFrom), 10))\n+\t}\n+\tif params.TimestampTo != DEFAULT_FILES_TS_TO {\n+\t\tvalues.Add(\"ts_to\", strconv.FormatInt(int64(params.TimestampTo), 10))\n+\t}\n+\tif params.Types != DEFAULT_FILES_TYPES {\n+\t\tvalues.Add(\"types\", params.Types)\n+\t}\n+\tif params.Count != DEFAULT_FILES_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Page != DEFAULT_FILES_PAGE {\n+\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n+\t}\n+\tif params.ShowHidden != DEFAULT_FILES_SHOW_HIDDEN {\n+\t\tvalues.Add(\"show_files_hidden_by_limit\", strconv.FormatBool(params.ShowHidden))\n+\t}\n+\n+\tresponse, err := api.fileRequest(ctx, \"files.list\", values)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\treturn response.Files, &response.Paging, nil\n+}\n+\n+// UploadFile uploads a file\n+func (api *Client) UploadFile(params FileUploadParameters) (file *File, err error) {\n+\treturn api.UploadFileContext(context.Background(), params)\n+}\n+\n+// UploadFileContext uploads a file and setting a custom context\n+func (api *Client) UploadFileContext(ctx context.Context, params FileUploadParameters) (file *File, err error) {\n+\t// Test if user token is valid. This helps because client.Do doesn't like this for some reason. XXX: More\n+\t// investigation needed, but for now this will do.\n+\t_, err = api.AuthTest()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresponse := &fileResponseFull{}\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.Filetype != \"\" {\n+\t\tvalues.Add(\"filetype\", params.Filetype)\n+\t}\n+\tif params.Filename != \"\" {\n+\t\tvalues.Add(\"filename\", params.Filename)\n+\t}\n+\tif params.Title != \"\" {\n+\t\tvalues.Add(\"title\", params.Title)\n+\t}\n+\tif params.InitialComment != \"\" {\n+\t\tvalues.Add(\"initial_comment\", params.InitialComment)\n+\t}\n+\tif params.ThreadTimestamp != \"\" {\n+\t\tvalues.Add(\"thread_ts\", params.ThreadTimestamp)\n+\t}\n+\tif len(params.Channels) != 0 {\n+\t\tvalues.Add(\"channels\", strings.Join(params.Channels, \",\"))\n+\t}\n+\tif params.Content != \"\" {\n+\t\tvalues.Add(\"content\", params.Content)\n+\t\terr = api.postMethod(ctx, \"files.upload\", values, response)\n+\t} else if params.File != \"\" {\n+\t\terr = postLocalWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.upload\", params.File, \"file\", values, response, api)\n+\t} else if params.Reader != nil {\n+\t\tif params.Filename == \"\" {\n+\t\t\treturn nil, fmt.Errorf(\"files.upload: FileUploadParameters.Filename is mandatory when using FileUploadParameters.Reader\")\n+\t\t}\n+\t\terr = postWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"files.upload\", params.Filename, \"file\", values, params.Reader, response, api)\n+\t}\n+\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response.File, response.Err()\n+}\n+\n+// DeleteFileComment deletes a file's comment\n+func (api *Client) DeleteFileComment(commentID, fileID string) error {\n+\treturn api.DeleteFileCommentContext(context.Background(), fileID, commentID)\n+}\n+\n+// DeleteFileCommentContext deletes a file's comment with a custom context\n+func (api *Client) DeleteFileCommentContext(ctx context.Context, fileID, commentID string) (err error) {\n+\tif fileID == \"\" || commentID == \"\" {\n+\t\treturn ErrParametersMissing\n+\t}\n+\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"file\":  {fileID},\n+\t\t\"id\":    {commentID},\n+\t}\n+\t_, err = api.fileRequest(ctx, \"files.comments.delete\", values)\n+\treturn err\n+}\n+\n+// DeleteFile deletes a file\n+func (api *Client) DeleteFile(fileID string) error {\n+\treturn api.DeleteFileContext(context.Background(), fileID)\n+}\n+\n+// DeleteFileContext deletes a file with a custom context\n+func (api *Client) DeleteFileContext(ctx context.Context, fileID string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"file\":  {fileID},\n+\t}\n+\n+\t_, err = api.fileRequest(ctx, \"files.delete\", values)\n+\treturn err\n+}\n+\n+// RevokeFilePublicURL disables public/external sharing for a file\n+func (api *Client) RevokeFilePublicURL(fileID string) (*File, error) {\n+\treturn api.RevokeFilePublicURLContext(context.Background(), fileID)\n+}\n+\n+// RevokeFilePublicURLContext disables public/external sharing for a file with a custom context\n+func (api *Client) RevokeFilePublicURLContext(ctx context.Context, fileID string) (*File, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"file\":  {fileID},\n+\t}\n+\n+\tresponse, err := api.fileRequest(ctx, \"files.revokePublicURL\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.File, nil\n+}\n+\n+// ShareFilePublicURL enabled public/external sharing for a file\n+func (api *Client) ShareFilePublicURL(fileID string) (*File, []Comment, *Paging, error) {\n+\treturn api.ShareFilePublicURLContext(context.Background(), fileID)\n+}\n+\n+// ShareFilePublicURLContext enabled public/external sharing for a file with a custom context\n+func (api *Client) ShareFilePublicURLContext(ctx context.Context, fileID string) (*File, []Comment, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"file\":  {fileID},\n+\t}\n+\n+\tresponse, err := api.fileRequest(ctx, \"files.sharedPublicURL\", values)\n+\tif err != nil {\n+\t\treturn nil, nil, nil, err\n+\t}\n+\treturn &response.File, response.Comments, &response.Paging, nil\n+}"
    },
    {
      "sha": "32fc4b93992750c60c8c225c0775f97427125abe",
      "filename": "backend/vendor/github.com/slack-go/slack/go.mod",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/go.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/go.mod?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,12 @@\n+module github.com/slack-go/slack\n+\n+require (\n+\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n+\tgithub.com/go-test/deep v1.0.4\n+\tgithub.com/gorilla/websocket v1.4.2\n+\tgithub.com/pkg/errors v0.8.0\n+\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n+\tgithub.com/stretchr/testify v1.2.2\n+)\n+\n+go 1.13"
    },
    {
      "sha": "d01bacbf11bd51e56e91a2ec7aea67d5795a261d",
      "filename": "backend/vendor/github.com/slack-go/slack/go.sum",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/go.sum",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/go.sum?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,12 @@\n+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\n+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/go-test/deep v1.0.4 h1:u2CU3YKy9I2pmu9pX0eq50wCgjfGIt539SqR7FbHiho=\n+github.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\n+github.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\n+github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\n+github.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=\n+github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n+github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\n+github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs="
    },
    {
      "sha": "4c5793dc3e34e57692e8102e8cc5e0d79e3f0fab",
      "filename": "backend/vendor/github.com/slack-go/slack/groups.go",
      "status": "added",
      "additions": 574,
      "deletions": 0,
      "changes": 574,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/groups.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/groups.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/groups.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,574 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+)\n+\n+// Group contains all the information for a group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+type Group struct {\n+\tGroupConversation\n+\tIsGroup bool `json:\"is_group\"`\n+}\n+\n+type groupResponseFull struct {\n+\tGroup          Group   `json:\"group\"`\n+\tGroups         []Group `json:\"groups\"`\n+\tPurpose        string  `json:\"purpose\"`\n+\tTopic          string  `json:\"topic\"`\n+\tNotInGroup     bool    `json:\"not_in_group\"`\n+\tNoOp           bool    `json:\"no_op\"`\n+\tAlreadyClosed  bool    `json:\"already_closed\"`\n+\tAlreadyOpen    bool    `json:\"already_open\"`\n+\tAlreadyInGroup bool    `json:\"already_in_group\"`\n+\tChannel        Channel `json:\"channel\"`\n+\tHistory\n+\tSlackResponse\n+}\n+\n+func (api *Client) groupRequest(ctx context.Context, path string, values url.Values) (*groupResponseFull, error) {\n+\tresponse := &groupResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// ArchiveGroup archives a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) ArchiveGroup(group string) error {\n+\treturn api.ArchiveGroupContext(context.Background(), group)\n+}\n+\n+// ArchiveGroupContext archives a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) ArchiveGroupContext(ctx context.Context, group string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t}\n+\n+\t_, err := api.groupRequest(ctx, \"groups.archive\", values)\n+\treturn err\n+}\n+\n+// UnarchiveGroup unarchives a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) UnarchiveGroup(group string) error {\n+\treturn api.UnarchiveGroupContext(context.Background(), group)\n+}\n+\n+// UnarchiveGroupContext unarchives a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) UnarchiveGroupContext(ctx context.Context, group string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t}\n+\n+\t_, err := api.groupRequest(ctx, \"groups.unarchive\", values)\n+\treturn err\n+}\n+\n+// CreateGroup creates a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CreateGroup(group string) (*Group, error) {\n+\treturn api.CreateGroupContext(context.Background(), group)\n+}\n+\n+// CreateGroupContext creates a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CreateGroupContext(ctx context.Context, group string) (*Group, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"name\":  {group},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.create\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Group, nil\n+}\n+\n+// CreateChildGroup creates a new private group archiving the old one\n+// This method takes an existing private group and performs the following steps:\n+//   1. Renames the existing group (from \"example\" to \"example-archived\").\n+//   2. Archives the existing group.\n+//   3. Creates a new group with the name of the existing group.\n+//   4. Adds all members of the existing group to the new group.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CreateChildGroup(group string) (*Group, error) {\n+\treturn api.CreateChildGroupContext(context.Background(), group)\n+}\n+\n+// CreateChildGroupContext creates a new private group archiving the old one with a custom context\n+// For more information see CreateChildGroup\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CreateChildGroupContext(ctx context.Context, group string) (*Group, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.createChild\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Group, nil\n+}\n+\n+// GetGroupHistory fetches all the history for a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupHistory(group string, params HistoryParameters) (*History, error) {\n+\treturn api.GetGroupHistoryContext(context.Background(), group, params)\n+}\n+\n+// GetGroupHistoryContext fetches all the history for a private group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupHistoryContext(ctx context.Context, group string, params HistoryParameters) (*History, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t}\n+\tif params.Latest != DEFAULT_HISTORY_LATEST {\n+\t\tvalues.Add(\"latest\", params.Latest)\n+\t}\n+\tif params.Oldest != DEFAULT_HISTORY_OLDEST {\n+\t\tvalues.Add(\"oldest\", params.Oldest)\n+\t}\n+\tif params.Count != DEFAULT_HISTORY_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Inclusive != DEFAULT_HISTORY_INCLUSIVE {\n+\t\tif params.Inclusive {\n+\t\t\tvalues.Add(\"inclusive\", \"1\")\n+\t\t} else {\n+\t\t\tvalues.Add(\"inclusive\", \"0\")\n+\t\t}\n+\t}\n+\tif params.Unreads != DEFAULT_HISTORY_UNREADS {\n+\t\tif params.Unreads {\n+\t\t\tvalues.Add(\"unreads\", \"1\")\n+\t\t} else {\n+\t\t\tvalues.Add(\"unreads\", \"0\")\n+\t\t}\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.history\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.History, nil\n+}\n+\n+// InviteUserToGroup invites a specific user to a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) InviteUserToGroup(group, user string) (*Group, bool, error) {\n+\treturn api.InviteUserToGroupContext(context.Background(), group, user)\n+}\n+\n+// InviteUserToGroupContext invites a specific user to a private group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) InviteUserToGroupContext(ctx context.Context, group, user string) (*Group, bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t\t\"user\":    {user},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.invite\", values)\n+\tif err != nil {\n+\t\treturn nil, false, err\n+\t}\n+\treturn &response.Group, response.AlreadyInGroup, nil\n+}\n+\n+// LeaveGroup makes authenticated user leave the group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) LeaveGroup(group string) error {\n+\treturn api.LeaveGroupContext(context.Background(), group)\n+}\n+\n+// LeaveGroupContext makes authenticated user leave the group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) LeaveGroupContext(ctx context.Context, group string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t}\n+\n+\t_, err = api.groupRequest(ctx, \"groups.leave\", values)\n+\treturn err\n+}\n+\n+// KickUserFromGroup kicks a user from a group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) KickUserFromGroup(group, user string) error {\n+\treturn api.KickUserFromGroupContext(context.Background(), group, user)\n+}\n+\n+// KickUserFromGroupContext kicks a user from a group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) KickUserFromGroupContext(ctx context.Context, group, user string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t\t\"user\":    {user},\n+\t}\n+\n+\t_, err = api.groupRequest(ctx, \"groups.kick\", values)\n+\treturn err\n+}\n+\n+// GetGroups retrieves all groups\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroups(excludeArchived bool) ([]Group, error) {\n+\treturn api.GetGroupsContext(context.Background(), excludeArchived)\n+}\n+\n+// GetGroupsContext retrieves all groups with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupsContext(ctx context.Context, excludeArchived bool) ([]Group, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif excludeArchived {\n+\t\tvalues.Add(\"exclude_archived\", \"1\")\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.list\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response.Groups, nil\n+}\n+\n+// GetGroupInfo retrieves the given group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupInfo(group string) (*Group, error) {\n+\treturn api.GetGroupInfoContext(context.Background(), group)\n+}\n+\n+// GetGroupInfoContext retrieves the given group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupInfoContext(ctx context.Context, group string) (*Group, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":          {api.token},\n+\t\t\"channel\":        {group},\n+\t\t\"include_locale\": {strconv.FormatBool(true)},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Group, nil\n+}\n+\n+// SetGroupReadMark sets the read mark on a private group\n+// Clients should try to avoid making this call too often. When needing to mark a read position, a client should set a\n+// timer before making the call. In this way, any further updates needed during the timeout will not generate extra\n+// calls (just one per channel). This is useful for when reading scroll-back history, or following a busy live\n+// channel. A timeout of 5 seconds is a good starting point. Be sure to flush these calls on shutdown/logout.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetGroupReadMark(group, ts string) error {\n+\treturn api.SetGroupReadMarkContext(context.Background(), group, ts)\n+}\n+\n+// SetGroupReadMarkContext sets the read mark on a private group with a custom context\n+// For more details see SetGroupReadMark\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetGroupReadMarkContext(ctx context.Context, group, ts string) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t\t\"ts\":      {ts},\n+\t}\n+\n+\t_, err = api.groupRequest(ctx, \"groups.mark\", values)\n+\treturn err\n+}\n+\n+// OpenGroup opens a private group\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) OpenGroup(group string) (bool, bool, error) {\n+\treturn api.OpenGroupContext(context.Background(), group)\n+}\n+\n+// OpenGroupContext opens a private group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) OpenGroupContext(ctx context.Context, group string) (bool, bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.open\", values)\n+\tif err != nil {\n+\t\treturn false, false, err\n+\t}\n+\treturn response.NoOp, response.AlreadyOpen, nil\n+}\n+\n+// RenameGroup renames a group\n+// XXX: They return a channel, not a group. What is this crap? :(\n+// Inconsistent api it seems.\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) RenameGroup(group, name string) (*Channel, error) {\n+\treturn api.RenameGroupContext(context.Background(), group, name)\n+}\n+\n+// RenameGroupContext renames a group with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) RenameGroupContext(ctx context.Context, group, name string) (*Channel, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t\t\"name\":    {name},\n+\t}\n+\n+\t// XXX: the created entry in this call returns a string instead of a number\n+\t// so I may have to do some workaround to solve it.\n+\tresponse, err := api.groupRequest(ctx, \"groups.rename\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Channel, nil\n+}\n+\n+// SetGroupPurpose sets the group purpose\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetGroupPurpose(group, purpose string) (string, error) {\n+\treturn api.SetGroupPurposeContext(context.Background(), group, purpose)\n+}\n+\n+// SetGroupPurposeContext sets the group purpose with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetGroupPurposeContext(ctx context.Context, group, purpose string) (string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t\t\"purpose\": {purpose},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.setPurpose\", values)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn response.Purpose, nil\n+}\n+\n+// SetGroupTopic sets the group topic\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetGroupTopic(group, topic string) (string, error) {\n+\treturn api.SetGroupTopicContext(context.Background(), group, topic)\n+}\n+\n+// SetGroupTopicContext sets the group topic with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) SetGroupTopicContext(ctx context.Context, group, topic string) (string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {group},\n+\t\t\"topic\":   {topic},\n+\t}\n+\n+\tresponse, err := api.groupRequest(ctx, \"groups.setTopic\", values)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn response.Topic, nil\n+}\n+\n+// GetGroupReplies gets an entire thread (a message plus all the messages in reply to it).\n+// see https://api.slack.com/methods/groups.replies\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupReplies(channelID, thread_ts string) ([]Message, error) {\n+\treturn api.GetGroupRepliesContext(context.Background(), channelID, thread_ts)\n+}\n+\n+// GetGroupRepliesContext gets an entire thread (a message plus all the messages in reply to it) with a custom context\n+// see https://api.slack.com/methods/groups.replies\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetGroupRepliesContext(ctx context.Context, channelID, thread_ts string) ([]Message, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"channel\":   {channelID},\n+\t\t\"thread_ts\": {thread_ts},\n+\t}\n+\tresponse, err := api.groupRequest(ctx, \"groups.replies\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response.History.Messages, nil\n+}"
    },
    {
      "sha": "49dfe35402f6daa6d1529849c46d4cfed222162e",
      "filename": "backend/vendor/github.com/slack-go/slack/history.go",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/history.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/history.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/history.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,37 @@\n+package slack\n+\n+const (\n+\tDEFAULT_HISTORY_LATEST    = \"\"\n+\tDEFAULT_HISTORY_OLDEST    = \"0\"\n+\tDEFAULT_HISTORY_COUNT     = 100\n+\tDEFAULT_HISTORY_INCLUSIVE = false\n+\tDEFAULT_HISTORY_UNREADS   = false\n+)\n+\n+// HistoryParameters contains all the necessary information to help in the retrieval of history for Channels/Groups/DMs\n+type HistoryParameters struct {\n+\tLatest    string\n+\tOldest    string\n+\tCount     int\n+\tInclusive bool\n+\tUnreads   bool\n+}\n+\n+// History contains message history information needed to navigate a Channel / Group / DM history\n+type History struct {\n+\tLatest   string    `json:\"latest\"`\n+\tMessages []Message `json:\"messages\"`\n+\tHasMore  bool      `json:\"has_more\"`\n+\tUnread   int       `json:\"unread_count_display\"`\n+}\n+\n+// NewHistoryParameters provides an instance of HistoryParameters with all the sane default values set\n+func NewHistoryParameters() HistoryParameters {\n+\treturn HistoryParameters{\n+\t\tLatest:    DEFAULT_HISTORY_LATEST,\n+\t\tOldest:    DEFAULT_HISTORY_OLDEST,\n+\t\tCount:     DEFAULT_HISTORY_COUNT,\n+\t\tInclusive: DEFAULT_HISTORY_INCLUSIVE,\n+\t\tUnreads:   DEFAULT_HISTORY_UNREADS,\n+\t}\n+}"
    },
    {
      "sha": "a884b29531e0a48533dad60025fdbd1bf0895819",
      "filename": "backend/vendor/github.com/slack-go/slack/im.go",
      "status": "added",
      "additions": 220,
      "deletions": 0,
      "changes": 220,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/im.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/im.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/im.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,220 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+)\n+\n+type imChannel struct {\n+\tID string `json:\"id\"`\n+}\n+\n+type imResponseFull struct {\n+\tNoOp          bool      `json:\"no_op\"`\n+\tAlreadyClosed bool      `json:\"already_closed\"`\n+\tAlreadyOpen   bool      `json:\"already_open\"`\n+\tChannel       imChannel `json:\"channel\"`\n+\tIMs           []IM      `json:\"ims\"`\n+\tHistory\n+\tSlackResponse\n+}\n+\n+// IM contains information related to the Direct Message channel\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+type IM struct {\n+\tConversation\n+\tIsUserDeleted bool `json:\"is_user_deleted\"`\n+}\n+\n+func (api *Client) imRequest(ctx context.Context, path string, values url.Values) (*imResponseFull, error) {\n+\tresponse := &imResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// CloseIMChannel closes the direct message channel\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CloseIMChannel(channel string) (bool, bool, error) {\n+\treturn api.CloseIMChannelContext(context.Background(), channel)\n+}\n+\n+// CloseIMChannelContext closes the direct message channel with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) CloseIMChannelContext(ctx context.Context, channel string) (bool, bool, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channel},\n+\t}\n+\n+\tresponse, err := api.imRequest(ctx, \"im.close\", values)\n+\tif err != nil {\n+\t\treturn false, false, err\n+\t}\n+\treturn response.NoOp, response.AlreadyClosed, nil\n+}\n+\n+// OpenIMChannel opens a direct message channel to the user provided as argument\n+// Returns some status and the channel ID\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) OpenIMChannel(user string) (bool, bool, string, error) {\n+\treturn api.OpenIMChannelContext(context.Background(), user)\n+}\n+\n+// OpenIMChannelContext opens a direct message channel to the user provided as argument with a custom context\n+// Returns some status and the channel ID\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) OpenIMChannelContext(ctx context.Context, user string) (bool, bool, string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"user\":  {user},\n+\t}\n+\n+\tresponse, err := api.imRequest(ctx, \"im.open\", values)\n+\tif err != nil {\n+\t\treturn false, false, \"\", err\n+\t}\n+\treturn response.NoOp, response.AlreadyOpen, response.Channel.ID, nil\n+}\n+\n+// MarkIMChannel sets the read mark of a direct message channel to a specific point\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) MarkIMChannel(channel, ts string) (err error) {\n+\treturn api.MarkIMChannelContext(context.Background(), channel, ts)\n+}\n+\n+// MarkIMChannelContext sets the read mark of a direct message channel to a specific point with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) MarkIMChannelContext(ctx context.Context, channel, ts string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channel},\n+\t\t\"ts\":      {ts},\n+\t}\n+\n+\t_, err := api.imRequest(ctx, \"im.mark\", values)\n+\treturn err\n+}\n+\n+// GetIMHistory retrieves the direct message channel history\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetIMHistory(channel string, params HistoryParameters) (*History, error) {\n+\treturn api.GetIMHistoryContext(context.Background(), channel, params)\n+}\n+\n+// GetIMHistoryContext retrieves the direct message channel history with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetIMHistoryContext(ctx context.Context, channel string, params HistoryParameters) (*History, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"channel\": {channel},\n+\t}\n+\tif params.Latest != DEFAULT_HISTORY_LATEST {\n+\t\tvalues.Add(\"latest\", params.Latest)\n+\t}\n+\tif params.Oldest != DEFAULT_HISTORY_OLDEST {\n+\t\tvalues.Add(\"oldest\", params.Oldest)\n+\t}\n+\tif params.Count != DEFAULT_HISTORY_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Inclusive != DEFAULT_HISTORY_INCLUSIVE {\n+\t\tif params.Inclusive {\n+\t\t\tvalues.Add(\"inclusive\", \"1\")\n+\t\t} else {\n+\t\t\tvalues.Add(\"inclusive\", \"0\")\n+\t\t}\n+\t}\n+\tif params.Unreads != DEFAULT_HISTORY_UNREADS {\n+\t\tif params.Unreads {\n+\t\t\tvalues.Add(\"unreads\", \"1\")\n+\t\t} else {\n+\t\t\tvalues.Add(\"unreads\", \"0\")\n+\t\t}\n+\t}\n+\n+\tresponse, err := api.imRequest(ctx, \"im.history\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.History, nil\n+}\n+\n+// GetIMChannels returns the list of direct message channels\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetIMChannels() ([]IM, error) {\n+\treturn api.GetIMChannelsContext(context.Background())\n+}\n+\n+// GetIMChannelsContext returns the list of direct message channels with a custom context\n+//\n+// Deprecated: channels.*, groups.* im.* and mpim.* methods will be deprecated in the next version.\n+// In Slack, these API are no longer available for  newly Apps created after June 10th, 2020.\n+// Also, existing applications will not be able to use these APIs after February 24th, 2021.\n+//\n+// See also: https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api\n+func (api *Client) GetIMChannelsContext(ctx context.Context) ([]IM, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\tresponse, err := api.imRequest(ctx, \"im.list\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response.IMs, nil\n+}"
    },
    {
      "sha": "ec70624076c6b3529969a13b4582d29e9bd186d3",
      "filename": "backend/vendor/github.com/slack-go/slack/info.go",
      "status": "added",
      "additions": 468,
      "deletions": 0,
      "changes": 468,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/info.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/info.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/info.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,468 @@\n+package slack\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+type UserPrefsCarrier struct {\n+\tSlackResponse\n+\tUserPrefs *UserPrefs `json:\"prefs\"`\n+}\n+\n+// UserPrefs carries a bunch of user settings including some unknown types\n+type UserPrefs struct {\n+\tUserColors       string `json:\"user_colors,omitempty\"`\n+\tColorNamesInList bool   `json:\"color_names_in_list,omitempty\"`\n+\t// Keyboard UnknownType `json:\"keyboard\"`\n+\tEmailAlerts                         string `json:\"email_alerts,omitempty\"`\n+\tEmailAlertsSleepUntil               int    `json:\"email_alerts_sleep_until,omitempty\"`\n+\tEmailTips                           bool   `json:\"email_tips,omitempty\"`\n+\tEmailWeekly                         bool   `json:\"email_weekly,omitempty\"`\n+\tEmailOffers                         bool   `json:\"email_offers,omitempty\"`\n+\tEmailResearch                       bool   `json:\"email_research,omitempty\"`\n+\tEmailDeveloper                      bool   `json:\"email_developer,omitempty\"`\n+\tWelcomeMessageHidden                bool   `json:\"welcome_message_hidden,omitempty\"`\n+\tSearchSort                          string `json:\"search_sort,omitempty\"`\n+\tSearchFileSort                      string `json:\"search_file_sort,omitempty\"`\n+\tSearchChannelSort                   string `json:\"search_channel_sort,omitempty\"`\n+\tSearchPeopleSort                    string `json:\"search_people_sort,omitempty\"`\n+\tExpandInlineImages                  bool   `json:\"expand_inline_images,omitempty\"`\n+\tExpandInternalInlineImages          bool   `json:\"expand_internal_inline_images,omitempty\"`\n+\tExpandSnippets                      bool   `json:\"expand_snippets,omitempty\"`\n+\tPostsFormattingGuide                bool   `json:\"posts_formatting_guide,omitempty\"`\n+\tSeenWelcome2                        bool   `json:\"seen_welcome_2,omitempty\"`\n+\tSeenSSBPrompt                       bool   `json:\"seen_ssb_prompt,omitempty\"`\n+\tSpacesNewXpBannerDismissed          bool   `json:\"spaces_new_xp_banner_dismissed,omitempty\"`\n+\tSearchOnlyMyChannels                bool   `json:\"search_only_my_channels,omitempty\"`\n+\tSearchOnlyCurrentTeam               bool   `json:\"search_only_current_team,omitempty\"`\n+\tSearchHideMyChannels                bool   `json:\"search_hide_my_channels,omitempty\"`\n+\tSearchOnlyShowOnline                bool   `json:\"search_only_show_online,omitempty\"`\n+\tSearchHideDeactivatedUsers          bool   `json:\"search_hide_deactivated_users,omitempty\"`\n+\tEmojiMode                           string `json:\"emoji_mode,omitempty\"`\n+\tEmojiUse                            string `json:\"emoji_use,omitempty\"`\n+\tHasInvited                          bool   `json:\"has_invited,omitempty\"`\n+\tHasUploaded                         bool   `json:\"has_uploaded,omitempty\"`\n+\tHasCreatedChannel                   bool   `json:\"has_created_channel,omitempty\"`\n+\tHasSearched                         bool   `json:\"has_searched,omitempty\"`\n+\tSearchExcludeChannels               string `json:\"search_exclude_channels,omitempty\"`\n+\tMessagesTheme                       string `json:\"messages_theme,omitempty\"`\n+\tWebappSpellcheck                    bool   `json:\"webapp_spellcheck,omitempty\"`\n+\tNoJoinedOverlays                    bool   `json:\"no_joined_overlays,omitempty\"`\n+\tNoCreatedOverlays                   bool   `json:\"no_created_overlays,omitempty\"`\n+\tDropboxEnabled                      bool   `json:\"dropbox_enabled,omitempty\"`\n+\tSeenDomainInviteReminder            bool   `json:\"seen_domain_invite_reminder,omitempty\"`\n+\tSeenMemberInviteReminder            bool   `json:\"seen_member_invite_reminder,omitempty\"`\n+\tMuteSounds                          bool   `json:\"mute_sounds,omitempty\"`\n+\tArrowHistory                        bool   `json:\"arrow_history,omitempty\"`\n+\tTabUIReturnSelects                  bool   `json:\"tab_ui_return_selects,omitempty\"`\n+\tObeyInlineImgLimit                  bool   `json:\"obey_inline_img_limit,omitempty\"`\n+\tRequireAt                           bool   `json:\"require_at,omitempty\"`\n+\tSsbSpaceWindow                      string `json:\"ssb_space_window,omitempty\"`\n+\tMacSsbBounce                        string `json:\"mac_ssb_bounce,omitempty\"`\n+\tMacSsbBullet                        bool   `json:\"mac_ssb_bullet,omitempty\"`\n+\tExpandNonMediaAttachments           bool   `json:\"expand_non_media_attachments,omitempty\"`\n+\tShowTyping                          bool   `json:\"show_typing,omitempty\"`\n+\tPagekeysHandled                     bool   `json:\"pagekeys_handled,omitempty\"`\n+\tLastSnippetType                     string `json:\"last_snippet_type,omitempty\"`\n+\tDisplayRealNamesOverride            int    `json:\"display_real_names_override,omitempty\"`\n+\tDisplayDisplayNames                 bool   `json:\"display_display_names,omitempty\"`\n+\tTime24                              bool   `json:\"time24,omitempty\"`\n+\tEnterIsSpecialInTbt                 bool   `json:\"enter_is_special_in_tbt,omitempty\"`\n+\tMsgInputSendBtn                     bool   `json:\"msg_input_send_btn,omitempty\"`\n+\tMsgInputSendBtnAutoSet              bool   `json:\"msg_input_send_btn_auto_set,omitempty\"`\n+\tMsgInputStickyComposer              bool   `json:\"msg_input_sticky_composer,omitempty\"`\n+\tGraphicEmoticons                    bool   `json:\"graphic_emoticons,omitempty\"`\n+\tConvertEmoticons                    bool   `json:\"convert_emoticons,omitempty\"`\n+\tSsEmojis                            bool   `json:\"ss_emojis,omitempty\"`\n+\tSeenOnboardingStart                 bool   `json:\"seen_onboarding_start,omitempty\"`\n+\tOnboardingCancelled                 bool   `json:\"onboarding_cancelled,omitempty\"`\n+\tSeenOnboardingSlackbotConversation  bool   `json:\"seen_onboarding_slackbot_conversation,omitempty\"`\n+\tSeenOnboardingChannels              bool   `json:\"seen_onboarding_channels,omitempty\"`\n+\tSeenOnboardingDirectMessages        bool   `json:\"seen_onboarding_direct_messages,omitempty\"`\n+\tSeenOnboardingInvites               bool   `json:\"seen_onboarding_invites,omitempty\"`\n+\tSeenOnboardingSearch                bool   `json:\"seen_onboarding_search,omitempty\"`\n+\tSeenOnboardingRecentMentions        bool   `json:\"seen_onboarding_recent_mentions,omitempty\"`\n+\tSeenOnboardingStarredItems          bool   `json:\"seen_onboarding_starred_items,omitempty\"`\n+\tSeenOnboardingPrivateGroups         bool   `json:\"seen_onboarding_private_groups,omitempty\"`\n+\tSeenOnboardingBanner                bool   `json:\"seen_onboarding_banner,omitempty\"`\n+\tOnboardingSlackbotConversationStep  int    `json:\"onboarding_slackbot_conversation_step,omitempty\"`\n+\tSetTzAutomatically                  bool   `json:\"set_tz_automatically,omitempty\"`\n+\tSuppressLinkWarning                 bool   `json:\"suppress_link_warning,omitempty\"`\n+\tDndEnabled                          bool   `json:\"dnd_enabled,omitempty\"`\n+\tDndStartHour                        string `json:\"dnd_start_hour,omitempty\"`\n+\tDndEndHour                          string `json:\"dnd_end_hour,omitempty\"`\n+\tDndBeforeMonday                     string `json:\"dnd_before_monday,omitempty\"`\n+\tDndAfterMonday                      string `json:\"dnd_after_monday,omitempty\"`\n+\tDndEnabledMonday                    string `json:\"dnd_enabled_monday,omitempty\"`\n+\tDndBeforeTuesday                    string `json:\"dnd_before_tuesday,omitempty\"`\n+\tDndAfterTuesday                     string `json:\"dnd_after_tuesday,omitempty\"`\n+\tDndEnabledTuesday                   string `json:\"dnd_enabled_tuesday,omitempty\"`\n+\tDndBeforeWednesday                  string `json:\"dnd_before_wednesday,omitempty\"`\n+\tDndAfterWednesday                   string `json:\"dnd_after_wednesday,omitempty\"`\n+\tDndEnabledWednesday                 string `json:\"dnd_enabled_wednesday,omitempty\"`\n+\tDndBeforeThursday                   string `json:\"dnd_before_thursday,omitempty\"`\n+\tDndAfterThursday                    string `json:\"dnd_after_thursday,omitempty\"`\n+\tDndEnabledThursday                  string `json:\"dnd_enabled_thursday,omitempty\"`\n+\tDndBeforeFriday                     string `json:\"dnd_before_friday,omitempty\"`\n+\tDndAfterFriday                      string `json:\"dnd_after_friday,omitempty\"`\n+\tDndEnabledFriday                    string `json:\"dnd_enabled_friday,omitempty\"`\n+\tDndBeforeSaturday                   string `json:\"dnd_before_saturday,omitempty\"`\n+\tDndAfterSaturday                    string `json:\"dnd_after_saturday,omitempty\"`\n+\tDndEnabledSaturday                  string `json:\"dnd_enabled_saturday,omitempty\"`\n+\tDndBeforeSunday                     string `json:\"dnd_before_sunday,omitempty\"`\n+\tDndAfterSunday                      string `json:\"dnd_after_sunday,omitempty\"`\n+\tDndEnabledSunday                    string `json:\"dnd_enabled_sunday,omitempty\"`\n+\tDndDays                             string `json:\"dnd_days,omitempty\"`\n+\tDndCustomNewBadgeSeen               bool   `json:\"dnd_custom_new_badge_seen,omitempty\"`\n+\tDndNotificationScheduleNewBadgeSeen bool   `json:\"dnd_notification_schedule_new_badge_seen,omitempty\"`\n+\t// UnreadCollapsedChannels      unknownType                  `json:\"unread_collapsed_channels,omitempty\"`\n+\tSidebarBehavior          string `json:\"sidebar_behavior,omitempty\"`\n+\tChannelSort              string `json:\"channel_sort,omitempty\"`\n+\tSeparatePrivateChannels  bool   `json:\"separate_private_channels,omitempty\"`\n+\tSeparateSharedChannels   bool   `json:\"separate_shared_channels,omitempty\"`\n+\tSidebarTheme             string `json:\"sidebar_theme,omitempty\"`\n+\tSidebarThemeCustomValues string `json:\"sidebar_theme_custom_values,omitempty\"`\n+\tNoInvitesWidgetInSidebar bool   `json:\"no_invites_widget_in_sidebar,omitempty\"`\n+\tNoOmniboxInChannels      bool   `json:\"no_omnibox_in_channels,omitempty\"`\n+\n+\tKKeyOmniboxAutoHideCount       int    `json:\"k_key_omnibox_auto_hide_count,omitempty\"`\n+\tShowSidebarQuickswitcherButton bool   `json:\"show_sidebar_quickswitcher_button,omitempty\"`\n+\tEntOrgWideChannelsSidebar      bool   `json:\"ent_org_wide_channels_sidebar,omitempty\"`\n+\tMarkMsgsReadImmediately        bool   `json:\"mark_msgs_read_immediately,omitempty\"`\n+\tStartScrollAtOldest            bool   `json:\"start_scroll_at_oldest,omitempty\"`\n+\tSnippetEditorWrapLongLines     bool   `json:\"snippet_editor_wrap_long_lines,omitempty\"`\n+\tLsDisabled                     bool   `json:\"ls_disabled,omitempty\"`\n+\tFKeySearch                     bool   `json:\"f_key_search,omitempty\"`\n+\tKKeyOmnibox                    bool   `json:\"k_key_omnibox,omitempty\"`\n+\tPromptedForEmailDisabling      bool   `json:\"prompted_for_email_disabling,omitempty\"`\n+\tNoMacelectronBanner            bool   `json:\"no_macelectron_banner,omitempty\"`\n+\tNoMacssb1Banner                bool   `json:\"no_macssb1_banner,omitempty\"`\n+\tNoMacssb2Banner                bool   `json:\"no_macssb2_banner,omitempty\"`\n+\tNoWinssb1Banner                bool   `json:\"no_winssb1_banner,omitempty\"`\n+\tHideUserGroupInfoPane          bool   `json:\"hide_user_group_info_pane,omitempty\"`\n+\tMentionsExcludeAtUserGroups    bool   `json:\"mentions_exclude_at_user_groups,omitempty\"`\n+\tMentionsExcludeReactions       bool   `json:\"mentions_exclude_reactions,omitempty\"`\n+\tPrivacyPolicySeen              bool   `json:\"privacy_policy_seen,omitempty\"`\n+\tEnterpriseMigrationSeen        bool   `json:\"enterprise_migration_seen,omitempty\"`\n+\tLastTosAcknowledged            string `json:\"last_tos_acknowledged,omitempty\"`\n+\tSearchExcludeBots              bool   `json:\"search_exclude_bots,omitempty\"`\n+\tLoadLato2                      bool   `json:\"load_lato_2,omitempty\"`\n+\tFullerTimestamps               bool   `json:\"fuller_timestamps,omitempty\"`\n+\tLastSeenAtChannelWarning       int    `json:\"last_seen_at_channel_warning,omitempty\"`\n+\tEmojiAutocompleteBig           bool   `json:\"emoji_autocomplete_big,omitempty\"`\n+\tTwoFactorAuthEnabled           bool   `json:\"two_factor_auth_enabled,omitempty\"`\n+\t// TwoFactorType                         unknownType    `json:\"two_factor_type,omitempty\"`\n+\t// TwoFactorBackupType                   unknownType    `json:\"two_factor_backup_type,omitempty\"`\n+\tHideHexSwatch          bool   `json:\"hide_hex_swatch,omitempty\"`\n+\tShowJumperScores       bool   `json:\"show_jumper_scores,omitempty\"`\n+\tEnterpriseMdmCustomMsg string `json:\"enterprise_mdm_custom_msg,omitempty\"`\n+\t// EnterpriseExcludedAppTeams                 unknownType    `json:\"enterprise_excluded_app_teams,omitempty\"`\n+\tClientLogsPri             string `json:\"client_logs_pri,omitempty\"`\n+\tFlannelServerPool         string `json:\"flannel_server_pool,omitempty\"`\n+\tMentionsExcludeAtChannels bool   `json:\"mentions_exclude_at_channels,omitempty\"`\n+\tConfirmClearAllUnreads    bool   `json:\"confirm_clear_all_unreads,omitempty\"`\n+\tConfirmUserMarkedAway     bool   `json:\"confirm_user_marked_away,omitempty\"`\n+\tBoxEnabled                bool   `json:\"box_enabled,omitempty\"`\n+\tSeenSingleEmojiMsg        bool   `json:\"seen_single_emoji_msg,omitempty\"`\n+\tConfirmShCallStart        bool   `json:\"confirm_sh_call_start,omitempty\"`\n+\tPreferredSkinTone         string `json:\"preferred_skin_tone,omitempty\"`\n+\tShowAllSkinTones          bool   `json:\"show_all_skin_tones,omitempty\"`\n+\tWhatsNewRead              int    `json:\"whats_new_read,omitempty\"`\n+\t// FrecencyJumper                           unknownType      `json:\"frecency_jumper,omitempty\"`\n+\tFrecencyEntJumper                       string `json:\"frecency_ent_jumper,omitempty\"`\n+\tFrecencyEntJumperBackup                 string `json:\"frecency_ent_jumper_backup,omitempty\"`\n+\tJumbomoji                               bool   `json:\"jumbomoji,omitempty\"`\n+\tNewxpSeenLastMessage                    int    `json:\"newxp_seen_last_message,omitempty\"`\n+\tShowMemoryInstrument                    bool   `json:\"show_memory_instrument,omitempty\"`\n+\tEnableUnreadView                        bool   `json:\"enable_unread_view,omitempty\"`\n+\tSeenUnreadViewCoachmark                 bool   `json:\"seen_unread_view_coachmark,omitempty\"`\n+\tEnableReactEmojiPicker                  bool   `json:\"enable_react_emoji_picker,omitempty\"`\n+\tSeenCustomStatusBadge                   bool   `json:\"seen_custom_status_badge,omitempty\"`\n+\tSeenCustomStatusCallout                 bool   `json:\"seen_custom_status_callout,omitempty\"`\n+\tSeenCustomStatusExpirationBadge         bool   `json:\"seen_custom_status_expiration_badge,omitempty\"`\n+\tUsedCustomStatusKbShortcut              bool   `json:\"used_custom_status_kb_shortcut,omitempty\"`\n+\tSeenGuestAdminSlackbotAnnouncement      bool   `json:\"seen_guest_admin_slackbot_announcement,omitempty\"`\n+\tSeenThreadsNotificationBanner           bool   `json:\"seen_threads_notification_banner,omitempty\"`\n+\tSeenNameTaggingCoachmark                bool   `json:\"seen_name_tagging_coachmark,omitempty\"`\n+\tAllUnreadsSortOrder                     string `json:\"all_unreads_sort_order,omitempty\"`\n+\tLocale                                  string `json:\"locale,omitempty\"`\n+\tSeenIntlChannelNamesCoachmark           bool   `json:\"seen_intl_channel_names_coachmark,omitempty\"`\n+\tSeenP2LocaleChangeMessage               int    `json:\"seen_p2_locale_change_message,omitempty\"`\n+\tSeenLocaleChangeMessage                 int    `json:\"seen_locale_change_message,omitempty\"`\n+\tSeenJapaneseLocaleChangeMessage         bool   `json:\"seen_japanese_locale_change_message,omitempty\"`\n+\tSeenSharedChannelsCoachmark             bool   `json:\"seen_shared_channels_coachmark,omitempty\"`\n+\tSeenSharedChannelsOptInChangeMessage    bool   `json:\"seen_shared_channels_opt_in_change_message,omitempty\"`\n+\tHasRecentlySharedaChannel               bool   `json:\"has_recently_shared_a_channel,omitempty\"`\n+\tSeenChannelBrowserAdminCoachmark        bool   `json:\"seen_channel_browser_admin_coachmark,omitempty\"`\n+\tSeenAdministrationMenu                  bool   `json:\"seen_administration_menu,omitempty\"`\n+\tSeenDraftsSectionCoachmark              bool   `json:\"seen_drafts_section_coachmark,omitempty\"`\n+\tSeenEmojiUpdateOverlayCoachmark         bool   `json:\"seen_emoji_update_overlay_coachmark,omitempty\"`\n+\tSeenSonicDeluxeToast                    int    `json:\"seen_sonic_deluxe_toast,omitempty\"`\n+\tSeenWysiwygDeluxeToast                  bool   `json:\"seen_wysiwyg_deluxe_toast,omitempty\"`\n+\tSeenMarkdownPasteToast                  int    `json:\"seen_markdown_paste_toast,omitempty\"`\n+\tSeenMarkdownPasteShortcut               int    `json:\"seen_markdown_paste_shortcut,omitempty\"`\n+\tSeenIaEducation                         bool   `json:\"seen_ia_education,omitempty\"`\n+\tPlainTextMode                           bool   `json:\"plain_text_mode,omitempty\"`\n+\tShowSharedChannelsEducationBanner       bool   `json:\"show_shared_channels_education_banner,omitempty\"`\n+\tAllowCallsToSetCurrentStatus            bool   `json:\"allow_calls_to_set_current_status,omitempty\"`\n+\tInInteractiveMasMigrationFlow           bool   `json:\"in_interactive_mas_migration_flow,omitempty\"`\n+\tSunsetInteractiveMessageViews           int    `json:\"sunset_interactive_message_views,omitempty\"`\n+\tShdepPromoCodeSubmitted                 bool   `json:\"shdep_promo_code_submitted,omitempty\"`\n+\tSeenShdepSlackbotMessage                bool   `json:\"seen_shdep_slackbot_message,omitempty\"`\n+\tSeenCallsInteractiveCoachmark           bool   `json:\"seen_calls_interactive_coachmark,omitempty\"`\n+\tAllowCmdTabIss                          bool   `json:\"allow_cmd_tab_iss,omitempty\"`\n+\tSeenWorkflowBuilderDeluxeToast          bool   `json:\"seen_workflow_builder_deluxe_toast,omitempty\"`\n+\tWorkflowBuilderIntroModalClickedThrough bool   `json:\"workflow_builder_intro_modal_clicked_through,omitempty\"`\n+\t// WorkflowBuilderCoachmarks                    unknownType  `json:\"workflow_builder_coachmarks,omitempty\"`\n+\tSeenGdriveCoachmark                            bool   `json:\"seen_gdrive_coachmark,omitempty\"`\n+\tOverloadedMessageEnabled                       bool   `json:\"overloaded_message_enabled,omitempty\"`\n+\tSeenHighlightsCoachmark                        bool   `json:\"seen_highlights_coachmark,omitempty\"`\n+\tSeenHighlightsArrowsCoachmark                  bool   `json:\"seen_highlights_arrows_coachmark,omitempty\"`\n+\tSeenHighlightsWarmWelcome                      bool   `json:\"seen_highlights_warm_welcome,omitempty\"`\n+\tSeenNewSearchUi                                bool   `json:\"seen_new_search_ui,omitempty\"`\n+\tSeenChannelSearch                              bool   `json:\"seen_channel_search,omitempty\"`\n+\tSeenPeopleSearch                               bool   `json:\"seen_people_search,omitempty\"`\n+\tSeenPeopleSearchCount                          int    `json:\"seen_people_search_count,omitempty\"`\n+\tDismissedScrollSearchTooltipCount              int    `json:\"dismissed_scroll_search_tooltip_count,omitempty\"`\n+\tLastDismissedScrollSearchTooltipTimestamp      int    `json:\"last_dismissed_scroll_search_tooltip_timestamp,omitempty\"`\n+\tHasUsedQuickswitcherShortcut                   bool   `json:\"has_used_quickswitcher_shortcut,omitempty\"`\n+\tSeenQuickswitcherShortcutTipCount              int    `json:\"seen_quickswitcher_shortcut_tip_count,omitempty\"`\n+\tBrowsersDismissedChannelsLowResultsEducation   bool   `json:\"browsers_dismissed_channels_low_results_education,omitempty\"`\n+\tBrowsersSeenInitialChannelsEducation           bool   `json:\"browsers_seen_initial_channels_education,omitempty\"`\n+\tBrowsersDismissedPeopleLowResultsEducation     bool   `json:\"browsers_dismissed_people_low_results_education,omitempty\"`\n+\tBrowsersSeenInitialPeopleEducation             bool   `json:\"browsers_seen_initial_people_education,omitempty\"`\n+\tBrowsersDismissedUserGroupsLowResultsEducation bool   `json:\"browsers_dismissed_user_groups_low_results_education,omitempty\"`\n+\tBrowsersSeenInitialUserGroupsEducation         bool   `json:\"browsers_seen_initial_user_groups_education,omitempty\"`\n+\tBrowsersDismissedFilesLowResultsEducation      bool   `json:\"browsers_dismissed_files_low_results_education,omitempty\"`\n+\tBrowsersSeenInitialFilesEducation              bool   `json:\"browsers_seen_initial_files_education,omitempty\"`\n+\tA11yAnimations                                 bool   `json:\"a11y_animations,omitempty\"`\n+\tSeenKeyboardShortcutsCoachmark                 bool   `json:\"seen_keyboard_shortcuts_coachmark,omitempty\"`\n+\tNeedsInitialPasswordSet                        bool   `json:\"needs_initial_password_set,omitempty\"`\n+\tLessonsEnabled                                 bool   `json:\"lessons_enabled,omitempty\"`\n+\tTractorEnabled                                 bool   `json:\"tractor_enabled,omitempty\"`\n+\tTractorExperimentGroup                         string `json:\"tractor_experiment_group,omitempty\"`\n+\tOpenedSlackbotDm                               bool   `json:\"opened_slackbot_dm,omitempty\"`\n+\tNewxpSuggestedChannels                         string `json:\"newxp_suggested_channels,omitempty\"`\n+\tOnboardingComplete                             bool   `json:\"onboarding_complete,omitempty\"`\n+\tWelcomePlaceState                              string `json:\"welcome_place_state,omitempty\"`\n+\t// OnboardingRoleApps  unknownType `json:\"onboarding_role_apps,omitempty\"`\n+\tHasReceivedThreadedMessage        bool   `json:\"has_received_threaded_message,omitempty\"`\n+\tSendYourFirstMessageBannerEnabled bool   `json:\"send_your_first_message_banner_enabled,omitempty\"`\n+\tWhocanseethisDmMpdmBadge          bool   `json:\"whocanseethis_dm_mpdm_badge,omitempty\"`\n+\tHighlightWords                    string `json:\"highlight_words,omitempty\"`\n+\tThreadsEverything                 bool   `json:\"threads_everything,omitempty\"`\n+\tNoTextInNotifications             bool   `json:\"no_text_in_notifications,omitempty\"`\n+\tPushShowPreview                   bool   `json:\"push_show_preview,omitempty\"`\n+\tGrowlsEnabled                     bool   `json:\"growls_enabled,omitempty\"`\n+\tAllChannelsLoud                   bool   `json:\"all_channels_loud,omitempty\"`\n+\tPushDmAlert                       bool   `json:\"push_dm_alert,omitempty\"`\n+\tPushMentionAlert                  bool   `json:\"push_mention_alert,omitempty\"`\n+\tPushEverything                    bool   `json:\"push_everything,omitempty\"`\n+\tPushIdleWait                      int    `json:\"push_idle_wait,omitempty\"`\n+\tPushSound                         string `json:\"push_sound,omitempty\"`\n+\tNewMsgSnd                         string `json:\"new_msg_snd,omitempty\"`\n+\tPushLoudChannels                  string `json:\"push_loud_channels,omitempty\"`\n+\tPushMentionChannels               string `json:\"push_mention_channels,omitempty\"`\n+\tPushLoudChannelsSet               string `json:\"push_loud_channels_set,omitempty\"`\n+\tLoudChannels                      string `json:\"loud_channels,omitempty\"`\n+\tNeverChannels                     string `json:\"never_channels,omitempty\"`\n+\tLoudChannelsSet                   string `json:\"loud_channels_set,omitempty\"`\n+\tAtChannelSuppressedChannels       string `json:\"at_channel_suppressed_channels,omitempty\"`\n+\tPushAtChannelSuppressedChannels   string `json:\"push_at_channel_suppressed_channels,omitempty\"`\n+\tMutedChannels                     string `json:\"muted_channels,omitempty\"`\n+\t// AllNotificationsPrefs                  unknownType `json:\"all_notifications_prefs,omitempty\"`\n+\tGrowthMsgLimitApproachingCtaCount     int `json:\"growth_msg_limit_approaching_cta_count,omitempty\"`\n+\tGrowthMsgLimitApproachingCtaTs        int `json:\"growth_msg_limit_approaching_cta_ts,omitempty\"`\n+\tGrowthMsgLimitReachedCtaCount         int `json:\"growth_msg_limit_reached_cta_count,omitempty\"`\n+\tGrowthMsgLimitReachedCtaLastTs        int `json:\"growth_msg_limit_reached_cta_last_ts,omitempty\"`\n+\tGrowthMsgLimitLongReachedCtaCount     int `json:\"growth_msg_limit_long_reached_cta_count,omitempty\"`\n+\tGrowthMsgLimitLongReachedCtaLastTs    int `json:\"growth_msg_limit_long_reached_cta_last_ts,omitempty\"`\n+\tGrowthMsgLimitSixtyDayBannerCtaCount  int `json:\"growth_msg_limit_sixty_day_banner_cta_count,omitempty\"`\n+\tGrowthMsgLimitSixtyDayBannerCtaLastTs int `json:\"growth_msg_limit_sixty_day_banner_cta_last_ts,omitempty\"`\n+\t// GrowthAllBannersPrefs unknownType `json:\"growth_all_banners_prefs,omitempty\"`\n+\tAnalyticsUpsellCoachmarkSeen bool `json:\"analytics_upsell_coachmark_seen,omitempty\"`\n+\tSeenAppSpaceCoachmark        bool `json:\"seen_app_space_coachmark,omitempty\"`\n+\tSeenAppSpaceTutorial         bool `json:\"seen_app_space_tutorial,omitempty\"`\n+\tDismissedAppLauncherWelcome  bool `json:\"dismissed_app_launcher_welcome,omitempty\"`\n+\tDismissedAppLauncherLimit    bool `json:\"dismissed_app_launcher_limit,omitempty\"`\n+\tPurchaser                    bool `json:\"purchaser,omitempty\"`\n+\tShowEntOnboarding            bool `json:\"show_ent_onboarding,omitempty\"`\n+\tFoldersEnabled               bool `json:\"folders_enabled,omitempty\"`\n+\t// FolderData unknownType `json:\"folder_data,omitempty\"`\n+\tSeenCorporateExportAlert               bool   `json:\"seen_corporate_export_alert,omitempty\"`\n+\tShowAutocompleteHelp                   int    `json:\"show_autocomplete_help,omitempty\"`\n+\tDeprecationToastLastSeen               int    `json:\"deprecation_toast_last_seen,omitempty\"`\n+\tDeprecationModalLastSeen               int    `json:\"deprecation_modal_last_seen,omitempty\"`\n+\tIap1Lab                                int    `json:\"iap1_lab,omitempty\"`\n+\tIaTopNavTheme                          string `json:\"ia_top_nav_theme,omitempty\"`\n+\tIaPlatformActionsLab                   int    `json:\"ia_platform_actions_lab,omitempty\"`\n+\tActivityView                           string `json:\"activity_view,omitempty\"`\n+\tFailoverProxyCheckCompleted            int    `json:\"failover_proxy_check_completed,omitempty\"`\n+\tEdgeUploadProxyCheckCompleted          int    `json:\"edge_upload_proxy_check_completed,omitempty\"`\n+\tAppSubdomainCheckCompleted             int    `json:\"app_subdomain_check_completed,omitempty\"`\n+\tAddAppsPromptDismissed                 bool   `json:\"add_apps_prompt_dismissed,omitempty\"`\n+\tAddChannelPromptDismissed              bool   `json:\"add_channel_prompt_dismissed,omitempty\"`\n+\tChannelSidebarHideInvite               bool   `json:\"channel_sidebar_hide_invite,omitempty\"`\n+\tInProdSurveysEnabled                   bool   `json:\"in_prod_surveys_enabled,omitempty\"`\n+\tDismissedInstalledAppDmSuggestions     string `json:\"dismissed_installed_app_dm_suggestions,omitempty\"`\n+\tSeenContextualMessageShortcutsModal    bool   `json:\"seen_contextual_message_shortcuts_modal,omitempty\"`\n+\tSeenMessageNavigationEducationalToast  bool   `json:\"seen_message_navigation_educational_toast,omitempty\"`\n+\tContextualMessageShortcutsModalWasSeen bool   `json:\"contextual_message_shortcuts_modal_was_seen,omitempty\"`\n+\tMessageNavigationToastWasSeen          bool   `json:\"message_navigation_toast_was_seen,omitempty\"`\n+\tUpToBrowseKbShortcut                   bool   `json:\"up_to_browse_kb_shortcut,omitempty\"`\n+\tChannelSections                        string `json:\"channel_sections,omitempty\"`\n+\tTZ                                     string `json:\"tz,omitempty\"`\n+}\n+\n+func (api *Client) GetUserPrefs() (*UserPrefsCarrier, error) {\n+\tvalues := url.Values{\"token\": {api.token}}\n+\tresponse := UserPrefsCarrier{}\n+\n+\terr := api.getMethod(context.Background(), \"users.prefs.get\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response, response.Err()\n+}\n+\n+func (api *Client) MuteChat(channelID string) (*UserPrefsCarrier, error) {\n+\tprefs, err := api.GetUserPrefs()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tchnls := strings.Split(prefs.UserPrefs.MutedChannels, \",\")\n+\tfor _, chn := range chnls {\n+\t\tif chn == channelID {\n+\t\t\treturn nil, nil // noop\n+\t\t}\n+\t}\n+\tnewChnls := prefs.UserPrefs.MutedChannels + \",\" + channelID\n+\tvalues := url.Values{\"token\": {api.token}, \"muted_channels\": {newChnls}, \"reason\": {\"update-muted-channels\"}}\n+\tresponse := UserPrefsCarrier{}\n+\n+\terr = api.postMethod(context.Background(), \"users.prefs.set\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response, response.Err()\n+}\n+\n+func (api *Client) UnMuteChat(channelID string) (*UserPrefsCarrier, error) {\n+\tprefs, err := api.GetUserPrefs()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tchnls := strings.Split(prefs.UserPrefs.MutedChannels, \",\")\n+\tnewChnls := make([]string, len(chnls)-1)\n+\tfor i, chn := range chnls {\n+\t\tif chn == channelID {\n+\t\t\treturn nil, nil // noop\n+\t\t}\n+\t\tnewChnls[i] = chn\n+\t}\n+\tvalues := url.Values{\"token\": {api.token}, \"muted_channels\": {strings.Join(newChnls, \",\")}, \"reason\": {\"update-muted-channels\"}}\n+\tresponse := UserPrefsCarrier{}\n+\n+\terr = api.postMethod(context.Background(), \"users.prefs.set\", values, &response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &response, response.Err()\n+}\n+\n+// UserDetails contains user details coming in the initial response from StartRTM\n+type UserDetails struct {\n+\tID             string    `json:\"id\"`\n+\tName           string    `json:\"name\"`\n+\tCreated        JSONTime  `json:\"created\"`\n+\tManualPresence string    `json:\"manual_presence\"`\n+\tPrefs          UserPrefs `json:\"prefs\"`\n+}\n+\n+// JSONTime exists so that we can have a String method converting the date\n+type JSONTime int64\n+\n+// String converts the unix timestamp into a string\n+func (t JSONTime) String() string {\n+\ttm := t.Time()\n+\treturn fmt.Sprintf(\"\\\"%s\\\"\", tm.Format(\"Mon Jan _2\"))\n+}\n+\n+// Time returns a `time.Time` representation of this value.\n+func (t JSONTime) Time() time.Time {\n+\treturn time.Unix(int64(t), 0)\n+}\n+\n+// UnmarshalJSON will unmarshal both string and int JSON values\n+func (t *JSONTime) UnmarshalJSON(buf []byte) error {\n+\ts := bytes.Trim(buf, `\"`)\n+\n+\tv, err := strconv.Atoi(string(s))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t*t = JSONTime(int64(v))\n+\treturn nil\n+}\n+\n+// Team contains details about a team\n+type Team struct {\n+\tID     string `json:\"id\"`\n+\tName   string `json:\"name\"`\n+\tDomain string `json:\"domain\"`\n+}\n+\n+// Icons XXX: needs further investigation\n+type Icons struct {\n+\tImage36 string `json:\"image_36,omitempty\"`\n+\tImage48 string `json:\"image_48,omitempty\"`\n+\tImage72 string `json:\"image_72,omitempty\"`\n+}\n+\n+// Info contains various details about the authenticated user and team.\n+// It is returned by StartRTM or included in the \"ConnectedEvent\" RTM event.\n+type Info struct {\n+\tURL  string       `json:\"url,omitempty\"`\n+\tUser *UserDetails `json:\"self,omitempty\"`\n+\tTeam *Team        `json:\"team,omitempty\"`\n+}\n+\n+type infoResponseFull struct {\n+\tInfo\n+\tSlackResponse\n+}\n+\n+// GetBotByID is deprecated and returns nil\n+func (info Info) GetBotByID(botID string) *Bot {\n+\treturn nil\n+}\n+\n+// GetUserByID is deprecated and returns nil\n+func (info Info) GetUserByID(userID string) *User {\n+\treturn nil\n+}\n+\n+// GetChannelByID is deprecated and returns nil\n+func (info Info) GetChannelByID(channelID string) *Channel {\n+\treturn nil\n+}\n+\n+// GetGroupByID is deprecated and returns nil\n+func (info Info) GetGroupByID(groupID string) *Group {\n+\treturn nil\n+}\n+\n+// GetIMByID is deprecated and returns nil\n+func (info Info) GetIMByID(imID string) *IM {\n+\treturn nil\n+}"
    },
    {
      "sha": "2515e290fd3fb270bd6f8e98776aa337839caf7d",
      "filename": "backend/vendor/github.com/slack-go/slack/interactions.go",
      "status": "added",
      "additions": 221,
      "deletions": 0,
      "changes": 221,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/interactions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/interactions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/interactions.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,221 @@\n+package slack\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+)\n+\n+// InteractionType type of interactions\n+type InteractionType string\n+\n+// ActionType type represents the type of action (attachment, block, etc.)\n+type actionType string\n+\n+// action is an interface that should be implemented by all callback action types\n+type action interface {\n+\tactionType() actionType\n+}\n+\n+// Types of interactions that can be received.\n+const (\n+\tInteractionTypeDialogCancellation = InteractionType(\"dialog_cancellation\")\n+\tInteractionTypeDialogSubmission   = InteractionType(\"dialog_submission\")\n+\tInteractionTypeDialogSuggestion   = InteractionType(\"dialog_suggestion\")\n+\tInteractionTypeInteractionMessage = InteractionType(\"interactive_message\")\n+\tInteractionTypeMessageAction      = InteractionType(\"message_action\")\n+\tInteractionTypeBlockActions       = InteractionType(\"block_actions\")\n+\tInteractionTypeBlockSuggestion    = InteractionType(\"block_suggestion\")\n+\tInteractionTypeViewSubmission     = InteractionType(\"view_submission\")\n+\tInteractionTypeViewClosed         = InteractionType(\"view_closed\")\n+\tInteractionTypeShortcut           = InteractionType(\"shortcut\")\n+)\n+\n+// InteractionCallback is sent from slack when a user interactions with a button or dialog.\n+type InteractionCallback struct {\n+\tType            InteractionType `json:\"type\"`\n+\tToken           string          `json:\"token\"`\n+\tCallbackID      string          `json:\"callback_id\"`\n+\tResponseURL     string          `json:\"response_url\"`\n+\tTriggerID       string          `json:\"trigger_id\"`\n+\tActionTs        string          `json:\"action_ts\"`\n+\tTeam            Team            `json:\"team\"`\n+\tChannel         Channel         `json:\"channel\"`\n+\tUser            User            `json:\"user\"`\n+\tOriginalMessage Message         `json:\"original_message\"`\n+\tMessage         Message         `json:\"message\"`\n+\tName            string          `json:\"name\"`\n+\tValue           string          `json:\"value\"`\n+\tMessageTs       string          `json:\"message_ts\"`\n+\tAttachmentID    string          `json:\"attachment_id\"`\n+\tActionCallback  ActionCallbacks `json:\"actions\"`\n+\tView            View            `json:\"view\"`\n+\tActionID        string          `json:\"action_id\"`\n+\tAPIAppID        string          `json:\"api_app_id\"`\n+\tBlockID         string          `json:\"block_id\"`\n+\tContainer       Container       `json:\"container\"`\n+\tDialogSubmissionCallback\n+\tViewSubmissionCallback\n+\tViewClosedCallback\n+\n+\t// FIXME(kanata2): just workaround for backward-compatibility.\n+\t// See also https://github.com/slack-go/slack/issues/816\n+\tRawState json.RawMessage `json:\"state,omitempty\"`\n+\n+\t// BlockActionState stands for the `state` field in block_actions type.\n+\t// NOTE: InteractionCallback.State has a role for the state of dialog_submission type,\n+\t// so we cannot use this field for backward-compatibility for now.\n+\tBlockActionState *BlockActionStates `json:\"-\"`\n+}\n+\n+type BlockActionStates struct {\n+\tValues map[string]map[string]BlockAction `json:\"values\"`\n+}\n+\n+func (ic *InteractionCallback) MarshalJSON() ([]byte, error) {\n+\ttype alias InteractionCallback\n+\ttmp := alias(*ic)\n+\tif tmp.Type == InteractionTypeBlockActions {\n+\t\tif tmp.BlockActionState == nil {\n+\t\t\ttmp.RawState = []byte(`{}`)\n+\t\t} else {\n+\t\t\tstate, err := json.Marshal(tmp.BlockActionState.Values)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\ttmp.RawState = []byte(`{\"values\":` + string(state) + `}`)\n+\t\t}\n+\t} else if ic.Type == InteractionTypeDialogSubmission {\n+\t\ttmp.RawState = []byte(tmp.State)\n+\t}\n+\t// Use pointer for go1.7\n+\treturn json.Marshal(&tmp)\n+}\n+\n+func (ic *InteractionCallback) UnmarshalJSON(b []byte) error {\n+\ttype alias InteractionCallback\n+\ttmp := struct {\n+\t\tType InteractionType `json:\"type\"`\n+\t\t*alias\n+\t}{\n+\t\talias: (*alias)(ic),\n+\t}\n+\tif err := json.Unmarshal(b, &tmp); err != nil {\n+\t\treturn err\n+\t}\n+\t*ic = InteractionCallback(*tmp.alias)\n+\tic.Type = tmp.Type\n+\tif ic.Type == InteractionTypeBlockActions {\n+\t\tif len(ic.RawState) > 0 {\n+\t\t\terr := json.Unmarshal(ic.RawState, &ic.BlockActionState)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t} else if ic.Type == InteractionTypeDialogSubmission {\n+\t\tic.State = string(ic.RawState)\n+\t}\n+\treturn nil\n+}\n+\n+type Container struct {\n+\tType         string      `json:\"type\"`\n+\tViewID       string      `json:\"view_id\"`\n+\tMessageTs    string      `json:\"message_ts\"`\n+\tAttachmentID json.Number `json:\"attachment_id\"`\n+\tChannelID    string      `json:\"channel_id\"`\n+\tIsEphemeral  bool        `json:\"is_ephemeral\"`\n+\tIsAppUnfurl  bool        `json:\"is_app_unfurl\"`\n+}\n+\n+// ActionCallback is a convenience struct defined to allow dynamic unmarshalling of\n+// the \"actions\" value in Slack's JSON response, which varies depending on block type\n+type ActionCallbacks struct {\n+\tAttachmentActions []*AttachmentAction\n+\tBlockActions      []*BlockAction\n+}\n+\n+// MarshalJSON implements the Marshaller interface in order to combine both\n+// action callback types back into a single array, like how the api responds.\n+// This makes Marshaling and Unmarshaling an InteractionCallback symmetrical\n+func (a ActionCallbacks) MarshalJSON() ([]byte, error) {\n+\tcount := 0\n+\tlength := len(a.AttachmentActions) + len(a.BlockActions)\n+\tbuffer := bytes.NewBufferString(\"[\")\n+\n+\tf := func(obj interface{}) error {\n+\t\tjs, err := json.Marshal(obj)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t_, err = buffer.Write(js)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tcount++\n+\t\tif count < length {\n+\t\t\t_, err = buffer.WriteString(\",\")\n+\t\t\treturn err\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tfor _, act := range a.AttachmentActions {\n+\t\terr := f(act)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tfor _, blk := range a.BlockActions {\n+\t\terr := f(blk)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tbuffer.WriteString(\"]\")\n+\treturn buffer.Bytes(), nil\n+}\n+\n+// UnmarshalJSON implements the Marshaller interface in order to delegate\n+// marshalling and allow for proper type assertion when decoding the response\n+func (a *ActionCallbacks) UnmarshalJSON(data []byte) error {\n+\tvar raw []json.RawMessage\n+\terr := json.Unmarshal(data, &raw)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfor _, r := range raw {\n+\t\tvar obj map[string]interface{}\n+\t\terr := json.Unmarshal(r, &obj)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif _, ok := obj[\"block_id\"].(string); ok {\n+\t\t\taction, err := unmarshalAction(r, &BlockAction{})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\n+\t\t\ta.BlockActions = append(a.BlockActions, action.(*BlockAction))\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\taction, err := unmarshalAction(r, &AttachmentAction{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\ta.AttachmentActions = append(a.AttachmentActions, action.(*AttachmentAction))\n+\t}\n+\n+\treturn nil\n+}\n+\n+func unmarshalAction(r json.RawMessage, callbackAction action) (action, error) {\n+\terr := json.Unmarshal(r, callbackAction)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn callbackAction, nil\n+}"
    },
    {
      "sha": "df210f80d52a697de00a2cd8d0e4739657fa6f43",
      "filename": "backend/vendor/github.com/slack-go/slack/internal/backoff/backoff.go",
      "status": "added",
      "additions": 62,
      "deletions": 0,
      "changes": 62,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/backoff/backoff.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/backoff/backoff.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/internal/backoff/backoff.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,62 @@\n+package backoff\n+\n+import (\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// This one was ripped from https://github.com/jpillora/backoff/blob/master/backoff.go\n+\n+// Backoff is a time.Duration counter. It starts at Min.  After every\n+// call to Duration() it is multiplied by Factor.  It is capped at\n+// Max. It returns to Min on every call to Reset().  Used in\n+// conjunction with the time package.\n+type Backoff struct {\n+\tattempts int\n+\t// Initial value to scale out\n+\tInitial time.Duration\n+\t// Jitter value randomizes an additional delay between 0 and Jitter\n+\tJitter time.Duration\n+\t// Max maximum values of the backoff\n+\tMax time.Duration\n+}\n+\n+// Returns the current value of the counter and then multiplies it\n+// Factor\n+func (b *Backoff) Duration() (dur time.Duration) {\n+\t// Zero-values are nonsensical, so we use\n+\t// them to apply defaults\n+\tif b.Max == 0 {\n+\t\tb.Max = 10 * time.Second\n+\t}\n+\n+\tif b.Initial == 0 {\n+\t\tb.Initial = 100 * time.Millisecond\n+\t}\n+\n+\t// calculate this duration\n+\tif dur = time.Duration(1 << uint(b.attempts)); dur > 0 {\n+\t\tdur = dur * b.Initial\n+\t} else {\n+\t\tdur = b.Max\n+\t}\n+\n+\tif b.Jitter > 0 {\n+\t\tdur = dur + time.Duration(rand.Intn(int(b.Jitter)))\n+\t}\n+\n+\t// bump attempts count\n+\tb.attempts++\n+\n+\treturn dur\n+}\n+\n+//Resets the current value of the counter back to Min\n+func (b *Backoff) Reset() {\n+\tb.attempts = 0\n+}\n+\n+// Attempts returns the number of attempts that we had done so far\n+func (b *Backoff) Attempts() int {\n+\treturn b.attempts\n+}"
    },
    {
      "sha": "0182ec68cd9271358235b3a9091067cc7b4afed8",
      "filename": "backend/vendor/github.com/slack-go/slack/internal/errorsx/errorsx.go",
      "status": "added",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/errorsx/errorsx.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/errorsx/errorsx.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/internal/errorsx/errorsx.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,17 @@\n+package errorsx\n+\n+// String representing an error, useful for declaring string constants as errors.\n+type String string\n+\n+func (t String) Error() string {\n+\treturn string(t)\n+}\n+\n+// Is reports whether String matches with the target error\n+func (t String) Is(target error) bool {\n+\tif target == nil {\n+\t\treturn false\n+\t}\n+\n+\treturn t.Error() == target.Error()\n+}"
    },
    {
      "sha": "eab8cdd8c0276e9fc334da8ee279eb302fc5843e",
      "filename": "backend/vendor/github.com/slack-go/slack/internal/misc/misc.go",
      "status": "added",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/misc/misc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/misc/misc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/internal/misc/misc.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,28 @@\n+package misc\n+\n+import (\n+\t\"fmt\"\n+\t\"net/http\"\n+)\n+\n+// StatusCodeError represents an http response error.\n+// type httpStatusCode interface { HTTPStatusCode() int } to handle it.\n+type StatusCodeError struct {\n+\tCode   int\n+\tStatus string\n+}\n+\n+func (t StatusCodeError) Error() string {\n+\treturn fmt.Sprintf(\"slack server error: %s\", t.Status)\n+}\n+\n+func (t StatusCodeError) HTTPStatusCode() int {\n+\treturn t.Code\n+}\n+\n+func (t StatusCodeError) Retryable() bool {\n+\tif t.Code >= 500 || t.Code == http.StatusTooManyRequests {\n+\t\treturn true\n+\t}\n+\treturn false\n+}"
    },
    {
      "sha": "40063f738b3891836a3a5fe4d6bd18cf3d379b7e",
      "filename": "backend/vendor/github.com/slack-go/slack/internal/timex/timex.go",
      "status": "added",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/timex/timex.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/internal/timex/timex.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/internal/timex/timex.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,18 @@\n+package timex\n+\n+import \"time\"\n+\n+// Max returns the maximum duration\n+func Max(values ...time.Duration) time.Duration {\n+\tvar (\n+\t\tmax time.Duration\n+\t)\n+\n+\tfor _, v := range values {\n+\t\tif v > max {\n+\t\t\tmax = v\n+\t\t}\n+\t}\n+\n+\treturn max\n+}"
    },
    {
      "sha": "89af4eb15befa2de96e501294dbf33c84e2d720b",
      "filename": "backend/vendor/github.com/slack-go/slack/item.go",
      "status": "added",
      "additions": 75,
      "deletions": 0,
      "changes": 75,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/item.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/item.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/item.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,75 @@\n+package slack\n+\n+const (\n+\tTYPE_MESSAGE      = \"message\"\n+\tTYPE_FILE         = \"file\"\n+\tTYPE_FILE_COMMENT = \"file_comment\"\n+\tTYPE_CHANNEL      = \"channel\"\n+\tTYPE_IM           = \"im\"\n+\tTYPE_GROUP        = \"group\"\n+)\n+\n+// Item is any type of slack message - message, file, or file comment.\n+type Item struct {\n+\tType      string   `json:\"type\"`\n+\tChannel   string   `json:\"channel,omitempty\"`\n+\tMessage   *Message `json:\"message,omitempty\"`\n+\tFile      *File    `json:\"file,omitempty\"`\n+\tComment   *Comment `json:\"comment,omitempty\"`\n+\tTimestamp string   `json:\"ts,omitempty\"`\n+}\n+\n+// NewMessageItem turns a message on a channel into a typed message struct.\n+func NewMessageItem(ch string, m *Message) Item {\n+\treturn Item{Type: TYPE_MESSAGE, Channel: ch, Message: m}\n+}\n+\n+// NewFileItem turns a file into a typed file struct.\n+func NewFileItem(f *File) Item {\n+\treturn Item{Type: TYPE_FILE, File: f}\n+}\n+\n+// NewFileCommentItem turns a file and comment into a typed file_comment struct.\n+func NewFileCommentItem(f *File, c *Comment) Item {\n+\treturn Item{Type: TYPE_FILE_COMMENT, File: f, Comment: c}\n+}\n+\n+// NewChannelItem turns a channel id into a typed channel struct.\n+func NewChannelItem(ch string) Item {\n+\treturn Item{Type: TYPE_CHANNEL, Channel: ch}\n+}\n+\n+// NewIMItem turns a channel id into a typed im struct.\n+func NewIMItem(ch string) Item {\n+\treturn Item{Type: TYPE_IM, Channel: ch}\n+}\n+\n+// NewGroupItem turns a channel id into a typed group struct.\n+func NewGroupItem(ch string) Item {\n+\treturn Item{Type: TYPE_GROUP, Channel: ch}\n+}\n+\n+// ItemRef is a reference to a message of any type. One of FileID,\n+// CommentId, or the combination of ChannelId and Timestamp must be\n+// specified.\n+type ItemRef struct {\n+\tChannel   string `json:\"channel\"`\n+\tTimestamp string `json:\"timestamp\"`\n+\tFile      string `json:\"file\"`\n+\tComment   string `json:\"file_comment\"`\n+}\n+\n+// NewRefToMessage initializes a reference to to a message.\n+func NewRefToMessage(channel, timestamp string) ItemRef {\n+\treturn ItemRef{Channel: channel, Timestamp: timestamp}\n+}\n+\n+// NewRefToFile initializes a reference to a file.\n+func NewRefToFile(file string) ItemRef {\n+\treturn ItemRef{File: file}\n+}\n+\n+// NewRefToComment initializes a reference to a file comment.\n+func NewRefToComment(comment string) ItemRef {\n+\treturn ItemRef{Comment: comment}\n+}"
    },
    {
      "sha": "90cb3caab3dd2595f9d8c2c2aff1ff6359fdf7f6",
      "filename": "backend/vendor/github.com/slack-go/slack/logger.go",
      "status": "added",
      "additions": 60,
      "deletions": 0,
      "changes": 60,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/logger.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/logger.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/logger.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,60 @@\n+package slack\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+// logger is a logger interface compatible with both stdlib and some\n+// 3rd party loggers.\n+type logger interface {\n+\tOutput(int, string) error\n+}\n+\n+// ilogger represents the internal logging api we use.\n+type ilogger interface {\n+\tlogger\n+\tPrint(...interface{})\n+\tPrintf(string, ...interface{})\n+\tPrintln(...interface{})\n+}\n+\n+type Debug interface {\n+\tDebug() bool\n+\n+\t// Debugf print a formatted debug line.\n+\tDebugf(format string, v ...interface{})\n+\t// Debugln print a debug line.\n+\tDebugln(v ...interface{})\n+}\n+\n+// internalLog implements the additional methods used by our internal logging.\n+type internalLog struct {\n+\tlogger\n+}\n+\n+// Println replicates the behaviour of the standard logger.\n+func (t internalLog) Println(v ...interface{}) {\n+\tt.Output(2, fmt.Sprintln(v...))\n+}\n+\n+// Printf replicates the behaviour of the standard logger.\n+func (t internalLog) Printf(format string, v ...interface{}) {\n+\tt.Output(2, fmt.Sprintf(format, v...))\n+}\n+\n+// Print replicates the behaviour of the standard logger.\n+func (t internalLog) Print(v ...interface{}) {\n+\tt.Output(2, fmt.Sprint(v...))\n+}\n+\n+type discard struct{}\n+\n+func (t discard) Debug() bool {\n+\treturn false\n+}\n+\n+// Debugf print a formatted debug line.\n+func (t discard) Debugf(format string, v ...interface{}) {}\n+\n+// Debugln print a debug line.\n+func (t discard) Debugln(v ...interface{}) {}"
    },
    {
      "sha": "9bd143459bfe55bb6e01e721623c51a367be7190",
      "filename": "backend/vendor/github.com/slack-go/slack/logo.png",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/logo.png",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/logo.png",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/logo.png?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79"
    },
    {
      "sha": "a17472b4fc58a06a9519388c374d21ef200be500",
      "filename": "backend/vendor/github.com/slack-go/slack/messageID.go",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/messageID.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/messageID.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/messageID.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,30 @@\n+package slack\n+\n+import \"sync\"\n+\n+// IDGenerator provides an interface for generating integer ID values.\n+type IDGenerator interface {\n+\tNext() int\n+}\n+\n+// NewSafeID returns a new instance of an IDGenerator which is safe for\n+// concurrent use by multiple goroutines.\n+func NewSafeID(startID int) IDGenerator {\n+\treturn &safeID{\n+\t\tnextID: startID,\n+\t\tmutex:  &sync.Mutex{},\n+\t}\n+}\n+\n+type safeID struct {\n+\tnextID int\n+\tmutex  *sync.Mutex\n+}\n+\n+func (s *safeID) Next() int {\n+\ts.mutex.Lock()\n+\tdefer s.mutex.Unlock()\n+\tid := s.nextID\n+\ts.nextID++\n+\treturn id\n+}"
    },
    {
      "sha": "999df5d949fa7685479aacec28e7df5b11b6094c",
      "filename": "backend/vendor/github.com/slack-go/slack/messages.go",
      "status": "added",
      "additions": 220,
      "deletions": 0,
      "changes": 220,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/messages.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/messages.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/messages.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,220 @@\n+package slack\n+\n+// OutgoingMessage is used for the realtime API, and seems incomplete.\n+type OutgoingMessage struct {\n+\tID int `json:\"id\"`\n+\t// channel ID\n+\tChannel         string   `json:\"channel,omitempty\"`\n+\tText            string   `json:\"text,omitempty\"`\n+\tType            string   `json:\"type,omitempty\"`\n+\tThreadTimestamp string   `json:\"thread_ts,omitempty\"`\n+\tThreadBroadcast bool     `json:\"reply_broadcast,omitempty\"`\n+\tIDs             []string `json:\"ids,omitempty\"`\n+}\n+\n+// Message is an auxiliary type to allow us to have a message containing sub messages\n+type Message struct {\n+\tMsg\n+\tSubMessage      *Msg `json:\"message,omitempty\"`\n+\tPreviousMessage *Msg `json:\"previous_message,omitempty\"`\n+}\n+\n+// Msg contains information about a slack message\n+type Msg struct {\n+\t// Basic Message\n+\tClientMsgID     string       `json:\"client_msg_id,omitempty\"`\n+\tType            string       `json:\"type,omitempty\"`\n+\tChannel         string       `json:\"channel,omitempty\"`\n+\tUser            string       `json:\"user,omitempty\"`\n+\tText            string       `json:\"text,omitempty\"`\n+\tTimestamp       string       `json:\"ts,omitempty\"`\n+\tThreadTimestamp string       `json:\"thread_ts,omitempty\"`\n+\tIsStarred       bool         `json:\"is_starred,omitempty\"`\n+\tPinnedTo        []string     `json:\"pinned_to,omitempty\"`\n+\tAttachments     []Attachment `json:\"attachments,omitempty\"`\n+\tEdited          *Edited      `json:\"edited,omitempty\"`\n+\tLastRead        string       `json:\"last_read,omitempty\"`\n+\tSubscribed      bool         `json:\"subscribed,omitempty\"`\n+\tUnreadCount     int          `json:\"unread_count,omitempty\"`\n+\n+\t// Message Subtypes\n+\tSubType string `json:\"subtype,omitempty\"`\n+\n+\t// Hidden Subtypes\n+\tHidden           bool   `json:\"hidden,omitempty\"`     // message_changed, message_deleted, unpinned_item\n+\tDeletedTimestamp string `json:\"deleted_ts,omitempty\"` // message_deleted\n+\tEventTimestamp   string `json:\"event_ts,omitempty\"`\n+\n+\t// bot_message (https://api.slack.com/events/message/bot_message)\n+\tBotID      string      `json:\"bot_id,omitempty\"`\n+\tUsername   string      `json:\"username,omitempty\"`\n+\tIcons      *Icon       `json:\"icons,omitempty\"`\n+\tBotProfile *BotProfile `json:\"bot_profile,omitempty\"`\n+\n+\t// channel_join, group_join\n+\tInviter string `json:\"inviter,omitempty\"`\n+\n+\t// channel_topic, group_topic\n+\tTopic string `json:\"topic,omitempty\"`\n+\n+\t// channel_purpose, group_purpose\n+\tPurpose string `json:\"purpose,omitempty\"`\n+\n+\t// channel_name, group_name\n+\tName    string `json:\"name,omitempty\"`\n+\tOldName string `json:\"old_name,omitempty\"`\n+\n+\t// channel_archive, group_archive\n+\tMembers []string `json:\"members,omitempty\"`\n+\n+\t// channels.replies, groups.replies, im.replies, mpim.replies\n+\tReplyCount   int     `json:\"reply_count,omitempty\"`\n+\tReplies      []Reply `json:\"replies,omitempty\"`\n+\tParentUserId string  `json:\"parent_user_id,omitempty\"`\n+\n+\t// file_share, file_comment, file_mention\n+\tFiles []File `json:\"files,omitempty\"`\n+\n+\t// file_share\n+\tUpload bool `json:\"upload,omitempty\"`\n+\n+\t// file_comment\n+\tComment *Comment `json:\"comment,omitempty\"`\n+\n+\t// pinned_item\n+\tItemType string `json:\"item_type,omitempty\"`\n+\n+\t// https://api.slack.com/rtm\n+\tReplyTo int    `json:\"reply_to,omitempty\"`\n+\tTeam    string `json:\"team,omitempty\"`\n+\n+\t// reactions\n+\tReactions []ItemReaction `json:\"reactions,omitempty\"`\n+\n+\t// slash commands and interactive messages\n+\tResponseType    string `json:\"response_type,omitempty\"`\n+\tReplaceOriginal bool   `json:\"replace_original\"`\n+\tDeleteOriginal  bool   `json:\"delete_original\"`\n+\n+\t// Block type Message\n+\tBlocks Blocks `json:\"blocks,omitempty\"`\n+}\n+\n+const (\n+\t// ResponseTypeInChannel in channel response for slash commands.\n+\tResponseTypeInChannel = \"in_channel\"\n+\t// ResponseTypeEphemeral ephemeral response for slash commands.\n+\tResponseTypeEphemeral = \"ephemeral\"\n+)\n+\n+// ScheduledMessage contains information about a slack scheduled message\n+type ScheduledMessage struct {\n+\tID          string `json:\"id\"`\n+\tChannel     string `json:\"channel_id\"`\n+\tPostAt      int    `json:\"post_at\"`\n+\tDateCreated int    `json:\"date_created\"`\n+\tText        string `json:\"text\"`\n+}\n+\n+// Icon is used for bot messages\n+type Icon struct {\n+\tIconURL   string `json:\"icon_url,omitempty\"`\n+\tIconEmoji string `json:\"icon_emoji,omitempty\"`\n+}\n+\n+// BotProfile contains information about a bot\n+type BotProfile struct {\n+\tAppID   string `json:\"app_id,omitempty\"`\n+\tDeleted bool   `json:\"deleted,omitempty\"`\n+\tIcons   *Icons `json:\"icons,omitempty\"`\n+\tID      string `json:\"id,omitempty\"`\n+\tName    string `json:\"name,omitempty\"`\n+\tTeamID  string `json:\"team_id,omitempty\"`\n+\tUpdated int64  `json:\"updated,omitempty\"`\n+}\n+\n+// Edited indicates that a message has been edited.\n+type Edited struct {\n+\tUser      string `json:\"user,omitempty\"`\n+\tTimestamp string `json:\"ts,omitempty\"`\n+}\n+\n+// Reply contains information about a reply for a thread\n+type Reply struct {\n+\tUser      string `json:\"user,omitempty\"`\n+\tTimestamp string `json:\"ts,omitempty\"`\n+}\n+\n+// Event contains the event type\n+type Event struct {\n+\tType string `json:\"type,omitempty\"`\n+}\n+\n+// Ping contains information about a Ping Event\n+type Ping struct {\n+\tID        int    `json:\"id\"`\n+\tType      string `json:\"type\"`\n+\tTimestamp int64  `json:\"timestamp\"`\n+}\n+\n+// Pong contains information about a Pong Event\n+type Pong struct {\n+\tType      string `json:\"type\"`\n+\tReplyTo   int    `json:\"reply_to\"`\n+\tTimestamp int64  `json:\"timestamp\"`\n+}\n+\n+// NewOutgoingMessage prepares an OutgoingMessage that the user can\n+// use to send a message. Use this function to properly set the\n+// messageID.\n+func (rtm *RTM) NewOutgoingMessage(text string, channelID string, options ...RTMsgOption) *OutgoingMessage {\n+\tid := rtm.idGen.Next()\n+\tmsg := OutgoingMessage{\n+\t\tID:      id,\n+\t\tType:    \"message\",\n+\t\tChannel: channelID,\n+\t\tText:    text,\n+\t}\n+\tfor _, option := range options {\n+\t\toption(&msg)\n+\t}\n+\treturn &msg\n+}\n+\n+// NewSubscribeUserPresence prepares an OutgoingMessage that the user can\n+// use to subscribe presence events for the specified users.\n+func (rtm *RTM) NewSubscribeUserPresence(ids []string) *OutgoingMessage {\n+\treturn &OutgoingMessage{\n+\t\tType: \"presence_sub\",\n+\t\tIDs:  ids,\n+\t}\n+}\n+\n+// NewTypingMessage prepares an OutgoingMessage that the user can\n+// use to send as a typing indicator. Use this function to properly set the\n+// messageID.\n+func (rtm *RTM) NewTypingMessage(channelID string) *OutgoingMessage {\n+\tid := rtm.idGen.Next()\n+\treturn &OutgoingMessage{\n+\t\tID:      id,\n+\t\tType:    \"typing\",\n+\t\tChannel: channelID,\n+\t}\n+}\n+\n+// RTMsgOption allows configuration of various options available for sending an RTM message\n+type RTMsgOption func(*OutgoingMessage)\n+\n+// RTMsgOptionTS sets thead timestamp of an outgoing message in order to respond to a thread\n+func RTMsgOptionTS(threadTimestamp string) RTMsgOption {\n+\treturn func(msg *OutgoingMessage) {\n+\t\tmsg.ThreadTimestamp = threadTimestamp\n+\t}\n+}\n+\n+// RTMsgOptionBroadcast sets broadcast reply to channel to \"true\"\n+func RTMsgOptionBroadcast() RTMsgOption {\n+\treturn func(msg *OutgoingMessage) {\n+\t\tmsg.ThreadBroadcast = true\n+\t}\n+}"
    },
    {
      "sha": "821bda869c15db7e19e0116effbe565eade5ddad",
      "filename": "backend/vendor/github.com/slack-go/slack/misc.go",
      "status": "added",
      "additions": 341,
      "deletions": 0,
      "changes": 341,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/misc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/misc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/misc.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,341 @@\n+package slack\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"mime\"\n+\t\"mime/multipart\"\n+\t\"net/http\"\n+\t\"net/http/httputil\"\n+\t\"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"github.com/slack-go/slack/internal/misc\"\n+)\n+\n+// SlackResponse handles parsing out errors from the web api.\n+type SlackResponse struct {\n+\tOk               bool             `json:\"ok\"`\n+\tError            string           `json:\"error\"`\n+\tResponseMetadata ResponseMetadata `json:\"response_metadata\"`\n+}\n+\n+func (t SlackResponse) Err() error {\n+\tif t.Ok {\n+\t\treturn nil\n+\t}\n+\n+\t// handle pure text based responses like chat.post\n+\t// which while they have a slack response in their data structure\n+\t// it doesn't actually get set during parsing.\n+\tif strings.TrimSpace(t.Error) == \"\" {\n+\t\treturn nil\n+\t}\n+\n+\treturn errors.New(t.Error)\n+}\n+\n+// RateLimitedError represents the rate limit respond from slack\n+type RateLimitedError struct {\n+\tRetryAfter time.Duration\n+}\n+\n+func (e *RateLimitedError) Error() string {\n+\treturn fmt.Sprintf(\"slack rate limit exceeded, retry after %s\", e.RetryAfter)\n+}\n+\n+func (e *RateLimitedError) Retryable() bool {\n+\treturn true\n+}\n+\n+func fileUploadReq(ctx context.Context, path string, values url.Values, r io.Reader) (*http.Request, error) {\n+\treq, err := http.NewRequest(\"POST\", path, r)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treq = req.WithContext(ctx)\n+\treq.URL.RawQuery = (values).Encode()\n+\treturn req, nil\n+}\n+\n+func downloadFile(client httpClient, token string, downloadURL string, writer io.Writer, d Debug) error {\n+\tif downloadURL == \"\" {\n+\t\treturn fmt.Errorf(\"received empty download URL\")\n+\t}\n+\n+\treq, err := http.NewRequest(\"GET\", downloadURL, &bytes.Buffer{})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar bearer = \"Bearer \" + token\n+\treq.Header.Add(\"Authorization\", bearer)\n+\treq.WithContext(context.Background())\n+\n+\tresp, err := client.Do(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tdefer resp.Body.Close()\n+\n+\terr = checkStatusCode(resp, d)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t_, err = io.Copy(writer, resp.Body)\n+\n+\treturn err\n+}\n+\n+func formReq(endpoint string, values url.Values) (req *http.Request, err error) {\n+\tif req, err = http.NewRequest(\"POST\", endpoint, strings.NewReader(values.Encode())); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n+\treturn req, nil\n+}\n+\n+func jsonReq(endpoint string, body interface{}) (req *http.Request, err error) {\n+\tbuffer := bytes.NewBuffer([]byte{})\n+\tif err = json.NewEncoder(buffer).Encode(body); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req, err = http.NewRequest(\"POST\", endpoint, buffer); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n+\treturn req, nil\n+}\n+\n+func parseResponseBody(body io.ReadCloser, intf interface{}, d Debug) error {\n+\tresponse, err := ioutil.ReadAll(body)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif d.Debug() {\n+\t\td.Debugln(\"parseResponseBody\", string(response))\n+\t}\n+\n+\treturn json.Unmarshal(response, intf)\n+}\n+\n+func postLocalWithMultipartResponse(ctx context.Context, client httpClient, method, fpath, fieldname string, values url.Values, intf interface{}, d Debug) error {\n+\tfullpath, err := filepath.Abs(fpath)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfile, err := os.Open(fullpath)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer file.Close()\n+\n+\treturn postWithMultipartResponse(ctx, client, method, filepath.Base(fpath), fieldname, values, file, intf, d)\n+}\n+\n+func postWithMultipartResponse(ctx context.Context, client httpClient, path, name, fieldname string, values url.Values, r io.Reader, intf interface{}, d Debug) error {\n+\tpipeReader, pipeWriter := io.Pipe()\n+\twr := multipart.NewWriter(pipeWriter)\n+\terrc := make(chan error)\n+\tgo func() {\n+\t\tdefer pipeWriter.Close()\n+\t\tioWriter, err := wr.CreateFormFile(fieldname, name)\n+\t\tif err != nil {\n+\t\t\terrc <- err\n+\t\t\treturn\n+\t\t}\n+\t\t_, err = io.Copy(ioWriter, r)\n+\t\tif err != nil {\n+\t\t\terrc <- err\n+\t\t\treturn\n+\t\t}\n+\t\tif err = wr.Close(); err != nil {\n+\t\t\terrc <- err\n+\t\t\treturn\n+\t\t}\n+\t}()\n+\treq, err := fileUploadReq(ctx, path, values, pipeReader)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treq.Header.Add(\"Content-Type\", wr.FormDataContentType())\n+\treq = req.WithContext(ctx)\n+\tresp, err := client.Do(req)\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\terr = checkStatusCode(resp, d)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tselect {\n+\tcase err = <-errc:\n+\t\treturn err\n+\tdefault:\n+\t\treturn newJSONParser(intf)(resp)\n+\t}\n+}\n+\n+func doPost(ctx context.Context, client httpClient, req *http.Request, parser responseParser, d Debug) error {\n+\treq = req.WithContext(ctx)\n+\tresp, err := client.Do(req)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\terr = checkStatusCode(resp, d)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn parser(resp)\n+}\n+\n+// post JSON.\n+func postJSON(ctx context.Context, client httpClient, endpoint, token string, json []byte, intf interface{}, d Debug) error {\n+\treqBody := bytes.NewBuffer(json)\n+\treq, err := http.NewRequest(\"POST\", endpoint, reqBody)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treq.Header.Set(\"Content-Type\", \"application/json\")\n+\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", token))\n+\n+\treturn doPost(ctx, client, req, newJSONParser(intf), d)\n+}\n+\n+// post a url encoded form.\n+func postForm(ctx context.Context, client httpClient, endpoint string, values url.Values, intf interface{}, d Debug) error {\n+\treqBody := strings.NewReader(values.Encode())\n+\treq, err := http.NewRequest(\"POST\", endpoint, reqBody)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n+\treturn doPost(ctx, client, req, newJSONParser(intf), d)\n+}\n+\n+func getResource(ctx context.Context, client httpClient, endpoint string, values url.Values, intf interface{}, d Debug) error {\n+\treq, err := http.NewRequest(\"GET\", endpoint, nil)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n+\treq.URL.RawQuery = values.Encode()\n+\n+\treturn doPost(ctx, client, req, newJSONParser(intf), d)\n+}\n+\n+func parseAdminResponse(ctx context.Context, client httpClient, method string, teamName string, values url.Values, intf interface{}, d Debug) error {\n+\tendpoint := fmt.Sprintf(WEBAPIURLFormat, teamName, method, time.Now().Unix())\n+\treturn postForm(ctx, client, endpoint, values, intf, d)\n+}\n+\n+func logResponse(resp *http.Response, d Debug) error {\n+\tif d.Debug() {\n+\t\ttext, err := httputil.DumpResponse(resp, true)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\td.Debugln(string(text))\n+\t}\n+\n+\treturn nil\n+}\n+\n+func okJSONHandler(rw http.ResponseWriter, r *http.Request) {\n+\trw.Header().Set(\"Content-Type\", \"application/json\")\n+\tresponse, _ := json.Marshal(SlackResponse{\n+\t\tOk: true,\n+\t})\n+\trw.Write(response)\n+}\n+\n+// timerReset safely reset a timer, see time.Timer.Reset for details.\n+func timerReset(t *time.Timer, d time.Duration) {\n+\tif !t.Stop() {\n+\t\t<-t.C\n+\t}\n+\tt.Reset(d)\n+}\n+\n+func checkStatusCode(resp *http.Response, d Debug) error {\n+\tif resp.StatusCode == http.StatusTooManyRequests {\n+\t\tretry, err := strconv.ParseInt(resp.Header.Get(\"Retry-After\"), 10, 64)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\treturn &RateLimitedError{time.Duration(retry) * time.Second}\n+\t}\n+\n+\t// Slack seems to send an HTML body along with 5xx error codes. Don't parse it.\n+\tif resp.StatusCode != http.StatusOK {\n+\t\tlogResponse(resp, d)\n+\t\treturn misc.StatusCodeError{Code: resp.StatusCode, Status: resp.Status}\n+\t}\n+\n+\treturn nil\n+}\n+\n+type responseParser func(*http.Response) error\n+\n+func newJSONParser(dst interface{}) responseParser {\n+\treturn func(resp *http.Response) error {\n+\t\treturn json.NewDecoder(resp.Body).Decode(dst)\n+\t}\n+}\n+\n+func newTextParser(dst interface{}) responseParser {\n+\treturn func(resp *http.Response) error {\n+\t\tb, err := ioutil.ReadAll(resp.Body)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif !bytes.Equal(b, []byte(\"ok\")) {\n+\t\t\treturn errors.New(string(b))\n+\t\t}\n+\n+\t\treturn nil\n+\t}\n+}\n+\n+func newContentTypeParser(dst interface{}) responseParser {\n+\treturn func(req *http.Response) (err error) {\n+\t\tvar (\n+\t\t\tctype string\n+\t\t)\n+\n+\t\tif ctype, _, err = mime.ParseMediaType(req.Header.Get(\"Content-Type\")); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tswitch ctype {\n+\t\tcase \"application/json\":\n+\t\t\treturn newJSONParser(dst)(req)\n+\t\tdefault:\n+\t\t\treturn newTextParser(dst)(req)\n+\t\t}\n+\t}\n+}"
    },
    {
      "sha": "707ccc6b5863aa0da2b776bdf9f4e2387a3763cd",
      "filename": "backend/vendor/github.com/slack-go/slack/oauth.go",
      "status": "added",
      "additions": 134,
      "deletions": 0,
      "changes": 134,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/oauth.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/oauth.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/oauth.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,134 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+)\n+\n+// OAuthResponseIncomingWebhook ...\n+type OAuthResponseIncomingWebhook struct {\n+\tURL              string `json:\"url\"`\n+\tChannel          string `json:\"channel\"`\n+\tChannelID        string `json:\"channel_id,omitempty\"`\n+\tConfigurationURL string `json:\"configuration_url\"`\n+}\n+\n+// OAuthResponseBot ...\n+type OAuthResponseBot struct {\n+\tBotUserID      string `json:\"bot_user_id\"`\n+\tBotAccessToken string `json:\"bot_access_token\"`\n+}\n+\n+// OAuthResponse ...\n+type OAuthResponse struct {\n+\tAccessToken     string                       `json:\"access_token\"`\n+\tScope           string                       `json:\"scope\"`\n+\tTeamName        string                       `json:\"team_name\"`\n+\tTeamID          string                       `json:\"team_id\"`\n+\tIncomingWebhook OAuthResponseIncomingWebhook `json:\"incoming_webhook\"`\n+\tBot             OAuthResponseBot             `json:\"bot\"`\n+\tUserID          string                       `json:\"user_id,omitempty\"`\n+\tSlackResponse\n+}\n+\n+// OAuthV2Response ...\n+type OAuthV2Response struct {\n+\tAccessToken     string                       `json:\"access_token\"`\n+\tTokenType       string                       `json:\"token_type\"`\n+\tScope           string                       `json:\"scope\"`\n+\tBotUserID       string                       `json:\"bot_user_id\"`\n+\tAppID           string                       `json:\"app_id\"`\n+\tTeam            OAuthV2ResponseTeam          `json:\"team\"`\n+\tIncomingWebhook OAuthResponseIncomingWebhook `json:\"incoming_webhook\"`\n+\tEnterprise      OAuthV2ResponseEnterprise    `json:\"enterprise\"`\n+\tAuthedUser      OAuthV2ResponseAuthedUser    `json:\"authed_user\"`\n+\tSlackResponse\n+}\n+\n+// OAuthV2ResponseTeam ...\n+type OAuthV2ResponseTeam struct {\n+\tID   string `json:\"id\"`\n+\tName string `json:\"name\"`\n+}\n+\n+// OAuthV2ResponseEnterprise ...\n+type OAuthV2ResponseEnterprise struct {\n+\tID   string `json:\"id\"`\n+\tName string `json:\"name\"`\n+}\n+\n+// OAuthV2ResponseAuthedUser ...\n+type OAuthV2ResponseAuthedUser struct {\n+\tID          string `json:\"id\"`\n+\tScope       string `json:\"scope\"`\n+\tAccessToken string `json:\"access_token\"`\n+\tTokenType   string `json:\"token_type\"`\n+}\n+\n+// GetOAuthToken retrieves an AccessToken\n+func GetOAuthToken(client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, err error) {\n+\treturn GetOAuthTokenContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n+}\n+\n+// GetOAuthTokenContext retrieves an AccessToken with a custom context\n+func GetOAuthTokenContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, err error) {\n+\tresponse, err := GetOAuthResponseContext(ctx, client, clientID, clientSecret, code, redirectURI)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n+\treturn response.AccessToken, response.Scope, nil\n+}\n+\n+// GetBotOAuthToken retrieves top-level and bot AccessToken - https://api.slack.com/legacy/oauth#bot_user_access_tokens\n+func GetBotOAuthToken(client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, bot OAuthResponseBot, err error) {\n+\treturn GetBotOAuthTokenContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n+}\n+\n+// GetBotOAuthTokenContext retrieves top-level and bot AccessToken with a custom context\n+func GetBotOAuthTokenContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (accessToken string, scope string, bot OAuthResponseBot, err error) {\n+\tresponse, err := GetOAuthResponseContext(ctx, client, clientID, clientSecret, code, redirectURI)\n+\tif err != nil {\n+\t\treturn \"\", \"\", OAuthResponseBot{}, err\n+\t}\n+\treturn response.AccessToken, response.Scope, response.Bot, nil\n+}\n+\n+// GetOAuthResponse retrieves OAuth response\n+func GetOAuthResponse(client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthResponse, err error) {\n+\treturn GetOAuthResponseContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n+}\n+\n+// GetOAuthResponseContext retrieves OAuth response with custom context\n+func GetOAuthResponseContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthResponse, err error) {\n+\tvalues := url.Values{\n+\t\t\"client_id\":     {clientID},\n+\t\t\"client_secret\": {clientSecret},\n+\t\t\"code\":          {code},\n+\t\t\"redirect_uri\":  {redirectURI},\n+\t}\n+\tresponse := &OAuthResponse{}\n+\tif err = postForm(ctx, client, APIURL+\"oauth.access\", values, response, discard{}); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response, response.Err()\n+}\n+\n+// GetOAuthV2Response gets a V2 OAuth access token response - https://api.slack.com/methods/oauth.v2.access\n+func GetOAuthV2Response(client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthV2Response, err error) {\n+\treturn GetOAuthV2ResponseContext(context.Background(), client, clientID, clientSecret, code, redirectURI)\n+}\n+\n+// GetOAuthV2ResponseContext with a context, gets a V2 OAuth access token response\n+func GetOAuthV2ResponseContext(ctx context.Context, client httpClient, clientID, clientSecret, code, redirectURI string) (resp *OAuthV2Response, err error) {\n+\tvalues := url.Values{\n+\t\t\"client_id\":     {clientID},\n+\t\t\"client_secret\": {clientSecret},\n+\t\t\"code\":          {code},\n+\t\t\"redirect_uri\":  {redirectURI},\n+\t}\n+\tresponse := &OAuthV2Response{}\n+\tif err = postForm(ctx, client, APIURL+\"oauth.v2.access\", values, response, discard{}); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response, response.Err()\n+}"
    },
    {
      "sha": "87dd136a4b035d94046315355d2291448941858c",
      "filename": "backend/vendor/github.com/slack-go/slack/pagination.go",
      "status": "added",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/pagination.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/pagination.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/pagination.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,20 @@\n+package slack\n+\n+// Paging contains paging information\n+type Paging struct {\n+\tCount int `json:\"count\"`\n+\tTotal int `json:\"total\"`\n+\tPage  int `json:\"page\"`\n+\tPages int `json:\"pages\"`\n+}\n+\n+// Pagination contains pagination information\n+// This is different from Paging in that it contains additional details\n+type Pagination struct {\n+\tTotalCount int `json:\"total_count\"`\n+\tPage       int `json:\"page\"`\n+\tPerPage    int `json:\"per_page\"`\n+\tPageCount  int `json:\"page_count\"`\n+\tFirst      int `json:\"first\"`\n+\tLast       int `json:\"last\"`\n+}"
    },
    {
      "sha": "ef97c8dfbf216c2bb9e754725a1189093dc4dfc0",
      "filename": "backend/vendor/github.com/slack-go/slack/pins.go",
      "status": "added",
      "additions": 94,
      "deletions": 0,
      "changes": 94,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/pins.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/pins.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/pins.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,94 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"errors\"\n+\t\"net/url\"\n+)\n+\n+type listPinsResponseFull struct {\n+\tItems  []Item\n+\tPaging `json:\"paging\"`\n+\tSlackResponse\n+}\n+\n+// AddPin pins an item in a channel\n+func (api *Client) AddPin(channel string, item ItemRef) error {\n+\treturn api.AddPinContext(context.Background(), channel, item)\n+}\n+\n+// AddPinContext pins an item in a channel with a custom context\n+func (api *Client) AddPinContext(ctx context.Context, channel string, item ItemRef) error {\n+\tvalues := url.Values{\n+\t\t\"channel\": {channel},\n+\t\t\"token\":   {api.token},\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(ctx, \"pins.add\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// RemovePin un-pins an item from a channel\n+func (api *Client) RemovePin(channel string, item ItemRef) error {\n+\treturn api.RemovePinContext(context.Background(), channel, item)\n+}\n+\n+// RemovePinContext un-pins an item from a channel with a custom context\n+func (api *Client) RemovePinContext(ctx context.Context, channel string, item ItemRef) error {\n+\tvalues := url.Values{\n+\t\t\"channel\": {channel},\n+\t\t\"token\":   {api.token},\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(ctx, \"pins.remove\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// ListPins returns information about the items a user reacted to.\n+func (api *Client) ListPins(channel string) ([]Item, *Paging, error) {\n+\treturn api.ListPinsContext(context.Background(), channel)\n+}\n+\n+// ListPinsContext returns information about the items a user reacted to with a custom context.\n+func (api *Client) ListPinsContext(ctx context.Context, channel string) ([]Item, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"channel\": {channel},\n+\t\t\"token\":   {api.token},\n+\t}\n+\n+\tresponse := &listPinsResponseFull{}\n+\terr := api.postMethod(ctx, \"pins.list\", values, response)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tif !response.Ok {\n+\t\treturn nil, nil, errors.New(response.Error)\n+\t}\n+\treturn response.Items, &response.Paging, nil\n+}"
    },
    {
      "sha": "2a9bd42e71ca38b7df11df89f6782c0aead617bf",
      "filename": "backend/vendor/github.com/slack-go/slack/reactions.go",
      "status": "added",
      "additions": 270,
      "deletions": 0,
      "changes": 270,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/reactions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/reactions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/reactions.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,270 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+)\n+\n+// ItemReaction is the reactions that have happened on an item.\n+type ItemReaction struct {\n+\tName  string   `json:\"name\"`\n+\tCount int      `json:\"count\"`\n+\tUsers []string `json:\"users\"`\n+}\n+\n+// ReactedItem is an item that was reacted to, and the details of the\n+// reactions.\n+type ReactedItem struct {\n+\tItem\n+\tReactions []ItemReaction\n+}\n+\n+// GetReactionsParameters is the inputs to get reactions to an item.\n+type GetReactionsParameters struct {\n+\tFull bool\n+}\n+\n+// NewGetReactionsParameters initializes the inputs to get reactions to an item.\n+func NewGetReactionsParameters() GetReactionsParameters {\n+\treturn GetReactionsParameters{\n+\t\tFull: false,\n+\t}\n+}\n+\n+type getReactionsResponseFull struct {\n+\tType string\n+\tM    struct {\n+\t\tReactions []ItemReaction\n+\t} `json:\"message\"`\n+\tF struct {\n+\t\tReactions []ItemReaction\n+\t} `json:\"file\"`\n+\tFC struct {\n+\t\tReactions []ItemReaction\n+\t} `json:\"comment\"`\n+\tSlackResponse\n+}\n+\n+func (res getReactionsResponseFull) extractReactions() []ItemReaction {\n+\tswitch res.Type {\n+\tcase \"message\":\n+\t\treturn res.M.Reactions\n+\tcase \"file\":\n+\t\treturn res.F.Reactions\n+\tcase \"file_comment\":\n+\t\treturn res.FC.Reactions\n+\t}\n+\treturn []ItemReaction{}\n+}\n+\n+const (\n+\tDEFAULT_REACTIONS_USER  = \"\"\n+\tDEFAULT_REACTIONS_COUNT = 100\n+\tDEFAULT_REACTIONS_PAGE  = 1\n+\tDEFAULT_REACTIONS_FULL  = false\n+)\n+\n+// ListReactionsParameters is the inputs to find all reactions by a user.\n+type ListReactionsParameters struct {\n+\tUser  string\n+\tCount int\n+\tPage  int\n+\tFull  bool\n+}\n+\n+// NewListReactionsParameters initializes the inputs to find all reactions\n+// performed by a user.\n+func NewListReactionsParameters() ListReactionsParameters {\n+\treturn ListReactionsParameters{\n+\t\tUser:  DEFAULT_REACTIONS_USER,\n+\t\tCount: DEFAULT_REACTIONS_COUNT,\n+\t\tPage:  DEFAULT_REACTIONS_PAGE,\n+\t\tFull:  DEFAULT_REACTIONS_FULL,\n+\t}\n+}\n+\n+type listReactionsResponseFull struct {\n+\tItems []struct {\n+\t\tType    string\n+\t\tChannel string\n+\t\tM       struct {\n+\t\t\t*Message\n+\t\t} `json:\"message\"`\n+\t\tF struct {\n+\t\t\t*File\n+\t\t\tReactions []ItemReaction\n+\t\t} `json:\"file\"`\n+\t\tFC struct {\n+\t\t\t*Comment\n+\t\t\tReactions []ItemReaction\n+\t\t} `json:\"comment\"`\n+\t}\n+\tPaging `json:\"paging\"`\n+\tSlackResponse\n+}\n+\n+func (res listReactionsResponseFull) extractReactedItems() []ReactedItem {\n+\titems := make([]ReactedItem, len(res.Items))\n+\tfor i, input := range res.Items {\n+\t\titem := ReactedItem{}\n+\t\titem.Type = input.Type\n+\t\tswitch input.Type {\n+\t\tcase \"message\":\n+\t\t\titem.Channel = input.Channel\n+\t\t\titem.Message = input.M.Message\n+\t\t\titem.Reactions = input.M.Reactions\n+\t\tcase \"file\":\n+\t\t\titem.File = input.F.File\n+\t\t\titem.Reactions = input.F.Reactions\n+\t\tcase \"file_comment\":\n+\t\t\titem.File = input.F.File\n+\t\t\titem.Comment = input.FC.Comment\n+\t\t\titem.Reactions = input.FC.Reactions\n+\t\t}\n+\t\titems[i] = item\n+\t}\n+\treturn items\n+}\n+\n+// AddReaction adds a reaction emoji to a message, file or file comment.\n+func (api *Client) AddReaction(name string, item ItemRef) error {\n+\treturn api.AddReactionContext(context.Background(), name, item)\n+}\n+\n+// AddReactionContext adds a reaction emoji to a message, file or file comment with a custom context.\n+func (api *Client) AddReactionContext(ctx context.Context, name string, item ItemRef) error {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif name != \"\" {\n+\t\tvalues.Set(\"name\", name)\n+\t}\n+\tif item.Channel != \"\" {\n+\t\tvalues.Set(\"channel\", item.Channel)\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(ctx, \"reactions.add\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// RemoveReaction removes a reaction emoji from a message, file or file comment.\n+func (api *Client) RemoveReaction(name string, item ItemRef) error {\n+\treturn api.RemoveReactionContext(context.Background(), name, item)\n+}\n+\n+// RemoveReactionContext removes a reaction emoji from a message, file or file comment with a custom context.\n+func (api *Client) RemoveReactionContext(ctx context.Context, name string, item ItemRef) error {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif name != \"\" {\n+\t\tvalues.Set(\"name\", name)\n+\t}\n+\tif item.Channel != \"\" {\n+\t\tvalues.Set(\"channel\", item.Channel)\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(ctx, \"reactions.remove\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// GetReactions returns details about the reactions on an item.\n+func (api *Client) GetReactions(item ItemRef, params GetReactionsParameters) ([]ItemReaction, error) {\n+\treturn api.GetReactionsContext(context.Background(), item, params)\n+}\n+\n+// GetReactionsContext returns details about the reactions on an item with a custom context\n+func (api *Client) GetReactionsContext(ctx context.Context, item ItemRef, params GetReactionsParameters) ([]ItemReaction, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif item.Channel != \"\" {\n+\t\tvalues.Set(\"channel\", item.Channel)\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\tif params.Full != DEFAULT_REACTIONS_FULL {\n+\t\tvalues.Set(\"full\", strconv.FormatBool(params.Full))\n+\t}\n+\n+\tresponse := &getReactionsResponseFull{}\n+\tif err := api.postMethod(ctx, \"reactions.get\", values, response); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := response.Err(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response.extractReactions(), nil\n+}\n+\n+// ListReactions returns information about the items a user reacted to.\n+func (api *Client) ListReactions(params ListReactionsParameters) ([]ReactedItem, *Paging, error) {\n+\treturn api.ListReactionsContext(context.Background(), params)\n+}\n+\n+// ListReactionsContext returns information about the items a user reacted to with a custom context.\n+func (api *Client) ListReactionsContext(ctx context.Context, params ListReactionsParameters) ([]ReactedItem, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.User != DEFAULT_REACTIONS_USER {\n+\t\tvalues.Add(\"user\", params.User)\n+\t}\n+\tif params.Count != DEFAULT_REACTIONS_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Page != DEFAULT_REACTIONS_PAGE {\n+\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n+\t}\n+\tif params.Full != DEFAULT_REACTIONS_FULL {\n+\t\tvalues.Add(\"full\", strconv.FormatBool(params.Full))\n+\t}\n+\n+\tresponse := &listReactionsResponseFull{}\n+\terr := api.postMethod(ctx, \"reactions.list\", values, response)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tif err := response.Err(); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\treturn response.extractReactedItems(), &response.Paging, nil\n+}"
    },
    {
      "sha": "ae1da86693535fbbb7e9de6f0b462812c3e56f8a",
      "filename": "backend/vendor/github.com/slack-go/slack/reminders.go",
      "status": "added",
      "additions": 104,
      "deletions": 0,
      "changes": 104,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/reminders.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/reminders.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/reminders.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,104 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+)\n+\n+type Reminder struct {\n+\tID         string `json:\"id\"`\n+\tCreator    string `json:\"creator\"`\n+\tUser       string `json:\"user\"`\n+\tText       string `json:\"text\"`\n+\tRecurring  bool   `json:\"recurring\"`\n+\tTime       int    `json:\"time\"`\n+\tCompleteTS int    `json:\"complete_ts\"`\n+}\n+\n+type reminderResp struct {\n+\tSlackResponse\n+\tReminder Reminder `json:\"reminder\"`\n+}\n+\n+type remindersResp struct {\n+\tSlackResponse\n+\tReminders []*Reminder `json:\"reminders\"`\n+}\n+\n+func (api *Client) doReminder(ctx context.Context, path string, values url.Values) (*Reminder, error) {\n+\tresponse := &reminderResp{}\n+\tif err := api.postMethod(ctx, path, values, response); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Reminder, response.Err()\n+}\n+\n+func (api *Client) doReminders(ctx context.Context, path string, values url.Values) ([]*Reminder, error) {\n+\tresponse := &remindersResp{}\n+\tif err := api.postMethod(ctx, path, values, response); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// create an array of pointers to reminders\n+\tvar reminders = make([]*Reminder, 0, len(response.Reminders))\n+\tfor _, reminder := range response.Reminders {\n+\t\treminders = append(reminders, reminder)\n+\t}\n+\n+\treturn reminders, response.Err()\n+}\n+\n+// ListReminders lists all the reminders created by or for the authenticated user\n+//\n+// See https://api.slack.com/methods/reminders.list\n+func (api *Client) ListReminders() ([]*Reminder, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\treturn api.doReminders(context.Background(), \"reminders.list\", values)\n+}\n+\n+// AddChannelReminder adds a reminder for a channel.\n+//\n+// See https://api.slack.com/methods/reminders.add (NOTE: the ability to set\n+// reminders on a channel is currently undocumented but has been tested to\n+// work)\n+func (api *Client) AddChannelReminder(channelID, text, time string) (*Reminder, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"text\":    {text},\n+\t\t\"time\":    {time},\n+\t\t\"channel\": {channelID},\n+\t}\n+\treturn api.doReminder(context.Background(), \"reminders.add\", values)\n+}\n+\n+// AddUserReminder adds a reminder for a user.\n+//\n+// See https://api.slack.com/methods/reminders.add (NOTE: the ability to set\n+// reminders on a channel is currently undocumented but has been tested to\n+// work)\n+func (api *Client) AddUserReminder(userID, text, time string) (*Reminder, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"text\":  {text},\n+\t\t\"time\":  {time},\n+\t\t\"user\":  {userID},\n+\t}\n+\treturn api.doReminder(context.Background(), \"reminders.add\", values)\n+}\n+\n+// DeleteReminder deletes an existing reminder.\n+//\n+// See https://api.slack.com/methods/reminders.delete\n+func (api *Client) DeleteReminder(id string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":    {api.token},\n+\t\t\"reminder\": {id},\n+\t}\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(context.Background(), \"reminders.delete\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\treturn response.Err()\n+}"
    },
    {
      "sha": "ef6ba34349651431eedf2e8b3e843e0c1a0ffff1",
      "filename": "backend/vendor/github.com/slack-go/slack/rtm.go",
      "status": "added",
      "additions": 131,
      "deletions": 0,
      "changes": 131,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/rtm.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/rtm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/rtm.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,131 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+)\n+\n+const (\n+\twebsocketDefaultTimeout = 10 * time.Second\n+\tdefaultPingInterval     = 30 * time.Second\n+)\n+\n+const (\n+\trtmEventTypeAck                 = \"\"\n+\trtmEventTypeHello               = \"hello\"\n+\trtmEventTypeGoodbye             = \"goodbye\"\n+\trtmEventTypePong                = \"pong\"\n+\trtmEventTypeDesktopNotification = \"desktop_notification\"\n+)\n+\n+// StartRTM calls the \"rtm.start\" endpoint and returns the provided URL and the full Info block.\n+//\n+// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\n+func (api *Client) StartRTM() (info *Info, websocketURL string, err error) {\n+\tctx, cancel := context.WithTimeout(context.Background(), websocketDefaultTimeout)\n+\tdefer cancel()\n+\n+\treturn api.StartRTMContext(ctx)\n+}\n+\n+// StartRTMContext calls the \"rtm.start\" endpoint and returns the provided URL and the full Info block with a custom context.\n+//\n+// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\n+func (api *Client) StartRTMContext(ctx context.Context) (info *Info, websocketURL string, err error) {\n+\tresponse := &infoResponseFull{}\n+\terr = api.postMethod(ctx, \"rtm.start\", url.Values{\"token\": {api.token}}, response)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\tapi.Debugln(\"Using URL:\", response.Info.URL)\n+\treturn &response.Info, response.Info.URL, response.Err()\n+}\n+\n+// ConnectRTM calls the \"rtm.connect\" endpoint and returns the provided URL and the compact Info block.\n+//\n+// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\n+func (api *Client) ConnectRTM() (info *Info, websocketURL string, err error) {\n+\tctx, cancel := context.WithTimeout(context.Background(), websocketDefaultTimeout)\n+\tdefer cancel()\n+\n+\treturn api.ConnectRTMContext(ctx)\n+}\n+\n+// ConnectRTMContext calls the \"rtm.connect\" endpoint and returns the\n+// provided URL and the compact Info block with a custom context.\n+//\n+// To have a fully managed Websocket connection, use `NewRTM`, and call `ManageConnection()` on it.\n+func (api *Client) ConnectRTMContext(ctx context.Context) (info *Info, websocketURL string, err error) {\n+\tresponse := &infoResponseFull{}\n+\terr = api.postMethod(ctx, \"rtm.connect\", url.Values{\"token\": {api.token}}, response)\n+\tif err != nil {\n+\t\tapi.Debugf(\"Failed to connect to RTM: %s\", err)\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\tapi.Debugln(\"Using URL:\", response.Info.URL)\n+\treturn &response.Info, response.Info.URL, response.Err()\n+}\n+\n+// RTMOption options for the managed RTM.\n+type RTMOption func(*RTM)\n+\n+// RTMOptionUseStart as of 11th July 2017 you should prefer setting this to false, see:\n+// https://api.slack.com/changelog/2017-04-start-using-rtm-connect-and-stop-using-rtm-start\n+func RTMOptionUseStart(b bool) RTMOption {\n+\treturn func(rtm *RTM) {\n+\t\trtm.useRTMStart = b\n+\t}\n+}\n+\n+// RTMOptionDialer takes a gorilla websocket Dialer and uses it as the\n+// Dialer when opening the websocket for the RTM connection.\n+func RTMOptionDialer(d *websocket.Dialer) RTMOption {\n+\treturn func(rtm *RTM) {\n+\t\trtm.dialer = d\n+\t}\n+}\n+\n+// RTMOptionPingInterval determines how often to deliver a ping message to slack.\n+func RTMOptionPingInterval(d time.Duration) RTMOption {\n+\treturn func(rtm *RTM) {\n+\t\trtm.pingInterval = d\n+\t\trtm.resetDeadman()\n+\t}\n+}\n+\n+// RTMOptionConnParams installs parameters to embed into the connection URL.\n+func RTMOptionConnParams(connParams url.Values) RTMOption {\n+\treturn func(rtm *RTM) {\n+\t\trtm.connParams = connParams\n+\t}\n+}\n+\n+// NewRTM returns a RTM, which provides a fully managed connection to\n+// Slack's websocket-based Real-Time Messaging protocol.\n+func (api *Client) NewRTM(options ...RTMOption) *RTM {\n+\tresult := &RTM{\n+\t\tClient:           *api,\n+\t\tIncomingEvents:   make(chan RTMEvent, 50),\n+\t\toutgoingMessages: make(chan OutgoingMessage, 20),\n+\t\tpingInterval:     defaultPingInterval,\n+\t\tpingDeadman:      time.NewTimer(deadmanDuration(defaultPingInterval)),\n+\t\tkillChannel:      make(chan bool),\n+\t\tdisconnected:     make(chan struct{}),\n+\t\tdisconnectedm:    &sync.Once{},\n+\t\tforcePing:        make(chan bool),\n+\t\tidGen:            NewSafeID(1),\n+\t\tmu:               &sync.Mutex{},\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\topt(result)\n+\t}\n+\n+\treturn result\n+}"
    },
    {
      "sha": "de6b40acb0fd8a4bae469778870d87d55378faba",
      "filename": "backend/vendor/github.com/slack-go/slack/search.go",
      "status": "added",
      "additions": 156,
      "deletions": 0,
      "changes": 156,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/search.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/search.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/search.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,156 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+)\n+\n+const (\n+\tDEFAULT_SEARCH_SORT      = \"score\"\n+\tDEFAULT_SEARCH_SORT_DIR  = \"desc\"\n+\tDEFAULT_SEARCH_HIGHLIGHT = false\n+\tDEFAULT_SEARCH_COUNT     = 20\n+\tDEFAULT_SEARCH_PAGE      = 1\n+)\n+\n+type SearchParameters struct {\n+\tSort          string\n+\tSortDirection string\n+\tHighlight     bool\n+\tCount         int\n+\tPage          int\n+}\n+\n+type CtxChannel struct {\n+\tID                 string `json:\"id\"`\n+\tName               string `json:\"name\"`\n+\tIsExtShared        bool   `json:\"is_ext_shared\"`\n+\tIsMPIM             bool   `json:\"is_mpim\"`\n+\tISOrgShared        bool   `json:\"is_org_shared\"`\n+\tIsPendingExtShared bool   `json:\"is_pending_ext_shared\"`\n+\tIsPrivate          bool   `json:\"is_private\"`\n+\tIsShared           bool   `json:\"is_shared\"`\n+}\n+\n+type CtxMessage struct {\n+\tUser      string `json:\"user\"`\n+\tUsername  string `json:\"username\"`\n+\tText      string `json:\"text\"`\n+\tTimestamp string `json:\"ts\"`\n+\tType      string `json:\"type\"`\n+}\n+\n+type SearchMessage struct {\n+\tType        string       `json:\"type\"`\n+\tChannel     CtxChannel   `json:\"channel\"`\n+\tUser        string       `json:\"user\"`\n+\tUsername    string       `json:\"username\"`\n+\tTimestamp   string       `json:\"ts\"`\n+\tBlocks      Blocks       `json:\"blocks,omitempty\"`\n+\tText        string       `json:\"text\"`\n+\tPermalink   string       `json:\"permalink\"`\n+\tAttachments []Attachment `json:\"attachments\"`\n+\tPrevious    CtxMessage   `json:\"previous\"`\n+\tPrevious2   CtxMessage   `json:\"previous_2\"`\n+\tNext        CtxMessage   `json:\"next\"`\n+\tNext2       CtxMessage   `json:\"next_2\"`\n+}\n+\n+type SearchMessages struct {\n+\tMatches    []SearchMessage `json:\"matches\"`\n+\tPaging     `json:\"paging\"`\n+\tPagination `json:\"pagination\"`\n+\tTotal      int `json:\"total\"`\n+}\n+\n+type SearchFiles struct {\n+\tMatches    []File `json:\"matches\"`\n+\tPaging     `json:\"paging\"`\n+\tPagination `json:\"pagination\"`\n+\tTotal      int `json:\"total\"`\n+}\n+\n+type searchResponseFull struct {\n+\tQuery          string `json:\"query\"`\n+\tSearchMessages `json:\"messages\"`\n+\tSearchFiles    `json:\"files\"`\n+\tSlackResponse\n+}\n+\n+func NewSearchParameters() SearchParameters {\n+\treturn SearchParameters{\n+\t\tSort:          DEFAULT_SEARCH_SORT,\n+\t\tSortDirection: DEFAULT_SEARCH_SORT_DIR,\n+\t\tHighlight:     DEFAULT_SEARCH_HIGHLIGHT,\n+\t\tCount:         DEFAULT_SEARCH_COUNT,\n+\t\tPage:          DEFAULT_SEARCH_PAGE,\n+\t}\n+}\n+\n+func (api *Client) _search(ctx context.Context, path, query string, params SearchParameters, files, messages bool) (response *searchResponseFull, error error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"query\": {query},\n+\t}\n+\tif params.Sort != DEFAULT_SEARCH_SORT {\n+\t\tvalues.Add(\"sort\", params.Sort)\n+\t}\n+\tif params.SortDirection != DEFAULT_SEARCH_SORT_DIR {\n+\t\tvalues.Add(\"sort_dir\", params.SortDirection)\n+\t}\n+\tif params.Highlight != DEFAULT_SEARCH_HIGHLIGHT {\n+\t\tvalues.Add(\"highlight\", strconv.Itoa(1))\n+\t}\n+\tif params.Count != DEFAULT_SEARCH_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Page != DEFAULT_SEARCH_PAGE {\n+\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n+\t}\n+\n+\tresponse = &searchResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+\n+}\n+\n+func (api *Client) Search(query string, params SearchParameters) (*SearchMessages, *SearchFiles, error) {\n+\treturn api.SearchContext(context.Background(), query, params)\n+}\n+\n+func (api *Client) SearchContext(ctx context.Context, query string, params SearchParameters) (*SearchMessages, *SearchFiles, error) {\n+\tresponse, err := api._search(ctx, \"search.all\", query, params, true, true)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\treturn &response.SearchMessages, &response.SearchFiles, nil\n+}\n+\n+func (api *Client) SearchFiles(query string, params SearchParameters) (*SearchFiles, error) {\n+\treturn api.SearchFilesContext(context.Background(), query, params)\n+}\n+\n+func (api *Client) SearchFilesContext(ctx context.Context, query string, params SearchParameters) (*SearchFiles, error) {\n+\tresponse, err := api._search(ctx, \"search.files\", query, params, true, false)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.SearchFiles, nil\n+}\n+\n+func (api *Client) SearchMessages(query string, params SearchParameters) (*SearchMessages, error) {\n+\treturn api.SearchMessagesContext(context.Background(), query, params)\n+}\n+\n+func (api *Client) SearchMessagesContext(ctx context.Context, query string, params SearchParameters) (*SearchMessages, error) {\n+\tresponse, err := api._search(ctx, \"search.messages\", query, params, false, true)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.SearchMessages, nil\n+}"
    },
    {
      "sha": "451035293716c39c83f84d7b007367f7be9cf89a",
      "filename": "backend/vendor/github.com/slack-go/slack/security.go",
      "status": "added",
      "additions": 108,
      "deletions": 0,
      "changes": 108,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/security.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/security.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/security.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,108 @@\n+package slack\n+\n+import (\n+\t\"crypto/hmac\"\n+\t\"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\t\"hash\"\n+\t\"net/http\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// Signature headers\n+const (\n+\thSignature = \"X-Slack-Signature\"\n+\thTimestamp = \"X-Slack-Request-Timestamp\"\n+)\n+\n+// SecretsVerifier contains the information needed to verify that the request comes from Slack\n+type SecretsVerifier struct {\n+\td         Debug\n+\tsignature []byte\n+\thmac      hash.Hash\n+}\n+\n+func unsafeSignatureVerifier(header http.Header, secret string) (_ SecretsVerifier, err error) {\n+\tvar (\n+\t\tbsignature []byte\n+\t)\n+\n+\tsignature := header.Get(hSignature)\n+\tstimestamp := header.Get(hTimestamp)\n+\n+\tif signature == \"\" || stimestamp == \"\" {\n+\t\treturn SecretsVerifier{}, ErrMissingHeaders\n+\t}\n+\n+\tif bsignature, err = hex.DecodeString(strings.TrimPrefix(signature, \"v0=\")); err != nil {\n+\t\treturn SecretsVerifier{}, err\n+\t}\n+\n+\thash := hmac.New(sha256.New, []byte(secret))\n+\tif _, err = hash.Write([]byte(fmt.Sprintf(\"v0:%s:\", stimestamp))); err != nil {\n+\t\treturn SecretsVerifier{}, err\n+\t}\n+\n+\treturn SecretsVerifier{\n+\t\tsignature: bsignature,\n+\t\thmac:      hash,\n+\t}, nil\n+}\n+\n+// NewSecretsVerifier returns a SecretsVerifier object in exchange for an http.Header object and signing secret\n+func NewSecretsVerifier(header http.Header, secret string) (sv SecretsVerifier, err error) {\n+\tvar (\n+\t\ttimestamp int64\n+\t)\n+\n+\tstimestamp := header.Get(hTimestamp)\n+\n+\tif sv, err = unsafeSignatureVerifier(header, secret); err != nil {\n+\t\treturn SecretsVerifier{}, err\n+\t}\n+\n+\tif timestamp, err = strconv.ParseInt(stimestamp, 10, 64); err != nil {\n+\t\treturn SecretsVerifier{}, err\n+\t}\n+\n+\tdiff := absDuration(time.Since(time.Unix(timestamp, 0)))\n+\tif diff > 5*time.Minute {\n+\t\treturn SecretsVerifier{}, ErrExpiredTimestamp\n+\t}\n+\n+\treturn sv, err\n+}\n+\n+func (v *SecretsVerifier) WithDebug(d Debug) *SecretsVerifier {\n+\tv.d = d\n+\treturn v\n+}\n+\n+func (v *SecretsVerifier) Write(body []byte) (n int, err error) {\n+\treturn v.hmac.Write(body)\n+}\n+\n+// Ensure compares the signature sent from Slack with the actual computed hash to judge validity\n+func (v SecretsVerifier) Ensure() error {\n+\tcomputed := v.hmac.Sum(nil)\n+\t// use hmac.Equal prevent leaking timing information.\n+\tif hmac.Equal(computed, v.signature) {\n+\t\treturn nil\n+\t}\n+\tif v.d != nil && v.d.Debug() {\n+\t\tv.d.Debugln(fmt.Sprintf(\"Expected signing signature: %s, but computed: %s\", hex.EncodeToString(v.signature), hex.EncodeToString(computed)))\n+\t}\n+\treturn fmt.Errorf(\"Computed unexpected signature of: %s\", hex.EncodeToString(computed))\n+}\n+\n+func abs64(n int64) int64 {\n+\ty := n >> 63\n+\treturn (n ^ y) - y\n+}\n+\n+func absDuration(n time.Duration) time.Duration {\n+\treturn time.Duration(abs64(int64(n)))\n+}"
    },
    {
      "sha": "143673656e3a1e0607cef76c76ea1d8944177730",
      "filename": "backend/vendor/github.com/slack-go/slack/slack.go",
      "status": "added",
      "additions": 162,
      "deletions": 0,
      "changes": 162,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/slack.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/slack.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/slack.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,162 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"os\"\n+)\n+\n+const (\n+\t// APIURL of the slack api.\n+\tAPIURL = \"https://slack.com/api/\"\n+\t// WEBAPIURLFormat ...\n+\tWEBAPIURLFormat = \"https://%s.slack.com/api/users.admin.%s?t=%d\"\n+)\n+\n+// httpClient defines the minimal interface needed for an http.Client to be implemented.\n+type httpClient interface {\n+\tDo(*http.Request) (*http.Response, error)\n+}\n+\n+// ResponseMetadata holds pagination metadata\n+type ResponseMetadata struct {\n+\tCursor   string   `json:\"next_cursor\"`\n+\tMessages []string `json:\"messages\"`\n+\tWarnings []string `json:\"warnings\"`\n+}\n+\n+func (t *ResponseMetadata) initialize() *ResponseMetadata {\n+\tif t != nil {\n+\t\treturn t\n+\t}\n+\n+\treturn &ResponseMetadata{}\n+}\n+\n+// AuthTestResponse ...\n+type AuthTestResponse struct {\n+\tURL    string `json:\"url\"`\n+\tTeam   string `json:\"team\"`\n+\tUser   string `json:\"user\"`\n+\tTeamID string `json:\"team_id\"`\n+\tUserID string `json:\"user_id\"`\n+\t// EnterpriseID is only returned when an enterprise id present\n+\tEnterpriseID string `json:\"enterprise_id,omitempty\"`\n+\tBotID        string `json:\"bot_id\"`\n+}\n+\n+type authTestResponseFull struct {\n+\tSlackResponse\n+\tAuthTestResponse\n+}\n+\n+// Client for the slack api.\n+type ParamOption func(*url.Values)\n+\n+type Client struct {\n+\ttoken         string\n+\tappLevelToken string\n+\tendpoint      string\n+\tdebug         bool\n+\tlog           ilogger\n+\thttpclient    httpClient\n+}\n+\n+// Option defines an option for a Client\n+type Option func(*Client)\n+\n+// OptionHTTPClient - provide a custom http client to the slack client.\n+func OptionHTTPClient(client httpClient) func(*Client) {\n+\treturn func(c *Client) {\n+\t\tc.httpclient = client\n+\t}\n+}\n+\n+// OptionDebug enable debugging for the client\n+func OptionDebug(b bool) func(*Client) {\n+\treturn func(c *Client) {\n+\t\tc.debug = b\n+\t}\n+}\n+\n+// OptionLog set logging for client.\n+func OptionLog(l logger) func(*Client) {\n+\treturn func(c *Client) {\n+\t\tc.log = internalLog{logger: l}\n+\t}\n+}\n+\n+// OptionAPIURL set the url for the client. only useful for testing.\n+func OptionAPIURL(u string) func(*Client) {\n+\treturn func(c *Client) { c.endpoint = u }\n+}\n+\n+// OptionAppLevelToken sets an app-level token for the client.\n+func OptionAppLevelToken(token string) func(*Client) {\n+\treturn func(c *Client) { c.appLevelToken = token }\n+}\n+\n+// New builds a slack client from the provided token and options.\n+func New(token string, options ...Option) *Client {\n+\ts := &Client{\n+\t\ttoken:      token,\n+\t\tendpoint:   APIURL,\n+\t\thttpclient: &http.Client{},\n+\t\tlog:        log.New(os.Stderr, \"slack-go/slack\", log.LstdFlags|log.Lshortfile),\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\topt(s)\n+\t}\n+\n+\treturn s\n+}\n+\n+// AuthTest tests if the user is able to do authenticated requests or not\n+func (api *Client) AuthTest() (response *AuthTestResponse, error error) {\n+\treturn api.AuthTestContext(context.Background())\n+}\n+\n+// AuthTestContext tests if the user is able to do authenticated requests or not with a custom context\n+func (api *Client) AuthTestContext(ctx context.Context) (response *AuthTestResponse, err error) {\n+\tapi.Debugf(\"Challenging auth...\")\n+\tresponseFull := &authTestResponseFull{}\n+\terr = api.postMethod(ctx, \"auth.test\", url.Values{\"token\": {api.token}}, responseFull)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &responseFull.AuthTestResponse, responseFull.Err()\n+}\n+\n+// Debugf print a formatted debug line.\n+func (api *Client) Debugf(format string, v ...interface{}) {\n+\tif api.debug {\n+\t\tapi.log.Output(2, fmt.Sprintf(format, v...))\n+\t}\n+}\n+\n+// Debugln print a debug line.\n+func (api *Client) Debugln(v ...interface{}) {\n+\tif api.debug {\n+\t\tapi.log.Output(2, fmt.Sprintln(v...))\n+\t}\n+}\n+\n+// Debug returns if debug is enabled.\n+func (api *Client) Debug() bool {\n+\treturn api.debug\n+}\n+\n+// post to a slack web method.\n+func (api *Client) postMethod(ctx context.Context, path string, values url.Values, intf interface{}) error {\n+\treturn postForm(ctx, api.httpclient, api.endpoint+path, values, intf, api)\n+}\n+\n+// get a slack web method.\n+func (api *Client) getMethod(ctx context.Context, path string, values url.Values, intf interface{}) error {\n+\treturn getResource(ctx, api.httpclient, api.endpoint+path, values, intf, api)\n+}"
    },
    {
      "sha": "1f7b2b8c28875937f36d20267baa0124979cb607",
      "filename": "backend/vendor/github.com/slack-go/slack/slackutilsx/slackutilsx.go",
      "status": "added",
      "additions": 62,
      "deletions": 0,
      "changes": 62,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/slackutilsx/slackutilsx.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/slackutilsx/slackutilsx.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/slackutilsx/slackutilsx.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,62 @@\n+// Package slackutilsx is a utility package that doesn't promise API stability.\n+// its for experimental functionality and utilities.\n+package slackutilsx\n+\n+import (\n+\t\"strings\"\n+\t\"unicode/utf8\"\n+)\n+\n+// ChannelType the type of channel based on the channelID\n+type ChannelType int\n+\n+func (t ChannelType) String() string {\n+\tswitch t {\n+\tcase CTypeDM:\n+\t\treturn \"Direct\"\n+\tcase CTypeGroup:\n+\t\treturn \"Group\"\n+\tcase CTypeChannel:\n+\t\treturn \"Channel\"\n+\tdefault:\n+\t\treturn \"Unknown\"\n+\t}\n+}\n+\n+const (\n+\t// CTypeUnknown represents channels we cannot properly detect.\n+\tCTypeUnknown ChannelType = iota\n+\t// CTypeDM is a private channel between two slack users.\n+\tCTypeDM\n+\t// CTypeGroup is a group channel.\n+\tCTypeGroup\n+\t// CTypeChannel is a public channel.\n+\tCTypeChannel\n+)\n+\n+// DetectChannelType converts a channelID to a ChannelType.\n+// channelID must not be empty. However, if it is empty, the channel type will default to Unknown.\n+func DetectChannelType(channelID string) ChannelType {\n+\t// intentionally ignore the error and just default to CTypeUnknown\n+\tswitch r, _ := utf8.DecodeRuneInString(channelID); r {\n+\tcase 'C':\n+\t\treturn CTypeChannel\n+\tcase 'G':\n+\t\treturn CTypeGroup\n+\tcase 'D':\n+\t\treturn CTypeDM\n+\tdefault:\n+\t\treturn CTypeUnknown\n+\t}\n+}\n+\n+// EscapeMessage text\n+func EscapeMessage(message string) string {\n+\treplacer := strings.NewReplacer(\"&\", \"&amp;\", \"<\", \"&lt;\", \">\", \"&gt;\")\n+\treturn replacer.Replace(message)\n+}\n+\n+// Retryable errors return true.\n+type Retryable interface {\n+\tRetryable() bool\n+}"
    },
    {
      "sha": "b2c509476e4ae5ba8549ca201429b98fe24c7be5",
      "filename": "backend/vendor/github.com/slack-go/slack/slash.go",
      "status": "added",
      "additions": 55,
      "deletions": 0,
      "changes": 55,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/slash.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/slash.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/slash.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,55 @@\n+package slack\n+\n+import (\n+\t\"net/http\"\n+)\n+\n+// SlashCommand contains information about a request of the slash command\n+type SlashCommand struct {\n+\tToken          string `json:\"token\"`\n+\tTeamID         string `json:\"team_id\"`\n+\tTeamDomain     string `json:\"team_domain\"`\n+\tEnterpriseID   string `json:\"enterprise_id,omitempty\"`\n+\tEnterpriseName string `json:\"enterprise_name,omitempty\"`\n+\tChannelID      string `json:\"channel_id\"`\n+\tChannelName    string `json:\"channel_name\"`\n+\tUserID         string `json:\"user_id\"`\n+\tUserName       string `json:\"user_name\"`\n+\tCommand        string `json:\"command\"`\n+\tText           string `json:\"text\"`\n+\tResponseURL    string `json:\"response_url\"`\n+\tTriggerID      string `json:\"trigger_id\"`\n+\tAPIAppID       string `json:\"api_app_id\"`\n+}\n+\n+// SlashCommandParse will parse the request of the slash command\n+func SlashCommandParse(r *http.Request) (s SlashCommand, err error) {\n+\tif err = r.ParseForm(); err != nil {\n+\t\treturn s, err\n+\t}\n+\ts.Token = r.PostForm.Get(\"token\")\n+\ts.TeamID = r.PostForm.Get(\"team_id\")\n+\ts.TeamDomain = r.PostForm.Get(\"team_domain\")\n+\ts.EnterpriseID = r.PostForm.Get(\"enterprise_id\")\n+\ts.EnterpriseName = r.PostForm.Get(\"enterprise_name\")\n+\ts.ChannelID = r.PostForm.Get(\"channel_id\")\n+\ts.ChannelName = r.PostForm.Get(\"channel_name\")\n+\ts.UserID = r.PostForm.Get(\"user_id\")\n+\ts.UserName = r.PostForm.Get(\"user_name\")\n+\ts.Command = r.PostForm.Get(\"command\")\n+\ts.Text = r.PostForm.Get(\"text\")\n+\ts.ResponseURL = r.PostForm.Get(\"response_url\")\n+\ts.TriggerID = r.PostForm.Get(\"trigger_id\")\n+\ts.APIAppID = r.PostForm.Get(\"api_app_id\")\n+\treturn s, nil\n+}\n+\n+// ValidateToken validates verificationTokens\n+func (s SlashCommand) ValidateToken(verificationTokens ...string) bool {\n+\tfor _, token := range verificationTokens {\n+\t\tif s.Token == token {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"
    },
    {
      "sha": "69e40d99ddcb854fccbd74fab2d563b35b24c5ca",
      "filename": "backend/vendor/github.com/slack-go/slack/socket_mode.go",
      "status": "added",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/socket_mode.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/socket_mode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/socket_mode.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,34 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+)\n+\n+// SocketModeConnection contains various details about the SocketMode connection.\n+// It is returned by an \"apps.connections.open\" API call.\n+type SocketModeConnection struct {\n+\tURL  string                 `json:\"url,omitempty\"`\n+\tData map[string]interface{} `json:\"-\"`\n+}\n+\n+type openResponseFull struct {\n+\tSlackResponse\n+\tSocketModeConnection\n+}\n+\n+// StartSocketModeContext calls the \"apps.connections.open\" endpoint and returns the provided URL and the full Info block with a custom context.\n+//\n+// To have a fully managed Socket Mode connection, use `socketmode.New()`, and call `Run()` on it.\n+func (api *Client) StartSocketModeContext(ctx context.Context) (info *SocketModeConnection, websocketURL string, err error) {\n+\tresponse := &openResponseFull{}\n+\terr = postJSON(ctx, api.httpclient, api.endpoint+\"apps.connections.open\", api.appLevelToken, nil, response, api)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\n+\tif response.Err() == nil {\n+\t\tapi.Debugln(\"Using URL:\", response.SocketModeConnection.URL)\n+\t}\n+\n+\treturn &response.SocketModeConnection, response.SocketModeConnection.URL, response.Err()\n+}"
    },
    {
      "sha": "5296760482451405b323afbc7a11fb62cbd1afcb",
      "filename": "backend/vendor/github.com/slack-go/slack/stars.go",
      "status": "added",
      "additions": 263,
      "deletions": 0,
      "changes": 263,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/stars.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/stars.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/stars.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,263 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"time\"\n+)\n+\n+const (\n+\tDEFAULT_STARS_USER  = \"\"\n+\tDEFAULT_STARS_COUNT = 100\n+\tDEFAULT_STARS_PAGE  = 1\n+)\n+\n+type StarsParameters struct {\n+\tUser  string\n+\tCount int\n+\tPage  int\n+}\n+\n+type StarredItem Item\n+\n+type listResponseFull struct {\n+\tItems  []Item `json:\"items\"`\n+\tPaging `json:\"paging\"`\n+\tSlackResponse\n+}\n+\n+// NewStarsParameters initialises StarsParameters with default values\n+func NewStarsParameters() StarsParameters {\n+\treturn StarsParameters{\n+\t\tUser:  DEFAULT_STARS_USER,\n+\t\tCount: DEFAULT_STARS_COUNT,\n+\t\tPage:  DEFAULT_STARS_PAGE,\n+\t}\n+}\n+\n+// AddStar stars an item in a channel\n+func (api *Client) AddStar(channel string, item ItemRef) error {\n+\treturn api.AddStarContext(context.Background(), channel, item)\n+}\n+\n+// AddStarContext stars an item in a channel with a custom context\n+func (api *Client) AddStarContext(ctx context.Context, channel string, item ItemRef) error {\n+\tvalues := url.Values{\n+\t\t\"channel\": {channel},\n+\t\t\"token\":   {api.token},\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(ctx, \"stars.add\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// RemoveStar removes a starred item from a channel\n+func (api *Client) RemoveStar(channel string, item ItemRef) error {\n+\treturn api.RemoveStarContext(context.Background(), channel, item)\n+}\n+\n+// RemoveStarContext removes a starred item from a channel with a custom context\n+func (api *Client) RemoveStarContext(ctx context.Context, channel string, item ItemRef) error {\n+\tvalues := url.Values{\n+\t\t\"channel\": {channel},\n+\t\t\"token\":   {api.token},\n+\t}\n+\tif item.Timestamp != \"\" {\n+\t\tvalues.Set(\"timestamp\", item.Timestamp)\n+\t}\n+\tif item.File != \"\" {\n+\t\tvalues.Set(\"file\", item.File)\n+\t}\n+\tif item.Comment != \"\" {\n+\t\tvalues.Set(\"file_comment\", item.Comment)\n+\t}\n+\n+\tresponse := &SlackResponse{}\n+\tif err := api.postMethod(ctx, \"stars.remove\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// ListStars returns information about the stars a user added\n+func (api *Client) ListStars(params StarsParameters) ([]Item, *Paging, error) {\n+\treturn api.ListStarsContext(context.Background(), params)\n+}\n+\n+// ListStarsContext returns information about the stars a user added with a custom context\n+func (api *Client) ListStarsContext(ctx context.Context, params StarsParameters) ([]Item, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.User != DEFAULT_STARS_USER {\n+\t\tvalues.Add(\"user\", params.User)\n+\t}\n+\tif params.Count != DEFAULT_STARS_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Page != DEFAULT_STARS_PAGE {\n+\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n+\t}\n+\n+\tresponse := &listResponseFull{}\n+\terr := api.postMethod(ctx, \"stars.list\", values, response)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tif err := response.Err(); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\treturn response.Items, &response.Paging, nil\n+}\n+\n+// GetStarred returns a list of StarredItem items.\n+//\n+// The user then has to iterate over them and figure out what they should\n+// be looking at according to what is in the Type.\n+//    for _, item := range items {\n+//        switch c.Type {\n+//        case \"file_comment\":\n+//            log.Println(c.Comment)\n+//        case \"file\":\n+//             ...\n+//\n+//    }\n+// This function still exists to maintain backwards compatibility.\n+// I exposed it as returning []StarredItem, so it shall stay as StarredItem\n+func (api *Client) GetStarred(params StarsParameters) ([]StarredItem, *Paging, error) {\n+\treturn api.GetStarredContext(context.Background(), params)\n+}\n+\n+// GetStarredContext returns a list of StarredItem items with a custom context\n+//\n+// For more details see GetStarred\n+func (api *Client) GetStarredContext(ctx context.Context, params StarsParameters) ([]StarredItem, *Paging, error) {\n+\titems, paging, err := api.ListStarsContext(ctx, params)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tstarredItems := make([]StarredItem, len(items))\n+\tfor i, item := range items {\n+\t\tstarredItems[i] = StarredItem(item)\n+\t}\n+\treturn starredItems, paging, nil\n+}\n+\n+type listResponsePaginated struct {\n+\tItems []Item `json:\"items\"`\n+\tSlackResponse\n+\tMetadata ResponseMetadata `json:\"response_metadata\"`\n+}\n+\n+// StarredItemPagination allows for paginating over the starred items\n+type StarredItemPagination struct {\n+\tItems        []Item\n+\tlimit        int\n+\tpreviousResp *ResponseMetadata\n+\tc            *Client\n+}\n+\n+// ListStarsOption options for the GetUsers method call.\n+type ListStarsOption func(*StarredItemPagination)\n+\n+// ListAllStars returns the complete list of starred items\n+func (api *Client) ListAllStars() ([]Item, error) {\n+\treturn api.ListAllStarsContext(context.Background())\n+}\n+\n+// ListAllStarsContext returns the list of users (with their detailed information) with a custom context\n+func (api *Client) ListAllStarsContext(ctx context.Context) (results []Item, err error) {\n+\tp := api.ListStarsPaginated()\n+\tfor err == nil {\n+\t\tp, err = p.next(ctx)\n+\t\tif err == nil {\n+\t\t\tresults = append(results, p.Items...)\n+\t\t} else if rateLimitedError, ok := err.(*RateLimitedError); ok {\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\terr = ctx.Err()\n+\t\t\tcase <-time.After(rateLimitedError.RetryAfter):\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn results, p.failure(err)\n+}\n+\n+// ListStarsPaginated fetches users in a paginated fashion, see ListStarsPaginationContext for usage.\n+func (api *Client) ListStarsPaginated(options ...ListStarsOption) StarredItemPagination {\n+\treturn newStarPagination(api, options...)\n+}\n+\n+func newStarPagination(c *Client, options ...ListStarsOption) (sip StarredItemPagination) {\n+\tsip = StarredItemPagination{\n+\t\tc:     c,\n+\t\tlimit: 200, // per slack api documentation.\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\topt(&sip)\n+\t}\n+\n+\treturn sip\n+}\n+\n+// done checks if the pagination has completed\n+func (StarredItemPagination) done(err error) bool {\n+\treturn err == errPaginationComplete\n+}\n+\n+// done checks if pagination failed.\n+func (t StarredItemPagination) failure(err error) error {\n+\tif t.done(err) {\n+\t\treturn nil\n+\t}\n+\n+\treturn err\n+}\n+\n+// next gets the next list of starred items based on the cursor value\n+func (t StarredItemPagination) next(ctx context.Context) (_ StarredItemPagination, err error) {\n+\tvar (\n+\t\tresp *listResponsePaginated\n+\t)\n+\n+\tif t.c == nil || (t.previousResp != nil && t.previousResp.Cursor == \"\") {\n+\t\treturn t, errPaginationComplete\n+\t}\n+\n+\tt.previousResp = t.previousResp.initialize()\n+\n+\tvalues := url.Values{\n+\t\t\"limit\":  {strconv.Itoa(t.limit)},\n+\t\t\"token\":  {t.c.token},\n+\t\t\"cursor\": {t.previousResp.Cursor},\n+\t}\n+\n+\tif err = t.c.postMethod(ctx, \"stars.list\", values, &resp); err != nil {\n+\t\treturn t, err\n+\t}\n+\n+\tt.previousResp = &resp.Metadata\n+\tt.Items = resp.Items\n+\n+\treturn t, nil\n+}"
    },
    {
      "sha": "029e2b5bc5e3ffe2128a4e7e12621931949915ad",
      "filename": "backend/vendor/github.com/slack-go/slack/team.go",
      "status": "added",
      "additions": 167,
      "deletions": 0,
      "changes": 167,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/team.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/team.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/team.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,167 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strconv\"\n+)\n+\n+const (\n+\tDEFAULT_LOGINS_COUNT = 100\n+\tDEFAULT_LOGINS_PAGE  = 1\n+)\n+\n+type TeamResponse struct {\n+\tTeam TeamInfo `json:\"team\"`\n+\tSlackResponse\n+}\n+\n+type TeamInfo struct {\n+\tID          string                 `json:\"id\"`\n+\tName        string                 `json:\"name\"`\n+\tDomain      string                 `json:\"domain\"`\n+\tEmailDomain string                 `json:\"email_domain\"`\n+\tIcon        map[string]interface{} `json:\"icon\"`\n+}\n+\n+type LoginResponse struct {\n+\tLogins []Login `json:\"logins\"`\n+\tPaging `json:\"paging\"`\n+\tSlackResponse\n+}\n+\n+type Login struct {\n+\tUserID    string `json:\"user_id\"`\n+\tUsername  string `json:\"username\"`\n+\tDateFirst int    `json:\"date_first\"`\n+\tDateLast  int    `json:\"date_last\"`\n+\tCount     int    `json:\"count\"`\n+\tIP        string `json:\"ip\"`\n+\tUserAgent string `json:\"user_agent\"`\n+\tISP       string `json:\"isp\"`\n+\tCountry   string `json:\"country\"`\n+\tRegion    string `json:\"region\"`\n+}\n+\n+type BillableInfoResponse struct {\n+\tBillableInfo map[string]BillingActive `json:\"billable_info\"`\n+\tSlackResponse\n+}\n+\n+type BillingActive struct {\n+\tBillingActive bool `json:\"billing_active\"`\n+}\n+\n+// AccessLogParameters contains all the parameters necessary (including the optional ones) for a GetAccessLogs() request\n+type AccessLogParameters struct {\n+\tCount int\n+\tPage  int\n+}\n+\n+// NewAccessLogParameters provides an instance of AccessLogParameters with all the sane default values set\n+func NewAccessLogParameters() AccessLogParameters {\n+\treturn AccessLogParameters{\n+\t\tCount: DEFAULT_LOGINS_COUNT,\n+\t\tPage:  DEFAULT_LOGINS_PAGE,\n+\t}\n+}\n+\n+func (api *Client) teamRequest(ctx context.Context, path string, values url.Values) (*TeamResponse, error) {\n+\tresponse := &TeamResponse{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+func (api *Client) billableInfoRequest(ctx context.Context, path string, values url.Values) (map[string]BillingActive, error) {\n+\tresponse := &BillableInfoResponse{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response.BillableInfo, response.Err()\n+}\n+\n+func (api *Client) accessLogsRequest(ctx context.Context, path string, values url.Values) (*LoginResponse, error) {\n+\tresponse := &LoginResponse{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response, response.Err()\n+}\n+\n+// GetTeamInfo gets the Team Information of the user\n+func (api *Client) GetTeamInfo() (*TeamInfo, error) {\n+\treturn api.GetTeamInfoContext(context.Background())\n+}\n+\n+// GetTeamInfoContext gets the Team Information of the user with a custom context\n+func (api *Client) GetTeamInfoContext(ctx context.Context) (*TeamInfo, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\tresponse, err := api.teamRequest(ctx, \"team.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Team, nil\n+}\n+\n+// GetAccessLogs retrieves a page of logins according to the parameters given\n+func (api *Client) GetAccessLogs(params AccessLogParameters) ([]Login, *Paging, error) {\n+\treturn api.GetAccessLogsContext(context.Background(), params)\n+}\n+\n+// GetAccessLogsContext retrieves a page of logins according to the parameters given with a custom context\n+func (api *Client) GetAccessLogsContext(ctx context.Context, params AccessLogParameters) ([]Login, *Paging, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.Count != DEFAULT_LOGINS_COUNT {\n+\t\tvalues.Add(\"count\", strconv.Itoa(params.Count))\n+\t}\n+\tif params.Page != DEFAULT_LOGINS_PAGE {\n+\t\tvalues.Add(\"page\", strconv.Itoa(params.Page))\n+\t}\n+\n+\tresponse, err := api.accessLogsRequest(ctx, \"team.accessLogs\", values)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\treturn response.Logins, &response.Paging, nil\n+}\n+\n+// GetBillableInfo ...\n+func (api *Client) GetBillableInfo(user string) (map[string]BillingActive, error) {\n+\treturn api.GetBillableInfoContext(context.Background(), user)\n+}\n+\n+// GetBillableInfoContext ...\n+func (api *Client) GetBillableInfoContext(ctx context.Context, user string) (map[string]BillingActive, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"user\":  {user},\n+\t}\n+\n+\treturn api.billableInfoRequest(ctx, \"team.billableInfo\", values)\n+}\n+\n+// GetBillableInfoForTeam returns the billing_active status of all users on the team.\n+func (api *Client) GetBillableInfoForTeam() (map[string]BillingActive, error) {\n+\treturn api.GetBillableInfoForTeamContext(context.Background())\n+}\n+\n+// GetBillableInfoForTeamContext returns the billing_active status of all users on the team with a custom context\n+func (api *Client) GetBillableInfoForTeamContext(ctx context.Context) (map[string]BillingActive, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\treturn api.billableInfoRequest(ctx, \"team.billableInfo\", values)\n+}"
    },
    {
      "sha": "9417f817743782186e1d4c96754d9c088cbf2fb2",
      "filename": "backend/vendor/github.com/slack-go/slack/usergroups.go",
      "status": "added",
      "additions": 258,
      "deletions": 0,
      "changes": 258,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/usergroups.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/usergroups.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/usergroups.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,258 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/url\"\n+\t\"strings\"\n+)\n+\n+// UserGroup contains all the information of a user group\n+type UserGroup struct {\n+\tID          string         `json:\"id\"`\n+\tTeamID      string         `json:\"team_id\"`\n+\tIsUserGroup bool           `json:\"is_usergroup\"`\n+\tName        string         `json:\"name\"`\n+\tDescription string         `json:\"description\"`\n+\tHandle      string         `json:\"handle\"`\n+\tIsExternal  bool           `json:\"is_external\"`\n+\tDateCreate  JSONTime       `json:\"date_create\"`\n+\tDateUpdate  JSONTime       `json:\"date_update\"`\n+\tDateDelete  JSONTime       `json:\"date_delete\"`\n+\tAutoType    string         `json:\"auto_type\"`\n+\tCreatedBy   string         `json:\"created_by\"`\n+\tUpdatedBy   string         `json:\"updated_by\"`\n+\tDeletedBy   string         `json:\"deleted_by\"`\n+\tPrefs       UserGroupPrefs `json:\"prefs\"`\n+\tUserCount   int            `json:\"user_count\"`\n+\tUsers       []string       `json:\"users\"`\n+}\n+\n+// UserGroupPrefs contains default channels and groups (private channels)\n+type UserGroupPrefs struct {\n+\tChannels []string `json:\"channels\"`\n+\tGroups   []string `json:\"groups\"`\n+}\n+\n+type userGroupResponseFull struct {\n+\tUserGroups []UserGroup `json:\"usergroups\"`\n+\tUserGroup  UserGroup   `json:\"usergroup\"`\n+\tUsers      []string    `json:\"users\"`\n+\tSlackResponse\n+}\n+\n+func (api *Client) userGroupRequest(ctx context.Context, path string, values url.Values) (*userGroupResponseFull, error) {\n+\tresponse := &userGroupResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// CreateUserGroup creates a new user group\n+func (api *Client) CreateUserGroup(userGroup UserGroup) (UserGroup, error) {\n+\treturn api.CreateUserGroupContext(context.Background(), userGroup)\n+}\n+\n+// CreateUserGroupContext creates a new user group with a custom context\n+func (api *Client) CreateUserGroupContext(ctx context.Context, userGroup UserGroup) (UserGroup, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"name\":  {userGroup.Name},\n+\t}\n+\n+\tif userGroup.Handle != \"\" {\n+\t\tvalues[\"handle\"] = []string{userGroup.Handle}\n+\t}\n+\n+\tif userGroup.Description != \"\" {\n+\t\tvalues[\"description\"] = []string{userGroup.Description}\n+\t}\n+\n+\tif len(userGroup.Prefs.Channels) > 0 {\n+\t\tvalues[\"channels\"] = []string{strings.Join(userGroup.Prefs.Channels, \",\")}\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.create\", values)\n+\tif err != nil {\n+\t\treturn UserGroup{}, err\n+\t}\n+\treturn response.UserGroup, nil\n+}\n+\n+// DisableUserGroup disables an existing user group\n+func (api *Client) DisableUserGroup(userGroup string) (UserGroup, error) {\n+\treturn api.DisableUserGroupContext(context.Background(), userGroup)\n+}\n+\n+// DisableUserGroupContext disables an existing user group with a custom context\n+func (api *Client) DisableUserGroupContext(ctx context.Context, userGroup string) (UserGroup, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"usergroup\": {userGroup},\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.disable\", values)\n+\tif err != nil {\n+\t\treturn UserGroup{}, err\n+\t}\n+\treturn response.UserGroup, nil\n+}\n+\n+// EnableUserGroup enables an existing user group\n+func (api *Client) EnableUserGroup(userGroup string) (UserGroup, error) {\n+\treturn api.EnableUserGroupContext(context.Background(), userGroup)\n+}\n+\n+// EnableUserGroupContext enables an existing user group with a custom context\n+func (api *Client) EnableUserGroupContext(ctx context.Context, userGroup string) (UserGroup, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"usergroup\": {userGroup},\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.enable\", values)\n+\tif err != nil {\n+\t\treturn UserGroup{}, err\n+\t}\n+\treturn response.UserGroup, nil\n+}\n+\n+// GetUserGroupsOption options for the GetUserGroups method call.\n+type GetUserGroupsOption func(*GetUserGroupsParams)\n+\n+// GetUserGroupsOptionIncludeCount include the number of users in each User Group (default: false)\n+func GetUserGroupsOptionIncludeCount(b bool) GetUserGroupsOption {\n+\treturn func(params *GetUserGroupsParams) {\n+\t\tparams.IncludeCount = b\n+\t}\n+}\n+\n+// GetUserGroupsOptionIncludeDisabled include disabled User Groups (default: false)\n+func GetUserGroupsOptionIncludeDisabled(b bool) GetUserGroupsOption {\n+\treturn func(params *GetUserGroupsParams) {\n+\t\tparams.IncludeDisabled = b\n+\t}\n+}\n+\n+// GetUserGroupsOptionIncludeUsers include the list of users for each User Group (default: false)\n+func GetUserGroupsOptionIncludeUsers(b bool) GetUserGroupsOption {\n+\treturn func(params *GetUserGroupsParams) {\n+\t\tparams.IncludeUsers = b\n+\t}\n+}\n+\n+// GetUserGroupsParams contains arguments for GetUserGroups method call\n+type GetUserGroupsParams struct {\n+\tIncludeCount    bool\n+\tIncludeDisabled bool\n+\tIncludeUsers    bool\n+}\n+\n+// GetUserGroups returns a list of user groups for the team\n+func (api *Client) GetUserGroups(options ...GetUserGroupsOption) ([]UserGroup, error) {\n+\treturn api.GetUserGroupsContext(context.Background(), options...)\n+}\n+\n+// GetUserGroupsContext returns a list of user groups for the team with a custom context\n+func (api *Client) GetUserGroupsContext(ctx context.Context, options ...GetUserGroupsOption) ([]UserGroup, error) {\n+\tparams := GetUserGroupsParams{}\n+\n+\tfor _, opt := range options {\n+\t\topt(&params)\n+\t}\n+\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.IncludeCount {\n+\t\tvalues.Add(\"include_count\", \"true\")\n+\t}\n+\tif params.IncludeDisabled {\n+\t\tvalues.Add(\"include_disabled\", \"true\")\n+\t}\n+\tif params.IncludeUsers {\n+\t\tvalues.Add(\"include_users\", \"true\")\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.list\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn response.UserGroups, nil\n+}\n+\n+// UpdateUserGroup will update an existing user group\n+func (api *Client) UpdateUserGroup(userGroup UserGroup) (UserGroup, error) {\n+\treturn api.UpdateUserGroupContext(context.Background(), userGroup)\n+}\n+\n+// UpdateUserGroupContext will update an existing user group with a custom context\n+func (api *Client) UpdateUserGroupContext(ctx context.Context, userGroup UserGroup) (UserGroup, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"usergroup\": {userGroup.ID},\n+\t}\n+\n+\tif userGroup.Name != \"\" {\n+\t\tvalues[\"name\"] = []string{userGroup.Name}\n+\t}\n+\n+\tif userGroup.Handle != \"\" {\n+\t\tvalues[\"handle\"] = []string{userGroup.Handle}\n+\t}\n+\n+\tif userGroup.Description != \"\" {\n+\t\tvalues[\"description\"] = []string{userGroup.Description}\n+\t}\n+\n+\tif len(userGroup.Prefs.Channels) > 0 {\n+\t\tvalues[\"channels\"] = []string{strings.Join(userGroup.Prefs.Channels, \",\")}\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.update\", values)\n+\tif err != nil {\n+\t\treturn UserGroup{}, err\n+\t}\n+\treturn response.UserGroup, nil\n+}\n+\n+// GetUserGroupMembers will retrieve the current list of users in a group\n+func (api *Client) GetUserGroupMembers(userGroup string) ([]string, error) {\n+\treturn api.GetUserGroupMembersContext(context.Background(), userGroup)\n+}\n+\n+// GetUserGroupMembersContext will retrieve the current list of users in a group with a custom context\n+func (api *Client) GetUserGroupMembersContext(ctx context.Context, userGroup string) ([]string, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"usergroup\": {userGroup},\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.users.list\", values)\n+\tif err != nil {\n+\t\treturn []string{}, err\n+\t}\n+\treturn response.Users, nil\n+}\n+\n+// UpdateUserGroupMembers will update the members of an existing user group\n+func (api *Client) UpdateUserGroupMembers(userGroup string, members string) (UserGroup, error) {\n+\treturn api.UpdateUserGroupMembersContext(context.Background(), userGroup, members)\n+}\n+\n+// UpdateUserGroupMembersContext will update the members of an existing user group with a custom context\n+func (api *Client) UpdateUserGroupMembersContext(ctx context.Context, userGroup string, members string) (UserGroup, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":     {api.token},\n+\t\t\"usergroup\": {userGroup},\n+\t\t\"users\":     {members},\n+\t}\n+\n+\tresponse, err := api.userGroupRequest(ctx, \"usergroups.users.update\", values)\n+\tif err != nil {\n+\t\treturn UserGroup{}, err\n+\t}\n+\treturn response.UserGroup, nil\n+}"
    },
    {
      "sha": "82657d76f641d0e4dce30b202fbe8913860075dd",
      "filename": "backend/vendor/github.com/slack-go/slack/users.go",
      "status": "added",
      "additions": 666,
      "deletions": 0,
      "changes": 666,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/users.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/users.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/users.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,666 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"net/url\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+const (\n+\tDEFAULT_USER_PHOTO_CROP_X = -1\n+\tDEFAULT_USER_PHOTO_CROP_Y = -1\n+\tDEFAULT_USER_PHOTO_CROP_W = -1\n+)\n+\n+// UserProfile contains all the information details of a given user\n+type UserProfile struct {\n+\tFirstName             string                  `json:\"first_name\"`\n+\tLastName              string                  `json:\"last_name\"`\n+\tRealName              string                  `json:\"real_name\"`\n+\tRealNameNormalized    string                  `json:\"real_name_normalized\"`\n+\tDisplayName           string                  `json:\"display_name\"`\n+\tDisplayNameNormalized string                  `json:\"display_name_normalized\"`\n+\tEmail                 string                  `json:\"email\"`\n+\tSkype                 string                  `json:\"skype\"`\n+\tPhone                 string                  `json:\"phone\"`\n+\tImage24               string                  `json:\"image_24\"`\n+\tImage32               string                  `json:\"image_32\"`\n+\tImage48               string                  `json:\"image_48\"`\n+\tImage72               string                  `json:\"image_72\"`\n+\tImage192              string                  `json:\"image_192\"`\n+\tImage512              string                  `json:\"image_512\"`\n+\tImageOriginal         string                  `json:\"image_original\"`\n+\tTitle                 string                  `json:\"title\"`\n+\tBotID                 string                  `json:\"bot_id,omitempty\"`\n+\tApiAppID              string                  `json:\"api_app_id,omitempty\"`\n+\tStatusText            string                  `json:\"status_text,omitempty\"`\n+\tStatusEmoji           string                  `json:\"status_emoji,omitempty\"`\n+\tStatusExpiration      int                     `json:\"status_expiration\"`\n+\tTeam                  string                  `json:\"team\"`\n+\tFields                UserProfileCustomFields `json:\"fields\"`\n+}\n+\n+// UserProfileCustomFields represents user profile's custom fields.\n+// Slack API's response data type is inconsistent so we use the struct.\n+// For detail, please see below.\n+// https://github.com/slack-go/slack/pull/298#discussion_r185159233\n+type UserProfileCustomFields struct {\n+\tfields map[string]UserProfileCustomField\n+}\n+\n+// UnmarshalJSON is the implementation of the json.Unmarshaler interface.\n+func (fields *UserProfileCustomFields) UnmarshalJSON(b []byte) error {\n+\t// https://github.com/slack-go/slack/pull/298#discussion_r185159233\n+\tif string(b) == \"[]\" {\n+\t\treturn nil\n+\t}\n+\treturn json.Unmarshal(b, &fields.fields)\n+}\n+\n+// MarshalJSON is the implementation of the json.Marshaler interface.\n+func (fields UserProfileCustomFields) MarshalJSON() ([]byte, error) {\n+\tif len(fields.fields) == 0 {\n+\t\treturn []byte(\"[]\"), nil\n+\t}\n+\treturn json.Marshal(fields.fields)\n+}\n+\n+// ToMap returns a map of custom fields.\n+func (fields *UserProfileCustomFields) ToMap() map[string]UserProfileCustomField {\n+\treturn fields.fields\n+}\n+\n+// Len returns the number of custom fields.\n+func (fields *UserProfileCustomFields) Len() int {\n+\treturn len(fields.fields)\n+}\n+\n+// SetMap sets a map of custom fields.\n+func (fields *UserProfileCustomFields) SetMap(m map[string]UserProfileCustomField) {\n+\tfields.fields = m\n+}\n+\n+// FieldsMap returns a map of custom fields.\n+func (profile *UserProfile) FieldsMap() map[string]UserProfileCustomField {\n+\treturn profile.Fields.ToMap()\n+}\n+\n+// SetFieldsMap sets a map of custom fields.\n+func (profile *UserProfile) SetFieldsMap(m map[string]UserProfileCustomField) {\n+\tprofile.Fields.SetMap(m)\n+}\n+\n+// UserProfileCustomField represents a custom user profile field\n+type UserProfileCustomField struct {\n+\tValue string `json:\"value\"`\n+\tAlt   string `json:\"alt\"`\n+\tLabel string `json:\"label\"`\n+}\n+\n+// User contains all the information of a user\n+type User struct {\n+\tID                string         `json:\"id\"`\n+\tTeamID            string         `json:\"team_id\"`\n+\tName              string         `json:\"name\"`\n+\tDeleted           bool           `json:\"deleted\"`\n+\tColor             string         `json:\"color\"`\n+\tRealName          string         `json:\"real_name\"`\n+\tTZ                string         `json:\"tz,omitempty\"`\n+\tTZLabel           string         `json:\"tz_label\"`\n+\tTZOffset          int            `json:\"tz_offset\"`\n+\tProfile           UserProfile    `json:\"profile\"`\n+\tIsBot             bool           `json:\"is_bot\"`\n+\tIsAdmin           bool           `json:\"is_admin\"`\n+\tIsOwner           bool           `json:\"is_owner\"`\n+\tIsPrimaryOwner    bool           `json:\"is_primary_owner\"`\n+\tIsRestricted      bool           `json:\"is_restricted\"`\n+\tIsUltraRestricted bool           `json:\"is_ultra_restricted\"`\n+\tIsStranger        bool           `json:\"is_stranger\"`\n+\tIsAppUser         bool           `json:\"is_app_user\"`\n+\tIsInvitedUser     bool           `json:\"is_invited_user\"`\n+\tHas2FA            bool           `json:\"has_2fa\"`\n+\tHasFiles          bool           `json:\"has_files\"`\n+\tPresence          string         `json:\"presence\"`\n+\tLocale            string         `json:\"locale\"`\n+\tUpdated           JSONTime       `json:\"updated\"`\n+\tEnterprise        EnterpriseUser `json:\"enterprise_user,omitempty\"`\n+}\n+\n+// UserPresence contains details about a user online status\n+type UserPresence struct {\n+\tPresence        string   `json:\"presence,omitempty\"`\n+\tOnline          bool     `json:\"online,omitempty\"`\n+\tAutoAway        bool     `json:\"auto_away,omitempty\"`\n+\tManualAway      bool     `json:\"manual_away,omitempty\"`\n+\tConnectionCount int      `json:\"connection_count,omitempty\"`\n+\tLastActivity    JSONTime `json:\"last_activity,omitempty\"`\n+}\n+\n+type UserIdentityResponse struct {\n+\tUser UserIdentity `json:\"user\"`\n+\tTeam TeamIdentity `json:\"team\"`\n+\tSlackResponse\n+}\n+\n+type UserIdentity struct {\n+\tID       string `json:\"id\"`\n+\tName     string `json:\"name\"`\n+\tEmail    string `json:\"email\"`\n+\tImage24  string `json:\"image_24\"`\n+\tImage32  string `json:\"image_32\"`\n+\tImage48  string `json:\"image_48\"`\n+\tImage72  string `json:\"image_72\"`\n+\tImage192 string `json:\"image_192\"`\n+\tImage512 string `json:\"image_512\"`\n+}\n+\n+// EnterpriseUser is present when a user is part of Slack Enterprise Grid\n+// https://api.slack.com/types/user#enterprise_grid_user_objects\n+type EnterpriseUser struct {\n+\tID             string   `json:\"id\"`\n+\tEnterpriseID   string   `json:\"enterprise_id\"`\n+\tEnterpriseName string   `json:\"enterprise_name\"`\n+\tIsAdmin        bool     `json:\"is_admin\"`\n+\tIsOwner        bool     `json:\"is_owner\"`\n+\tTeams          []string `json:\"teams\"`\n+}\n+\n+type TeamIdentity struct {\n+\tID            string `json:\"id\"`\n+\tName          string `json:\"name\"`\n+\tDomain        string `json:\"domain\"`\n+\tImage34       string `json:\"image_34\"`\n+\tImage44       string `json:\"image_44\"`\n+\tImage68       string `json:\"image_68\"`\n+\tImage88       string `json:\"image_88\"`\n+\tImage102      string `json:\"image_102\"`\n+\tImage132      string `json:\"image_132\"`\n+\tImage230      string `json:\"image_230\"`\n+\tImageDefault  bool   `json:\"image_default\"`\n+\tImageOriginal string `json:\"image_original\"`\n+}\n+\n+type userResponseFull struct {\n+\tMembers []User `json:\"members,omitempty\"`\n+\tUser    `json:\"user,omitempty\"`\n+\tUsers   []User `json:\"users,omitempty\"`\n+\tUserPresence\n+\tSlackResponse\n+\tMetadata ResponseMetadata `json:\"response_metadata\"`\n+}\n+\n+type UserSetPhotoParams struct {\n+\tCropX int\n+\tCropY int\n+\tCropW int\n+}\n+\n+func NewUserSetPhotoParams() UserSetPhotoParams {\n+\treturn UserSetPhotoParams{\n+\t\tCropX: DEFAULT_USER_PHOTO_CROP_X,\n+\t\tCropY: DEFAULT_USER_PHOTO_CROP_Y,\n+\t\tCropW: DEFAULT_USER_PHOTO_CROP_W,\n+\t}\n+}\n+\n+func (api *Client) userRequest(ctx context.Context, path string, values url.Values) (*userResponseFull, error) {\n+\tresponse := &userResponseFull{}\n+\terr := api.postMethod(ctx, path, values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, response.Err()\n+}\n+\n+// GetUserPresence will retrieve the current presence status of given user.\n+func (api *Client) GetUserPresence(user string) (*UserPresence, error) {\n+\treturn api.GetUserPresenceContext(context.Background(), user)\n+}\n+\n+// GetUserPresenceContext will retrieve the current presence status of given user with a custom context.\n+func (api *Client) GetUserPresenceContext(ctx context.Context, user string) (*UserPresence, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"user\":  {user},\n+\t}\n+\n+\tresponse, err := api.userRequest(ctx, \"users.getPresence\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.UserPresence, nil\n+}\n+\n+// GetUserInfo will retrieve the complete user information\n+func (api *Client) GetUserInfo(user string) (*User, error) {\n+\treturn api.GetUserInfoContext(context.Background(), user)\n+}\n+\n+// GetUserInfoContext will retrieve the complete user information with a custom context\n+func (api *Client) GetUserInfoContext(ctx context.Context, user string) (*User, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":          {api.token},\n+\t\t\"user\":           {user},\n+\t\t\"include_locale\": {strconv.FormatBool(true)},\n+\t}\n+\n+\tresponse, err := api.userRequest(ctx, \"users.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.User, nil\n+}\n+\n+// GetUsersInfo will retrieve the complete multi-users information\n+func (api *Client) GetUsersInfo(users ...string) (*[]User, error) {\n+\treturn api.GetUsersInfoContext(context.Background(), users...)\n+}\n+\n+// GetUsersInfoContext will retrieve the complete multi-users information with a custom context\n+func (api *Client) GetUsersInfoContext(ctx context.Context, users ...string) (*[]User, error) {\n+\tvalues := url.Values{\n+\t\t\"token\":          {api.token},\n+\t\t\"users\":          {strings.Join(users, \",\")},\n+\t\t\"include_locale\": {strconv.FormatBool(true)},\n+\t}\n+\n+\tresponse, err := api.userRequest(ctx, \"users.info\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.Users, nil\n+}\n+\n+// GetUsersOption options for the GetUsers method call.\n+type GetUsersOption func(*UserPagination)\n+\n+// GetUsersOptionLimit limit the number of users returned\n+func GetUsersOptionLimit(n int) GetUsersOption {\n+\treturn func(p *UserPagination) {\n+\t\tp.limit = n\n+\t}\n+}\n+\n+// GetUsersOptionPresence include user presence\n+func GetUsersOptionPresence(n bool) GetUsersOption {\n+\treturn func(p *UserPagination) {\n+\t\tp.presence = n\n+\t}\n+}\n+\n+func newUserPagination(c *Client, options ...GetUsersOption) (up UserPagination) {\n+\tup = UserPagination{\n+\t\tc:     c,\n+\t\tlimit: 200, // per slack api documentation.\n+\t}\n+\n+\tfor _, opt := range options {\n+\t\topt(&up)\n+\t}\n+\n+\treturn up\n+}\n+\n+// UserPagination allows for paginating over the users\n+type UserPagination struct {\n+\tUsers        []User\n+\tlimit        int\n+\tpresence     bool\n+\tpreviousResp *ResponseMetadata\n+\tc            *Client\n+}\n+\n+// Done checks if the pagination has completed\n+func (UserPagination) Done(err error) bool {\n+\treturn err == errPaginationComplete\n+}\n+\n+// Failure checks if pagination failed.\n+func (t UserPagination) Failure(err error) error {\n+\tif t.Done(err) {\n+\t\treturn nil\n+\t}\n+\n+\treturn err\n+}\n+\n+func (t UserPagination) Next(ctx context.Context) (_ UserPagination, err error) {\n+\tvar (\n+\t\tresp *userResponseFull\n+\t)\n+\n+\tif t.c == nil || (t.previousResp != nil && t.previousResp.Cursor == \"\") {\n+\t\treturn t, errPaginationComplete\n+\t}\n+\n+\tt.previousResp = t.previousResp.initialize()\n+\n+\tvalues := url.Values{\n+\t\t\"limit\":          {strconv.Itoa(t.limit)},\n+\t\t\"presence\":       {strconv.FormatBool(t.presence)},\n+\t\t\"token\":          {t.c.token},\n+\t\t\"cursor\":         {t.previousResp.Cursor},\n+\t\t\"include_locale\": {strconv.FormatBool(true)},\n+\t}\n+\n+\tif resp, err = t.c.userRequest(ctx, \"users.list\", values); err != nil {\n+\t\treturn t, err\n+\t}\n+\n+\tt.c.Debugf(\"GetUsersContext: got %d users; metadata %v\", len(resp.Members), resp.Metadata)\n+\tt.Users = resp.Members\n+\tt.previousResp = &resp.Metadata\n+\n+\treturn t, nil\n+}\n+\n+// GetUsersPaginated fetches users in a paginated fashion, see GetUsersContext for usage.\n+func (api *Client) GetUsersPaginated(options ...GetUsersOption) UserPagination {\n+\treturn newUserPagination(api, options...)\n+}\n+\n+// GetUsers returns the list of users (with their detailed information)\n+func (api *Client) GetUsers() ([]User, error) {\n+\treturn api.GetUsersContext(context.Background())\n+}\n+\n+// GetUsersContext returns the list of users (with their detailed information) with a custom context\n+func (api *Client) GetUsersContext(ctx context.Context) (results []User, err error) {\n+\tp := api.GetUsersPaginated()\n+\tfor err == nil {\n+\t\tp, err = p.Next(ctx)\n+\t\tif err == nil {\n+\t\t\tresults = append(results, p.Users...)\n+\t\t} else if rateLimitedError, ok := err.(*RateLimitedError); ok {\n+\t\t\tselect {\n+\t\t\tcase <-ctx.Done():\n+\t\t\t\terr = ctx.Err()\n+\t\t\tcase <-time.After(rateLimitedError.RetryAfter):\n+\t\t\t\terr = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn results, p.Failure(err)\n+}\n+\n+// GetUserByEmail will retrieve the complete user information by email\n+func (api *Client) GetUserByEmail(email string) (*User, error) {\n+\treturn api.GetUserByEmailContext(context.Background(), email)\n+}\n+\n+// GetUserByEmailContext will retrieve the complete user information by email with a custom context\n+func (api *Client) GetUserByEmailContext(ctx context.Context, email string) (*User, error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t\t\"email\": {email},\n+\t}\n+\tresponse, err := api.userRequest(ctx, \"users.lookupByEmail\", values)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &response.User, nil\n+}\n+\n+// SetUserAsActive marks the currently authenticated user as active\n+func (api *Client) SetUserAsActive() error {\n+\treturn api.SetUserAsActiveContext(context.Background())\n+}\n+\n+// SetUserAsActiveContext marks the currently authenticated user as active with a custom context\n+func (api *Client) SetUserAsActiveContext(ctx context.Context) (err error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\t_, err = api.userRequest(ctx, \"users.setActive\", values)\n+\treturn err\n+}\n+\n+// SetUserPresence changes the currently authenticated user presence\n+func (api *Client) SetUserPresence(presence string) error {\n+\treturn api.SetUserPresenceContext(context.Background(), presence)\n+}\n+\n+// SetUserPresenceContext changes the currently authenticated user presence with a custom context\n+func (api *Client) SetUserPresenceContext(ctx context.Context, presence string) error {\n+\tvalues := url.Values{\n+\t\t\"token\":    {api.token},\n+\t\t\"presence\": {presence},\n+\t}\n+\n+\t_, err := api.userRequest(ctx, \"users.setPresence\", values)\n+\treturn err\n+}\n+\n+// GetUserIdentity will retrieve user info available per identity scopes\n+func (api *Client) GetUserIdentity() (*UserIdentityResponse, error) {\n+\treturn api.GetUserIdentityContext(context.Background())\n+}\n+\n+// GetUserIdentityContext will retrieve user info available per identity scopes with a custom context\n+func (api *Client) GetUserIdentityContext(ctx context.Context) (response *UserIdentityResponse, err error) {\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tresponse = &UserIdentityResponse{}\n+\n+\terr = api.postMethod(ctx, \"users.identity\", values, response)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := response.Err(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn response, nil\n+}\n+\n+// SetUserPhoto changes the currently authenticated user's profile image\n+func (api *Client) SetUserPhoto(image string, params UserSetPhotoParams) error {\n+\treturn api.SetUserPhotoContext(context.Background(), image, params)\n+}\n+\n+// SetUserPhotoContext changes the currently authenticated user's profile image using a custom context\n+func (api *Client) SetUserPhotoContext(ctx context.Context, image string, params UserSetPhotoParams) (err error) {\n+\tresponse := &SlackResponse{}\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\tif params.CropX != DEFAULT_USER_PHOTO_CROP_X {\n+\t\tvalues.Add(\"crop_x\", strconv.Itoa(params.CropX))\n+\t}\n+\tif params.CropY != DEFAULT_USER_PHOTO_CROP_Y {\n+\t\tvalues.Add(\"crop_y\", strconv.Itoa(params.CropX))\n+\t}\n+\tif params.CropW != DEFAULT_USER_PHOTO_CROP_W {\n+\t\tvalues.Add(\"crop_w\", strconv.Itoa(params.CropW))\n+\t}\n+\n+\terr = postLocalWithMultipartResponse(ctx, api.httpclient, api.endpoint+\"users.setPhoto\", image, \"image\", values, response, api)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// DeleteUserPhoto deletes the current authenticated user's profile image\n+func (api *Client) DeleteUserPhoto() error {\n+\treturn api.DeleteUserPhotoContext(context.Background())\n+}\n+\n+// DeleteUserPhotoContext deletes the current authenticated user's profile image with a custom context\n+func (api *Client) DeleteUserPhotoContext(ctx context.Context) (err error) {\n+\tresponse := &SlackResponse{}\n+\tvalues := url.Values{\n+\t\t\"token\": {api.token},\n+\t}\n+\n+\terr = api.postMethod(ctx, \"users.deletePhoto\", values, response)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// SetUserRealName changes the currently authenticated user's realName\n+//\n+// For more information see SetUserRealNameContextWithUser\n+func (api *Client) SetUserRealName(realName string) error {\n+\treturn api.SetUserRealNameContextWithUser(context.Background(), \"\", realName)\n+}\n+\n+// SetUserRealNameContextWithUser will set a real name for the provided user with a custom context\n+func (api *Client) SetUserRealNameContextWithUser(ctx context.Context, user, realName string) error {\n+\tprofile, err := json.Marshal(\n+\t\t&struct {\n+\t\t\tRealName string `json:\"real_name\"`\n+\t\t}{\n+\t\t\tRealName: realName,\n+\t\t},\n+\t)\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"profile\": {string(profile)},\n+\t}\n+\n+\t// optional field. It should not be set if empty\n+\tif user != \"\" {\n+\t\tvalues[\"user\"] = []string{user}\n+\t}\n+\n+\tresponse := &userResponseFull{}\n+\tif err = api.postMethod(ctx, \"users.profile.set\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// SetUserCustomStatus will set a custom status and emoji for the currently\n+// authenticated user. If statusEmoji is \"\" and statusText is not, the Slack API\n+// will automatically set it to \":speech_balloon:\". Otherwise, if both are \"\"\n+// the Slack API will unset the custom status/emoji. If statusExpiration is set to 0\n+// the status will not expire.\n+func (api *Client) SetUserCustomStatus(statusText, statusEmoji string, statusExpiration int64) error {\n+\treturn api.SetUserCustomStatusContextWithUser(context.Background(), \"\", statusText, statusEmoji, statusExpiration)\n+}\n+\n+// SetUserCustomStatusContext will set a custom status and emoji for the currently authenticated user with a custom context\n+//\n+// For more information see SetUserCustomStatus\n+func (api *Client) SetUserCustomStatusContext(ctx context.Context, statusText, statusEmoji string, statusExpiration int64) error {\n+\treturn api.SetUserCustomStatusContextWithUser(ctx, \"\", statusText, statusEmoji, statusExpiration)\n+}\n+\n+// SetUserCustomStatusWithUser will set a custom status and emoji for the provided user.\n+//\n+// For more information see SetUserCustomStatus\n+func (api *Client) SetUserCustomStatusWithUser(user, statusText, statusEmoji string, statusExpiration int64) error {\n+\treturn api.SetUserCustomStatusContextWithUser(context.Background(), user, statusText, statusEmoji, statusExpiration)\n+}\n+\n+// SetUserCustomStatusContextWithUser will set a custom status and emoji for the provided user with a custom context\n+//\n+// For more information see SetUserCustomStatus\n+func (api *Client) SetUserCustomStatusContextWithUser(ctx context.Context, user, statusText, statusEmoji string, statusExpiration int64) error {\n+\t// XXX(theckman): this anonymous struct is for making requests to the Slack\n+\t// API for setting and unsetting a User's Custom Status/Emoji. To change\n+\t// these values we must provide a JSON document as the profile POST field.\n+\t//\n+\t// We use an anonymous struct over UserProfile because to unset the values\n+\t// on the User's profile we cannot use the `json:\"omitempty\"` tag. This is\n+\t// because an empty string (\"\") is what's used to unset the values. Check\n+\t// out the API docs for more details:\n+\t//\n+\t// - https://api.slack.com/docs/presence-and-status#custom_status\n+\tprofile, err := json.Marshal(\n+\t\t&struct {\n+\t\t\tStatusText       string `json:\"status_text\"`\n+\t\t\tStatusEmoji      string `json:\"status_emoji\"`\n+\t\t\tStatusExpiration int64  `json:\"status_expiration\"`\n+\t\t}{\n+\t\t\tStatusText:       statusText,\n+\t\t\tStatusEmoji:      statusEmoji,\n+\t\t\tStatusExpiration: statusExpiration,\n+\t\t},\n+\t)\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvalues := url.Values{\n+\t\t\"token\":   {api.token},\n+\t\t\"profile\": {string(profile)},\n+\t}\n+\n+\t// optional field. It should not be set if empty\n+\tif user != \"\" {\n+\t\tvalues[\"user\"] = []string{user}\n+\t}\n+\n+\tresponse := &userResponseFull{}\n+\tif err = api.postMethod(ctx, \"users.profile.set\", values, response); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn response.Err()\n+}\n+\n+// UnsetUserCustomStatus removes the custom status message for the currently\n+// authenticated user. This is a convenience method that wraps (*Client).SetUserCustomStatus().\n+func (api *Client) UnsetUserCustomStatus() error {\n+\treturn api.UnsetUserCustomStatusContext(context.Background())\n+}\n+\n+// UnsetUserCustomStatusContext removes the custom status message for the currently authenticated user\n+// with a custom context. This is a convenience method that wraps (*Client).SetUserCustomStatus().\n+func (api *Client) UnsetUserCustomStatusContext(ctx context.Context) error {\n+\treturn api.SetUserCustomStatusContext(ctx, \"\", \"\", 0)\n+}\n+\n+// GetUserProfile retrieves a user's profile information.\n+func (api *Client) GetUserProfile(userID string, includeLabels bool) (*UserProfile, error) {\n+\treturn api.GetUserProfileContext(context.Background(), userID, includeLabels)\n+}\n+\n+type getUserProfileResponse struct {\n+\tSlackResponse\n+\tProfile *UserProfile `json:\"profile\"`\n+}\n+\n+// GetUserProfileContext retrieves a user's profile information with a context.\n+func (api *Client) GetUserProfileContext(ctx context.Context, userID string, includeLabels bool) (*UserProfile, error) {\n+\tvalues := url.Values{\"token\": {api.token}}\n+\tif includeLabels {\n+\t\tvalues.Add(\"include_labels\", \"true\")\n+\t}\n+\tif userID != \"\" {\n+\t\tvalues.Add(\"user\", userID)\n+\t}\n+\tresp := &getUserProfileResponse{}\n+\n+\terr := api.postMethod(ctx, \"users.profile.get\", values, &resp)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif err := resp.Err(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn resp.Profile, nil\n+}"
    },
    {
      "sha": "ee197ad84e6af5906f6d1ee1af4b747b43c4d52b",
      "filename": "backend/vendor/github.com/slack-go/slack/views.go",
      "status": "added",
      "additions": 297,
      "deletions": 0,
      "changes": 297,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/views.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/views.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/views.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,297 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"encoding/json\"\n+)\n+\n+const (\n+\tVTModal   ViewType = \"modal\"\n+\tVTHomeTab ViewType = \"home\"\n+)\n+\n+type ViewType string\n+\n+type ViewState struct {\n+\tValues map[string]map[string]BlockAction `json:\"values\"`\n+}\n+\n+type View struct {\n+\tSlackResponse\n+\tID              string           `json:\"id\"`\n+\tTeamID          string           `json:\"team_id\"`\n+\tType            ViewType         `json:\"type\"`\n+\tTitle           *TextBlockObject `json:\"title\"`\n+\tClose           *TextBlockObject `json:\"close\"`\n+\tSubmit          *TextBlockObject `json:\"submit\"`\n+\tBlocks          Blocks           `json:\"blocks\"`\n+\tPrivateMetadata string           `json:\"private_metadata\"`\n+\tCallbackID      string           `json:\"callback_id\"`\n+\tState           *ViewState       `json:\"state\"`\n+\tHash            string           `json:\"hash\"`\n+\tClearOnClose    bool             `json:\"clear_on_close\"`\n+\tNotifyOnClose   bool             `json:\"notify_on_close\"`\n+\tRootViewID      string           `json:\"root_view_id\"`\n+\tPreviousViewID  string           `json:\"previous_view_id\"`\n+\tAppID           string           `json:\"app_id\"`\n+\tExternalID      string           `json:\"external_id\"`\n+\tBotID           string           `json:\"bot_id\"`\n+}\n+\n+type ViewSubmissionCallback struct {\n+\tHash string `json:\"hash\"`\n+}\n+\n+type ViewClosedCallback struct {\n+\tIsCleared bool `json:\"is_cleared\"`\n+}\n+\n+const (\n+\tRAClear  ViewResponseAction = \"clear\"\n+\tRAUpdate ViewResponseAction = \"update\"\n+\tRAPush   ViewResponseAction = \"push\"\n+\tRAErrors ViewResponseAction = \"errors\"\n+)\n+\n+type ViewResponseAction string\n+\n+type ViewSubmissionResponse struct {\n+\tResponseAction ViewResponseAction `json:\"response_action\"`\n+\tView           *ModalViewRequest  `json:\"view,omitempty\"`\n+\tErrors         map[string]string  `json:\"errors,omitempty\"`\n+}\n+\n+func NewClearViewSubmissionResponse() *ViewSubmissionResponse {\n+\treturn &ViewSubmissionResponse{\n+\t\tResponseAction: RAClear,\n+\t}\n+}\n+\n+func NewUpdateViewSubmissionResponse(view *ModalViewRequest) *ViewSubmissionResponse {\n+\treturn &ViewSubmissionResponse{\n+\t\tResponseAction: RAUpdate,\n+\t\tView:           view,\n+\t}\n+}\n+\n+func NewPushViewSubmissionResponse(view *ModalViewRequest) *ViewSubmissionResponse {\n+\treturn &ViewSubmissionResponse{\n+\t\tResponseAction: RAPush,\n+\t\tView:           view,\n+\t}\n+}\n+\n+func NewErrorsViewSubmissionResponse(errors map[string]string) *ViewSubmissionResponse {\n+\treturn &ViewSubmissionResponse{\n+\t\tResponseAction: RAErrors,\n+\t\tErrors:         errors,\n+\t}\n+}\n+\n+type ModalViewRequest struct {\n+\tType            ViewType         `json:\"type\"`\n+\tTitle           *TextBlockObject `json:\"title\"`\n+\tBlocks          Blocks           `json:\"blocks\"`\n+\tClose           *TextBlockObject `json:\"close,omitempty\"`\n+\tSubmit          *TextBlockObject `json:\"submit,omitempty\"`\n+\tPrivateMetadata string           `json:\"private_metadata,omitempty\"`\n+\tCallbackID      string           `json:\"callback_id,omitempty\"`\n+\tClearOnClose    bool             `json:\"clear_on_close,omitempty\"`\n+\tNotifyOnClose   bool             `json:\"notify_on_close,omitempty\"`\n+\tExternalID      string           `json:\"external_id,omitempty\"`\n+}\n+\n+func (v *ModalViewRequest) ViewType() ViewType {\n+\treturn v.Type\n+}\n+\n+type HomeTabViewRequest struct {\n+\tType            ViewType `json:\"type\"`\n+\tBlocks          Blocks   `json:\"blocks\"`\n+\tPrivateMetadata string   `json:\"private_metadata,omitempty\"`\n+\tCallbackID      string   `json:\"callback_id,omitempty\"`\n+\tExternalID      string   `json:\"external_id,omitempty\"`\n+}\n+\n+func (v *HomeTabViewRequest) ViewType() ViewType {\n+\treturn v.Type\n+}\n+\n+type openViewRequest struct {\n+\tTriggerID string           `json:\"trigger_id\"`\n+\tView      ModalViewRequest `json:\"view\"`\n+}\n+\n+type publishViewRequest struct {\n+\tUserID string             `json:\"user_id\"`\n+\tView   HomeTabViewRequest `json:\"view\"`\n+\tHash   string             `json:\"hash,omitempty\"`\n+}\n+\n+type pushViewRequest struct {\n+\tTriggerID string           `json:\"trigger_id\"`\n+\tView      ModalViewRequest `json:\"view\"`\n+}\n+\n+type updateViewRequest struct {\n+\tView       ModalViewRequest `json:\"view\"`\n+\tExternalID string           `json:\"external_id,omitempty\"`\n+\tHash       string           `json:\"hash,omitempty\"`\n+\tViewID     string           `json:\"view_id,omitempty\"`\n+}\n+\n+type ViewResponse struct {\n+\tSlackResponse\n+\tView `json:\"view\"`\n+}\n+\n+// OpenView opens a view for a user.\n+func (api *Client) OpenView(triggerID string, view ModalViewRequest) (*ViewResponse, error) {\n+\treturn api.OpenViewContext(context.Background(), triggerID, view)\n+}\n+\n+// ValidateUniqueBlockID will verify if each input block has a unique block ID if set\n+func ValidateUniqueBlockID(view ModalViewRequest) bool {\n+\n+\tuniqueBlockID := map[string]bool{}\n+\n+\tfor _, b := range view.Blocks.BlockSet {\n+\t\tif inputBlock, ok := b.(*InputBlock); ok {\n+\t\t\tif _, ok := uniqueBlockID[inputBlock.BlockID]; ok {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tuniqueBlockID[inputBlock.BlockID] = true\n+\t\t}\n+\t}\n+\n+\treturn true\n+}\n+\n+// OpenViewContext opens a view for a user with a custom context.\n+func (api *Client) OpenViewContext(\n+\tctx context.Context,\n+\ttriggerID string,\n+\tview ModalViewRequest,\n+) (*ViewResponse, error) {\n+\tif triggerID == \"\" {\n+\t\treturn nil, ErrParametersMissing\n+\t}\n+\n+\tif !ValidateUniqueBlockID(view) {\n+\t\treturn nil, ErrBlockIDNotUnique\n+\t}\n+\n+\treq := openViewRequest{\n+\t\tTriggerID: triggerID,\n+\t\tView:      view,\n+\t}\n+\tencoded, err := json.Marshal(req)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tendpoint := api.endpoint + \"views.open\"\n+\tresp := &ViewResponse{}\n+\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn resp, resp.Err()\n+}\n+\n+// PublishView publishes a static view for a user.\n+func (api *Client) PublishView(userID string, view HomeTabViewRequest, hash string) (*ViewResponse, error) {\n+\treturn api.PublishViewContext(context.Background(), userID, view, hash)\n+}\n+\n+// PublishViewContext publishes a static view for a user with a custom context.\n+func (api *Client) PublishViewContext(\n+\tctx context.Context,\n+\tuserID string,\n+\tview HomeTabViewRequest,\n+\thash string,\n+) (*ViewResponse, error) {\n+\tif userID == \"\" {\n+\t\treturn nil, ErrParametersMissing\n+\t}\n+\treq := publishViewRequest{\n+\t\tUserID: userID,\n+\t\tView:   view,\n+\t\tHash:   hash,\n+\t}\n+\tencoded, err := json.Marshal(req)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tendpoint := api.endpoint + \"views.publish\"\n+\tresp := &ViewResponse{}\n+\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn resp, resp.Err()\n+}\n+\n+// PushView pushes a view onto the stack of a root view.\n+func (api *Client) PushView(triggerID string, view ModalViewRequest) (*ViewResponse, error) {\n+\treturn api.PushViewContext(context.Background(), triggerID, view)\n+}\n+\n+// PublishViewContext pushes a view onto the stack of a root view with a custom context.\n+func (api *Client) PushViewContext(\n+\tctx context.Context,\n+\ttriggerID string,\n+\tview ModalViewRequest,\n+) (*ViewResponse, error) {\n+\tif triggerID == \"\" {\n+\t\treturn nil, ErrParametersMissing\n+\t}\n+\treq := pushViewRequest{\n+\t\tTriggerID: triggerID,\n+\t\tView:      view,\n+\t}\n+\tencoded, err := json.Marshal(req)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tendpoint := api.endpoint + \"views.push\"\n+\tresp := &ViewResponse{}\n+\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn resp, resp.Err()\n+}\n+\n+// UpdateView updates an existing view.\n+func (api *Client) UpdateView(view ModalViewRequest, externalID, hash, viewID string) (*ViewResponse, error) {\n+\treturn api.UpdateViewContext(context.Background(), view, externalID, hash, viewID)\n+}\n+\n+// UpdateViewContext updates an existing view with a custom context.\n+func (api *Client) UpdateViewContext(\n+\tctx context.Context,\n+\tview ModalViewRequest,\n+\texternalID, hash,\n+\tviewID string,\n+) (*ViewResponse, error) {\n+\tif externalID == \"\" && viewID == \"\" {\n+\t\treturn nil, ErrParametersMissing\n+\t}\n+\treq := updateViewRequest{\n+\t\tView:       view,\n+\t\tExternalID: externalID,\n+\t\tHash:       hash,\n+\t\tViewID:     viewID,\n+\t}\n+\tencoded, err := json.Marshal(req)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tendpoint := api.endpoint + \"views.update\"\n+\tresp := &ViewResponse{}\n+\terr = postJSON(ctx, api.httpclient, endpoint, api.token, encoded, resp, api)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn resp, resp.Err()\n+}"
    },
    {
      "sha": "39fff441e738483ea4deca955263dd44d4e6eca3",
      "filename": "backend/vendor/github.com/slack-go/slack/webhooks.go",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/webhooks.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/webhooks.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/webhooks.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,30 @@\n+package slack\n+\n+import (\n+\t\"context\"\n+\t\"net/http\"\n+)\n+\n+type WebhookMessage struct {\n+\tUsername        string       `json:\"username,omitempty\"`\n+\tIconEmoji       string       `json:\"icon_emoji,omitempty\"`\n+\tIconURL         string       `json:\"icon_url,omitempty\"`\n+\tChannel         string       `json:\"channel,omitempty\"`\n+\tThreadTimestamp string       `json:\"thread_ts,omitempty\"`\n+\tText            string       `json:\"text,omitempty\"`\n+\tAttachments     []Attachment `json:\"attachments,omitempty\"`\n+\tParse           string       `json:\"parse,omitempty\"`\n+\tBlocks          *Blocks      `json:\"blocks,omitempty\"`\n+}\n+\n+func PostWebhook(url string, msg *WebhookMessage) error {\n+\treturn PostWebhookCustomHTTPContext(context.Background(), url, http.DefaultClient, msg)\n+}\n+\n+func PostWebhookContext(ctx context.Context, url string, msg *WebhookMessage) error {\n+\treturn PostWebhookCustomHTTPContext(ctx, url, http.DefaultClient, msg)\n+}\n+\n+func PostWebhookCustomHTTP(url string, httpClient *http.Client, msg *WebhookMessage) error {\n+\treturn PostWebhookCustomHTTPContext(context.Background(), url, httpClient, msg)\n+}"
    },
    {
      "sha": "4e0db0e41721240246ac1e911752d76411baa15e",
      "filename": "backend/vendor/github.com/slack-go/slack/webhooks_go112.go",
      "status": "added",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/webhooks_go112.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/webhooks_go112.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/webhooks_go112.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,34 @@\n+// +build !go1.13\n+\n+package slack\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"net/http\"\n+\n+\t\"github.com/pkg/errors\"\n+)\n+\n+func PostWebhookCustomHTTPContext(ctx context.Context, url string, httpClient *http.Client, msg *WebhookMessage) error {\n+\traw, err := json.Marshal(msg)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"marshal failed\")\n+\t}\n+\n+\treq, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(raw))\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed new request\")\n+\t}\n+\treq = req.WithContext(ctx)\n+\treq.Header.Set(\"Content-Type\", \"application/json\")\n+\n+\tresp, err := httpClient.Do(req)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed to post webhook\")\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\treturn checkStatusCode(resp, discard{})\n+}"
    },
    {
      "sha": "99c243f595857f7f7518d59166cb9da91ffce475",
      "filename": "backend/vendor/github.com/slack-go/slack/webhooks_go113.go",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/webhooks_go113.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/webhooks_go113.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/webhooks_go113.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,33 @@\n+// +build go1.13\n+\n+package slack\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/json\"\n+\t\"net/http\"\n+\n+\t\"github.com/pkg/errors\"\n+)\n+\n+func PostWebhookCustomHTTPContext(ctx context.Context, url string, httpClient *http.Client, msg *WebhookMessage) error {\n+\traw, err := json.Marshal(msg)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"marshal failed\")\n+\t}\n+\n+\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(raw))\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed new request\")\n+\t}\n+\treq.Header.Set(\"Content-Type\", \"application/json\")\n+\n+\tresp, err := httpClient.Do(req)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed to post webhook\")\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\treturn checkStatusCode(resp, discard{})\n+}"
    },
    {
      "sha": "d6895f2aa90be2bc41f3a2b83713f6633e9dfd3f",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket.go",
      "status": "added",
      "additions": 103,
      "deletions": 0,
      "changes": 103,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,103 @@\n+package slack\n+\n+import (\n+\t\"net/url\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gorilla/websocket\"\n+)\n+\n+const (\n+\t// MaxMessageTextLength is the current maximum message length in number of characters as defined here\n+\t// https://api.slack.com/rtm#limits\n+\tMaxMessageTextLength = 4000\n+)\n+\n+// RTM represents a managed websocket connection. It also supports\n+// all the methods of the `Client` type.\n+//\n+// Create this element with Client's NewRTM() or NewRTMWithOptions(*RTMOptions)\n+type RTM struct {\n+\t// Client is the main API, embedded\n+\tClient\n+\n+\tidGen        IDGenerator\n+\tpingInterval time.Duration\n+\tpingDeadman  *time.Timer\n+\n+\t// Connection life-cycle\n+\tconn             *websocket.Conn\n+\tIncomingEvents   chan RTMEvent\n+\toutgoingMessages chan OutgoingMessage\n+\tkillChannel      chan bool\n+\tdisconnected     chan struct{}\n+\tdisconnectedm    *sync.Once\n+\tforcePing        chan bool\n+\n+\t// UserDetails upon connection\n+\tinfo *Info\n+\n+\t// useRTMStart should be set to true if you want to use\n+\t// rtm.start to connect to Slack, otherwise it will use\n+\t// rtm.connect\n+\tuseRTMStart bool\n+\n+\t// dialer is a gorilla/websocket Dialer. If nil, use the default\n+\t// Dialer.\n+\tdialer *websocket.Dialer\n+\n+\t// mu is mutex used to prevent RTM connection race conditions\n+\tmu *sync.Mutex\n+\n+\t// connParams is a map of flags for connection parameters.\n+\tconnParams url.Values\n+}\n+\n+// signal that we are disconnected by closing the channel.\n+// protect it with a mutex to ensure it only happens once.\n+func (rtm *RTM) disconnect() {\n+\trtm.disconnectedm.Do(func() {\n+\t\tclose(rtm.disconnected)\n+\t})\n+}\n+\n+// Disconnect and wait, blocking until a successful disconnection.\n+func (rtm *RTM) Disconnect() error {\n+\t// always push into the kill channel when invoked,\n+\t// this lets the ManagedConnection() function properly clean up.\n+\t// if the buffer is full then just continue on.\n+\tselect {\n+\tcase rtm.killChannel <- true:\n+\t\treturn nil\n+\tcase <-rtm.disconnected:\n+\t\treturn ErrAlreadyDisconnected\n+\t}\n+}\n+\n+// GetInfo returns the info structure received when calling\n+// \"startrtm\", holding metadata needed to implement a full\n+// chat client. It will be non-nil after a call to StartRTM().\n+func (rtm *RTM) GetInfo() *Info {\n+\treturn rtm.info\n+}\n+\n+// SendMessage submits a simple message through the websocket.  For\n+// more complicated messages, use `rtm.PostMessage` with a complete\n+// struct describing your attachments and all.\n+func (rtm *RTM) SendMessage(msg *OutgoingMessage) {\n+\tif msg == nil {\n+\t\trtm.Debugln(\"Error: Attempted to SendMessage(nil)\")\n+\t\treturn\n+\t}\n+\n+\trtm.outgoingMessages <- *msg\n+}\n+\n+func (rtm *RTM) resetDeadman() {\n+\trtm.pingDeadman.Reset(deadmanDuration(rtm.pingInterval))\n+}\n+\n+func deadmanDuration(d time.Duration) time.Duration {\n+\treturn d * 4\n+}"
    },
    {
      "sha": "fe274fd701732c8b5086dc320c1160658e4fcf9d",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_channels.go",
      "status": "added",
      "additions": 72,
      "deletions": 0,
      "changes": 72,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_channels.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_channels.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_channels.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,72 @@\n+package slack\n+\n+// ChannelCreatedEvent represents the Channel created event\n+type ChannelCreatedEvent struct {\n+\tType           string             `json:\"type\"`\n+\tChannel        ChannelCreatedInfo `json:\"channel\"`\n+\tEventTimestamp string             `json:\"event_ts\"`\n+}\n+\n+// ChannelCreatedInfo represents the information associated with the Channel created event\n+type ChannelCreatedInfo struct {\n+\tID        string `json:\"id\"`\n+\tIsChannel bool   `json:\"is_channel\"`\n+\tName      string `json:\"name\"`\n+\tCreated   int    `json:\"created\"`\n+\tCreator   string `json:\"creator\"`\n+}\n+\n+// ChannelJoinedEvent represents the Channel joined event\n+type ChannelJoinedEvent struct {\n+\tType    string  `json:\"type\"`\n+\tChannel Channel `json:\"channel\"`\n+}\n+\n+// ChannelInfoEvent represents the Channel info event\n+type ChannelInfoEvent struct {\n+\t// channel_left\n+\t// channel_deleted\n+\t// channel_archive\n+\t// channel_unarchive\n+\tType      string `json:\"type\"`\n+\tChannel   string `json:\"channel\"`\n+\tUser      string `json:\"user,omitempty\"`\n+\tTimestamp string `json:\"ts,omitempty\"`\n+}\n+\n+// ChannelRenameEvent represents the Channel rename event\n+type ChannelRenameEvent struct {\n+\tType      string            `json:\"type\"`\n+\tChannel   ChannelRenameInfo `json:\"channel\"`\n+\tTimestamp string            `json:\"event_ts\"`\n+}\n+\n+// ChannelRenameInfo represents the information associated with a Channel rename event\n+type ChannelRenameInfo struct {\n+\tID      string `json:\"id\"`\n+\tName    string `json:\"name\"`\n+\tCreated int    `json:\"created\"`\n+}\n+\n+// ChannelHistoryChangedEvent represents the Channel history changed event\n+type ChannelHistoryChangedEvent struct {\n+\tType           string `json:\"type\"`\n+\tLatest         string `json:\"latest\"`\n+\tTimestamp      string `json:\"ts\"`\n+\tEventTimestamp string `json:\"event_ts\"`\n+}\n+\n+// ChannelMarkedEvent represents the Channel marked event\n+type ChannelMarkedEvent ChannelInfoEvent\n+\n+// ChannelLeftEvent represents the Channel left event\n+type ChannelLeftEvent ChannelInfoEvent\n+\n+// ChannelDeletedEvent represents the Channel deleted event\n+type ChannelDeletedEvent ChannelInfoEvent\n+\n+// ChannelArchiveEvent represents the Channel archive event\n+type ChannelArchiveEvent ChannelInfoEvent\n+\n+// ChannelUnarchiveEvent represents the Channel unarchive event\n+type ChannelUnarchiveEvent ChannelInfoEvent"
    },
    {
      "sha": "7c61abf7d6d90308d5eb56159c315cc922bc6ee9",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_desktop_notification.go",
      "status": "added",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_desktop_notification.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_desktop_notification.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_desktop_notification.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,19 @@\n+package slack\n+\n+// DesktopNotificationEvent represents the update event for Desktop Notification.\n+type DesktopNotificationEvent struct {\n+\tType            string `json:\"type\"`\n+\tTitle           string `json:\"title\"`\n+\tSubtitle        string `json:\"subtitle\"`\n+\tMessage         string `json:\"msg\"`\n+\tTimestamp       string `json:\"ts\"`\n+\tContent         string `json:\"content\"`\n+\tChannel         string `json:\"channel\"`\n+\tLaunchURI       string `json:\"launchUri\"`\n+\tAvatarImage     string `json:\"avatarImage\"`\n+\tSsbFilename     string `json:\"ssbFilename\"`\n+\tImageURI        string `json:\"imageUri\"`\n+\tIsShared        bool   `json:\"is_shared\"`\n+\tIsChannelInvite bool   `json:\"is_channel_invite\"`\n+\tEventTimestamp  string `json:\"event_ts\"`\n+}"
    },
    {
      "sha": "98bf6f8854ee588b80892ceb3f6fce128eb5270d",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_dm.go",
      "status": "added",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_dm.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_dm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_dm.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,23 @@\n+package slack\n+\n+// IMCreatedEvent represents the IM created event\n+type IMCreatedEvent struct {\n+\tType    string             `json:\"type\"`\n+\tUser    string             `json:\"user\"`\n+\tChannel ChannelCreatedInfo `json:\"channel\"`\n+}\n+\n+// IMHistoryChangedEvent represents the IM history changed event\n+type IMHistoryChangedEvent ChannelHistoryChangedEvent\n+\n+// IMOpenEvent represents the IM open event\n+type IMOpenEvent ChannelInfoEvent\n+\n+// IMCloseEvent represents the IM close event\n+type IMCloseEvent ChannelInfoEvent\n+\n+// IMMarkedEvent represents the IM marked event\n+type IMMarkedEvent ChannelInfoEvent\n+\n+// IMMarkedHistoryChanged represents the IM marked history changed event\n+type IMMarkedHistoryChanged ChannelInfoEvent"
    },
    {
      "sha": "62ddea3a5acef478fae4e570cc2c18dc25c9c75a",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_dnd.go",
      "status": "added",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_dnd.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_dnd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_dnd.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,8 @@\n+package slack\n+\n+// DNDUpdatedEvent represents the update event for Do Not Disturb\n+type DNDUpdatedEvent struct {\n+\tType   string    `json:\"type\"`\n+\tUser   string    `json:\"user\"`\n+\tStatus DNDStatus `json:\"dnd_status\"`\n+}"
    },
    {
      "sha": "8c5bd4f8bfba7586a18232d9ff3221fa4d390bdd",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_files.go",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_files.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_files.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_files.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,49 @@\n+package slack\n+\n+// FileActionEvent represents the File action event\n+type fileActionEvent struct {\n+\tType           string `json:\"type\"`\n+\tEventTimestamp string `json:\"event_ts\"`\n+\tFile           File   `json:\"file\"`\n+\t// FileID is used for FileDeletedEvent\n+\tFileID string `json:\"file_id,omitempty\"`\n+}\n+\n+// FileCreatedEvent represents the File created event\n+type FileCreatedEvent fileActionEvent\n+\n+// FileSharedEvent represents the File shared event\n+type FileSharedEvent fileActionEvent\n+\n+// FilePublicEvent represents the File public event\n+type FilePublicEvent fileActionEvent\n+\n+// FileUnsharedEvent represents the File unshared event\n+type FileUnsharedEvent fileActionEvent\n+\n+// FileChangeEvent represents the File change event\n+type FileChangeEvent fileActionEvent\n+\n+// FileDeletedEvent represents the File deleted event\n+type FileDeletedEvent fileActionEvent\n+\n+// FilePrivateEvent represents the File private event\n+type FilePrivateEvent fileActionEvent\n+\n+// FileCommentAddedEvent represents the File comment added event\n+type FileCommentAddedEvent struct {\n+\tfileActionEvent\n+\tComment Comment `json:\"comment\"`\n+}\n+\n+// FileCommentEditedEvent represents the File comment edited event\n+type FileCommentEditedEvent struct {\n+\tfileActionEvent\n+\tComment Comment `json:\"comment\"`\n+}\n+\n+// FileCommentDeletedEvent represents the File comment deleted event\n+type FileCommentDeletedEvent struct {\n+\tfileActionEvent\n+\tComment string `json:\"comment\"`\n+}"
    },
    {
      "sha": "eb88985c45d06d95f4500cc7d2b460ef38416de0",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_groups.go",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_groups.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_groups.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_groups.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,49 @@\n+package slack\n+\n+// GroupCreatedEvent represents the Group created event\n+type GroupCreatedEvent struct {\n+\tType    string             `json:\"type\"`\n+\tUser    string             `json:\"user\"`\n+\tChannel ChannelCreatedInfo `json:\"channel\"`\n+}\n+\n+// XXX: Should we really do this? event.Group is probably nicer than event.Channel\n+// even though the api returns \"channel\"\n+\n+// GroupMarkedEvent represents the Group marked event\n+type GroupMarkedEvent ChannelInfoEvent\n+\n+// GroupOpenEvent represents the Group open event\n+type GroupOpenEvent ChannelInfoEvent\n+\n+// GroupCloseEvent represents the Group close event\n+type GroupCloseEvent ChannelInfoEvent\n+\n+// GroupArchiveEvent represents the Group archive event\n+type GroupArchiveEvent ChannelInfoEvent\n+\n+// GroupUnarchiveEvent represents the Group unarchive event\n+type GroupUnarchiveEvent ChannelInfoEvent\n+\n+// GroupLeftEvent represents the Group left event\n+type GroupLeftEvent ChannelInfoEvent\n+\n+// GroupJoinedEvent represents the Group joined event\n+type GroupJoinedEvent ChannelJoinedEvent\n+\n+// GroupRenameEvent represents the Group rename event\n+type GroupRenameEvent struct {\n+\tType      string          `json:\"type\"`\n+\tGroup     GroupRenameInfo `json:\"channel\"`\n+\tTimestamp string          `json:\"ts\"`\n+}\n+\n+// GroupRenameInfo represents the group info related to the renamed group\n+type GroupRenameInfo struct {\n+\tID      string `json:\"id\"`\n+\tName    string `json:\"name\"`\n+\tCreated string `json:\"created\"`\n+}\n+\n+// GroupHistoryChangedEvent represents the Group history changed event\n+type GroupHistoryChangedEvent ChannelHistoryChangedEvent"
    },
    {
      "sha": "454a21331a6d0279725694972c9423ae33898038",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_internals.go",
      "status": "added",
      "additions": 102,
      "deletions": 0,
      "changes": 102,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_internals.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_internals.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_internals.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,102 @@\n+package slack\n+\n+import (\n+\t\"fmt\"\n+\t\"time\"\n+)\n+\n+/**\n+ * Internal events, created by this lib and not mapped to Slack APIs.\n+ */\n+\n+// ConnectedEvent is used for when we connect to Slack\n+type ConnectedEvent struct {\n+\tConnectionCount int // 1 = first time, 2 = second time\n+\tInfo            *Info\n+}\n+\n+// ConnectionErrorEvent contains information about a connection error\n+type ConnectionErrorEvent struct {\n+\tAttempt  int\n+\tBackoff  time.Duration // how long we'll wait before the next attempt\n+\tErrorObj error\n+}\n+\n+func (c *ConnectionErrorEvent) Error() string {\n+\treturn c.ErrorObj.Error()\n+}\n+\n+// ConnectingEvent contains information about our connection attempt\n+type ConnectingEvent struct {\n+\tAttempt         int // 1 = first attempt, 2 = second attempt\n+\tConnectionCount int\n+}\n+\n+// DisconnectedEvent contains information about how we disconnected\n+type DisconnectedEvent struct {\n+\tIntentional bool\n+\tCause       error\n+}\n+\n+// LatencyReport contains information about connection latency\n+type LatencyReport struct {\n+\tValue time.Duration\n+}\n+\n+// InvalidAuthEvent is used in case we can't even authenticate with the API\n+type InvalidAuthEvent struct{}\n+\n+// UnmarshallingErrorEvent is used when there are issues deconstructing a response\n+type UnmarshallingErrorEvent struct {\n+\tErrorObj error\n+}\n+\n+func (u UnmarshallingErrorEvent) Error() string {\n+\treturn u.ErrorObj.Error()\n+}\n+\n+// MessageTooLongEvent is used when sending a message that is too long\n+type MessageTooLongEvent struct {\n+\tMessage   OutgoingMessage\n+\tMaxLength int\n+}\n+\n+func (m *MessageTooLongEvent) Error() string {\n+\treturn fmt.Sprintf(\"Message too long (max %d characters)\", m.MaxLength)\n+}\n+\n+// RateLimitEvent is used when Slack warns that rate-limits are being hit.\n+type RateLimitEvent struct{}\n+\n+func (e *RateLimitEvent) Error() string {\n+\treturn \"Messages are being sent too fast.\"\n+}\n+\n+// OutgoingErrorEvent contains information in case there were errors sending messages\n+type OutgoingErrorEvent struct {\n+\tMessage  OutgoingMessage\n+\tErrorObj error\n+}\n+\n+func (o OutgoingErrorEvent) Error() string {\n+\treturn o.ErrorObj.Error()\n+}\n+\n+// IncomingEventError contains information about an unexpected error receiving a websocket event\n+type IncomingEventError struct {\n+\tErrorObj error\n+}\n+\n+func (i *IncomingEventError) Error() string {\n+\treturn i.ErrorObj.Error()\n+}\n+\n+// AckErrorEvent i\n+type AckErrorEvent struct {\n+\tErrorObj error\n+\tReplyTo  int\n+}\n+\n+func (a *AckErrorEvent) Error() string {\n+\treturn a.ErrorObj.Error()\n+}"
    },
    {
      "sha": "5555c3162ea33def2c4f56af5d1287650375c69a",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_managed_conn.go",
      "status": "added",
      "additions": 587,
      "deletions": 0,
      "changes": 587,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_managed_conn.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_managed_conn.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_managed_conn.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,587 @@\n+package slack\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\tstdurl \"net/url\"\n+\t\"reflect\"\n+\t\"time\"\n+\n+\t\"github.com/slack-go/slack/internal/backoff\"\n+\t\"github.com/slack-go/slack/internal/misc\"\n+\n+\t\"github.com/gorilla/websocket\"\n+\t\"github.com/slack-go/slack/internal/errorsx\"\n+\t\"github.com/slack-go/slack/internal/timex\"\n+)\n+\n+// ManageConnection can be called on a Slack RTM instance returned by the\n+// NewRTM method. It will connect to the slack RTM API and handle all incoming\n+// and outgoing events. If a connection fails then it will attempt to reconnect\n+// and will notify any listeners through an error event on the IncomingEvents\n+// channel.\n+//\n+// If the connection ends and the disconnect was unintentional then this will\n+// attempt to reconnect.\n+//\n+// This should only be called once per slack API! Otherwise expect undefined\n+// behavior.\n+//\n+// The defined error events are located in websocket_internals.go.\n+func (rtm *RTM) ManageConnection() {\n+\tvar (\n+\t\terr  error\n+\t\tinfo *Info\n+\t\tconn *websocket.Conn\n+\t)\n+\n+\tfor connectionCount := 0; ; connectionCount++ {\n+\t\t// start trying to connect\n+\t\t// the returned err is already passed onto the IncomingEvents channel\n+\t\tif info, conn, err = rtm.connect(connectionCount, rtm.useRTMStart); err != nil {\n+\t\t\t// when the connection is unsuccessful its fatal, and we need to bail out.\n+\t\t\trtm.Debugf(\"Failed to connect with RTM on try %d: %s\", connectionCount, err)\n+\t\t\trtm.disconnect()\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// lock to prevent data races with Disconnect particularly around isConnected\n+\t\t// and conn.\n+\t\trtm.mu.Lock()\n+\t\trtm.conn = conn\n+\t\trtm.info = info\n+\t\trtm.mu.Unlock()\n+\n+\t\trtm.IncomingEvents <- RTMEvent{\"connected\", &ConnectedEvent{\n+\t\t\tConnectionCount: connectionCount,\n+\t\t\tInfo:            info,\n+\t\t}}\n+\n+\t\trtm.Debugf(\"RTM connection succeeded on try %d\", connectionCount)\n+\n+\t\trawEvents := make(chan json.RawMessage)\n+\t\t// we're now connected so we can set up listeners\n+\t\tgo rtm.handleIncomingEvents(rawEvents)\n+\t\t// this should be a blocking call until the connection has ended\n+\t\trtm.handleEvents(rawEvents)\n+\n+\t\tselect {\n+\t\tcase <-rtm.disconnected:\n+\t\t\t// after handle events returns we need to check if we're disconnected\n+\t\t\t// when this happens we need to cleanup the newly created connection.\n+\t\t\tif err = conn.Close(); err != nil {\n+\t\t\t\trtm.Debugln(\"failed to close conn on disconnected RTM\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\tdefault:\n+\t\t\t// otherwise continue and run the loop again to reconnect\n+\t\t}\n+\t}\n+}\n+\n+// connect attempts to connect to the slack websocket API. It handles any\n+// errors that occur while connecting and will return once a connection\n+// has been successfully opened.\n+// If useRTMStart is false then it uses rtm.connect to create the connection,\n+// otherwise it uses rtm.start.\n+func (rtm *RTM) connect(connectionCount int, useRTMStart bool) (*Info, *websocket.Conn, error) {\n+\tconst (\n+\t\terrInvalidAuth      = \"invalid_auth\"\n+\t\terrInactiveAccount  = \"account_inactive\"\n+\t\terrMissingAuthToken = \"not_authed\"\n+\t\terrTokenRevoked     = \"token_revoked\"\n+\t)\n+\n+\t// used to provide exponential backoff wait time with jitter before trying\n+\t// to connect to slack again\n+\tboff := &backoff.Backoff{\n+\t\tMax: 5 * time.Minute,\n+\t}\n+\n+\tfor {\n+\t\tvar (\n+\t\t\tbackoff time.Duration\n+\t\t)\n+\n+\t\t// send connecting event\n+\t\trtm.IncomingEvents <- RTMEvent{\"connecting\", &ConnectingEvent{\n+\t\t\tAttempt:         boff.Attempts() + 1,\n+\t\t\tConnectionCount: connectionCount,\n+\t\t}}\n+\n+\t\t// attempt to start the connection\n+\t\tinfo, conn, err := rtm.startRTMAndDial(useRTMStart)\n+\t\tif err == nil {\n+\t\t\treturn info, conn, nil\n+\t\t}\n+\n+\t\t// check for fatal errors\n+\t\tswitch err.Error() {\n+\t\tcase errInvalidAuth, errInactiveAccount, errMissingAuthToken, errTokenRevoked:\n+\t\t\trtm.Debugf(\"invalid auth when connecting with RTM: %s\", err)\n+\t\t\trtm.IncomingEvents <- RTMEvent{\"invalid_auth\", &InvalidAuthEvent{}}\n+\t\t\treturn nil, nil, err\n+\t\tdefault:\n+\t\t}\n+\n+\t\tswitch actual := err.(type) {\n+\t\tcase misc.StatusCodeError:\n+\t\t\tif actual.Code == http.StatusNotFound {\n+\t\t\t\trtm.Debugf(\"invalid auth when connecting with RTM: %s\", err)\n+\t\t\t\trtm.IncomingEvents <- RTMEvent{\"invalid_auth\", &InvalidAuthEvent{}}\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\t\tcase *RateLimitedError:\n+\t\t\tbackoff = actual.RetryAfter\n+\t\tdefault:\n+\t\t}\n+\n+\t\tbackoff = timex.Max(backoff, boff.Duration())\n+\t\t// any other errors are treated as recoverable and we try again after\n+\t\t// sending the event along the IncomingEvents channel\n+\t\trtm.IncomingEvents <- RTMEvent{\"connection_error\", &ConnectionErrorEvent{\n+\t\t\tAttempt:  boff.Attempts(),\n+\t\t\tBackoff:  backoff,\n+\t\t\tErrorObj: err,\n+\t\t}}\n+\n+\t\t// get time we should wait before attempting to connect again\n+\t\trtm.Debugf(\"reconnection %d failed: %s reconnecting in %v\\n\", boff.Attempts(), err, backoff)\n+\n+\t\t// wait for one of the following to occur,\n+\t\t// backoff duration has elapsed, killChannel is signalled, or\n+\t\t// the rtm finishes disconnecting.\n+\t\tselect {\n+\t\tcase <-time.After(backoff): // retry after the backoff.\n+\t\tcase intentional := <-rtm.killChannel:\n+\t\t\tif intentional {\n+\t\t\t\trtm.killConnection(intentional, ErrRTMDisconnected)\n+\t\t\t\treturn nil, nil, ErrRTMDisconnected\n+\t\t\t}\n+\t\tcase <-rtm.disconnected:\n+\t\t\treturn nil, nil, ErrRTMDisconnected\n+\t\t}\n+\t}\n+}\n+\n+// startRTMAndDial attempts to connect to the slack websocket. If useRTMStart is true,\n+// then it returns the  full information returned by the \"rtm.start\" method on the\n+// slack API. Else it uses the \"rtm.connect\" method to connect\n+func (rtm *RTM) startRTMAndDial(useRTMStart bool) (info *Info, _ *websocket.Conn, err error) {\n+\tvar (\n+\t\turl string\n+\t)\n+\n+\tif useRTMStart {\n+\t\trtm.Debugf(\"Starting RTM\")\n+\t\tinfo, url, err = rtm.StartRTM()\n+\t} else {\n+\t\trtm.Debugf(\"Connecting to RTM\")\n+\t\tinfo, url, err = rtm.ConnectRTM()\n+\t}\n+\tif err != nil {\n+\t\trtm.Debugf(\"Failed to start or connect to RTM: %s\", err)\n+\t\treturn nil, nil, err\n+\t}\n+\n+\t// install connection parameters\n+\tu, err := stdurl.Parse(url)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tu.RawQuery = rtm.connParams.Encode()\n+\turl = u.String()\n+\n+\trtm.Debugf(\"Dialing to websocket on url %s\", url)\n+\t// Only use HTTPS for connections to prevent MITM attacks on the connection.\n+\tupgradeHeader := http.Header{}\n+\tupgradeHeader.Add(\"Origin\", \"https://api.slack.com\")\n+\tdialer := websocket.DefaultDialer\n+\tif rtm.dialer != nil {\n+\t\tdialer = rtm.dialer\n+\t}\n+\tconn, _, err := dialer.Dial(url, upgradeHeader)\n+\tif err != nil {\n+\t\trtm.Debugf(\"Failed to dial to the websocket: %s\", err)\n+\t\treturn nil, nil, err\n+\t}\n+\treturn info, conn, err\n+}\n+\n+// killConnection stops the websocket connection and signals to all goroutines\n+// that they should cease listening to the connection for events.\n+//\n+// This should not be called directly! Instead a boolean value (true for\n+// intentional, false otherwise) should be sent to the killChannel on the RTM.\n+func (rtm *RTM) killConnection(intentional bool, cause error) (err error) {\n+\trtm.Debugln(\"killing connection\", cause)\n+\n+\tif rtm.conn != nil {\n+\t\terr = rtm.conn.Close()\n+\t}\n+\n+\trtm.IncomingEvents <- RTMEvent{\"disconnected\", &DisconnectedEvent{Intentional: intentional, Cause: cause}}\n+\n+\tif intentional {\n+\t\trtm.disconnect()\n+\t}\n+\n+\treturn err\n+}\n+\n+// handleEvents is a blocking function that handles all events. This sends\n+// pings when asked to (on rtm.forcePing) and upon every given elapsed\n+// interval. This also sends outgoing messages that are received from the RTM's\n+// outgoingMessages channel. This also handles incoming raw events from the RTM\n+// rawEvents channel.\n+func (rtm *RTM) handleEvents(events chan json.RawMessage) {\n+\tticker := time.NewTicker(rtm.pingInterval)\n+\tdefer ticker.Stop()\n+\tfor {\n+\t\tselect {\n+\t\t// catch \"stop\" signal on channel close\n+\t\tcase intentional := <-rtm.killChannel:\n+\t\t\t_ = rtm.killConnection(intentional, errorsx.String(\"signaled\"))\n+\t\t\treturn\n+\t\t// detect when the connection is dead.\n+\t\tcase <-rtm.pingDeadman.C:\n+\t\t\t_ = rtm.killConnection(false, ErrRTMDeadman)\n+\t\t\treturn\n+\t\t// send pings on ticker interval\n+\t\tcase <-ticker.C:\n+\t\t\tif err := rtm.ping(); err != nil {\n+\t\t\t\t_ = rtm.killConnection(false, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase <-rtm.forcePing:\n+\t\t\tif err := rtm.ping(); err != nil {\n+\t\t\t\t_ = rtm.killConnection(false, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t// listen for messages that need to be sent\n+\t\tcase msg := <-rtm.outgoingMessages:\n+\t\t\trtm.sendOutgoingMessage(msg)\n+\t\t\t// listen for incoming messages that need to be parsed\n+\t\tcase rawEvent := <-events:\n+\t\t\tswitch rtm.handleRawEvent(rawEvent) {\n+\t\t\tcase rtmEventTypeGoodbye:\n+\t\t\t\t// kill the connection, but DO NOT RETURN, a follow up kill signal will\n+\t\t\t\t// be sent that still needs to be processed. this duplication is because\n+\t\t\t\t// the event reader restarts once it emits the goodbye event.\n+\t\t\t\t// unlike the other cases in this function a final read will be triggered\n+\t\t\t\t// against the connection which will emit a kill signal. if we return early\n+\t\t\t\t// this kill signal will be processed by the next connection.\n+\t\t\t\t_ = rtm.killConnection(false, ErrRTMGoodbye)\n+\t\t\tdefault:\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// handleIncomingEvents monitors the RTM's opened websocket for any incoming\n+// events. It pushes the raw events into the channel.\n+//\n+// This will stop executing once the RTM's when a fatal error is detected, or\n+// a disconnect occurs.\n+func (rtm *RTM) handleIncomingEvents(events chan json.RawMessage) {\n+\tfor {\n+\t\tif err := rtm.receiveIncomingEvent(events); err != nil {\n+\t\t\tselect {\n+\t\t\tcase rtm.killChannel <- false:\n+\t\t\tcase <-rtm.disconnected:\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+func (rtm *RTM) sendWithDeadline(msg interface{}) error {\n+\t// set a write deadline on the connection\n+\tif err := rtm.conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := rtm.conn.WriteJSON(msg); err != nil {\n+\t\treturn err\n+\t}\n+\t// remove write deadline\n+\treturn rtm.conn.SetWriteDeadline(time.Time{})\n+}\n+\n+// sendOutgoingMessage sends the given OutgoingMessage to the slack websocket.\n+//\n+// It does not currently detect if a outgoing message fails due to a disconnect\n+// and instead lets a future failed 'PING' detect the failed connection.\n+func (rtm *RTM) sendOutgoingMessage(msg OutgoingMessage) {\n+\trtm.Debugln(\"Sending message:\", msg)\n+\tif len([]rune(msg.Text)) > MaxMessageTextLength {\n+\t\trtm.IncomingEvents <- RTMEvent{\"outgoing_error\", &MessageTooLongEvent{\n+\t\t\tMessage:   msg,\n+\t\t\tMaxLength: MaxMessageTextLength,\n+\t\t}}\n+\t\treturn\n+\t}\n+\n+\tif err := rtm.sendWithDeadline(msg); err != nil {\n+\t\trtm.IncomingEvents <- RTMEvent{\"outgoing_error\", &OutgoingErrorEvent{\n+\t\t\tMessage:  msg,\n+\t\t\tErrorObj: err,\n+\t\t}}\n+\t}\n+}\n+\n+// ping sends a 'PING' message to the RTM's websocket. If the 'PING' message\n+// fails to send then this returns an error signifying that the connection\n+// should be considered disconnected.\n+//\n+// This does not handle incoming 'PONG' responses but does store the time of\n+// each successful 'PING' send so latency can be detected upon a 'PONG'\n+// response.\n+func (rtm *RTM) ping() error {\n+\tid := rtm.idGen.Next()\n+\trtm.Debugln(\"Sending PING \", id)\n+\tmsg := &Ping{ID: id, Type: \"ping\", Timestamp: time.Now().Unix()}\n+\n+\tif err := rtm.sendWithDeadline(msg); err != nil {\n+\t\trtm.Debugf(\"RTM Error sending 'PING %d': %s\", id, err.Error())\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// receiveIncomingEvent attempts to receive an event from the RTM's websocket.\n+// This will block until a frame is available from the websocket.\n+// If the read from the websocket results in a fatal error, this function will return non-nil.\n+func (rtm *RTM) receiveIncomingEvent(events chan json.RawMessage) error {\n+\tevent := json.RawMessage{}\n+\terr := rtm.conn.ReadJSON(&event)\n+\n+\t// check if the connection was closed.\n+\tif websocket.IsUnexpectedCloseError(err) {\n+\t\treturn err\n+\t}\n+\n+\tswitch {\n+\tcase err == io.ErrUnexpectedEOF:\n+\t\t// EOF's don't seem to signify a failed connection so instead we ignore\n+\t\t// them here and detect a failed connection upon attempting to send a\n+\t\t// 'PING' message\n+\n+\t\t// trigger a 'PING' to detect potential websocket disconnect\n+\t\tselect {\n+\t\tcase rtm.forcePing <- true:\n+\t\tcase <-rtm.disconnected:\n+\t\t}\n+\tcase err != nil:\n+\t\t// All other errors from ReadJSON come from NextReader, and should\n+\t\t// kill the read loop and force a reconnect.\n+\t\trtm.IncomingEvents <- RTMEvent{\"incoming_error\", &IncomingEventError{\n+\t\t\tErrorObj: err,\n+\t\t}}\n+\n+\t\treturn err\n+\tcase len(event) == 0:\n+\t\trtm.Debugln(\"Received empty event\")\n+\tdefault:\n+\t\trtm.Debugln(\"Incoming Event:\", string(event))\n+\t\tselect {\n+\t\tcase events <- event:\n+\t\tcase <-rtm.disconnected:\n+\t\t\trtm.Debugln(\"disonnected while attempting to send raw event\")\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// handleRawEvent takes a raw JSON message received from the slack websocket\n+// and handles the encoded event.\n+// returns the event type of the message.\n+func (rtm *RTM) handleRawEvent(rawEvent json.RawMessage) string {\n+\tevent := &Event{}\n+\terr := json.Unmarshal(rawEvent, event)\n+\tif err != nil {\n+\t\trtm.IncomingEvents <- RTMEvent{\"unmarshalling_error\", &UnmarshallingErrorEvent{err}}\n+\t\treturn \"\"\n+\t}\n+\n+\tswitch event.Type {\n+\tcase rtmEventTypeAck:\n+\t\trtm.handleAck(rawEvent)\n+\tcase rtmEventTypeHello:\n+\t\trtm.IncomingEvents <- RTMEvent{\"hello\", &HelloEvent{}}\n+\tcase rtmEventTypePong:\n+\t\trtm.handlePong(rawEvent)\n+\tcase rtmEventTypeGoodbye:\n+\t\t// just return the event type up for goodbye, will be handled by caller.\n+\tdefault:\n+\t\trtm.handleEvent(event.Type, rawEvent)\n+\t}\n+\n+\treturn event.Type\n+}\n+\n+// handleAck handles an incoming 'ACK' message.\n+func (rtm *RTM) handleAck(event json.RawMessage) {\n+\tack := &AckMessage{}\n+\tif err := json.Unmarshal(event, ack); err != nil {\n+\t\trtm.Debugln(\"RTM Error unmarshalling 'ack' event:\", err)\n+\t\trtm.Debugln(\" -> Erroneous 'ack' event:\", string(event))\n+\t\treturn\n+\t}\n+\n+\tif ack.Ok {\n+\t\trtm.IncomingEvents <- RTMEvent{\"ack\", ack}\n+\t} else if ack.RTMResponse.Error != nil {\n+\t\t// As there is no documentation for RTM error-codes, this\n+\t\t// identification of a rate-limit warning is very brittle.\n+\t\tif ack.RTMResponse.Error.Code == -1 && ack.RTMResponse.Error.Msg == \"slow down, too many messages...\" {\n+\t\t\trtm.IncomingEvents <- RTMEvent{\"ack_error\", &RateLimitEvent{}}\n+\t\t} else {\n+\t\t\trtm.IncomingEvents <- RTMEvent{\"ack_error\", &AckErrorEvent{ack.Error, ack.ReplyTo}}\n+\t\t}\n+\t} else {\n+\t\trtm.IncomingEvents <- RTMEvent{\"ack_error\", &AckErrorEvent{ErrorObj: fmt.Errorf(\"ack decode failure\")}}\n+\t}\n+}\n+\n+// handlePong handles an incoming 'PONG' message which should be in response to\n+// a previously sent 'PING' message. This is then used to compute the\n+// connection's latency.\n+func (rtm *RTM) handlePong(event json.RawMessage) {\n+\tvar (\n+\t\tp Pong\n+\t)\n+\n+\trtm.resetDeadman()\n+\n+\tif err := json.Unmarshal(event, &p); err != nil {\n+\t\trtm.Client.log.Println(\"RTM Error unmarshalling 'pong' event:\", err)\n+\t\treturn\n+\t}\n+\n+\tlatency := time.Since(time.Unix(p.Timestamp, 0))\n+\trtm.IncomingEvents <- RTMEvent{\"latency_report\", &LatencyReport{Value: latency}}\n+}\n+\n+// handleEvent is the \"default\" response to an event that does not have a\n+// special case. It matches the command's name to a mapping of defined events\n+// and then sends the corresponding event struct to the IncomingEvents channel.\n+// If the event type is not found or the event cannot be unmarshalled into the\n+// correct struct then this sends an UnmarshallingErrorEvent to the\n+// IncomingEvents channel.\n+func (rtm *RTM) handleEvent(typeStr string, event json.RawMessage) {\n+\tv, exists := EventMapping[typeStr]\n+\tif !exists {\n+\t\trtm.Debugf(\"RTM Error - received unmapped event %q: %s\\n\", typeStr, string(event))\n+\t\terr := fmt.Errorf(\"RTM Error: Received unmapped event %q: %s\", typeStr, string(event))\n+\t\trtm.IncomingEvents <- RTMEvent{\"unmarshalling_error\", &UnmarshallingErrorEvent{err}}\n+\t\treturn\n+\t}\n+\tt := reflect.TypeOf(v)\n+\trecvEvent := reflect.New(t).Interface()\n+\terr := json.Unmarshal(event, recvEvent)\n+\tif err != nil {\n+\t\trtm.Debugf(\"RTM Error, could not unmarshall event %q: %s\\n\", typeStr, string(event))\n+\t\terr := fmt.Errorf(\"RTM Error: Could not unmarshall event %q: %s\", typeStr, string(event))\n+\t\trtm.IncomingEvents <- RTMEvent{\"unmarshalling_error\", &UnmarshallingErrorEvent{err}}\n+\t\treturn\n+\t}\n+\trtm.IncomingEvents <- RTMEvent{typeStr, recvEvent}\n+}\n+\n+// EventMapping holds a mapping of event names to their corresponding struct\n+// implementations. The structs should be instances of the unmarshalling\n+// target for the matching event type.\n+var EventMapping = map[string]interface{}{\n+\t\"message\":         MessageEvent{},\n+\t\"presence_change\": PresenceChangeEvent{},\n+\t\"user_typing\":     UserTypingEvent{},\n+\n+\t\"channel_marked\":          ChannelMarkedEvent{},\n+\t\"channel_created\":         ChannelCreatedEvent{},\n+\t\"channel_joined\":          ChannelJoinedEvent{},\n+\t\"channel_left\":            ChannelLeftEvent{},\n+\t\"channel_deleted\":         ChannelDeletedEvent{},\n+\t\"channel_rename\":          ChannelRenameEvent{},\n+\t\"channel_archive\":         ChannelArchiveEvent{},\n+\t\"channel_unarchive\":       ChannelUnarchiveEvent{},\n+\t\"channel_history_changed\": ChannelHistoryChangedEvent{},\n+\n+\t\"dnd_updated\":      DNDUpdatedEvent{},\n+\t\"dnd_updated_user\": DNDUpdatedEvent{},\n+\n+\t\"im_created\":         IMCreatedEvent{},\n+\t\"im_open\":            IMOpenEvent{},\n+\t\"im_close\":           IMCloseEvent{},\n+\t\"im_marked\":          IMMarkedEvent{},\n+\t\"im_history_changed\": IMHistoryChangedEvent{},\n+\n+\t\"group_marked\":          GroupMarkedEvent{},\n+\t\"group_open\":            GroupOpenEvent{},\n+\t\"group_joined\":          GroupJoinedEvent{},\n+\t\"group_left\":            GroupLeftEvent{},\n+\t\"group_close\":           GroupCloseEvent{},\n+\t\"group_rename\":          GroupRenameEvent{},\n+\t\"group_archive\":         GroupArchiveEvent{},\n+\t\"group_unarchive\":       GroupUnarchiveEvent{},\n+\t\"group_history_changed\": GroupHistoryChangedEvent{},\n+\n+\t\"file_created\":         FileCreatedEvent{},\n+\t\"file_shared\":          FileSharedEvent{},\n+\t\"file_unshared\":        FileUnsharedEvent{},\n+\t\"file_public\":          FilePublicEvent{},\n+\t\"file_private\":         FilePrivateEvent{},\n+\t\"file_change\":          FileChangeEvent{},\n+\t\"file_deleted\":         FileDeletedEvent{},\n+\t\"file_comment_added\":   FileCommentAddedEvent{},\n+\t\"file_comment_edited\":  FileCommentEditedEvent{},\n+\t\"file_comment_deleted\": FileCommentDeletedEvent{},\n+\n+\t\"pin_added\":   PinAddedEvent{},\n+\t\"pin_removed\": PinRemovedEvent{},\n+\n+\t\"star_added\":   StarAddedEvent{},\n+\t\"star_removed\": StarRemovedEvent{},\n+\n+\t\"reaction_added\":   ReactionAddedEvent{},\n+\t\"reaction_removed\": ReactionRemovedEvent{},\n+\n+\t\"pref_change\": PrefChangeEvent{},\n+\n+\t\"team_join\":              TeamJoinEvent{},\n+\t\"team_rename\":            TeamRenameEvent{},\n+\t\"team_pref_change\":       TeamPrefChangeEvent{},\n+\t\"team_domain_change\":     TeamDomainChangeEvent{},\n+\t\"team_migration_started\": TeamMigrationStartedEvent{},\n+\n+\t\"manual_presence_change\": ManualPresenceChangeEvent{},\n+\n+\t\"user_change\": UserChangeEvent{},\n+\n+\t\"emoji_changed\": EmojiChangedEvent{},\n+\n+\t\"commands_changed\": CommandsChangedEvent{},\n+\n+\t\"email_domain_changed\": EmailDomainChangedEvent{},\n+\n+\t\"bot_added\":   BotAddedEvent{},\n+\t\"bot_changed\": BotChangedEvent{},\n+\n+\t\"accounts_changed\": AccountsChangedEvent{},\n+\n+\t\"reconnect_url\": ReconnectUrlEvent{},\n+\n+\t\"member_joined_channel\": MemberJoinedChannelEvent{},\n+\t\"member_left_channel\":   MemberLeftChannelEvent{},\n+\n+\t\"subteam_created\":         SubteamCreatedEvent{},\n+\t\"subteam_members_changed\": SubteamMembersChangedEvent{},\n+\t\"subteam_self_added\":      SubteamSelfAddedEvent{},\n+\t\"subteam_self_removed\":    SubteamSelfRemovedEvent{},\n+\t\"subteam_updated\":         SubteamUpdatedEvent{},\n+\n+\t\"desktop_notification\":       DesktopNotificationEvent{},\n+\t\"mobile_in_app_notification\": MobileInAppNotificationEvent{},\n+}"
    },
    {
      "sha": "65a8bb65d4045e5bd7d4504e3255793f630ca136",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_misc.go",
      "status": "added",
      "additions": 141,
      "deletions": 0,
      "changes": 141,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_misc.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_misc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_misc.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,141 @@\n+package slack\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+)\n+\n+// AckMessage is used for messages received in reply to other messages\n+type AckMessage struct {\n+\tReplyTo   int    `json:\"reply_to\"`\n+\tTimestamp string `json:\"ts\"`\n+\tText      string `json:\"text\"`\n+\tRTMResponse\n+}\n+\n+// RTMResponse encapsulates response details as returned by the Slack API\n+type RTMResponse struct {\n+\tOk    bool      `json:\"ok\"`\n+\tError *RTMError `json:\"error\"`\n+}\n+\n+// RTMError encapsulates error information as returned by the Slack API\n+type RTMError struct {\n+\tCode int\n+\tMsg  string\n+}\n+\n+func (s RTMError) Error() string {\n+\treturn fmt.Sprintf(\"Code %d - %s\", s.Code, s.Msg)\n+}\n+\n+// MessageEvent represents a Slack Message (used as the event type for an incoming message)\n+type MessageEvent Message\n+\n+// RTMEvent is the main wrapper. You will find all the other messages attached\n+type RTMEvent struct {\n+\tType string\n+\tData interface{}\n+}\n+\n+// HelloEvent represents the hello event\n+type HelloEvent struct{}\n+\n+// PresenceChangeEvent represents the presence change event\n+type PresenceChangeEvent struct {\n+\tType     string   `json:\"type\"`\n+\tPresence string   `json:\"presence\"`\n+\tUser     string   `json:\"user\"`\n+\tUsers    []string `json:\"users\"`\n+}\n+\n+// UserTypingEvent represents the user typing event\n+type UserTypingEvent struct {\n+\tType    string `json:\"type\"`\n+\tUser    string `json:\"user\"`\n+\tChannel string `json:\"channel\"`\n+}\n+\n+// PrefChangeEvent represents a user preferences change event\n+type PrefChangeEvent struct {\n+\tType  string          `json:\"type\"`\n+\tName  string          `json:\"name\"`\n+\tValue json.RawMessage `json:\"value\"`\n+}\n+\n+// ManualPresenceChangeEvent represents the manual presence change event\n+type ManualPresenceChangeEvent struct {\n+\tType     string `json:\"type\"`\n+\tPresence string `json:\"presence\"`\n+}\n+\n+// UserChangeEvent represents the user change event\n+type UserChangeEvent struct {\n+\tType string `json:\"type\"`\n+\tUser User   `json:\"user\"`\n+}\n+\n+// EmojiChangedEvent represents the emoji changed event\n+type EmojiChangedEvent struct {\n+\tType           string   `json:\"type\"`\n+\tSubType        string   `json:\"subtype\"`\n+\tName           string   `json:\"name\"`\n+\tNames          []string `json:\"names\"`\n+\tValue          string   `json:\"value\"`\n+\tEventTimestamp string   `json:\"event_ts\"`\n+}\n+\n+// CommandsChangedEvent represents the commands changed event\n+type CommandsChangedEvent struct {\n+\tType           string `json:\"type\"`\n+\tEventTimestamp string `json:\"event_ts\"`\n+}\n+\n+// EmailDomainChangedEvent represents the email domain changed event\n+type EmailDomainChangedEvent struct {\n+\tType           string `json:\"type\"`\n+\tEventTimestamp string `json:\"event_ts\"`\n+\tEmailDomain    string `json:\"email_domain\"`\n+}\n+\n+// BotAddedEvent represents the bot added event\n+type BotAddedEvent struct {\n+\tType string `json:\"type\"`\n+\tBot  Bot    `json:\"bot\"`\n+}\n+\n+// BotChangedEvent represents the bot changed event\n+type BotChangedEvent struct {\n+\tType string `json:\"type\"`\n+\tBot  Bot    `json:\"bot\"`\n+}\n+\n+// AccountsChangedEvent represents the accounts changed event\n+type AccountsChangedEvent struct {\n+\tType string `json:\"type\"`\n+}\n+\n+// ReconnectUrlEvent represents the receiving reconnect url event\n+type ReconnectUrlEvent struct {\n+\tType string `json:\"type\"`\n+\tURL  string `json:\"url\"`\n+}\n+\n+// MemberJoinedChannelEvent, a user joined a public or private channel\n+type MemberJoinedChannelEvent struct {\n+\tType        string `json:\"type\"`\n+\tUser        string `json:\"user\"`\n+\tChannel     string `json:\"channel\"`\n+\tChannelType string `json:\"channel_type\"`\n+\tTeam        string `json:\"team\"`\n+\tInviter     string `json:\"inviter\"`\n+}\n+\n+// MemberLeftChannelEvent a user left a public or private channel\n+type MemberLeftChannelEvent struct {\n+\tType        string `json:\"type\"`\n+\tUser        string `json:\"user\"`\n+\tChannel     string `json:\"channel\"`\n+\tChannelType string `json:\"channel_type\"`\n+\tTeam        string `json:\"team\"`\n+}"
    },
    {
      "sha": "e3cfb3d9f08234b6dae7792f522f682ea9cd2e32",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_mobile_in_app_notification.go",
      "status": "added",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_mobile_in_app_notification.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_mobile_in_app_notification.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_mobile_in_app_notification.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,20 @@\n+package slack\n+\n+// MobileInAppNotificationEvent represents the update event for Mobile App Notification.\n+type MobileInAppNotificationEvent struct {\n+\tType              string `json:\"type\"`\n+\tTitle             string `json:\"title\"`\n+\tSubtitle          string `json:\"subtitle\"`\n+\tTimestamp         string `json:\"ts\"`\n+\tChannel           string `json:\"channel\"`\n+\tAvatarImage       string `json:\"avatarImage\"`\n+\tIsShared          bool   `json:\"is_shared\"`\n+\tChannelName       string `json:\"channel_name\"`\n+\tAuthorID          string `json:\"author_id\"`\n+\tAuthorDisplayName string `json:\"author_display_name\"`\n+\tMessageText       string `json:\"msg_text\"`\n+\tPushID            string `json:\"push_id\"`\n+\tNotifcationID     string `json:\"notif_id\"`\n+\tMobileLaunchURI   string `json:\"mobileLaunchUri\"`\n+\tEventTimestamp    string `json:\"event_ts\"`\n+}"
    },
    {
      "sha": "95445e286d89e41e609d09d479db7195a41b6229",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_pins.go",
      "status": "added",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_pins.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_pins.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_pins.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,16 @@\n+package slack\n+\n+type pinEvent struct {\n+\tType           string `json:\"type\"`\n+\tUser           string `json:\"user\"`\n+\tItem           Item   `json:\"item\"`\n+\tChannel        string `json:\"channel_id\"`\n+\tEventTimestamp string `json:\"event_ts\"`\n+\tHasPins        bool   `json:\"has_pins,omitempty\"`\n+}\n+\n+// PinAddedEvent represents the Pin added event\n+type PinAddedEvent pinEvent\n+\n+// PinRemovedEvent represents the Pin removed event\n+type PinRemovedEvent pinEvent"
    },
    {
      "sha": "e49738783c1c71e327a2cca64634b6636bd2d3dd",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_reactions.go",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_reactions.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_reactions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_reactions.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,25 @@\n+package slack\n+\n+// reactionItem is a lighter-weight item than is returned by the reactions list.\n+type reactionItem struct {\n+\tType        string `json:\"type\"`\n+\tChannel     string `json:\"channel,omitempty\"`\n+\tFile        string `json:\"file,omitempty\"`\n+\tFileComment string `json:\"file_comment,omitempty\"`\n+\tTimestamp   string `json:\"ts,omitempty\"`\n+}\n+\n+type reactionEvent struct {\n+\tType           string       `json:\"type\"`\n+\tUser           string       `json:\"user\"`\n+\tItemUser       string       `json:\"item_user\"`\n+\tItem           reactionItem `json:\"item\"`\n+\tReaction       string       `json:\"reaction\"`\n+\tEventTimestamp string       `json:\"event_ts\"`\n+}\n+\n+// ReactionAddedEvent represents the Reaction added event\n+type ReactionAddedEvent reactionEvent\n+\n+// ReactionRemovedEvent represents the Reaction removed event\n+type ReactionRemovedEvent reactionEvent"
    },
    {
      "sha": "e0f2dda3d61a1f8f700345be0c6baef1019e74b1",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_stars.go",
      "status": "added",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_stars.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_stars.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_stars.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,14 @@\n+package slack\n+\n+type starEvent struct {\n+\tType           string      `json:\"type\"`\n+\tUser           string      `json:\"user\"`\n+\tItem           StarredItem `json:\"item\"`\n+\tEventTimestamp string      `json:\"event_ts\"`\n+}\n+\n+// StarAddedEvent represents the Star added event\n+type StarAddedEvent starEvent\n+\n+// StarRemovedEvent represents the Star removed event\n+type StarRemovedEvent starEvent"
    },
    {
      "sha": "a23b274cfc943fa183219b9a7bb582a592b17abe",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_subteam.go",
      "status": "added",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_subteam.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_subteam.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_subteam.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,35 @@\n+package slack\n+\n+// SubteamCreatedEvent represents the Subteam created event\n+type SubteamCreatedEvent struct {\n+\tType    string    `json:\"type\"`\n+\tSubteam UserGroup `json:\"subteam\"`\n+}\n+\n+// SubteamCreatedEvent represents the membership of an existing User Group has changed event\n+type SubteamMembersChangedEvent struct {\n+\tType               string   `json:\"type\"`\n+\tSubteamID          string   `json:\"subteam_id\"`\n+\tTeamID             string   `json:\"team_id\"`\n+\tDatePreviousUpdate JSONTime `json:\"date_previous_update\"`\n+\tDateUpdate         JSONTime `json:\"date_update\"`\n+\tAddedUsers         []string `json:\"added_users\"`\n+\tAddedUsersCount    string   `json:\"added_users_count\"`\n+\tRemovedUsers       []string `json:\"removed_users\"`\n+\tRemovedUsersCount  string   `json:\"removed_users_count\"`\n+}\n+\n+// SubteamSelfAddedEvent represents an event of you have been added to a User Group\n+type SubteamSelfAddedEvent struct {\n+\tType      string `json:\"type\"`\n+\tSubteamID string `json:\"subteam_id\"`\n+}\n+\n+// SubteamSelfRemovedEvent represents an event of you have been removed from a User Group\n+type SubteamSelfRemovedEvent SubteamSelfAddedEvent\n+\n+// SubteamUpdatedEvent represents an event of an existing User Group has been updated or its members changed\n+type SubteamUpdatedEvent struct {\n+\tType    string    `json:\"type\"`\n+\tSubteam UserGroup `json:\"subteam\"`\n+}"
    },
    {
      "sha": "3898c8336f862b9663099242d5fc6fdca9f4c7d7",
      "filename": "backend/vendor/github.com/slack-go/slack/websocket_teams.go",
      "status": "added",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_teams.go",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/github.com/slack-go/slack/websocket_teams.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/github.com/slack-go/slack/websocket_teams.go?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,33 @@\n+package slack\n+\n+// TeamJoinEvent represents the Team join event\n+type TeamJoinEvent struct {\n+\tType string `json:\"type\"`\n+\tUser User   `json:\"user\"`\n+}\n+\n+// TeamRenameEvent represents the Team rename event\n+type TeamRenameEvent struct {\n+\tType           string `json:\"type\"`\n+\tName           string `json:\"name,omitempty\"`\n+\tEventTimestamp string `json:\"event_ts,omitempty\"`\n+}\n+\n+// TeamPrefChangeEvent represents the Team preference change event\n+type TeamPrefChangeEvent struct {\n+\tType  string   `json:\"type\"`\n+\tName  string   `json:\"name,omitempty\"`\n+\tValue []string `json:\"value,omitempty\"`\n+}\n+\n+// TeamDomainChangeEvent represents the Team domain change event\n+type TeamDomainChangeEvent struct {\n+\tType   string `json:\"type\"`\n+\tURL    string `json:\"url\"`\n+\tDomain string `json:\"domain\"`\n+}\n+\n+// TeamMigrationStartedEvent represents the Team migration started event\n+type TeamMigrationStartedEvent struct {\n+\tType string `json:\"type\"`\n+}"
    },
    {
      "sha": "ad26760db04969b265452f793e6b3322a8253f5c",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/modules.txt",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/backend/vendor/modules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/vendor/modules.txt?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -149,6 +149,8 @@ github.com/gorilla/css/scanner\n # github.com/gorilla/feeds v1.1.1\n ## explicit\n github.com/gorilla/feeds\n+# github.com/gorilla/websocket v1.4.2\n+github.com/gorilla/websocket\n # github.com/hashicorp/errwrap v1.0.0\n github.com/hashicorp/errwrap\n # github.com/hashicorp/go-multierror v1.1.0\n@@ -187,6 +189,14 @@ github.com/rs/xid\n # github.com/russross/blackfriday/v2 v2.1.0\n ## explicit\n github.com/russross/blackfriday/v2\n+# github.com/slack-go/slack v0.8.2\n+## explicit\n+github.com/slack-go/slack\n+github.com/slack-go/slack/internal/backoff\n+github.com/slack-go/slack/internal/errorsx\n+github.com/slack-go/slack/internal/misc\n+github.com/slack-go/slack/internal/timex\n+github.com/slack-go/slack/slackutilsx\n # github.com/stretchr/objx v0.1.1\n github.com/stretchr/objx\n # github.com/stretchr/testify v1.6.1"
    },
    {
      "sha": "38e04bb516dee6c1d85e20c7d35b857dadad1de6",
      "filename": "docs/latest/_index.md",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/docs/latest/_index.md",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/docs/latest/_index.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/docs/latest/_index.md?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -4,5 +4,6 @@\n - [How to configure remark42 without a subdomain](subdomain) with Nginx or Caddy\n - [How to configure remark42 for Single Page Apps (SPA)](spa)\n - [Telegram notifications](telegram)\n+- [Slack notifications](slack)\n - [Setup email authentication and\\or email notifications](email)\n - [How to add new translation to remark42](translation)"
    },
    {
      "sha": "42e0350541eccc6181740312c8f77fb30accf77c",
      "filename": "docs/latest/slack.md",
      "status": "added",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/umputun/remark42/blob/df4b0c80ac2a45f6042102a45c222e7f56515c79/docs/latest/slack.md",
      "raw_url": "https://github.com/umputun/remark42/raw/df4b0c80ac2a45f6042102a45c222e7f56515c79/docs/latest/slack.md",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/docs/latest/slack.md?ref=df4b0c80ac2a45f6042102a45c222e7f56515c79",
      "patch": "@@ -0,0 +1,40 @@\n+---\n+title: Slack\n+---\n+\n+## Slack notifications\n+\n+In order to integrate notifications from remark42 with the [slack](https://slack.com), you should create [a bot](https://slack.com/intl/en-cn/help/articles/115005265703-Create-a-bot-for-your-workspace) and obtain a token. \n+\n+### Create a Slack Bot\n+\n+1. Create a [Slack app](https://api.slack.com/apps/new) if you don't already have one, or select an existing app you've created.\n+2. Click the OAuth & Permissions tab in the left sidebar.\n+3. Below Bot Token Scopes, select the `chat:write`, `chat:write.public` and `channels:read` scopes. Then click Add an OAuth Scope.\n+4. Scroll to the top of the page, and click on Install to workspace.\n+5. You should see the \"_View basic information about public channels in your workspace_\",  \"_Send Message as ..._\" and \"_Send messages to channels ... isn't a member of_\" as the permission, then click allow. \n+6. You can then see you token, in the form of `xoxb-...-...-...`\n+\n+\n+### Remark42 configuration\n+\n+The slack token which you obtained before should be used as `NOTIFY_SLACK_TOKEN`. \n+\n+You also need to set `NOTIFY_TYPE=slack` for the slack notification to be active.\n+\n+By default, the notification are sent to the `general` channel on slack. If you need another channel, you can specify it, for instance with `NOTIFY_SLACK_CHAN=random`.\n+\n+```\n+    - NOTIFY_TYPE=slack\n+    - NOTIFY_SLACK_CHAN=general\n+    - NOTIFY_SLACK_TOKEN=xoxb-....\n+```\n+\n+\n+### Verify the notifications on Slack \n+\n+If all goes fine, you should be able to see the following message on your slack notification channel:\n+\n+> New comment from _author_ -> _original author_\n+>> [Demo | Remark42](http://127.0.0.1:8080/web/#remark42__comment-11288987987)\n+>> This is the comment written by _author_"
    }
  ]
}

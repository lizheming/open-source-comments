{
  "sha": "6449b7d92b53d0ef5f39b15020c06193b67684c8",
  "node_id": "C_kwDOBtgov9oAKDY0NDliN2Q5MmI1M2QwZWY1ZjM5YjE1MDIwYzA2MTkzYjY3Njg0Yzg",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2021-10-29T16:47:33Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2021-11-01T19:35:37Z"
    },
    "message": "improve telegram notifications\n\nThese changes are designed to ease the transition into\nthe simplified telegram notifications verification model.",
    "tree": {
      "sha": "1a3bc883829be9be57cb084707f61b4203b02d88",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/1a3bc883829be9be57cb084707f61b4203b02d88"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/6449b7d92b53d0ef5f39b15020c06193b67684c8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/6449b7d92b53d0ef5f39b15020c06193b67684c8",
  "html_url": "https://github.com/umputun/remark42/commit/6449b7d92b53d0ef5f39b15020c06193b67684c8",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/6449b7d92b53d0ef5f39b15020c06193b67684c8/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c852ea4834dbed5e739fcdfecce51fe7638236a2",
      "url": "https://api.github.com/repos/umputun/remark42/commits/c852ea4834dbed5e739fcdfecce51fe7638236a2",
      "html_url": "https://github.com/umputun/remark42/commit/c852ea4834dbed5e739fcdfecce51fe7638236a2"
    }
  ],
  "stats": {
    "total": 334,
    "additions": 172,
    "deletions": 162
  },
  "files": [
    {
      "sha": "0e8e652758da0b1eda8692b3f363a602ec9bf5ff",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 49,
      "deletions": 44,
      "changes": 93,
      "blob_url": "https://github.com/umputun/remark42/blob/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/cmd/server.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/cmd/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/cmd/server.go?ref=6449b7d92b53d0ef5f39b15020c06193b67684c8",
      "patch": "@@ -472,23 +472,26 @@ func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \t\tKeyStore:          adminStore,\n \t}\n \n-\tvar emailNotifications bool\n-\tnotifyService, telegramBotUsername, err := s.makeNotify(dataService, authenticator)\n-\n-\tif contains(\"email\", s.Notify.Users) {\n-\t\temailNotifications = true\n+\tvar telegramService *notify.Telegram\n+\tvar telegramBotUsername string\n+\tnotifyDestinations, err := s.makeNotifyDestinations(authenticator)\n+\tif err != nil {\n+\t\tlog.Printf(\"[WARN] failed to prepare notify destinations, %s\", err)\n \t}\n \n-\t// we pass telegramBotUsername to Rest server only if user notifications are enabled\n-\tif !contains(\"telegram\", s.Notify.Users) {\n-\t\ttelegramBotUsername = \"\"\n+\tif contains(\"telegram\", s.Notify.Users) || contains(\"telegram\", s.Notify.Admins) {\n+\t\ttelegramService, err = s.makeTelegramNotify()\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"[WARN] failed to make telegram notify service, %s\", err)\n+\t\t} else {\n+\t\t\tnotifyDestinations = append(notifyDestinations, telegramService)\n+\t\t}\n \t}\n \n-\tif err != nil {\n-\t\tlog.Printf(\"[WARN] failed to make notify service, %s\", err)\n-\t\tnotifyService = notify.NopService // disable notifier\n-\t\temailNotifications = false        // email notifications are not available in this case\n-\t\ttelegramBotUsername = \"\"          // telegram notifications are not available in this case either\n+\tnotifyService := s.makeNotifyService(dataService, notifyDestinations)\n+\n+\tif telegramService != nil {\n+\t\ttelegramBotUsername = telegramService.GetBotUsername()\n \t}\n \n \timgProxy := &proxy.Image{\n@@ -526,7 +529,7 @@ func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \t\tSSLConfig:           sslConfig,\n \t\tUpdateLimiter:       s.UpdateLimit,\n \t\tImageService:        imageService,\n-\t\tEmailNotifications:  emailNotifications,\n+\t\tEmailNotifications:  contains(\"email\", s.Notify.Users),\n \t\tTelegramBotUsername: telegramBotUsername,\n \t\tEmojiEnabled:        s.EnableEmoji,\n \t\tAnonVote:            s.AnonymousVote && s.RestrictVoteIP,\n@@ -912,11 +915,17 @@ func (s *ServerCommand) loadEmailTemplate() (string, error) {\n \treturn string(file), nil\n }\n \n-// aside from notify.Service and error, returns telegram bot name which will be passed to the frontend\n-func (s *ServerCommand) makeNotify(dataStore *service.DataStore, authenticator *auth.Service) (*notify.Service, string, error) {\n-\tnotifyService := notify.NopService\n-\tvar destinations []notify.Destination\n-\tvar telegramBotUsername string\n+func (s *ServerCommand) makeNotifyService(dataStore *service.DataStore, destinations []notify.Destination) *notify.Service {\n+\tif len(destinations) > 0 {\n+\t\tlog.Printf(\"[INFO] make notify, for users: %s, for admins: %s\", s.Notify.Users, s.Notify.Admins)\n+\t\treturn notify.NewService(dataStore, s.Notify.QueueSize, destinations...)\n+\t}\n+\treturn notify.NopService\n+}\n+\n+// constructs list of notify destinations except for telegram, returns empty list in case of error\n+func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]notify.Destination, error) {\n+\tdestinations := make([]notify.Destination, 0)\n \n \tif contains(\"webhook\", s.Notify.Admins) {\n \t\tclient := &http.Client{Timeout: 5 * time.Second}\n@@ -932,37 +941,19 @@ func (s *ServerCommand) makeNotify(dataStore *service.DataStore, authenticator *\n \t\t}\n \t\twebhook, err := notify.NewWebhook(client, whParams)\n \t\tif err != nil {\n-\t\t\treturn nil, \"\", errors.Wrap(err, \"failed to create webhook notification destination\")\n+\t\t\treturn destinations, errors.Wrap(err, \"failed to create webhook notification destination\")\n \t\t}\n \t\tdestinations = append(destinations, webhook)\n \t}\n \n \tif contains(\"slack\", s.Notify.Admins) {\n \t\tslack, err := notify.NewSlack(s.Notify.Slack.Token, s.Notify.Slack.Channel)\n \t\tif err != nil {\n-\t\t\treturn nil, \"\", errors.Wrap(err, \"failed to create slack notification destination\")\n+\t\t\treturn destinations, errors.Wrap(err, \"failed to create slack notification destination\")\n \t\t}\n \t\tdestinations = append(destinations, slack)\n \t}\n \n-\tif contains(\"telegram\", s.Notify.Users) || contains(\"telegram\", s.Notify.Admins) {\n-\t\tif contains(\"telegram\", s.Notify.Admins) && s.Notify.Telegram.Channel == \"\" {\n-\t\t\treturn nil, \"\", errors.New(\"--notify.telegram.channel must be set for admin notifications to work\")\n-\t\t}\n-\t\ttelegramParams := notify.TelegramParams{\n-\t\t\tAdminChannelID:    s.Notify.Telegram.Channel,\n-\t\t\tUserNotifications: contains(\"telegram\", s.Notify.Users),\n-\t\t\tToken:             s.Telegram.Token,\n-\t\t\tTimeout:           s.Telegram.Timeout,\n-\t\t}\n-\t\ttg, err := notify.NewTelegram(telegramParams)\n-\t\tif err != nil {\n-\t\t\treturn nil, \"\", errors.Wrap(err, \"failed to create telegram notification destination\")\n-\t\t}\n-\t\tdestinations = append(destinations, tg)\n-\t\ttelegramBotUsername = tg.BotUsername\n-\t}\n-\n \t// with logic below admin notifications enable notifications for users on the backend even if they\n \t// are not enabled explicitly, however they won't be visible to the users in the frontend\n \t// because api.Rest.EmailNotifications would be set to false.\n@@ -1004,16 +995,30 @@ func (s *ServerCommand) makeNotify(dataStore *service.DataStore, authenticator *\n \t\t}\n \t\temailService, err := notify.NewEmail(emailParams, smtpParams)\n \t\tif err != nil {\n-\t\t\treturn nil, \"\", errors.Wrap(err, \"failed to create email notification destination\")\n+\t\t\treturn destinations, errors.Wrap(err, \"failed to create email notification destination\")\n \t\t}\n \t\tdestinations = append(destinations, emailService)\n \t}\n \n-\tif len(destinations) > 0 {\n-\t\tlog.Printf(\"[INFO] make notify, for users: %s, for admins: %s\", s.Notify.Users, s.Notify.Admins)\n-\t\tnotifyService = notify.NewService(dataStore, s.Notify.QueueSize, destinations...)\n+\treturn destinations, nil\n+}\n+\n+// constructs Telegram notify service\n+func (s *ServerCommand) makeTelegramNotify() (*notify.Telegram, error) {\n+\tif contains(\"telegram\", s.Notify.Admins) && s.Notify.Telegram.Channel == \"\" {\n+\t\treturn nil, errors.New(\"--notify.telegram.channel must be set for admin notifications to work\")\n+\t}\n+\ttelegramParams := notify.TelegramParams{\n+\t\tAdminChannelID:    s.Notify.Telegram.Channel,\n+\t\tUserNotifications: contains(\"telegram\", s.Notify.Users),\n+\t\tToken:             s.Telegram.Token,\n+\t\tTimeout:           s.Telegram.Timeout,\n+\t}\n+\ttg, err := notify.NewTelegram(telegramParams)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"failed to create telegram notification destination\")\n \t}\n-\treturn notifyService, telegramBotUsername, nil\n+\treturn tg, nil\n }\n \n func (s *ServerCommand) makeSSLConfig() (config api.SSLConfig, err error) {"
    },
    {
      "sha": "b37f8b66b67fc128c5a1b87886ef130bf2dd3071",
      "filename": "backend/app/notify/telegram.go",
      "status": "modified",
      "additions": 80,
      "deletions": 83,
      "changes": 163,
      "blob_url": "https://github.com/umputun/remark42/blob/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/notify/telegram.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/notify/telegram.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/notify/telegram.go?ref=6449b7d92b53d0ef5f39b15020c06193b67684c8",
      "patch": "@@ -5,6 +5,7 @@ import (\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io\"\n \t\"net/http\"\n \t\"strconv\"\n \t\"strings\"\n@@ -23,7 +24,6 @@ type TelegramParams struct {\n \tAdminChannelID    string        // unique identifier for the target chat or username of the target channel (in the format @channelusername)\n \tToken             string        // token for telegram bot API interactions\n \tTimeout           time.Duration // http client timeout\n-\tBotUsername       string        // filled with bot username after Telegram creation, used in frontend\n \tUserNotifications bool          // flag which enables user notifications\n \n \tapiPrefix string // changed only in tests\n@@ -32,6 +32,8 @@ type TelegramParams struct {\n // Telegram implements notify.Destination for telegram\n type Telegram struct {\n \tTelegramParams\n+\n+\tusername string // bot username\n }\n \n // telegramMsg is used to send message trough Telegram bot API\n@@ -40,12 +42,9 @@ type telegramMsg struct {\n \tParseMode string `json:\"parse_mode,omitempty\"`\n }\n \n-// TelegramBotInfo structure contains information about telegram bot\n+// TelegramBotInfo structure contains information about telegram bot, which is used from whole telegram API response\n type TelegramBotInfo struct {\n-\tID        uint64 `json:\"id\"`\n-\tIsBot     bool   `json:\"is_bot\"`\n-\tFirstName string `json:\"first_name\"`\n-\tUsername  string `json:\"username\"`\n+\tUsername string `json:\"username\"`\n }\n \n const telegramTimeOut = 5000 * time.Millisecond\n@@ -66,46 +65,13 @@ func NewTelegram(params TelegramParams) (*Telegram, error) {\n \tctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n \tdefer cancel()\n \n-\terr := repeater.NewDefault(5, time.Millisecond*250).Do(ctx, func() error {\n-\t\tclient := http.Client{Timeout: res.Timeout}\n-\t\tresp, err := client.Get(fmt.Sprintf(\"%s%s/getMe\", res.apiPrefix, res.Token))\n-\t\tif err != nil {\n-\t\t\treturn errors.Wrap(err, \"can't initialize telegram notifications\")\n-\t\t}\n-\t\tdefer func() {\n-\t\t\tif err = resp.Body.Close(); err != nil {\n-\t\t\t\tlog.Printf(\"[WARN] can't close request body, %s\", err)\n-\t\t\t}\n-\t\t}()\n-\n-\t\tif resp.StatusCode != http.StatusOK {\n-\t\t\ttgErr := struct {\n-\t\t\t\tDescription string `json:\"description\"`\n-\t\t\t}{}\n-\t\t\tif err = json.NewDecoder(resp.Body).Decode(&tgErr); err == nil {\n-\t\t\t\treturn errors.Errorf(\"unexpected telegram API status code %d, error: %q\", resp.StatusCode, tgErr.Description)\n-\t\t\t}\n-\t\t\treturn errors.Errorf(\"unexpected telegram API status code %d\", resp.StatusCode)\n-\t\t}\n-\n-\t\ttgResp := struct {\n-\t\t\tOK     bool `json:\"ok\"`\n-\t\t\tResult TelegramBotInfo\n-\t\t}{}\n-\n-\t\tif err = json.NewDecoder(resp.Body).Decode(&tgResp); err != nil {\n-\t\t\treturn errors.Wrap(err, \"can't decode response\")\n-\t\t}\n-\n-\t\tif !tgResp.OK || !tgResp.Result.IsBot {\n-\t\t\treturn errors.Errorf(\"unexpected telegram response %+v\", tgResp)\n-\t\t}\n-\n-\t\tres.BotUsername = tgResp.Result.Username\n-\t\treturn nil\n-\t})\n+\tbotInfo, err := res.botInfo(ctx)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"can't retrieve bot info from Telegram API\")\n+\t}\n+\tres.username = botInfo.Username\n \n-\treturn &res, err\n+\treturn &res, nil\n }\n \n // Send to telegram recipients\n@@ -141,44 +107,8 @@ func (t *Telegram) sendMessage(ctx context.Context, b []byte, chatID string) err\n \t\tchatID = \"@\" + chatID // if chatID not a number enforce @ prefix\n \t}\n \n-\tu := fmt.Sprintf(\"%s%s/sendMessage?chat_id=%s&disable_web_page_preview=true\",\n-\t\tt.apiPrefix, t.Token, chatID)\n-\tr, err := http.NewRequest(\"POST\", u, bytes.NewReader(b))\n-\tif err != nil {\n-\t\treturn errors.Wrap(err, \"failed to make telegram request\")\n-\t}\n-\tr.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n-\n-\tclient := http.Client{Timeout: t.Timeout}\n-\tr = r.WithContext(ctx)\n-\tresp, err := client.Do(r)\n-\tif err != nil {\n-\t\treturn errors.Wrap(err, \"failed to get telegram response\")\n-\t}\n-\tdefer func() {\n-\t\tif err = resp.Body.Close(); err != nil {\n-\t\t\tlog.Printf(\"[WARN] can't close request body, %s\", err)\n-\t\t}\n-\t}()\n-\n-\tif resp.StatusCode != http.StatusOK {\n-\t\ttgErr := struct {\n-\t\t\tDescription string `json:\"description\"`\n-\t\t}{}\n-\t\tif err = json.NewDecoder(resp.Body).Decode(&tgErr); err == nil {\n-\t\t\treturn errors.Errorf(\"unexpected telegram API status code %d, error: %q\", resp.StatusCode, tgErr.Description)\n-\t\t}\n-\t\treturn errors.Errorf(\"unexpected telegram API status code %d\", resp.StatusCode)\n-\t}\n-\n-\ttgResp := struct {\n-\t\tOK bool `json:\"ok\"`\n-\t}{}\n-\n-\tif err = json.NewDecoder(resp.Body).Decode(&tgResp); err != nil {\n-\t\treturn errors.Wrap(err, \"can't decode telegram response\")\n-\t}\n-\treturn nil\n+\turl := fmt.Sprintf(\"sendMessage?chat_id=%s&disable_web_page_preview=true\", chatID)\n+\treturn t.request(ctx, url, b, &struct{}{})\n }\n \n // buildMessage generates message for generic notification about new comment\n@@ -264,6 +194,11 @@ func (t *Telegram) buildVerificationMessage(user, token, site string) ([]byte, e\n \treturn b, nil\n }\n \n+// GetBotUsername returns bot username\n+func (t *Telegram) GetBotUsername() string {\n+\treturn t.username\n+}\n+\n func (t *Telegram) String() string {\n \tresult := \"telegram\"\n \tif t.AdminChannelID != \"\" {\n@@ -274,3 +209,65 @@ func (t *Telegram) String() string {\n \t}\n \treturn result\n }\n+\n+// botInfo returns info about configured bot\n+func (t *Telegram) botInfo(ctx context.Context) (*TelegramBotInfo, error) {\n+\tvar resp = struct {\n+\t\tResult *TelegramBotInfo `json:\"result\"`\n+\t}{}\n+\n+\terr := t.request(ctx, \"getMe\", nil, &resp)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif resp.Result == nil {\n+\t\treturn nil, errors.New(\"received empty result\")\n+\t}\n+\n+\treturn resp.Result, nil\n+}\n+\n+func (t *Telegram) request(ctx context.Context, method string, b []byte, data interface{}) error {\n+\treturn repeater.NewDefault(3, time.Millisecond*250).Do(ctx, func() error {\n+\t\turl := fmt.Sprintf(\"%s%s/%s\", t.apiPrefix, t.Token, method)\n+\n+\t\tvar req *http.Request\n+\t\tvar err error\n+\t\tif b == nil {\n+\t\t\treq, err = http.NewRequestWithContext(ctx, \"GET\", url, nil)\n+\t\t} else {\n+\t\t\treq, err = http.NewRequestWithContext(ctx, \"POST\", url, bytes.NewReader(b))\n+\t\t\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn errors.Wrap(err, \"failed to create request\")\n+\t\t}\n+\n+\t\tclient := http.Client{Timeout: t.Timeout}\n+\t\tresp, err := client.Do(req)\n+\t\tif err != nil {\n+\t\t\treturn errors.Wrap(err, \"failed to send request\")\n+\t\t}\n+\t\tdefer resp.Body.Close()\n+\n+\t\tif resp.StatusCode != http.StatusOK {\n+\t\t\treturn t.parseError(resp.Body, resp.StatusCode)\n+\t\t}\n+\n+\t\tif err = json.NewDecoder(resp.Body).Decode(data); err != nil {\n+\t\t\treturn errors.Wrap(err, \"failed to decode json response\")\n+\t\t}\n+\n+\t\treturn nil\n+\t})\n+}\n+\n+func (t *Telegram) parseError(r io.Reader, statusCode int) error {\n+\ttgErr := struct {\n+\t\tDescription string `json:\"description\"`\n+\t}{}\n+\tif err := json.NewDecoder(r).Decode(&tgErr); err != nil {\n+\t\treturn errors.Errorf(\"unexpected telegram API status code %d\", statusCode)\n+\t}\n+\treturn errors.Errorf(\"unexpected telegram API status code %d, error: %q\", statusCode, tgErr.Description)\n+}"
    },
    {
      "sha": "4e3f5afdac37ed51423b91f4cb20308415389157",
      "filename": "backend/app/notify/telegram_test.go",
      "status": "modified",
      "additions": 41,
      "deletions": 33,
      "changes": 74,
      "blob_url": "https://github.com/umputun/remark42/blob/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/notify/telegram_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/notify/telegram_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/notify/telegram_test.go?ref=6449b7d92b53d0ef5f39b15020c06193b67684c8",
      "patch": "@@ -15,8 +15,7 @@ import (\n )\n \n func TestTelegram_New(t *testing.T) {\n-\n-\tts := mockTelegramServer()\n+\tts := mockTelegramServer(nil)\n \tdefer ts.Close()\n \n \ttb, err := NewTelegram(TelegramParams{\n@@ -29,39 +28,39 @@ func TestTelegram_New(t *testing.T) {\n \tassert.Equal(t, tb.Timeout, time.Second*5)\n \tassert.Equal(t, \"remark_test\", tb.AdminChannelID, \"@ added\")\n \n-\tst := time.Now()\n \t_, err = NewTelegram(TelegramParams{\n \t\tAdminChannelID: \"remark_test\",\n-\t\tToken:          \"bad-resp\",\n+\t\tToken:          \"empty-json\",\n \t\tapiPrefix:      ts.URL + \"/\",\n \t})\n-\tassert.EqualError(t, err, \"unexpected telegram response {OK:false Result:{ID:707381019 IsBot:false FirstName:comments_test Username:remark42_test_bot}}\")\n-\tassert.True(t, time.Since(st) >= 250*5*time.Millisecond)\n+\tassert.EqualError(t, err, \"can't retrieve bot info from Telegram API: received empty result\")\n \n+\tst := time.Now()\n \t_, err = NewTelegram(TelegramParams{\n \t\tAdminChannelID: \"remark_test\",\n \t\tToken:          \"non-json-resp\",\n \t\tTimeout:        2 * time.Second,\n \t\tapiPrefix:      ts.URL + \"/\",\n \t})\n \tassert.Error(t, err)\n-\tassert.Contains(t, err.Error(), \"can't decode response:\")\n+\tassert.Contains(t, err.Error(), \"failed to decode json response:\")\n+\tassert.True(t, time.Since(st) >= 250*3*time.Millisecond)\n \n \t_, err = NewTelegram(TelegramParams{\n \t\tAdminChannelID: \"remark_test\",\n \t\tToken:          \"404\",\n \t\tTimeout:        2 * time.Second,\n \t\tapiPrefix:      ts.URL + \"/\",\n \t})\n-\tassert.EqualError(t, err, \"unexpected telegram API status code 404\")\n+\tassert.EqualError(t, err, \"can't retrieve bot info from Telegram API: unexpected telegram API status code 404\")\n \n \t_, err = NewTelegram(TelegramParams{\n \t\tAdminChannelID: \"remark_test\",\n \t\tToken:          \"no-such-thing\",\n \t\tapiPrefix:      \"http://127.0.0.1:4321/\",\n \t})\n \trequire.Error(t, err)\n-\tassert.Contains(t, err.Error(), \"can't initialize telegram notifications\")\n+\tassert.Contains(t, err.Error(), \"can't retrieve bot info from Telegram API\")\n \tassert.Contains(t, err.Error(), \"dial tcp 127.0.0.1:4321: connect: connection refused\")\n \n \t_, err = NewTelegram(TelegramParams{\n@@ -89,8 +88,22 @@ func TestTelegram_New(t *testing.T) {\n \tassert.Equal(t, \"1234567890\", tb.AdminChannelID, \"no @ prefix\")\n }\n \n+func TestTelegram_GetBotUsername(t *testing.T) {\n+\tts := mockTelegramServer(nil)\n+\tdefer ts.Close()\n+\n+\ttb, err := NewTelegram(TelegramParams{\n+\t\tAdminChannelID: \"remark_test\",\n+\t\tToken:          \"good-token\",\n+\t\tapiPrefix:      ts.URL + \"/\",\n+\t})\n+\tassert.NoError(t, err)\n+\tassert.NotNil(t, tb)\n+\tassert.Equal(t, \"remark42_test_bot\", tb.GetBotUsername())\n+}\n+\n func TestTelegram_Send(t *testing.T) {\n-\tts := mockTelegramServer()\n+\tts := mockTelegramServer(nil)\n \tdefer ts.Close()\n \n \ttb, err := NewTelegram(TelegramParams{\n@@ -124,7 +137,15 @@ func TestTelegram_Send(t *testing.T) {\n \t\tUserNotifications: true,\n \t\tapiPrefix:         ts.URL + \"/\",\n \t})\n+\tassert.Nil(t, tb)\n \tassert.Error(t, err, \"should fail\")\n+\ttb = &Telegram{\n+\t\tTelegramParams: TelegramParams{\n+\t\t\tAdminChannelID:    \"remark_test\",\n+\t\t\tToken:             \"non-json-resp\",\n+\t\t\tUserNotifications: true,\n+\t\t\tapiPrefix:         ts.URL + \"/\",\n+\t\t}}\n \terr = tb.Send(context.TODO(), Request{Comment: c, parent: cp, Telegrams: []string{\"test_user_channel\"}})\n \trequire.Error(t, err)\n \tassert.Contains(t, err.Error(), \"unexpected telegram API status code 404\", \"send on broken tg\")\n@@ -147,7 +168,7 @@ func TestTelegram_Send(t *testing.T) {\n }\n \n func TestTelegram_SendVerification(t *testing.T) {\n-\tts := mockTelegramServer()\n+\tts := mockTelegramServer(nil)\n \tdefer ts.Close()\n \n \ttb, err := NewTelegram(TelegramParams{\n@@ -182,37 +203,24 @@ func TestTelegram_SendVerification(t *testing.T) {\n \tassert.Contains(t, string(res), `secret_`)\n }\n \n-func mockTelegramServer() *httptest.Server {\n-\trouter := chi.NewRouter()\n-\trouter.Get(\"/good-token/getMe\", func(w http.ResponseWriter, r *http.Request) {\n-\t\ts := `{\"ok\": true,\n+const getMeResp = `{\"ok\": true,\n \t\t\t\t\"result\": {\n \t\t\t\t\t\"first_name\": \"comments_test\",\n \t\t\t\t\t\"id\": 707381019,\n \t\t\t\t\t\"is_bot\": true,\n \t\t\t\t\t\"username\": \"remark42_test_bot\"\n \t\t\t\t}}`\n-\t\t_, _ = w.Write([]byte(s))\n+\n+func mockTelegramServer(_ http.HandlerFunc) *httptest.Server {\n+\trouter := chi.NewRouter()\n+\trouter.Get(\"/good-token/getMe\", func(w http.ResponseWriter, r *http.Request) {\n+\t\t_, _ = w.Write([]byte(getMeResp))\n \t})\n-\trouter.Get(\"/bad-resp/getMe\", func(w http.ResponseWriter, r *http.Request) {\n-\t\ts := `{\"ok\": false,\n-\t\t\t\t\"result\": {\n-\t\t\t\t\t\"first_name\": \"comments_test\",\n-\t\t\t\t\t\"id\": 707381019,\n-\t\t\t\t\t\"is_bot\": false,\n-\t\t\t\t\t\"username\": \"remark42_test_bot\"\n-\t\t\t\t}}`\n-\t\t_, _ = w.Write([]byte(s))\n+\trouter.Get(\"/empty-json/getMe\", func(w http.ResponseWriter, r *http.Request) {\n+\t\t_, _ = w.Write([]byte(`{}`))\n \t})\n \trouter.Get(\"/non-json-resp/getMe\", func(w http.ResponseWriter, r *http.Request) {\n-\t\ts := `\"ok\": false,\n-\t\t\t\t\"result\": {\n-\t\t\t\t\t\"first_name\": \"comments_test\",\n-\t\t\t\t\t\"id\": 707381019,\n-\t\t\t\t\t\"is_bot\": false,\n-\t\t\t\t\t\"username\": \"remark42_test_bot\"\n-\t\t\t\t`\n-\t\t_, _ = w.Write([]byte(s))\n+\t\t_, _ = w.Write([]byte(`not-a-json`))\n \t})\n \trouter.Get(\"/404/getMe\", func(w http.ResponseWriter, r *http.Request) {\n \t\tw.WriteHeader(404)"
    },
    {
      "sha": "64605ddb340f798f01f143b8c719e479b1681a7a",
      "filename": "backend/app/rest/api/rest_private_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/rest/api/rest_private_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/6449b7d92b53d0ef5f39b15020c06193b67684c8/backend/app/rest/api/rest_private_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend/app/rest/api/rest_private_test.go?ref=6449b7d92b53d0ef5f39b15020c06193b67684c8",
      "patch": "@@ -605,8 +605,8 @@ func TestRest_EmailAndTelegram(t *testing.T) {\n \t\t{description: \"issue delete request without site_id\", url: \"/api/v1/email\", method: http.MethodDelete, responseCode: http.StatusBadRequest},\n \t\t{description: \"delete non-existent user email\", url: \"/api/v1/email?site=remark42\", method: http.MethodDelete, responseCode: http.StatusOK},\n \t\t{description: \"set user email, token not set\", url: \"/api/v1/email/confirm?site=remark42\", method: http.MethodPost, responseCode: http.StatusBadRequest},\n-\t\t{description: \"send confirmation without address\", url: \"/api/v1/email/subscribe?site=remark42\", method: http.MethodPost, responseCode: http.StatusBadRequest},\n-\t\t{description: \"send confirmation\", url: \"/api/v1/email/subscribe?site=remark42&address=good@example.com\", method: http.MethodPost, responseCode: http.StatusOK},\n+\t\t{description: \"send email confirmation without address\", url: \"/api/v1/email/subscribe?site=remark42\", method: http.MethodPost, responseCode: http.StatusBadRequest},\n+\t\t{description: \"send email confirmation\", url: \"/api/v1/email/subscribe?site=remark42&address=good@example.com\", method: http.MethodPost, responseCode: http.StatusOK},\n \t\t{description: \"set user email, token is good\", url: fmt.Sprintf(\"/api/v1/email/confirm?site=remark42&tkn=%s\", goodToken), method: http.MethodPost, responseCode: http.StatusOK, cookieEmail: \"good@example.com\"},\n \t\t{description: \"send confirmation with same address\", url: \"/api/v1/email/subscribe?site=remark42&address=good@example.com\", method: http.MethodPost, responseCode: http.StatusConflict},\n \t\t{description: \"get user email\", url: \"/api/v1/email?site=remark42\", method: http.MethodGet, responseCode: http.StatusOK},"
    }
  ]
}

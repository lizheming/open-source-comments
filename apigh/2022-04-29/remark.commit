{
  "sha": "ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
  "node_id": "C_kwDOBtgov9oAKGJhODZkYjEyNjNmZTFmNDVkYzZlZjZlMTUwMmYyODIzM2E1YWNiZTE",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2022-04-19T22:10:31Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2022-04-26T05:25:09Z"
    },
    "message": "replace errors package with fmt.Errorf\n\nhttps://gist.github.com/Peltoche/60b8b81dfbf70164d0e2b88988003229\nwas used for it, thanks to @Peltoche for publishing it.",
    "tree": {
      "sha": "12b10ae0f49938f4e6965f71d18e2d1a466087ab",
      "url": "https://api.github.com/repos/umputun/remark42/git/trees/12b10ae0f49938f4e6965f71d18e2d1a466087ab"
    },
    "url": "https://api.github.com/repos/umputun/remark42/git/commits/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark42/commits/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
  "html_url": "https://github.com/umputun/remark42/commit/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
  "comments_url": "https://api.github.com/repos/umputun/remark42/commits/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "21d0339d3d4a99cf72c1835bb811b7e98afa84a4",
      "url": "https://api.github.com/repos/umputun/remark42/commits/21d0339d3d4a99cf72c1835bb811b7e98afa84a4",
      "html_url": "https://github.com/umputun/remark42/commit/21d0339d3d4a99cf72c1835bb811b7e98afa84a4"
    }
  ],
  "stats": {
    "total": 825,
    "additions": 426,
    "deletions": 399
  },
  "files": [
    {
      "sha": "d0cbf866d88bba8e2d75acb2715386b9a14167a6",
      "filename": "backend/_example/memory_store/accessor/admin.go",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Faccessor%2Fadmin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Faccessor%2Fadmin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F_example%2Fmemory_store%2Faccessor%2Fadmin.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -7,8 +7,9 @@\n package accessor\n \n import (\n+\t\"fmt\"\n+\n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store/admin\"\n )\n@@ -43,7 +44,7 @@ func (m *MemAdmin) Key(_ string) (key string, err error) {\n func (m *MemAdmin) Admins(siteID string) (ids []string, err error) {\n \tresp, ok := m.data[siteID]\n \tif !ok {\n-\t\treturn nil, errors.Errorf(\"site %s not found\", siteID)\n+\t\treturn nil, fmt.Errorf(\"site %s not found\", siteID)\n \t}\n \tlog.Printf(\"[DEBUG] admins for %s, %+v\", siteID, resp.IDs)\n \treturn resp.IDs, nil\n@@ -53,7 +54,7 @@ func (m *MemAdmin) Admins(siteID string) (ids []string, err error) {\n func (m *MemAdmin) Email(siteID string) (email string, err error) {\n \tresp, ok := m.data[siteID]\n \tif !ok {\n-\t\treturn \"\", errors.Errorf(\"site %s not found\", siteID)\n+\t\treturn \"\", fmt.Errorf(\"site %s not found\", siteID)\n \t}\n \n \treturn resp.Email, nil\n@@ -63,7 +64,7 @@ func (m *MemAdmin) Email(siteID string) (email string, err error) {\n func (m *MemAdmin) Enabled(siteID string) (ok bool, err error) {\n \tresp, ok := m.data[siteID]\n \tif !ok {\n-\t\treturn false, errors.Errorf(\"site %s not found\", siteID)\n+\t\treturn false, fmt.Errorf(\"site %s not found\", siteID)\n \t}\n \treturn resp.Enabled, nil\n }\n@@ -72,7 +73,7 @@ func (m *MemAdmin) Enabled(siteID string) (ok bool, err error) {\n func (m *MemAdmin) OnEvent(siteID string, ev admin.EventType) error {\n \tresp, ok := m.data[siteID]\n \tif !ok {\n-\t\treturn errors.Errorf(\"site %s not found\", siteID)\n+\t\treturn fmt.Errorf(\"site %s not found\", siteID)\n \t}\n \tif ev == admin.EvCreate {\n \t\tresp.CountCreated++ // not a good idea, just for demo"
    },
    {
      "sha": "f12e941a5b947c171db87d38f44da7994f952d6e",
      "filename": "backend/_example/memory_store/accessor/data.go",
      "status": "modified",
      "additions": 19,
      "deletions": 17,
      "changes": 36,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Faccessor%2Fdata.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Faccessor%2Fdata.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F_example%2Fmemory_store%2Faccessor%2Fdata.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -7,13 +7,12 @@\n package accessor\n \n import (\n+\t\"fmt\"\n \t\"log\"\n \t\"sort\"\n \t\"sync\"\n \t\"time\"\n \n-\t\"github.com/pkg/errors\"\n-\n \t\"github.com/umputun/remark42/backend/app/store\"\n \t\"github.com/umputun/remark42/backend/app/store/engine\"\n )\n@@ -58,15 +57,15 @@ func NewMemData() *MemData {\n func (m *MemData) Create(comment store.Comment) (commentID string, err error) {\n \n \tif ro, e := m.Flag(engine.FlagRequest{Flag: engine.ReadOnly, Locator: comment.Locator}); e == nil && ro {\n-\t\treturn \"\", errors.Errorf(\"post %s is read-only\", comment.Locator.URL)\n+\t\treturn \"\", fmt.Errorf(\"post %s is read-only\", comment.Locator.URL)\n \t}\n \n \tm.mu.Lock()\n \tdefer m.mu.Unlock()\n \tcomments := m.posts[comment.Locator.SiteID]\n \tfor _, c := range comments { // don't allow duplicated IDs\n \t\tif c.ID == comment.ID {\n-\t\t\treturn \"\", errors.New(\"dup key\")\n+\t\t\treturn \"\", fmt.Errorf(\"dup key\")\n \t\t}\n \t}\n \tcomments = append(comments, comment)\n@@ -161,7 +160,7 @@ func (m *MemData) Count(req engine.FindRequest) (count int, err error) {\n \t\t})\n \t\treturn len(comments), nil\n \tdefault:\n-\t\treturn 0, errors.Errorf(\"invalid count request %+v\", req)\n+\t\treturn 0, fmt.Errorf(\"invalid count request %+v\", req)\n \t}\n }\n \n@@ -176,7 +175,7 @@ func (m *MemData) Info(req engine.InfoRequest) (res []store.PostInfo, err error)\n \t\t\treturn c.Locator == req.Locator\n \t\t})\n \t\tif len(comments) == 0 {\n-\t\t\treturn nil, errors.New(\"not found\")\n+\t\t\treturn nil, fmt.Errorf(\"not found\")\n \t\t}\n \t\tinfo := store.PostInfo{\n \t\t\tURL:      req.Locator.URL,\n@@ -235,7 +234,7 @@ func (m *MemData) Info(req engine.InfoRequest) (res []store.PostInfo, err error)\n \t\treturn res, nil\n \t}\n \n-\treturn nil, errors.Errorf(\"invalid info request %+v\", req)\n+\treturn nil, fmt.Errorf(\"invalid info request %+v\", req)\n }\n \n // Flag sets and gets flag values\n@@ -277,7 +276,7 @@ func (m *MemData) ListFlags(req engine.FlagRequest) (res []interface{}, err erro\n \t\treturn res, nil\n \t}\n \n-\treturn nil, errors.Errorf(\"flag %s not listable\", req.Flag)\n+\treturn nil, fmt.Errorf(\"flag %s not listable\", req.Flag)\n }\n \n // UserDetail sets or gets single detail value, or gets all details foÂ§r requested site.\n@@ -287,7 +286,7 @@ func (m *MemData) UserDetail(req engine.UserDetailRequest) ([]engine.UserDetailE\n \tswitch req.Detail {\n \tcase engine.UserEmail, engine.UserTelegram:\n \t\tif req.UserID == \"\" {\n-\t\t\treturn nil, errors.New(\"userid cannot be empty in request for single detail\")\n+\t\t\treturn nil, fmt.Errorf(\"userid cannot be empty in request for single detail\")\n \t\t}\n \n \t\tm.mu.Lock()\n@@ -306,9 +305,9 @@ func (m *MemData) UserDetail(req engine.UserDetailRequest) ([]engine.UserDetailE\n \t\t\tdefer m.mu.Unlock()\n \t\t\treturn m.listDetails(req.Locator)\n \t\t}\n-\t\treturn nil, errors.New(\"unsupported request with userdetail all\")\n+\t\treturn nil, fmt.Errorf(\"unsupported request with userdetail all\")\n \tdefault:\n-\t\treturn nil, errors.Errorf(\"unsupported detail %q\", req.Detail)\n+\t\treturn nil, fmt.Errorf(\"unsupported detail %q\", req.Detail)\n \t}\n }\n \n@@ -337,13 +336,13 @@ func (m *MemData) Delete(req engine.DeleteRequest) error {\n \n \tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.CommentID == \"\" && req.UserID == \"\" && req.UserDetail == \"\": // delete site\n \t\tif _, ok := m.posts[req.Locator.SiteID]; !ok {\n-\t\t\treturn errors.New(\"not found\")\n+\t\t\treturn fmt.Errorf(\"not found\")\n \t\t}\n \t\tm.posts[req.Locator.SiteID] = []store.Comment{}\n \t\treturn nil\n \t}\n \n-\treturn errors.Errorf(\"invalid delete request %+v\", req)\n+\treturn fmt.Errorf(\"invalid delete request %+v\", req)\n }\n \n func (m *MemData) deleteComment(loc store.Locator, id string, mode store.DeleteMode) error {\n@@ -352,7 +351,7 @@ func (m *MemData) deleteComment(loc store.Locator, id string, mode store.DeleteM\n \t\treturn c.Locator == loc && c.ID == id\n \t})\n \tif len(comments) == 0 {\n-\t\treturn errors.New(\"not found\")\n+\t\treturn fmt.Errorf(\"not found\")\n \t}\n \n \tcomments[0].SetDeleted(mode)\n@@ -430,7 +429,10 @@ func (m *MemData) setFlag(req engine.FlagRequest) (res bool, err error) {\n \t\tinfo.ReadOnly = status\n \t\tm.metaPosts[req.Locator] = info\n \t}\n-\treturn status, errors.Wrapf(err, \"failed to set flag %+v\", req)\n+\tif err != nil {\n+\t\treturn false, fmt.Errorf(\"failed to set flag %+v: %w\", req, err)\n+\t}\n+\treturn status, nil\n }\n \n // getUserDetail returns UserDetailEntry with requested userDetail (omitting other details)\n@@ -535,7 +537,7 @@ func (m *MemData) get(loc store.Locator, commentID string) (store.Comment, error\n \t\treturn c.Locator == loc && c.ID == commentID\n \t})\n \tif len(comments) == 0 {\n-\t\treturn store.Comment{}, errors.New(\"not found\")\n+\t\treturn store.Comment{}, fmt.Errorf(\"not found\")\n \t}\n \treturn comments[0], nil\n }\n@@ -557,7 +559,7 @@ func (m *MemData) updateComment(comment store.Comment) error {\n \t\tm.posts[comment.Locator.SiteID] = comments\n \t\treturn nil\n \t}\n-\treturn errors.New(\"not found\")\n+\treturn fmt.Errorf(\"not found\")\n }\n \n func (m *MemData) match(comments []store.Comment, fn func(c store.Comment) bool) (res []store.Comment) {"
    },
    {
      "sha": "a5757f5e87fff3f22d4d7f75e7fbba53878bb335",
      "filename": "backend/_example/memory_store/accessor/image.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Faccessor%2Fimage.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Faccessor%2Fimage.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F_example%2Fmemory_store%2Faccessor%2Fimage.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -8,11 +8,11 @@ package accessor\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \t\"sync\"\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store/image\"\n )\n@@ -53,7 +53,7 @@ func (m *MemImage) ResetCleanupTimer(id string) error {\n \t\tm.insertTime[id] = time.Now()\n \t\treturn nil\n \t}\n-\treturn errors.Errorf(\"image %s not found\", id)\n+\treturn fmt.Errorf(\"image %s not found\", id)\n }\n \n // Load image by ID\n@@ -65,7 +65,7 @@ func (m *MemImage) Load(id string) ([]byte, error) {\n \t}\n \tm.mu.RUnlock()\n \tif !ok {\n-\t\treturn nil, errors.Errorf(\"image %s not found\", id)\n+\t\treturn nil, fmt.Errorf(\"image %s not found\", id)\n \t}\n \treturn img, nil\n }\n@@ -76,7 +76,7 @@ func (m *MemImage) Commit(id string) error {\n \timg, ok := m.imagesStaging[id]\n \tm.mu.RUnlock()\n \tif !ok {\n-\t\treturn errors.Errorf(\"failed to commit %s, not found in staging\", id)\n+\t\treturn fmt.Errorf(\"failed to commit %s, not found in staging\", id)\n \t}\n \n \tm.mu.Lock()"
    },
    {
      "sha": "bfbdb5191441bce74ae609d95d3a3573d3efbc9e",
      "filename": "backend/_example/memory_store/go.mod",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Fgo.mod",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2F_example%2Fmemory_store%2Fgo.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2F_example%2Fmemory_store%2Fgo.mod?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -6,7 +6,6 @@ require (\n \tgithub.com/go-pkgz/jrpc v0.2.0\n \tgithub.com/go-pkgz/lgr v0.10.4\n \tgithub.com/jessevdk/go-flags v1.5.0\n-\tgithub.com/pkg/errors v0.9.1\n \tgithub.com/stretchr/testify v1.7.1\n \tgithub.com/umputun/remark42/backend v1.9.0\n )\n@@ -29,6 +28,7 @@ require (\n \tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n \tgithub.com/hashicorp/go-multierror v1.1.1 // indirect\n \tgithub.com/microcosm-cc/bluemonday v1.0.18 // indirect\n+\tgithub.com/pkg/errors v0.9.1 // indirect\n \tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n \tgithub.com/rs/xid v1.4.0 // indirect\n \tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect"
    },
    {
      "sha": "3baa4185530742df0891591f3406abee10c9b6e7",
      "filename": "backend/app/cmd/avatar.go",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Favatar.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Favatar.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Favatar.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,10 +1,10 @@\n package cmd\n \n import (\n+\t\"fmt\"\n \t\"path\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \tbolt \"go.etcd.io/bbolt\"\n \n \t\"github.com/go-pkgz/auth/avatar\"\n@@ -39,12 +39,12 @@ func (ac *AvatarCommand) Execute(_ []string) error {\n \n \tsrc, err := ac.makeAvatarStore(ac.AvatarSrc)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't make avatart store for %s\", ac.AvatarSrc.Type)\n+\t\treturn fmt.Errorf(\"can't make avatart store for %s: %w\", ac.AvatarSrc.Type, err)\n \t}\n \n \tdst, err := ac.makeAvatarStore(ac.AvatarDst)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't make avatart store for %s\", ac.AvatarDst.Type)\n+\t\treturn fmt.Errorf(\"can't make avatart store for %s: %w\", ac.AvatarDst.Type, err)\n \t}\n \n \tif ac.migrator == nil {\n@@ -72,14 +72,14 @@ func (ac *AvatarCommand) makeAvatarStore(gr AvatarGroup) (avatar.Store, error) {\n \tswitch gr.Type {\n \tcase \"fs\":\n \t\tif err := makeDirs(gr.FS.Path); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create avatar store\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create avatar store: %w\", err)\n \t\t}\n \t\treturn avatar.NewLocalFS(gr.FS.Path), nil\n \tcase \"bolt\":\n \t\tif err := makeDirs(path.Dir(gr.Bolt.File)); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create avatar store\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create avatar store: %w\", err)\n \t\t}\n \t\treturn avatar.NewBoltDB(gr.Bolt.File, bolt.Options{})\n \t}\n-\treturn nil, errors.Errorf(\"unsupported avatar store type %s\", gr.Type)\n+\treturn nil, fmt.Errorf(\"unsupported avatar store type %s\", gr.Type)\n }"
    },
    {
      "sha": "3d84fa6248190cc64fd96879f17f1faaecc99fd4",
      "filename": "backend/app/cmd/avatar_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Favatar_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Favatar_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Favatar_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,7 +1,7 @@\n package cmd\n \n import (\n-\t\"errors\"\n+\t\"fmt\"\n \t\"os\"\n \t\"testing\"\n \n@@ -25,7 +25,7 @@ func TestAvatar_Execute(t *testing.T) {\n \tassert.NoError(t, err)\n \n \t// failed\n-\tcmd = AvatarCommand{migrator: &avatarMigratorMock{retCount: 0, retError: errors.New(\"failed blah\")}}\n+\tcmd = AvatarCommand{migrator: &avatarMigratorMock{retCount: 0, retError: fmt.Errorf(\"failed blah\")}}\n \tcmd.SetCommon(CommonOpts{RemarkURL: \"\", SharedSecret: \"123456\"})\n \tp = flags.NewParser(&cmd, flags.Default)\n \t_, err = p.ParseArgs([]string{\"--src.type=fs\", \"--src.fs.path=/tmp/ava-test\", \"--dst.type=bolt\","
    },
    {
      "sha": "7f8c674882ccc31abab1086f414f57883111d2a3",
      "filename": "backend/app/cmd/backup.go",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fbackup.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fbackup.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fbackup.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -9,7 +9,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n )\n \n // BackupCommand set of flags and command for export\n@@ -43,14 +42,14 @@ func (ec *BackupCommand) Execute(_ []string) error {\n \texportURL := fmt.Sprintf(\"%s/api/v1/admin/export?mode=file&site=%s\", ec.RemarkURL, ec.Site)\n \treq, err := http.NewRequest(http.MethodGet, exportURL, http.NoBody)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't make export request for %s\", exportURL)\n+\t\treturn fmt.Errorf(\"can't make export request for %s: %w\", exportURL, err)\n \t}\n \treq.SetBasicAuth(\"admin\", ec.AdminPasswd)\n \n \t// get with timeout\n \tresp, err := client.Do(req.WithContext(ctx))\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"request failed for %s\", exportURL)\n+\t\treturn fmt.Errorf(\"request failed for %s: %w\", exportURL, err)\n \t}\n \tdefer func() {\n \t\tif err = resp.Body.Close(); err != nil {\n@@ -64,7 +63,7 @@ func (ec *BackupCommand) Execute(_ []string) error {\n \n \tfh, err := os.Create(fname) //nolint:gosec // harmless\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't create backup file %s\", fname)\n+\t\treturn fmt.Errorf(\"can't create backup file %s: %w\", fname, err)\n \t}\n \tdefer func() { //nolint:gosec // false positive on defer without error check when it's checked here\n \t\tif err = fh.Close(); err != nil {\n@@ -73,7 +72,7 @@ func (ec *BackupCommand) Execute(_ []string) error {\n \t}()\n \n \tif _, err = io.Copy(fh, resp.Body); err != nil {\n-\t\treturn errors.Wrapf(err, \"failed to write backup file %s\", fname)\n+\t\treturn fmt.Errorf(\"failed to write backup file %s: %w\", fname, err)\n \t}\n \n \tlog.Printf(\"[INFO] export completed, file %s\", fname)"
    },
    {
      "sha": "4409977a0a8dcd906a9216f21a46a7aa6b227a5b",
      "filename": "backend/app/cmd/cleanup.go",
      "status": "modified",
      "additions": 16,
      "deletions": 17,
      "changes": 33,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fcleanup.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fcleanup.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fcleanup.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -9,7 +9,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n )\n@@ -39,7 +38,7 @@ func (cc *CleanupCommand) Execute(_ []string) error {\n \n \tposts, err := cc.postsInRange(cc.From, cc.To)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"can't get posts\")\n+\t\treturn fmt.Errorf(\"can't get posts: %w\", err)\n \t}\n \tlog.Printf(\"[DEBUG] got %d posts\", len(posts))\n \n@@ -99,22 +98,22 @@ func (cc *CleanupCommand) procTitles(comments []store.Comment) {\n func (cc *CleanupCommand) postsInRange(fromS, toS string) ([]store.PostInfo, error) {\n \tposts, err := cc.listPosts()\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't list posts for %s\", cc.Site)\n+\t\treturn nil, fmt.Errorf(\"can't list posts for %s: %w\", cc.Site, err)\n \t}\n \n \tfrom, to := defaultFrom, defaultTo\n \n \tif fromS != \"\" {\n \t\tfrom, err = time.ParseInLocation(\"20060102\", fromS, time.Local)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"can't parse --from\")\n+\t\t\treturn nil, fmt.Errorf(\"can't parse --from: %w\", err)\n \t\t}\n \t}\n \n \tif toS != \"\" {\n \t\tto, err = time.ParseInLocation(\"20060102\", toS, time.Local)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"can't parse --to\")\n+\t\t\treturn nil, fmt.Errorf(\"can't parse --to: %w\", err)\n \t\t}\n \t}\n \n@@ -133,17 +132,17 @@ func (cc *CleanupCommand) listPosts() ([]store.PostInfo, error) {\n \tclient := http.Client{Timeout: 30 * time.Second}\n \tr, err := client.Get(listURL)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"get request failed for list of posts, site %s\", cc.Site)\n+\t\treturn nil, fmt.Errorf(\"get request failed for list of posts, site %s: %w\", cc.Site, err)\n \t}\n \tdefer func() { _ = r.Body.Close() }()\n \n \tif r.StatusCode != 200 {\n-\t\treturn nil, errors.Errorf(\"request %s failed with status %d\", listURL, r.StatusCode)\n+\t\treturn nil, fmt.Errorf(\"request %s failed with status %d\", listURL, r.StatusCode)\n \t}\n \n \tlist := []store.PostInfo{}\n \tif err = json.NewDecoder(r.Body).Decode(&list); err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't decode list of posts for site %s\", cc.Site)\n+\t\treturn nil, fmt.Errorf(\"can't decode list of posts for site %s: %w\", cc.Site, err)\n \t}\n \treturn list, nil\n }\n@@ -160,7 +159,7 @@ func (cc *CleanupCommand) listComments(postURL string) ([]store.Comment, error)\n \t\tclient := http.Client{Timeout: 30 * time.Second}\n \t\tr, err = client.Get(commentsURL)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrapf(err, \"get request failed for comments, %s\", postURL)\n+\t\t\treturn nil, fmt.Errorf(\"get request failed for comments, %s: %w\", postURL, err)\n \t\t}\n \t\tif r.StatusCode == http.StatusTooManyRequests {\n \t\t\t_ = r.Body.Close()\n@@ -173,7 +172,7 @@ func (cc *CleanupCommand) listComments(postURL string) ([]store.Comment, error)\n \tdefer func() { _ = r.Body.Close() }()\n \n \tif r.StatusCode != http.StatusOK {\n-\t\treturn nil, errors.Errorf(\"request %s failed with status %d\", commentsURL, r.StatusCode)\n+\t\treturn nil, fmt.Errorf(\"request %s failed with status %d\", commentsURL, r.StatusCode)\n \t}\n \n \tcommentsWithInfo := struct {\n@@ -182,7 +181,7 @@ func (cc *CleanupCommand) listComments(postURL string) ([]store.Comment, error)\n \t}{}\n \n \tif err = json.NewDecoder(r.Body).Decode(&commentsWithInfo); err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't decode list of comments for %s\", postURL)\n+\t\treturn nil, fmt.Errorf(\"can't decode list of comments for %s: %w\", postURL, err)\n \t}\n \treturn commentsWithInfo.Comments, nil\n }\n@@ -192,18 +191,18 @@ func (cc *CleanupCommand) deleteComment(c store.Comment) error {\n \tdeleteURL := fmt.Sprintf(\"%s/api/v1/admin/comment/%s?site=%s&url=%s&format=plain\", cc.RemarkURL, c.ID, cc.Site, c.Locator.URL)\n \treq, err := http.NewRequest(\"DELETE\", deleteURL, http.NoBody)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"failed to make delete request for comment %s, %s\", c.ID, c.Locator.URL)\n+\t\treturn fmt.Errorf(\"failed to make delete request for comment %s, %s: %w\", c.ID, c.Locator.URL, err)\n \t}\n \treq.SetBasicAuth(\"admin\", cc.AdminPasswd)\n \n \tclient := http.Client{}\n \tr, err := client.Do(req)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"delete request failed for comment %s, %s\", c.ID, c.Locator.URL)\n+\t\treturn fmt.Errorf(\"delete request failed for comment %s, %s: %w\", c.ID, c.Locator.URL, err)\n \t}\n \tdefer func() { _ = r.Body.Close() }()\n \tif r.StatusCode != http.StatusOK {\n-\t\treturn errors.Errorf(\"delete request failed with status %s\", r.Status)\n+\t\treturn fmt.Errorf(\"delete request failed with status %s\", r.Status)\n \t}\n \treturn nil\n }\n@@ -213,18 +212,18 @@ func (cc *CleanupCommand) setTitle(c store.Comment) error {\n \ttitleURL := fmt.Sprintf(\"%s/api/v1/admin/title/%s?site=%s&url=%s&format=plain\", cc.RemarkURL, c.ID, cc.Site, c.Locator.URL)\n \treq, err := http.NewRequest(\"PUT\", titleURL, http.NoBody)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"failed to make title request for comment %s, %s\", c.ID, c.Locator.URL)\n+\t\treturn fmt.Errorf(\"failed to make title request for comment %s, %s: %w\", c.ID, c.Locator.URL, err)\n \t}\n \treq.SetBasicAuth(\"admin\", cc.AdminPasswd)\n \n \tclient := http.Client{}\n \tr, err := client.Do(req)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"title request failed for comment %s, %s\", c.ID, c.Locator.URL)\n+\t\treturn fmt.Errorf(\"title request failed for comment %s, %s: %w\", c.ID, c.Locator.URL, err)\n \t}\n \tdefer func() { _ = r.Body.Close() }()\n \tif r.StatusCode != http.StatusOK {\n-\t\treturn errors.Errorf(\"title request failed with status %s\", r.Status)\n+\t\treturn fmt.Errorf(\"title request failed with status %s\", r.Status)\n \t}\n \treturn nil\n }"
    },
    {
      "sha": "2af3e729761243a85a2105f175168b973f5db115",
      "filename": "backend/app/cmd/cmd.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fcmd.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fcmd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fcmd.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,6 +4,7 @@ package cmd\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n \t\"os\"\n@@ -13,7 +14,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n )\n \n // CommonOptionsCommander extends flags.Commander with SetCommon\n@@ -87,7 +87,7 @@ func (p *fileParser) parse(now time.Time) (string, error) {\n \t}\n \n \tif err := template.Must(template.New(\"bb\").Parse(fname)).Execute(&bb, fileTemplate); err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"failed to parse %q\", fname)\n+\t\treturn \"\", fmt.Errorf(\"failed to parse %q: %w\", fname, err)\n \t}\n \treturn bb.String(), nil\n }\n@@ -107,14 +107,14 @@ func responseError(resp *http.Response) error {\n \tif e != nil {\n \t\tbody = []byte(\"\")\n \t}\n-\treturn errors.Errorf(\"error response %q, %s\", resp.Status, body)\n+\treturn fmt.Errorf(\"error response %q, %s\", resp.Status, body)\n }\n \n // mkdir -p for all dirs\n func makeDirs(dirs ...string) error {\n \tfor _, dir := range dirs {\n \t\tif err := os.MkdirAll(dir, 0o700); err != nil { // If path is already a directory, MkdirAll does nothing\n-\t\t\treturn errors.Wrapf(err, \"can't make directory %s\", dir)\n+\t\t\treturn fmt.Errorf(\"can't make directory %s: %w\", dir, err)\n \t\t}\n \t}\n \treturn nil"
    },
    {
      "sha": "3626d9ade1a6165bb069c81e79909c79b3da7da0",
      "filename": "backend/app/cmd/import.go",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fimport.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fimport.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fimport.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -11,7 +11,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n )\n \n // ImportCommand set of flags and command for import\n@@ -31,7 +30,7 @@ func (ic *ImportCommand) Execute(_ []string) error {\n \n \treader, err := ic.reader(ic.InputFile)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't open import file %s\", ic.InputFile)\n+\t\treturn fmt.Errorf(\"can't open import file %s: %w\", ic.InputFile, err)\n \t}\n \n \tclient := http.Client{}\n@@ -40,13 +39,13 @@ func (ic *ImportCommand) Execute(_ []string) error {\n \timportURL := fmt.Sprintf(\"%s/api/v1/admin/import?site=%s&provider=%s\", ic.RemarkURL, ic.Site, ic.Provider)\n \treq, err := http.NewRequest(http.MethodPost, importURL, reader)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't make import request for %s\", importURL)\n+\t\treturn fmt.Errorf(\"can't make import request for %s: %w\", importURL, err)\n \t}\n \treq.SetBasicAuth(\"admin\", ic.AdminPasswd)\n \n \tresp, err := client.Do(req.WithContext(ctx)) // closes request's reader\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"request failed for %s\", importURL)\n+\t\treturn fmt.Errorf(\"request failed for %s: %w\", importURL, err)\n \t}\n \tdefer func() {\n \t\tif err = resp.Body.Close(); err != nil {\n@@ -59,7 +58,7 @@ func (ic *ImportCommand) Execute(_ []string) error {\n \n \tbody, err := io.ReadAll(resp.Body)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"can't get response from importer\")\n+\t\treturn fmt.Errorf(\"can't get response from importer: %w\", err)\n \t}\n \n \tlog.Printf(\"[INFO] completed, status=%d, %s\", resp.StatusCode, string(body))\n@@ -70,13 +69,13 @@ func (ic *ImportCommand) Execute(_ []string) error {\n func (ic *ImportCommand) reader(inp string) (reader io.Reader, err error) {\n \tinpFile, err := os.Open(inp) // nolint\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"import failed, can't open %s\", inp)\n+\t\treturn nil, fmt.Errorf(\"import failed, can't open %s: %w\", inp, err)\n \t}\n \n \treader = inpFile\n \tif strings.HasSuffix(ic.InputFile, \".gz\") {\n \t\tif reader, err = gzip.NewReader(inpFile); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"can't make gz reader\")\n+\t\t\treturn nil, fmt.Errorf(\"can't make gz reader: %w\", err)\n \t\t}\n \t}\n \treturn reader, nil"
    },
    {
      "sha": "31acb8febd0522d4a6f66be92711c72db20999ef",
      "filename": "backend/app/cmd/remap.go",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fremap.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fremap.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fremap.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -9,7 +9,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n )\n \n // RemapCommand set of flags and command for change linkage between comments to\n@@ -29,7 +28,7 @@ func (rc *RemapCommand) Execute(_ []string) error {\n \n \trulesReader, err := os.Open(rc.InputFile)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"cant open file %s\", rc.InputFile)\n+\t\treturn fmt.Errorf(\"cant open file %s: %w\", rc.InputFile, err)\n \t}\n \n \tclient := http.Client{}\n@@ -38,13 +37,13 @@ func (rc *RemapCommand) Execute(_ []string) error {\n \tremapURL := fmt.Sprintf(\"%s/api/v1/admin/remap?site=%s\", rc.RemarkURL, rc.Site)\n \treq, err := http.NewRequest(http.MethodPost, remapURL, rulesReader)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't make remap request for %s\", remapURL)\n+\t\treturn fmt.Errorf(\"can't make remap request for %s: %w\", remapURL, err)\n \t}\n \treq.SetBasicAuth(\"admin\", rc.AdminPasswd)\n \n \tresp, err := client.Do(req.WithContext(ctx))\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"request failed for %s\", remapURL)\n+\t\treturn fmt.Errorf(\"request failed for %s: %w\", remapURL, err)\n \t}\n \tdefer func() {\n \t\tif err = resp.Body.Close(); err != nil {\n@@ -57,7 +56,7 @@ func (rc *RemapCommand) Execute(_ []string) error {\n \n \tbody, err := io.ReadAll(resp.Body)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"can't get response\")\n+\t\treturn fmt.Errorf(\"can't get response: %w\", err)\n \t}\n \n \tlog.Printf(\"[INFO] completed, status=%d, %s\", resp.StatusCode, string(body))"
    },
    {
      "sha": "9ed9e220db8fa078a78d06c5597a44125b386c73",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 35,
      "deletions": 33,
      "changes": 68,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fserver.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fcmd%2Fserver.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fcmd%2Fserver.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -18,7 +18,6 @@ import (\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/golang-jwt/jwt\"\n \t\"github.com/kyokomi/emoji/v2\"\n-\t\"github.com/pkg/errors\"\n \tbolt \"go.etcd.io/bbolt\"\n \n \t\"github.com/go-pkgz/auth\"\n@@ -450,27 +449,27 @@ func contains(s string, a []string) bool {\n // doesn't start anything\n func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \tif err := makeDirs(s.BackupLocation); err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to create backup store\")\n+\t\treturn nil, fmt.Errorf(\"failed to create backup store: %w\", err)\n \t}\n \n \tif !strings.HasPrefix(s.RemarkURL, \"http://\") && !strings.HasPrefix(s.RemarkURL, \"https://\") {\n-\t\treturn nil, errors.Errorf(\"invalid remark42 url %s\", s.RemarkURL)\n+\t\treturn nil, fmt.Errorf(\"invalid remark42 url %s\", s.RemarkURL)\n \t}\n \tlog.Printf(\"[INFO] root url=%s\", s.RemarkURL)\n \n \tstoreEngine, err := s.makeDataStore()\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to make data store engine\")\n+\t\treturn nil, fmt.Errorf(\"failed to make data store engine: %w\", err)\n \t}\n \n \tadminStore, err := s.makeAdminStore()\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to make admin store\")\n+\t\treturn nil, fmt.Errorf(\"failed to make admin store: %w\", err)\n \t}\n \n \timageService, err := s.makePicturesStore()\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to make pictures store\")\n+\t\treturn nil, fmt.Errorf(\"failed to make pictures store: %w\", err)\n \t}\n \tlog.Printf(\"[DEBUG] image service for url=%s, EditDuration=%v\", imageService.ImageAPI, imageService.EditDuration)\n \n@@ -492,13 +491,13 @@ func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \tloadingCache, err := s.makeCache()\n \tif err != nil {\n \t\t_ = dataService.Close()\n-\t\treturn nil, errors.Wrap(err, \"failed to make cache\")\n+\t\treturn nil, fmt.Errorf(\"failed to make cache: %w\", err)\n \t}\n \n \tavatarStore, err := s.makeAvatarStore()\n \tif err != nil {\n \t\t_ = dataService.Close()\n-\t\treturn nil, errors.Wrap(err, \"failed to make avatar store\")\n+\t\treturn nil, fmt.Errorf(\"failed to make avatar store: %w\", err)\n \t}\n \tauthRefreshCache := newAuthRefreshCache()\n \tauthenticator := s.getAuthenticator(dataService, avatarStore, adminStore, authRefreshCache)\n@@ -509,7 +508,7 @@ func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \terr = s.addAuthProviders(authenticator)\n \tif err != nil {\n \t\t_ = dataService.Close()\n-\t\treturn nil, errors.Wrap(err, \"failed to make authenticator\")\n+\t\treturn nil, fmt.Errorf(\"failed to make authenticator: %w\", err)\n \t}\n \n \texporter := &migrator.Native{DataStore: dataService}\n@@ -548,7 +547,7 @@ func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \tsslConfig, err := s.makeSSLConfig()\n \tif err != nil {\n \t\t_ = dataService.Close()\n-\t\treturn nil, errors.Wrap(err, \"failed to make config of ssl server params\")\n+\t\treturn nil, fmt.Errorf(\"failed to make config of ssl server params: %w\", err)\n \t}\n \n \tsrv := &api.Rest{\n@@ -587,7 +586,7 @@ func (s *ServerCommand) newServerApp(ctx context.Context) (*serverApp, error) {\n \t\tda, errDevAuth := authenticator.DevAuth()\n \t\tif errDevAuth != nil {\n \t\t\t_ = dataService.Close()\n-\t\t\treturn nil, errors.Wrap(errDevAuth, \"can't make dev oauth2 server\")\n+\t\t\treturn nil, fmt.Errorf(\"can't make dev oauth2 server: %w\", errDevAuth)\n \t\t}\n \t\tdevAuth = da\n \t}\n@@ -687,7 +686,7 @@ func (s *ServerCommand) makeDataStore() (result engine.Interface, err error) {\n \tswitch s.Store.Type {\n \tcase \"bolt\":\n \t\tif err = makeDirs(s.Store.Bolt.Path); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create bolt store\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create bolt store: %w\", err)\n \t\t}\n \t\tsites := []engine.BoltSite{}\n \t\tfor _, site := range s.Sites {\n@@ -703,9 +702,12 @@ func (s *ServerCommand) makeDataStore() (result engine.Interface, err error) {\n \t\t}}\n \t\treturn r, nil\n \tdefault:\n-\t\treturn nil, errors.Errorf(\"unsupported store type %s\", s.Store.Type)\n+\t\treturn nil, fmt.Errorf(\"unsupported store type %s\", s.Store.Type)\n \t}\n-\treturn result, errors.Wrap(err, \"can't initialize data store\")\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"can't initialize data store: %w\", err)\n+\t}\n+\treturn result, nil\n }\n \n func (s *ServerCommand) makeAvatarStore() (avatar.Store, error) {\n@@ -714,18 +716,18 @@ func (s *ServerCommand) makeAvatarStore() (avatar.Store, error) {\n \tswitch s.Avatar.Type {\n \tcase \"fs\":\n \t\tif err := makeDirs(s.Avatar.FS.Path); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create avatar store\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create avatar store: %w\", err)\n \t\t}\n \t\treturn avatar.NewLocalFS(s.Avatar.FS.Path), nil\n \tcase \"bolt\":\n \t\tif err := makeDirs(path.Dir(s.Avatar.Bolt.File)); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create avatar store\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create avatar store: %w\", err)\n \t\t}\n \t\treturn avatar.NewBoltDB(s.Avatar.Bolt.File, bolt.Options{})\n \tcase \"uri\":\n \t\treturn avatar.NewStore(s.Avatar.URI)\n \t}\n-\treturn nil, errors.Errorf(\"unsupported avatar store type %s\", s.Avatar.Type)\n+\treturn nil, fmt.Errorf(\"unsupported avatar store type %s\", s.Avatar.Type)\n }\n \n func (s *ServerCommand) makePicturesStore() (*image.Service, error) {\n@@ -746,7 +748,7 @@ func (s *ServerCommand) makePicturesStore() (*image.Service, error) {\n \t\treturn image.NewService(boltImageStore, imageServiceParams), nil\n \tcase \"fs\":\n \t\tif err := makeDirs(s.Image.FS.Path); err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create pictures store\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create pictures store: %w\", err)\n \t\t}\n \t\treturn image.NewService(&image.FileSystem{\n \t\t\tLocation:   s.Image.FS.Path,\n@@ -762,7 +764,7 @@ func (s *ServerCommand) makePicturesStore() (*image.Service, error) {\n \t\t\t\tAuthPasswd: s.Image.RPC.AuthPassword,\n \t\t\t}}, imageServiceParams), nil\n \t}\n-\treturn nil, errors.Errorf(\"unsupported pictures store type %s\", s.Image.Type)\n+\treturn nil, fmt.Errorf(\"unsupported pictures store type %s\", s.Image.Type)\n }\n \n func (s *ServerCommand) makeAdminStore() (admin.Store, error) {\n@@ -788,7 +790,7 @@ func (s *ServerCommand) makeAdminStore() (admin.Store, error) {\n \t\t}}\n \t\treturn r, nil\n \tdefault:\n-\t\treturn nil, errors.Errorf(\"unsupported admin store type %s\", s.Admin.Type)\n+\t\treturn nil, fmt.Errorf(\"unsupported admin store type %s\", s.Admin.Type)\n \t}\n }\n \n@@ -798,25 +800,25 @@ func (s *ServerCommand) makeCache() (LoadingCache, error) {\n \tcase \"redis_pub_sub\":\n \t\tredisPubSub, err := eventbus.NewRedisPubSub(s.Cache.RedisAddr, \"remark42-cache\")\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"cache backend initialization, redis PubSub initialisation\")\n+\t\t\treturn nil, fmt.Errorf(\"cache backend initialization, redis PubSub initialisation: %w\", err)\n \t\t}\n \t\tbackend, err := cache.NewLruCache(cache.MaxCacheSize(s.Cache.Max.Size), cache.MaxValSize(s.Cache.Max.Value),\n \t\t\tcache.MaxKeys(s.Cache.Max.Items), cache.EventBus(redisPubSub))\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"cache backend initialization\")\n+\t\t\treturn nil, fmt.Errorf(\"cache backend initialization: %w\", err)\n \t\t}\n \t\treturn cache.NewScache(backend), nil\n \tcase \"mem\":\n \t\tbackend, err := cache.NewLruCache(cache.MaxCacheSize(s.Cache.Max.Size), cache.MaxValSize(s.Cache.Max.Value),\n \t\t\tcache.MaxKeys(s.Cache.Max.Items))\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"cache backend initialization\")\n+\t\t\treturn nil, fmt.Errorf(\"cache backend initialization: %w\", err)\n \t\t}\n \t\treturn cache.NewScache(backend), nil\n \tcase \"none\":\n \t\treturn cache.NewScache(&cache.Nop{}), nil\n \t}\n-\treturn nil, errors.Errorf(\"unsupported cache type %s\", s.Cache.Type)\n+\treturn nil, fmt.Errorf(\"unsupported cache type %s\", s.Cache.Type)\n }\n \n func (s *ServerCommand) addAuthProviders(authenticator *auth.Service) error {\n@@ -930,7 +932,7 @@ func (s *ServerCommand) loadEmailTemplate() (string, error) {\n \t}\n \n \tif err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"failed to read file %s\", s.Auth.Email.MsgTemplate)\n+\t\treturn \"\", fmt.Errorf(\"failed to read file %s: %w\", s.Auth.Email.MsgTemplate, err)\n \t}\n \n \treturn string(file), nil\n@@ -986,15 +988,15 @@ func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]n\n \t\t}\n \t\twebhook, err := notify.NewWebhook(client, whParams)\n \t\tif err != nil {\n-\t\t\treturn destinations, errors.Wrap(err, \"failed to create webhook notification destination\")\n+\t\t\treturn destinations, fmt.Errorf(\"failed to create webhook notification destination: %w\", err)\n \t\t}\n \t\tdestinations = append(destinations, webhook)\n \t}\n \n \tif contains(\"slack\", s.Notify.Admins) {\n \t\tslack, err := notify.NewSlack(s.Notify.Slack.Token, s.Notify.Slack.Channel)\n \t\tif err != nil {\n-\t\t\treturn destinations, errors.Wrap(err, \"failed to create slack notification destination\")\n+\t\t\treturn destinations, fmt.Errorf(\"failed to create slack notification destination: %w\", err)\n \t\t}\n \t\tdestinations = append(destinations, slack)\n \t}\n@@ -1022,7 +1024,7 @@ func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]n\n \t\t\t\t}\n \t\t\t\ttkn, err := authenticator.TokenService().Token(claims)\n \t\t\t\tif err != nil {\n-\t\t\t\t\treturn \"\", errors.Wrapf(err, \"failed to make unsubscription token\")\n+\t\t\t\t\treturn \"\", fmt.Errorf(\"failed to make unsubscription token: %w\", err)\n \t\t\t\t}\n \t\t\t\treturn tkn, nil\n \t\t\t},\n@@ -1040,7 +1042,7 @@ func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]n\n \t\t}\n \t\temailService, err := notify.NewEmail(emailParams, smtpParams)\n \t\tif err != nil {\n-\t\t\treturn destinations, errors.Wrap(err, \"failed to create email notification destination\")\n+\t\t\treturn destinations, fmt.Errorf(\"failed to create email notification destination: %w\", err)\n \t\t}\n \t\tdestinations = append(destinations, emailService)\n \t}\n@@ -1051,7 +1053,7 @@ func (s *ServerCommand) makeNotifyDestinations(authenticator *auth.Service) ([]n\n // constructs Telegram notify service\n func (s *ServerCommand) makeTelegramNotify() (*notify.Telegram, error) {\n \tif contains(\"telegram\", s.Notify.Admins) && s.Notify.Telegram.Channel == \"\" {\n-\t\treturn nil, errors.New(\"--notify.telegram.channel must be set for admin notifications to work\")\n+\t\treturn nil, fmt.Errorf(\"--notify.telegram.channel must be set for admin notifications to work\")\n \t}\n \ttelegramParams := notify.TelegramParams{\n \t\tAdminChannelID:    s.Notify.Telegram.Channel,\n@@ -1062,7 +1064,7 @@ func (s *ServerCommand) makeTelegramNotify() (*notify.Telegram, error) {\n \t}\n \ttg, err := notify.NewTelegram(telegramParams)\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to create telegram notification destination\")\n+\t\treturn nil, fmt.Errorf(\"failed to create telegram notification destination: %w\", err)\n \t}\n \treturn tg, nil\n }\n@@ -1073,10 +1075,10 @@ func (s *ServerCommand) makeSSLConfig() (config api.SSLConfig, err error) {\n \t\tconfig.SSLMode = api.None\n \tcase \"static\":\n \t\tif s.SSL.Cert == \"\" {\n-\t\t\treturn config, errors.New(\"path to cert.pem is required\")\n+\t\t\treturn config, fmt.Errorf(\"path to cert.pem is required\")\n \t\t}\n \t\tif s.SSL.Key == \"\" {\n-\t\t\treturn config, errors.New(\"path to key.pem is required\")\n+\t\t\treturn config, fmt.Errorf(\"path to key.pem is required\")\n \t\t}\n \t\tconfig.SSLMode = api.Static\n \t\tconfig.Port = s.SSL.Port"
    },
    {
      "sha": "37a29024af5d167921d63d366442f7b2f15985af",
      "filename": "backend/app/migrator/backup.go",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fbackup.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fbackup.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fbackup.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -10,7 +10,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n )\n \n // AutoBackup struct handles daily backups params for siteID\n@@ -50,18 +49,18 @@ func (ab AutoBackup) makeBackup() (string, error) {\n \tbackupFile := fmt.Sprintf(\"%s/backup-%s-%s.gz\", ab.BackupLocation, ab.SiteID, time.Now().Format(\"20060102\"))\n \tfh, err := os.Create(backupFile) //nolint:gosec // harmless\n \tif err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't create backup file %s\", backupFile)\n+\t\treturn \"\", fmt.Errorf(\"can't create backup file %s: %w\", backupFile, err)\n \t}\n \tgz := gzip.NewWriter(fh)\n \n \tif _, err = ab.Exporter.Export(gz, ab.SiteID); err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"export failed for %s\", ab.SiteID)\n+\t\treturn \"\", fmt.Errorf(\"export failed for %s: %w\", ab.SiteID, err)\n \t}\n \tif err = gz.Close(); err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't close gz for %s\", backupFile)\n+\t\treturn \"\", fmt.Errorf(\"can't close gz for %s: %w\", backupFile, err)\n \t}\n \tif err = fh.Close(); err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't close file handler for %s\", backupFile)\n+\t\treturn \"\", fmt.Errorf(\"can't close file handler for %s: %w\", backupFile, err)\n \t}\n \tlog.Printf(\"[DEBUG] created backup file %s\", backupFile)\n \treturn backupFile, nil"
    },
    {
      "sha": "a5c06fce50dbdbc0a8a4d5ef291c6fd69ef3dca5",
      "filename": "backend/app/migrator/commento.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fcommento.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fcommento.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fcommento.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -2,10 +2,10 @@ package migrator\n \n import (\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"io\"\n \t\"time\"\n \n-\t\"github.com/pkg/errors\"\n \t\"github.com/umputun/remark42/backend/app/store\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n@@ -68,9 +68,9 @@ func (d *Commento) Import(r io.Reader, siteID string) (size int, err error) {\n \t}\n \n \tif failed > 0 {\n-\t\terr = errors.Errorf(\"failed to save %d comments\", failed)\n+\t\terr = fmt.Errorf(\"failed to save %d comments\", failed)\n \t\tif passed == 0 {\n-\t\t\terr = errors.New(\"import failed\")\n+\t\t\terr = fmt.Errorf(\"import failed\")\n \t\t}\n \t}\n "
    },
    {
      "sha": "f79e9ae070fd3bbe734e6a39474b0613ebf0d416",
      "filename": "backend/app/migrator/commento_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fcommento_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fcommento_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fcommento_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -7,11 +7,12 @@ import (\n \n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n+\tbolt \"go.etcd.io/bbolt\"\n+\n \t\"github.com/umputun/remark42/backend/app/store\"\n \t\"github.com/umputun/remark42/backend/app/store/admin\"\n \t\"github.com/umputun/remark42/backend/app/store/engine\"\n \t\"github.com/umputun/remark42/backend/app/store/service\"\n-\tbolt \"go.etcd.io/bbolt\"\n )\n \n func TestCommento_Import(t *testing.T) {"
    },
    {
      "sha": "ef08fb7e12c86739ac6cd42cd67c33bc1d0d90f8",
      "filename": "backend/app/migrator/disqus.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fdisqus.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fdisqus.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fdisqus.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -2,12 +2,12 @@ package migrator\n \n import (\n \t\"encoding/xml\"\n+\t\"fmt\"\n \t\"io\"\n \t\"strings\"\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n )\n@@ -68,9 +68,9 @@ func (d *Disqus) Import(r io.Reader, siteID string) (size int, err error) {\n \t}\n \n \tif failed > 0 {\n-\t\terr = errors.Errorf(\"failed to save %d comments\", failed)\n+\t\terr = fmt.Errorf(\"failed to save %d comments\", failed)\n \t\tif passed == 0 {\n-\t\t\terr = errors.New(\"import failed\")\n+\t\t\terr = fmt.Errorf(\"import failed\")\n \t\t}\n \t}\n "
    },
    {
      "sha": "9ecdec87d8fb58289ac058dd7de1bf7426757ac3",
      "filename": "backend/app/migrator/migrator.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fmigrator.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fmigrator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fmigrator.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,11 +4,11 @@\n package migrator\n \n import (\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n \t\"github.com/umputun/remark42/backend/app/store/service\"\n@@ -69,12 +69,12 @@ func ImportComments(p ImportParams) (int, error) {\n \tcase \"native\":\n \t\timporter = &Native{DataStore: p.DataStore}\n \tdefault:\n-\t\treturn 0, errors.Errorf(\"unsupported import provider %s\", p.Provider)\n+\t\treturn 0, fmt.Errorf(\"unsupported import provider %s\", p.Provider)\n \t}\n \n \tfh, err := os.Open(p.InputFile)\n \tif err != nil {\n-\t\treturn 0, errors.Wrapf(err, \"can't open import file %s\", p.InputFile)\n+\t\treturn 0, fmt.Errorf(\"can't open import file %s: %w\", p.InputFile, err)\n \t}\n \n \tdefer func() { //nolint:gosec // false positive on defer without error check when it's checked here"
    },
    {
      "sha": "1fe81fcd6db42f7460324aaaa9360412bf9e92fc",
      "filename": "backend/app/migrator/native.go",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fnative.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fnative.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fnative.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,12 +4,12 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/json\"\n+\t\"fmt\"\n \t\"io\"\n \t\"sync/atomic\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/go-pkgz/syncs\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n \t\"github.com/umputun/remark42/backend/app/store/service\"\n@@ -36,7 +36,7 @@ type meta struct {\n // The final file is a valid json\n func (n *Native) Export(w io.Writer, siteID string) (size int, err error) {\n \tif err = n.exportMeta(siteID, w); err != nil {\n-\t\treturn 0, errors.Wrapf(err, \"failed to export meta for site %s\", siteID)\n+\t\treturn 0, fmt.Errorf(\"failed to export meta for site %s: %w\", siteID, err)\n \t}\n \n \ttopics, err := n.DataStore.List(siteID, 0, 0)\n@@ -59,10 +59,10 @@ func (n *Native) Export(w io.Writer, siteID string) (size int, err error) {\n \t\t\tenc.SetEscapeHTML(false)\n \n \t\t\tif err = enc.Encode(comment); err != nil {\n-\t\t\t\treturn commentsCount, errors.Wrapf(err, \"can't marshal %v\", comments)\n+\t\t\t\treturn commentsCount, fmt.Errorf(\"can't marshal %v: %w\", comments, err)\n \t\t\t}\n \t\t\tif _, err = w.Write(buf.Bytes()); err != nil {\n-\t\t\t\treturn commentsCount, errors.Wrap(err, \"can't write comment data\")\n+\t\t\t\treturn commentsCount, fmt.Errorf(\"can't write comment data: %w\", err)\n \t\t\t}\n \t\t\tcommentsCount++\n \t\t}\n@@ -76,11 +76,11 @@ func (n *Native) exportMeta(siteID string, w io.Writer) (err error) {\n \tm := meta{Version: nativeVersion}\n \tm.Users, m.Posts, err = n.DataStore.Metas(siteID)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"can't get meta\")\n+\t\treturn fmt.Errorf(\"can't get meta: %w\", err)\n \t}\n \n \tif err = json.NewEncoder(w).Encode(m); err != nil {\n-\t\treturn errors.Wrap(err, \"can't encode meta\")\n+\t\treturn fmt.Errorf(\"can't encode meta: %w\", err)\n \t}\n \treturn nil\n }\n@@ -131,11 +131,11 @@ func (n *Native) Import(reader io.Reader, siteID string) (size int, err error) {\n \tm := meta{}\n \tdec := json.NewDecoder(reader)\n \tif err = dec.Decode(&m); err != nil {\n-\t\treturn 0, errors.Wrapf(err, \"failed to import meta for site %s\", siteID)\n+\t\treturn 0, fmt.Errorf(\"failed to import meta for site %s: %w\", siteID, err)\n \t}\n \n \tif m.Version != nativeVersion && m.Version != 0 { // this version allows back compatibility with 0 version\n-\t\treturn 0, errors.Errorf(\"unexpected import file version %d\", m.Version)\n+\t\treturn 0, fmt.Errorf(\"unexpected import file version %d\", m.Version)\n \t}\n \n \tif e := n.DataStore.DeleteAll(siteID); e != nil {\n@@ -183,7 +183,7 @@ func (n *Native) Import(reader io.Reader, siteID string) (size int, err error) {\n \tgrp.Wait()\n \n \tif failed > 0 {\n-\t\treturn int(comments), errors.Errorf(\"failed to save %d comments\", failed)\n+\t\treturn int(comments), fmt.Errorf(\"failed to save %d comments\", failed)\n \t}\n \tlog.Printf(\"[INFO] imported %d comments from %d records\", comments, total)\n "
    },
    {
      "sha": "1bb224c3ac9b42b7d12bfab556add749a9106421",
      "filename": "backend/app/migrator/wordpress.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fwordpress.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fmigrator%2Fwordpress.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fmigrator%2Fwordpress.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -2,12 +2,12 @@ package migrator\n \n import (\n \t\"encoding/xml\"\n+\t\"fmt\"\n \t\"html\"\n \t\"io\"\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n )\n@@ -75,9 +75,9 @@ func (w *WordPress) Import(r io.Reader, siteID string) (size int, err error) {\n \t}\n \n \tif failed > 0 {\n-\t\terr = errors.Errorf(\"failed to save %d comments\", failed)\n+\t\terr = fmt.Errorf(\"failed to save %d comments\", failed)\n \t\tif passed == 0 {\n-\t\t\terr = errors.New(\"import failed\")\n+\t\t\terr = fmt.Errorf(\"import failed\")\n \t\t}\n \t}\n "
    },
    {
      "sha": "6e858eb2aeaff8ea701b68e32ffe8c989927cea2",
      "filename": "backend/app/notify/email.go",
      "status": "modified",
      "additions": 20,
      "deletions": 16,
      "changes": 36,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Femail.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Femail.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Femail.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -129,7 +129,7 @@ func NewEmail(emailParams EmailParams, smtpParams SMTPParams) (*Email, error) {\n \t// initialize templates\n \terr := res.setTemplates()\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"can't set templates\")\n+\t\treturn nil, fmt.Errorf(\"can't set templates: %w\", err)\n \t}\n \n \tlog.Printf(\"[DEBUG] Create new email notifier for server %s with user %s, timeout=%s\",\n@@ -173,20 +173,24 @@ func (e *Email) setTemplates() error {\n func (e *Email) Send(ctx context.Context, req Request) error {\n \tselect {\n \tcase <-ctx.Done():\n-\t\treturn errors.Errorf(\"sending email messages about comment %q aborted due to canceled context\", req.Comment.ID)\n+\t\treturn fmt.Errorf(\"sending email messages about comment %q aborted due to canceled context\", req.Comment.ID)\n \tdefault:\n \t}\n \n \tresult := new(multierror.Error)\n \n \tfor _, email := range req.Emails {\n \t\terr := e.buildAndSendMessage(ctx, req, email, false)\n-\t\tresult = multierror.Append(errors.Wrapf(err, \"problem sending user email notification to %q\", email))\n+\t\tif err != nil {\n+\t\t\tresult = multierror.Append(fmt.Errorf(\"problem sending user email notification to %q: %w\", email, err))\n+\t\t}\n \t}\n \n \tfor _, email := range e.AdminEmails {\n \t\terr := e.buildAndSendMessage(ctx, req, email, true)\n-\t\tresult = multierror.Append(errors.Wrapf(err, \"problem sending admin email notification to %q\", email))\n+\t\tif err != nil {\n+\t\t\tresult = multierror.Append(fmt.Errorf(\"problem sending admin email notification to %q: %w\", email, err))\n+\t\t}\n \t}\n \n \treturn result.ErrorOrNil()\n@@ -215,7 +219,7 @@ func (e *Email) SendVerification(ctx context.Context, req VerificationRequest) e\n \t}\n \tselect {\n \tcase <-ctx.Done():\n-\t\treturn errors.Errorf(\"sending message to %q aborted due to canceled context\", req.User)\n+\t\treturn fmt.Errorf(\"sending message to %q aborted due to canceled context\", req.User)\n \tdefault:\n \t}\n \n@@ -338,11 +342,11 @@ func (e *Email) buildMessage(subject, body, to, contentType, unsubscribeLink str\n // Thread safe.\n func (e *Email) sendMessage(m emailMessage) error {\n \tif e.smtp == nil {\n-\t\treturn errors.New(\"sendMessage called without client set\")\n+\t\treturn fmt.Errorf(\"sendMessage called without client set\")\n \t}\n \tclient, err := e.smtp.Create(e.SMTPParams)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"failed to make smtp Create\")\n+\t\treturn fmt.Errorf(\"failed to make smtp Create: %w\", err)\n \t}\n \n \tdefer func() {\n@@ -355,15 +359,15 @@ func (e *Email) sendMessage(m emailMessage) error {\n \t}()\n \n \tif err = client.Mail(m.from); err != nil {\n-\t\treturn errors.Wrapf(err, \"bad from address %q\", m.from)\n+\t\treturn fmt.Errorf(\"bad from address %q: %w\", m.from, err)\n \t}\n \tif err = client.Rcpt(m.to); err != nil {\n-\t\treturn errors.Wrapf(err, \"bad to address %q\", m.to)\n+\t\treturn fmt.Errorf(\"bad to address %q: %w\", m.to, err)\n \t}\n \n \twriter, err := client.Data()\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"can't make email writer\")\n+\t\treturn fmt.Errorf(\"can't make email writer: %w\", err)\n \t}\n \n \tdefer func() {\n@@ -374,7 +378,7 @@ func (e *Email) sendMessage(m emailMessage) error {\n \n \tbuf := bytes.NewBufferString(m.message)\n \tif _, err = buf.WriteTo(writer); err != nil {\n-\t\treturn errors.Wrapf(err, \"failed to send email body to %q\", m.to)\n+\t\treturn fmt.Errorf(\"failed to send email body to %q: %w\", m.to, err)\n \t}\n \n \treturn nil\n@@ -394,7 +398,7 @@ func (s *emailClient) Create(params SMTPParams) (smtpClient, error) {\n \t\t}\n \t\tauth := smtp.PlainAuth(\"\", params.Username, params.Password, params.Host)\n \t\tif err := c.Auth(auth); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to auth to smtp %s:%d\", params.Host, params.Port)\n+\t\t\treturn fmt.Errorf(\"failed to auth to smtp %s:%d: %w\", params.Host, params.Port, err)\n \t\t}\n \t\treturn nil\n \t}\n@@ -409,22 +413,22 @@ func (s *emailClient) Create(params SMTPParams) (smtpClient, error) {\n \t\t}\n \t\tconn, err := tls.Dial(\"tcp\", srvAddress, tlsConf)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrapf(err, \"failed to dial smtp tls to %s\", srvAddress)\n+\t\t\treturn nil, fmt.Errorf(\"failed to dial smtp tls to %s: %w\", srvAddress, err)\n \t\t}\n \t\tif c, err = smtp.NewClient(conn, params.Host); err != nil {\n-\t\t\treturn nil, errors.Wrapf(err, \"failed to make smtp client for %s\", srvAddress)\n+\t\t\treturn nil, fmt.Errorf(\"failed to make smtp client for %s: %w\", srvAddress, err)\n \t\t}\n \t\treturn c, authenticate(c)\n \t}\n \n \tconn, err := net.DialTimeout(\"tcp\", srvAddress, params.TimeOut)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"timeout connecting to %s\", srvAddress)\n+\t\treturn nil, fmt.Errorf(\"timeout connecting to %s: %w\", srvAddress, err)\n \t}\n \n \tc, err = smtp.NewClient(conn, params.Host)\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to dial\")\n+\t\treturn nil, fmt.Errorf(\"failed to dial: %w\", err)\n \t}\n \n \treturn c, authenticate(c)"
    },
    {
      "sha": "091f18f28335522aae93618d48057546e6a59223",
      "filename": "backend/app/notify/email_test.go",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Femail_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Femail_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Femail_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -3,7 +3,7 @@ package notify\n import (\n \t\"bytes\"\n \t\"context\"\n-\t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"net/smtp\"\n \t\"sync\"\n@@ -361,7 +361,7 @@ type fakeTestSMTP struct {\n \n func (f *fakeTestSMTP) Create(SMTPParams) (smtpClient, error) {\n \tif f.fail[\"create\"] {\n-\t\treturn nil, errors.New(\"failed to create client\")\n+\t\treturn nil, fmt.Errorf(\"failed to create client\")\n \t}\n \treturn f, nil\n }\n@@ -373,7 +373,7 @@ func (f *fakeTestSMTP) Mail(m string) error {\n \tf.mail = m\n \tf.lock.Unlock()\n \tif f.fail[\"mail\"] {\n-\t\treturn errors.New(\"failed to verify sender\")\n+\t\treturn fmt.Errorf(\"failed to verify sender\")\n \t}\n \treturn nil\n }\n@@ -383,7 +383,7 @@ func (f *fakeTestSMTP) Rcpt(r string) error {\n \tf.rcpt = r\n \tf.lock.Unlock()\n \tif f.fail[\"rcpt\"] {\n-\t\treturn errors.New(\"failed to verify receiver\")\n+\t\treturn fmt.Errorf(\"failed to verify receiver\")\n \t}\n \treturn nil\n }\n@@ -393,22 +393,22 @@ func (f *fakeTestSMTP) Quit() error {\n \tf.quitCount++\n \tf.lock.Unlock()\n \tif f.fail[\"quit\"] {\n-\t\treturn errors.New(\"failed to quit\")\n+\t\treturn fmt.Errorf(\"failed to quit\")\n \t}\n \treturn nil\n }\n \n func (f *fakeTestSMTP) Close() error {\n \tf.close = true\n \tif f.fail[\"close\"] {\n-\t\treturn errors.New(\"failed to close\")\n+\t\treturn fmt.Errorf(\"failed to close\")\n \t}\n \treturn nil\n }\n \n func (f *fakeTestSMTP) Data() (io.WriteCloser, error) {\n \tif f.fail[\"data\"] {\n-\t\treturn nil, errors.New(\"failed to send\")\n+\t\treturn nil, fmt.Errorf(\"failed to send\")\n \t}\n \treturn nopCloser{&f.buff}, nil\n }\n@@ -433,7 +433,7 @@ func (f *fakeTestSMTP) readQuitCount() int {\n \n func TokenGenFn(user, _, _ string) (string, error) {\n \tif user == \"error\" {\n-\t\treturn \"\", errors.New(\"token generation error\")\n+\t\treturn \"\", fmt.Errorf(\"token generation error\")\n \t}\n \treturn \"token\", nil\n }"
    },
    {
      "sha": "91e677d9e6e0bf95a87b1561711a2f76c23b5a7a",
      "filename": "backend/app/notify/notify_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fnotify_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fnotify_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Fnotify_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,7 +1,6 @@\n package notify\n \n import (\n-\t\"errors\"\n \t\"fmt\"\n \t\"math/rand\"\n \t\"sync/atomic\"\n@@ -284,15 +283,15 @@ type mockStore struct {\n func (m mockStore) getUserDetail(userID string) (string, error) {\n \tdetail, ok := m.userDetails[userID]\n \tif !ok {\n-\t\treturn \"\", errors.New(\"no such user\")\n+\t\treturn \"\", fmt.Errorf(\"no such user\")\n \t}\n \treturn detail, nil\n }\n \n func (m mockStore) Get(_ store.Locator, id string, _ store.User) (store.Comment, error) {\n \tres, ok := m.data[id]\n \tif !ok {\n-\t\treturn store.Comment{}, errors.New(\"no such id\")\n+\t\treturn store.Comment{}, fmt.Errorf(\"no such id\")\n \t}\n \treturn res, nil\n }"
    },
    {
      "sha": "9cee44efcaaf40e88e1aff14e7efe5ea69b77b99",
      "filename": "backend/app/notify/slack.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fslack.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fslack.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Fslack.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -2,9 +2,9 @@ package notify\n \n import (\n \t\"context\"\n+\t\"fmt\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \t\"github.com/slack-go/slack\"\n )\n \n@@ -26,7 +26,7 @@ func NewSlack(token, channelName string, opts ...slack.Option) (*Slack, error) {\n \n \tchannelID, err := res.findChannelIDByName(channelName)\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"can not find slack channel '\"+channelName+\"'\")\n+\t\treturn nil, fmt.Errorf(\"can not find slack channel '\"+channelName+\"': %w\", err)\n \t}\n \n \tres.channelID = channelID\n@@ -91,5 +91,5 @@ func (t *Slack) findChannelIDByName(name string) (string, error) {\n \t\t}\n \t\tparams.Cursor = next\n \t}\n-\treturn \"\", errors.New(\"no such channel\")\n+\treturn \"\", fmt.Errorf(\"no such channel\")\n }"
    },
    {
      "sha": "b383c12e57dc5d8bb043abe3cd1f265641184aba",
      "filename": "backend/app/notify/telegram.go",
      "status": "modified",
      "additions": 17,
      "deletions": 18,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Ftelegram.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Ftelegram.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Ftelegram.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -5,7 +5,6 @@ import (\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n-\t\"golang.org/x/net/html\"\n \t\"io\"\n \t\"net/http\"\n \tneturl \"net/url\"\n@@ -15,12 +14,12 @@ import (\n \t\"sync/atomic\"\n \t\"time\"\n \n-\t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/microcosm-cc/bluemonday\"\n-\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/go-pkgz/repeater\"\n+\t\"github.com/hashicorp/go-multierror\"\n+\t\"github.com/microcosm-cc/bluemonday\"\n \t\"github.com/pkg/errors\"\n+\t\"golang.org/x/net/html\"\n )\n \n // TelegramParams contain settings for telegram notifications\n@@ -111,7 +110,7 @@ func (t *Telegram) Send(ctx context.Context, req Request) error {\n \n \tmsg, err := buildMessage(req)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"failed to make telegram message body for comment ID %s\", req.Comment.ID)\n+\t\treturn fmt.Errorf(\"failed to make telegram message body for comment ID %s: %w\", req.Comment.ID, err)\n \t}\n \n \tif t.AdminChannelID != \"\" {\n@@ -269,22 +268,22 @@ func (t *Telegram) CheckToken(token, user string) (telegram, site string, err er\n \tt.requests.RUnlock()\n \n \tif !ok {\n-\t\treturn \"\", \"\", errors.New(\"request is not found\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"request is not found\")\n \t}\n \n \tif time.Now().After(authRequest.expires) {\n \t\tt.requests.Lock()\n \t\tdelete(t.requests.data, token)\n \t\tt.requests.Unlock()\n-\t\treturn \"\", \"\", errors.New(\"request expired\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"request expired\")\n \t}\n \n \tif !authRequest.confirmed {\n-\t\treturn \"\", \"\", errors.New(\"request is not verified yet\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"request is not verified yet\")\n \t}\n \n \tif authRequest.user != user {\n-\t\treturn \"\", \"\", errors.New(\"user does not match original requester\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"user does not match original requester\")\n \t}\n \n \t// Delete request\n@@ -333,7 +332,7 @@ func (t *Telegram) Run(ctx context.Context) {\n // so that caller could get updates and send it not only there but to multiple sources\n func (t *Telegram) ProcessUpdate(ctx context.Context, textUpdate string) error {\n \tif atomic.LoadInt32(&t.run) != 0 {\n-\t\treturn errors.New(\"Run goroutine should not be used with ProcessUpdate\")\n+\t\treturn fmt.Errorf(\"the Run goroutine should not be used with ProcessUpdate\")\n \t}\n \tdefer func() {\n \t\t// as Run goroutine is not running, clean up old requests on each update\n@@ -349,7 +348,7 @@ func (t *Telegram) ProcessUpdate(ctx context.Context, textUpdate string) error {\n \t}()\n \tvar updates TelegramUpdate\n \tif err := json.Unmarshal([]byte(textUpdate), &updates); err != nil {\n-\t\treturn errors.Wrap(err, \"failed to decode provided telegram update\")\n+\t\treturn fmt.Errorf(\"failed to decode provided telegram update: %w\", err)\n \t}\n \tt.processUpdates(ctx, &updates)\n \treturn nil\n@@ -377,7 +376,7 @@ func (t *Telegram) getUpdates(ctx context.Context) (*TelegramUpdate, error) {\n \n \terr := t.Request(ctx, url, nil, &result)\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"failed to fetch updates\")\n+\t\treturn nil, fmt.Errorf(\"failed to fetch updates: %w\", err)\n \t}\n \n \tfor _, u := range result.Result {\n@@ -445,7 +444,7 @@ func (t *Telegram) botInfo(ctx context.Context) (*TelegramBotInfo, error) {\n \t\treturn nil, err\n \t}\n \tif resp.Result == nil {\n-\t\treturn nil, errors.New(\"received empty result\")\n+\t\treturn nil, fmt.Errorf(\"received empty result\")\n \t}\n \n \treturn resp.Result, nil\n@@ -465,13 +464,13 @@ func (t *Telegram) Request(ctx context.Context, method string, b []byte, data in\n \t\t\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n \t\t}\n \t\tif err != nil {\n-\t\t\treturn errors.Wrap(err, \"failed to create request\")\n+\t\t\treturn fmt.Errorf(\"failed to create request: %w\", err)\n \t\t}\n \n \t\tclient := http.Client{Timeout: t.Timeout}\n \t\tresp, err := client.Do(req)\n \t\tif err != nil {\n-\t\t\treturn errors.Wrap(err, \"failed to send request\")\n+\t\t\treturn fmt.Errorf(\"failed to send request: %w\", err)\n \t\t}\n \t\tdefer resp.Body.Close()\n \n@@ -480,7 +479,7 @@ func (t *Telegram) Request(ctx context.Context, method string, b []byte, data in\n \t\t}\n \n \t\tif err = json.NewDecoder(resp.Body).Decode(data); err != nil {\n-\t\t\treturn errors.Wrap(err, \"failed to decode json response\")\n+\t\t\treturn fmt.Errorf(\"failed to decode json response: %w\", err)\n \t\t}\n \n \t\treturn nil\n@@ -492,7 +491,7 @@ func (t *Telegram) parseError(r io.Reader, statusCode int) error {\n \t\tDescription string `json:\"description\"`\n \t}{}\n \tif err := json.NewDecoder(r).Decode(&tgErr); err != nil {\n-\t\treturn errors.Errorf(\"unexpected telegram API status code %d\", statusCode)\n+\t\treturn fmt.Errorf(\"unexpected telegram API status code %d\", statusCode)\n \t}\n-\treturn errors.Errorf(\"unexpected telegram API status code %d, error: %q\", statusCode, tgErr.Description)\n+\treturn fmt.Errorf(\"unexpected telegram API status code %d, error: %q\", statusCode, tgErr.Description)\n }"
    },
    {
      "sha": "9d448e5262b14777cb5b79a3286c803942a37c6b",
      "filename": "backend/app/notify/telegram_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Ftelegram_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Ftelegram_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Ftelegram_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -453,7 +453,7 @@ func TestTelegram_TokenVerification(t *testing.T) {\n \tctx, cancel := context.WithCancel(context.Background())\n \tgo tb.Run(ctx)\n \tassert.Eventually(t, func() bool {\n-\t\treturn tb.ProcessUpdate(ctx, \"\").Error() == \"Run goroutine should not be used with ProcessUpdate\"\n+\t\treturn tb.ProcessUpdate(ctx, \"\").Error() == \"the Run goroutine should not be used with ProcessUpdate\"\n \t}, time.Millisecond*100, time.Millisecond*10, \"ProcessUpdate should not work same time as Run\")\n \ttb.AddToken(\"expired token\", \"user\", \"site\", time.Now().Add(-time.Minute))\n \ttb.requests.RLock()"
    },
    {
      "sha": "722968a772ecfd0fcfc2d71c06d561eb73da7ad9",
      "filename": "backend/app/notify/webhook.go",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fwebhook.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fwebhook.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Fwebhook.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -40,7 +40,7 @@ type Webhook struct {\n func NewWebhook(client WebhookClient, params WebhookParams) (*Webhook, error) {\n \tres := &Webhook{WebhookParams: params}\n \tif res.WebhookURL == \"\" {\n-\t\treturn nil, errors.New(\"webhook URL is required for webhook notifications\")\n+\t\treturn nil, fmt.Errorf(\"webhook URL is required for webhook notifications\")\n \t}\n \n \tif res.Template == \"\" {\n@@ -49,7 +49,7 @@ func NewWebhook(client WebhookClient, params WebhookParams) (*Webhook, error) {\n \n \tpayloadTmpl, err := template.New(\"webhook\").Parse(res.Template)\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"unable to parse webhook template\")\n+\t\treturn nil, fmt.Errorf(\"unable to parse webhook template: %w\", err)\n \t}\n \n \tres.webhookClient = client\n@@ -65,12 +65,12 @@ func (t *Webhook) Send(ctx context.Context, req Request) error {\n \tvar payload bytes.Buffer\n \terr := t.webhookTemplate.Execute(&payload, req.Comment)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"unable to compile webhook template\")\n+\t\treturn fmt.Errorf(\"unable to compile webhook template: %w\", err)\n \t}\n \n \thttpReq, err := http.NewRequestWithContext(ctx, \"POST\", t.WebhookURL, &payload)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"unable to create webhook request\")\n+\t\treturn fmt.Errorf(\"unable to create webhook request: %w\", err)\n \t}\n \n \tfor _, h := range t.Headers {\n@@ -83,7 +83,7 @@ func (t *Webhook) Send(ctx context.Context, req Request) error {\n \n \tresp, err := t.webhookClient.Do(httpReq)\n \tif err != nil {\n-\t\treturn errors.Wrap(err, \"webhook request failed\")\n+\t\treturn fmt.Errorf(\"webhook request failed: %w\", err)\n \t}\n \n \tdefer resp.Body.Close()"
    },
    {
      "sha": "abcd2bedcc4e17f8aacc9e7b8208e2aad3f15117",
      "filename": "backend/app/notify/webhook_test.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fwebhook_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fnotify%2Fwebhook_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fnotify%2Fwebhook_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -3,7 +3,7 @@ package notify\n import (\n \t\"bytes\"\n \t\"context\"\n-\t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n \t\"testing\"\n@@ -31,7 +31,7 @@ type errReader struct {\n }\n \n func (errReader) Read(p []byte) (n int, err error) {\n-\treturn 0, errors.New(\"test error\")\n+\treturn 0, fmt.Errorf(\"test error\")\n }\n \n func TestWebhook_NewWebhook(t *testing.T) {\n@@ -104,7 +104,7 @@ func TestWebhook_Send(t *testing.T) {\n \tassert.Contains(t, err.Error(), \"unable to create webhook request\")\n \n \twh, err = NewWebhook(funcWebhookClient(func(*http.Request) (*http.Response, error) {\n-\t\treturn nil, errors.New(\"request failed\")\n+\t\treturn nil, fmt.Errorf(\"request failed\")\n \t}), WebhookParams{WebhookURL: \"https://not-existing-url.net\"})\n \tassert.NoError(t, err)\n \terr = wh.Send(context.TODO(), Request{Comment: c})"
    },
    {
      "sha": "684be12cd86f60057dbb630b384af5a0b393dcab",
      "filename": "backend/app/providers/telegram_test.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fproviders%2Ftelegram_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fproviders%2Ftelegram_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fproviders%2Ftelegram_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -3,7 +3,7 @@ package providers\n import (\n \t\"context\"\n \t\"encoding/json\"\n-\t\"errors\"\n+\t\"fmt\"\n \t\"testing\"\n \t\"time\"\n \n@@ -46,7 +46,7 @@ func (m *mockTGRequester) Request(_ context.Context, _ string, _ []byte, data in\n \t\tassert.NoError(m.t, json.Unmarshal([]byte(getUpdatesResp), data))\n \t\treturn nil\n \t}\n-\treturn errors.New(\"test error\")\n+\treturn fmt.Errorf(\"test error\")\n }\n \n type mockTGUpdatesReceiver struct {\n@@ -68,5 +68,5 @@ func (m *mockTGUpdatesReceiver) ProcessUpdate(_ context.Context, textUpdate stri\n \t\treturn nil\n \t}\n \tassert.Nil(m.t, result.Result)\n-\treturn errors.New(\"test error\")\n+\treturn fmt.Errorf(\"test error\")\n }"
    },
    {
      "sha": "635bae1ebe408ff89fea5edfca8bc07e4b126609",
      "filename": "backend/app/rest/api/admin.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Fadmin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fadmin.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,7 +1,7 @@\n package api\n \n import (\n-\t\"errors\"\n+\t\"fmt\"\n \t\"net/http\"\n \t\"path\"\n \t\"time\"\n@@ -103,7 +103,7 @@ func (a *admin) deleteMeRequestCtrl(w http.ResponseWriter, r *http.Request) {\n \n \t// deleteme set by deleteMeCtrl, this check just to make sure we not trying to delete with leaked token\n \tif !claims.User.BoolAttr(\"delete_me\") {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"forbidden\"), \"can't use provided token\", rest.ErrNoAccess)\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"forbidden\"), \"can't use provided token\", rest.ErrNoAccess)\n \t\treturn\n \t}\n \n@@ -183,7 +183,7 @@ func (a *admin) setReadOnlyCtrl(w http.ResponseWriter, r *http.Request) {\n \t// don't allow to reset ro for posts turned to ro by ReadOnlyAge\n \tif !roStatus {\n \t\tif info, e := a.dataService.Info(locator, a.readOnlyAge); e == nil && isRoByAge(info) {\n-\t\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"),\n+\t\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"rejected\"),\n \t\t\t\t\"read-only due the age\", rest.ErrActionRejected)\n \t\t\treturn\n \t\t}"
    },
    {
      "sha": "bd056c88b3c4c6d89a8dfea93b97c3f09c5e9377",
      "filename": "backend/app/rest/api/migrator.go",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Fmigrator.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Fmigrator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Fmigrator.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -15,7 +15,6 @@ import (\n \tcache \"github.com/go-pkgz/lcw\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/migrator\"\n \t\"github.com/umputun/remark42/backend/app/rest\"\n@@ -47,7 +46,7 @@ func (m *Migrator) importCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \n \tif m.isBusy(siteID) {\n-\t\trest.SendErrorJSON(w, r, http.StatusConflict, errors.New(\"already running\"),\n+\t\trest.SendErrorJSON(w, r, http.StatusConflict, fmt.Errorf(\"already running\"),\n \t\t\t\"import rejected\", rest.ErrActionRejected)\n \t\treturn\n \t}\n@@ -70,7 +69,7 @@ func (m *Migrator) importFormCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \n \tif m.isBusy(siteID) {\n-\t\trest.SendErrorJSON(w, r, http.StatusConflict, errors.New(\"already running\"),\n+\t\trest.SendErrorJSON(w, r, http.StatusConflict, fmt.Errorf(\"already running\"),\n \t\t\t\"import rejected\", rest.ErrActionRejected)\n \t\treturn\n \t}\n@@ -253,15 +252,15 @@ func (m *Migrator) runImport(siteID, provider, tmpfile string) {\n func (m *Migrator) saveTemp(r io.Reader) (string, error) {\n \ttmpfile, err := ioutil.TempFile(\"\", \"remark42_import\")\n \tif err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"can't make temp file\")\n+\t\treturn \"\", fmt.Errorf(\"can't make temp file: %w\", err)\n \t}\n \n \tif _, err = io.Copy(tmpfile, r); err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"can't copy to temp file\")\n+\t\treturn \"\", fmt.Errorf(\"can't copy to temp file: %w\", err)\n \t}\n \n \tif err = tmpfile.Close(); err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"can't close temp file\")\n+\t\treturn \"\", fmt.Errorf(\"can't close temp file: %w\", err)\n \t}\n \n \treturn tmpfile.Name(), nil"
    },
    {
      "sha": "664259b0a0aba54932e7702eb1c8f77ffaed047b",
      "filename": "backend/app/rest/api/rest.go",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -21,7 +21,6 @@ import (\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/go-pkgz/rest/logger\"\n-\t\"github.com/pkg/errors\"\n \t\"github.com/rakyll/statik/fs\"\n \n \t\"github.com/umputun/remark42/backend/app/notify\"\n@@ -505,7 +504,7 @@ func encodeJSONWithHTML(v interface{}) ([]byte, error) {\n \tenc := json.NewEncoder(buf)\n \tenc.SetEscapeHTML(false)\n \tif err := enc.Encode(v); err != nil {\n-\t\treturn nil, errors.Wrap(err, \"json encoding failed\")\n+\t\treturn nil, fmt.Errorf(\"json encoding failed: %w\", err)\n \t}\n \treturn buf.Bytes(), nil\n }"
    },
    {
      "sha": "618a4251601d0f1216b71b7a51c5068e7151266b",
      "filename": "backend/app/rest/api/rest_private.go",
      "status": "modified",
      "additions": 20,
      "deletions": 21,
      "changes": 41,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_private.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -22,7 +22,6 @@ import (\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/golang-jwt/jwt\"\n \t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/notify\"\n \t\"github.com/umputun/remark42/backend/app/rest\"\n@@ -142,12 +141,12 @@ func (s *private) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \n \t// check if user blocked\n \tif s.dataService.IsBlocked(comment.Locator.SiteID, comment.User.ID) {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"), \"user blocked\", rest.ErrUserBlocked)\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"rejected\"), \"user blocked\", rest.ErrUserBlocked)\n \t\treturn\n \t}\n \n \tif s.isReadOnly(comment.Locator) {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"), \"old post, read-only\", rest.ErrReadOnly)\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"rejected\"), \"old post, read-only\", rest.ErrReadOnly)\n \t\treturn\n \t}\n \n@@ -207,7 +206,7 @@ func (s *private) updateCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tif currComment.User.ID != user.ID {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"),\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"rejected\"),\n \t\t\t\"can not edit comments for other users\", rest.ErrNoAccess)\n \t\treturn\n \t}\n@@ -268,13 +267,13 @@ func (s *private) voteCtrl(w http.ResponseWriter, r *http.Request) {\n \tvote := r.URL.Query().Get(\"vote\") == \"1\"\n \n \tif s.isReadOnly(locator) {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"), \"old post, read-only\", rest.ErrReadOnly)\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"rejected\"), \"old post, read-only\", rest.ErrReadOnly)\n \t\treturn\n \t}\n \n \t// check if user blocked\n \tif s.dataService.IsBlocked(locator.SiteID, user.ID) {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"), \"user blocked\", rest.ErrUserBlocked)\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"rejected\"), \"user blocked\", rest.ErrUserBlocked)\n \t\treturn\n \t}\n \n@@ -317,7 +316,7 @@ func (s *private) sendEmailConfirmationCtrl(w http.ResponseWriter, r *http.Reque\n \tsiteID := r.URL.Query().Get(\"site\")\n \tif address == \"\" {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest,\n-\t\t\terrors.New(\"missing parameter\"), \"address parameter is required\", rest.ErrInternal)\n+\t\t\tfmt.Errorf(\"missing parameter\"), \"address parameter is required\", rest.ErrInternal)\n \t\treturn\n \t}\n \texistingAddress, err := s.dataService.GetUserEmail(siteID, user.ID)\n@@ -326,7 +325,7 @@ func (s *private) sendEmailConfirmationCtrl(w http.ResponseWriter, r *http.Reque\n \t}\n \tif address == existingAddress {\n \t\trest.SendErrorJSON(w, r, http.StatusConflict,\n-\t\t\terrors.New(\"already verified\"), \"email address is already verified for this user\", rest.ErrInternal)\n+\t\t\tfmt.Errorf(\"already verified\"), \"email address is already verified for this user\", rest.ErrInternal)\n \t\treturn\n \t}\n \tclaims := token.Claims{\n@@ -364,7 +363,7 @@ func (s *private) telegramSubscribeCtrl(w http.ResponseWriter, r *http.Request)\n \n \tif s.telegramService == nil {\n \t\trest.SendErrorJSON(w, r, http.StatusInternalServerError,\n-\t\t\terrors.New(\"not enabled\"), \"telegram notifications are not enabled\", rest.ErrActionRejected)\n+\t\t\tfmt.Errorf(\"not enabled\"), \"telegram notifications are not enabled\", rest.ErrActionRejected)\n \t\treturn\n \t}\n \n@@ -373,13 +372,13 @@ func (s *private) telegramSubscribeCtrl(w http.ResponseWriter, r *http.Request)\n \t\t// GET /telegram/subscribe?site=siteID (No token supplied)\n \t\tsiteID := r.URL.Query().Get(\"site\")\n \t\tif siteID == \"\" {\n-\t\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(\"missing parameter\"), \"site parameter is required\", rest.ErrInternal)\n+\t\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"missing parameter\"), \"site parameter is required\", rest.ErrInternal)\n \t\t\treturn\n \t\t}\n \t\t// we don't care as much if we can't retrieve the current value of that field for the user, so ignore the error\n \t\tif existingAddress, _ := s.dataService.GetUserTelegram(siteID, user.ID); existingAddress != \"\" {\n \t\t\trest.SendErrorJSON(w, r, http.StatusConflict,\n-\t\t\t\terrors.New(\"already subscribed\"), \"telegram subscription is already set for this user, delete if first to re-subscribe\", rest.ErrActionRejected)\n+\t\t\t\tfmt.Errorf(\"already subscribed\"), \"telegram subscription is already set for this user, delete if first to re-subscribe\", rest.ErrActionRejected)\n \t\t\treturn\n \t\t}\n \t\t// Generate and send token\n@@ -422,7 +421,7 @@ func (s *private) telegramSubscribeCtrl(w http.ResponseWriter, r *http.Request)\n func (s *private) setConfirmedEmailCtrl(w http.ResponseWriter, r *http.Request) {\n \ttkn := r.URL.Query().Get(\"tkn\")\n \tif tkn == \"\" {\n-\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(\"missing parameter\"), \"token parameter is required\", rest.ErrInternal)\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"missing parameter\"), \"token parameter is required\", rest.ErrInternal)\n \t\treturn\n \t}\n \tuser := rest.MustGetUserInfo(r)\n@@ -435,14 +434,14 @@ func (s *private) setConfirmedEmailCtrl(w http.ResponseWriter, r *http.Request)\n \t}\n \n \tif s.authenticator.TokenService().IsExpired(confClaims) {\n-\t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"expired\"), \"failed to verify confirmation token\", rest.ErrInternal)\n+\t\trest.SendErrorJSON(w, r, http.StatusForbidden, fmt.Errorf(\"expired\"), \"failed to verify confirmation token\", rest.ErrInternal)\n \t\treturn\n \t}\n \n \t// Handshake.ID is user.ID + \"::\" + address\n \telems := strings.Split(confClaims.Handshake.ID, \"::\")\n \tif len(elems) != 2 || elems[0] != user.ID {\n-\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(confClaims.Handshake.ID), \"invalid handshake token\", rest.ErrInternal)\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"%s\", confClaims.Handshake.ID), \"invalid handshake token\", rest.ErrInternal)\n \t\treturn\n \t}\n \taddress := elems[1]\n@@ -475,7 +474,7 @@ func (s *private) emailUnsubscribeCtrl(w http.ResponseWriter, r *http.Request) {\n \ttkn := r.URL.Query().Get(\"tkn\")\n \tif tkn == \"\" {\n \t\trest.SendErrorHTML(w, r, http.StatusBadRequest,\n-\t\t\terrors.New(\"missing parameter\"), \"token parameter is required\", rest.ErrInternal, s.templates)\n+\t\t\tfmt.Errorf(\"missing parameter\"), \"token parameter is required\", rest.ErrInternal, s.templates)\n \t\treturn\n \t}\n \tsiteID := r.URL.Query().Get(\"site\")\n@@ -488,15 +487,15 @@ func (s *private) emailUnsubscribeCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tif s.authenticator.TokenService().IsExpired(confClaims) {\n \t\trest.SendErrorHTML(w, r, http.StatusForbidden,\n-\t\t\terrors.New(\"expired\"), \"failed to verify confirmation token\", rest.ErrInternal, s.templates)\n+\t\t\tfmt.Errorf(\"expired\"), \"failed to verify confirmation token\", rest.ErrInternal, s.templates)\n \t\treturn\n \t}\n \n \t// Handshake.ID is user.ID + \"::\" + address\n \telems := strings.Split(confClaims.Handshake.ID, \"::\")\n \tif len(elems) != 2 {\n \t\trest.SendErrorHTML(w, r, http.StatusBadRequest,\n-\t\t\terrors.New(confClaims.Handshake.ID), \"invalid handshake token\", rest.ErrInternal, s.templates)\n+\t\t\tfmt.Errorf(\"%s\", confClaims.Handshake.ID), \"invalid handshake token\", rest.ErrInternal, s.templates)\n \t\treturn\n \t}\n \tuserID := elems[0]\n@@ -510,12 +509,12 @@ func (s *private) emailUnsubscribeCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \tif existingAddress == \"\" {\n \t\trest.SendErrorHTML(w, r, http.StatusConflict,\n-\t\t\terrors.New(\"user is not subscribed\"), \"user does not have active email subscription\", rest.ErrInternal, s.templates)\n+\t\t\tfmt.Errorf(\"user is not subscribed\"), \"user does not have active email subscription\", rest.ErrInternal, s.templates)\n \t\treturn\n \t}\n \tif address != existingAddress {\n \t\trest.SendErrorHTML(w, r, http.StatusBadRequest,\n-\t\t\terrors.New(\"wrong email unsubscription\"), \"email address in request does not match known for this user\",\n+\t\t\tfmt.Errorf(\"wrong email unsubscription\"), \"email address in request does not match known for this user\",\n \t\t\trest.ErrInternal, s.templates)\n \t\treturn\n \t}\n@@ -727,11 +726,11 @@ func (s *private) isReadOnly(locator store.Locator) bool {\n func randToken() (string, error) {\n \tb := make([]byte, 32)\n \tif _, err := rand.Read(b); err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"can't get random\")\n+\t\treturn \"\", fmt.Errorf(\"can't get random: %w\", err)\n \t}\n \ts := sha1.New() //nolint:gosec // not used for security\n \tif _, err := s.Write(b); err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"can't write randoms to sha1\")\n+\t\treturn \"\", fmt.Errorf(\"can't write randoms to sha1: %w\", err)\n \t}\n \treturn fmt.Sprintf(\"%x\", s.Sum(nil)), nil\n }"
    },
    {
      "sha": "3347e78d88eeb0c3c414aee1f116f02095cd48a7",
      "filename": "backend/app/rest/api/rest_private_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_private_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -6,7 +6,6 @@ import (\n \t\"context\"\n \t\"encoding/base64\"\n \t\"encoding/json\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"mime/multipart\"\n@@ -1287,7 +1286,7 @@ func (m *mockTelegram) GetBotUsername() string {\n \n func (m *mockTelegram) CheckToken(string, string) (telegram, site string, err error) {\n \tif m.notVerified {\n-\t\treturn \"\", \"\", errors.New(\"not verified\")\n+\t\treturn \"\", \"\", fmt.Errorf(\"not verified\")\n \t}\n \treturn \"good_telegram\", m.site, nil\n }"
    },
    {
      "sha": "5ebd704de1395b4e9523e7c5f5a40030aeffe3e7",
      "filename": "backend/app/rest/api/rest_public.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_public.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_public.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_public.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,6 +4,7 @@ import (\n \t\"bytes\"\n \t\"crypto/sha1\" // nolint\n \t\"encoding/base64\"\n+\t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n \t\"os\"\n@@ -17,7 +18,6 @@ import (\n \tcache \"github.com/go-pkgz/lcw\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n-\t\"github.com/pkg/errors\"\n \t\"github.com/skip2/go-qrcode\"\n \n \t\"github.com/umputun/remark42/backend/app/rest\"\n@@ -372,12 +372,12 @@ func (s *public) robotsCtrl(w http.ResponseWriter, r *http.Request) {\n func (s *public) telegramQrCtrl(w http.ResponseWriter, r *http.Request) {\n \ttext := r.URL.Query().Get(\"url\")\n \tif text == \"\" {\n-\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(\"missing parameter\"), \"text parameter is required\", rest.ErrInternal)\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"missing parameter\"), \"text parameter is required\", rest.ErrInternal)\n \t\treturn\n \t}\n \n \tif !strings.HasPrefix(text, \"https://t.me/\") {\n-\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, errors.New(\"wrong parameter\"), \"text parameter should start with https://t.me/\", rest.ErrInternal)\n+\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, fmt.Errorf(\"wrong parameter\"), \"text parameter should start with https://t.me/\", rest.ErrInternal)\n \t\treturn\n \t}\n \n@@ -423,7 +423,7 @@ func (s *public) parseSince(r *http.Request) (time.Time, error) {\n \tif since := r.URL.Query().Get(\"since\"); since != \"\" {\n \t\tunixTS, e := strconv.ParseInt(since, 10, 64)\n \t\tif e != nil {\n-\t\t\treturn time.Time{}, errors.Wrap(e, \"can't translate since parameter\")\n+\t\t\treturn time.Time{}, fmt.Errorf(\"can't translate since parameter: %w\", e)\n \t\t}\n \t\tsinceTS = time.Unix(unixTS/1000, 1000000*(unixTS%1000)) // since param in msec timestamp\n \t}"
    },
    {
      "sha": "a504c827af0e0cce0c05050d49a7c622e582ddce",
      "filename": "backend/app/rest/api/rest_test.go",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frest_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frest_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,7 +4,6 @@ import (\n \t\"bytes\"\n \t\"crypto/tls\"\n \t\"encoding/json\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"math/rand\"\n@@ -277,13 +276,13 @@ func TestRest_parseError(t *testing.T) {\n \t\terr error\n \t\tres int\n \t}{\n-\t\t{errors.New(\"can not vote for his own comment\"), rest.ErrVoteSelf},\n-\t\t{errors.New(\"already voted for\"), rest.ErrVoteDbl},\n-\t\t{errors.New(\"maximum number of votes exceeded for comment\"), rest.ErrVoteMax},\n-\t\t{errors.New(\"minimal score reached for comment\"), rest.ErrVoteMinScore},\n-\t\t{errors.New(\"too late to edit\"), rest.ErrCommentEditExpired},\n-\t\t{errors.New(\"parent comment with reply can't be edited\"), rest.ErrCommentEditChanged},\n-\t\t{errors.New(\"blah blah\"), rest.ErrInternal},\n+\t\t{fmt.Errorf(\"can not vote for his own comment\"), rest.ErrVoteSelf},\n+\t\t{fmt.Errorf(\"already voted for\"), rest.ErrVoteDbl},\n+\t\t{fmt.Errorf(\"maximum number of votes exceeded for comment\"), rest.ErrVoteMax},\n+\t\t{fmt.Errorf(\"minimal score reached for comment\"), rest.ErrVoteMinScore},\n+\t\t{fmt.Errorf(\"too late to edit\"), rest.ErrCommentEditExpired},\n+\t\t{fmt.Errorf(\"parent comment with reply can't be edited\"), rest.ErrCommentEditChanged},\n+\t\t{fmt.Errorf(\"blah blah\"), rest.ErrInternal},\n \t}\n \n \tfor n, tt := range tbl {\n@@ -398,7 +397,7 @@ func randomPath(tempDir, basename, suffix string) (string, error) {\n \t\t\treturn fname, nil\n \t\t}\n \t}\n-\treturn \"\", errors.New(\"cannot create temp file\")\n+\treturn \"\", fmt.Errorf(\"cannot create temp file in %s\", tempDir)\n }\n \n // startupT runs fully configured testing server"
    },
    {
      "sha": "4be92da07910ca50a619c750c80d80db43378c2e",
      "filename": "backend/app/rest/api/rss.go",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frss.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fapi%2Frss.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fapi%2Frss.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -8,7 +8,6 @@ import (\n \tcache \"github.com/go-pkgz/lcw\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/gorilla/feeds\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/rest\"\n \t\"github.com/umputun/remark42/backend/app/store\"\n@@ -104,7 +103,7 @@ func (s *rss) repliesCtrl(w http.ResponseWriter, r *http.Request) {\n \tdata, err := s.cache.Get(key, func() (res []byte, e error) {\n \t\treplies, userName, e := s.dataService.UserReplies(siteID, userID, maxRssItems, maxReplyDuration)\n \t\tif e != nil {\n-\t\t\treturn nil, errors.Wrap(e, \"can't get last comments\")\n+\t\t\treturn nil, fmt.Errorf(\"can't get last comments: %w\", e)\n \t\t}\n \n \t\tfeed, e := s.toRssFeed(siteID, replies, \"replies to \"+userName)"
    },
    {
      "sha": "5b4e73088b76204b15e86e64cc8a52505ff39520",
      "filename": "backend/app/rest/httperrors_test.go",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fhttperrors_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fhttperrors_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fhttperrors_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,7 +1,6 @@\n package rest\n \n import (\n-\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n@@ -18,7 +17,7 @@ func TestSendErrorJSON(t *testing.T) {\n \tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n \t\tif r.URL.Path == \"/error\" {\n \t\t\tt.Log(\"http err request\", r.URL)\n-\t\t\tSendErrorJSON(w, r, 500, errors.New(\"error 500\"), \"error details 123456\", 123)\n+\t\t\tSendErrorJSON(w, r, 500, fmt.Errorf(\"error 500\"), \"error details 123456\", 123)\n \t\t\treturn\n \t\t}\n \t\tw.WriteHeader(404)\n@@ -48,7 +47,7 @@ func TestSendErrorHTML(t *testing.T) {\n \tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n \t\tif r.URL.Path == \"/error\" {\n \t\t\tt.Log(\"http err request\", r.URL)\n-\t\t\tSendErrorHTML(w, r, 500, errors.New(\"error 500\"), \"error details 123456\", 987, fs)\n+\t\t\tSendErrorHTML(w, r, 500, fmt.Errorf(\"error 500\"), \"error details 123456\", 987, fs)\n \t\t\treturn\n \t\t}\n \t\tw.WriteHeader(404)\n@@ -74,7 +73,7 @@ func TestErrorDetailsMsg(t *testing.T) {\n \t\treq, err := http.NewRequest(\"GET\", \"https://example.com/test?k1=v1&k2=v2\", http.NoBody)\n \t\trequire.NoError(t, err)\n \t\treq.RemoteAddr = \"1.2.3.4\"\n-\t\tmsg := errDetailsMsg(req, 500, errors.New(\"error 500\"), \"error details 123456\", 123)\n+\t\tmsg := errDetailsMsg(req, 500, fmt.Errorf(\"error 500\"), \"error details 123456\", 123)\n \t\tassert.Contains(t, msg, \"error details 123456 - error 500 - 500 (123) - https://example.com/test?k1=v1&k2=v2 - [app/rest/httperrors_test.go:\")\n \t\t// error line in the middle of the message is not checked\n \t\tassert.Contains(t, msg, \" rest.TestErrorDetailsMsg]\")\n@@ -89,7 +88,7 @@ func TestErrorDetailsMsgWithUser(t *testing.T) {\n \t\treq.RemoteAddr = \"127.0.0.1:1234\"\n \t\treq = SetUserInfo(req, store.User{Name: \"test\", ID: \"id\"})\n \t\trequire.NoError(t, err)\n-\t\tmsg := errDetailsMsg(req, 500, errors.New(\"error 500\"), \"error details 123456\", 34567)\n+\t\tmsg := errDetailsMsg(req, 500, fmt.Errorf(\"error 500\"), \"error details 123456\", 34567)\n \t\tassert.Contains(t, msg, \"error details 123456 - error 500 - 500 (34567) - test/id - https://example.com/test?k1=v1&k2=v2 - [app/rest/httperrors_test.go:\")\n \t\t// error line in the middle of the message is not checked\n \t\tassert.Contains(t, msg, \" rest.TestErrorDetailsMsgWithUser]\")"
    },
    {
      "sha": "be6ce9e55149d9639af2cd8b33396ee6a856e1fc",
      "filename": "backend/app/rest/proxy/image.go",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fproxy%2Fimage.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fproxy%2Fimage.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fproxy%2Fimage.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,6 +4,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/base64\"\n+\t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n \t\"strings\"\n@@ -12,7 +13,6 @@ import (\n \t\"github.com/PuerkitoBio/goquery\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/go-pkgz/repeater\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/rest\"\n \t\"github.com/umputun/remark42/backend/app/store/image\"\n@@ -54,7 +54,7 @@ func (p Image) Convert(commentHTML string) string {\n func (p Image) extract(commentHTML string, imgSrcPred func(string) bool) ([]string, error) {\n \tdoc, err := goquery.NewDocumentFromReader(strings.NewReader(commentHTML))\n \tif err != nil {\n-\t\treturn nil, errors.Wrap(err, \"can't create document\")\n+\t\treturn nil, fmt.Errorf(\"can't create document: %w\", err)\n \t}\n \tresult := []string{}\n \tdoc.Find(\"img\").Each(func(i int, s *goquery.Selection) {\n@@ -150,23 +150,23 @@ func (p Image) downloadImage(ctx context.Context, imgURL string) ([]byte, error)\n \t\tvar e error\n \t\treq, e := http.NewRequest(\"GET\", imgURL, http.NoBody)\n \t\tif e != nil {\n-\t\t\treturn errors.Wrapf(e, \"failed to make request for %s\", imgURL)\n+\t\t\treturn fmt.Errorf(\"failed to make request for %s: %w\", imgURL, e)\n \t\t}\n \t\tresp, e = client.Do(req.WithContext(ctx)) //nolint:bodyclose // need a refactor to fix that\n \t\treturn e\n \t})\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't download image %s\", imgURL)\n+\t\treturn nil, fmt.Errorf(\"can't download image %s: %w\", imgURL, err)\n \t}\n \tdefer resp.Body.Close()\n \n \tif resp.StatusCode != http.StatusOK {\n-\t\treturn nil, errors.Errorf(\"got unsuccessful response status %d while fetching %s\", resp.StatusCode, imgURL)\n+\t\treturn nil, fmt.Errorf(\"got unsuccessful response status %d while fetching %s\", resp.StatusCode, imgURL)\n \t}\n \n \timgData, err := io.ReadAll(resp.Body)\n \tif err != nil {\n-\t\treturn nil, errors.Errorf(\"unable to read image body\")\n+\t\treturn nil, fmt.Errorf(\"unable to read image body\")\n \t}\n \treturn imgData, nil\n }"
    },
    {
      "sha": "f908bea93f43038ec2834c2a17c049bed2f4c9e5",
      "filename": "backend/app/rest/user.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fuser.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Frest%2Fuser.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Frest%2Fuser.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,10 +1,10 @@\n package rest\n \n import (\n+\t\"fmt\"\n \t\"net/http\"\n \n \t\"github.com/go-pkgz/auth/token\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n )\n@@ -23,7 +23,7 @@ func MustGetUserInfo(r *http.Request) store.User {\n func GetUserInfo(r *http.Request) (user store.User, err error) {\n \tu, err := token.GetUserInfo(r)\n \tif err != nil {\n-\t\treturn store.User{}, errors.Wrap(err, \"can't extract user info from the token\")\n+\t\treturn store.User{}, fmt.Errorf(\"can't extract user info from the token: %w\", err)\n \t}\n \n \treturn store.User{"
    },
    {
      "sha": "d45c0fc1b58885be8d6c74da0d44ea3f82ddc7cc",
      "filename": "backend/app/store/admin/admin.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fadmin%2Fadmin.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fadmin%2Fadmin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fadmin%2Fadmin.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -2,7 +2,7 @@\n package admin\n \n import (\n-\t\"errors\"\n+\t\"fmt\"\n \t\"strings\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n@@ -50,7 +50,7 @@ func NewStaticKeyStore(key string) *StaticStore {\n // Key returns static key, same for all sites\n func (s *StaticStore) Key(_ string) (key string, err error) {\n \tif s.key == \"\" {\n-\t\treturn \"\", errors.New(\"empty key for static key store\")\n+\t\treturn \"\", fmt.Errorf(\"empty key for static key store\")\n \t}\n \treturn s.key, nil\n }"
    },
    {
      "sha": "b33e935e312c7f7dbc5bb4dfd8bf379999b35de4",
      "filename": "backend/app/store/engine/bolt.go",
      "status": "modified",
      "additions": 79,
      "deletions": 63,
      "changes": 142,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fengine%2Fbolt.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fengine%2Fbolt.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fengine%2Fbolt.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -9,7 +9,6 @@ import (\n \n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/pkg/errors\"\n \tbolt \"go.etcd.io/bbolt\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n@@ -57,7 +56,7 @@ func NewBoltDB(options bolt.Options, sites ...BoltSite) (*BoltDB, error) {\n \tfor _, site := range sites {\n \t\tdb, err := bolt.Open(site.FileName, 0o600, &options) //nolint:gocritic //octalLiteral is OK as FileMode\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrapf(err, \"failed to make boltdb for %s\", site.FileName)\n+\t\t\treturn nil, fmt.Errorf(\"failed to make boltdb for %s: %w\", site.FileName, err)\n \t\t}\n \n \t\t// make top-level buckets\n@@ -66,14 +65,14 @@ func NewBoltDB(options bolt.Options, sites ...BoltSite) (*BoltDB, error) {\n \t\terr = db.Update(func(tx *bolt.Tx) error {\n \t\t\tfor _, bktName := range topBuckets {\n \t\t\t\tif _, e := tx.CreateBucketIfNotExists([]byte(bktName)); e != nil {\n-\t\t\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", bktName)\n+\t\t\t\t\treturn fmt.Errorf(\"failed to create top level bucket %s: %w\", bktName, e)\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn nil\n \t\t})\n \n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrap(err, \"failed to create top level bucket)\")\n+\t\t\treturn nil, fmt.Errorf(\"failed to create top level bucket): %w\", err)\n \t\t}\n \n \t\tresult.dbs[site.SiteID] = db\n@@ -90,7 +89,7 @@ func (b *BoltDB) Create(comment store.Comment) (commentID string, err error) {\n \t}\n \n \tif b.checkFlag(FlagRequest{Locator: comment.Locator, Flag: ReadOnly}) {\n-\t\treturn \"\", errors.Errorf(\"post %s is read-only\", comment.Locator.URL)\n+\t\treturn \"\", fmt.Errorf(\"post %s is read-only\", comment.Locator.URL)\n \t}\n \n \terr = bdb.Update(func(tx *bolt.Tx) (err error) {\n@@ -101,12 +100,12 @@ func (b *BoltDB) Create(comment store.Comment) (commentID string, err error) {\n \t\t}\n \t\t// check if key already in store, reject doubles\n \t\tif postBkt.Get([]byte(comment.ID)) != nil {\n-\t\t\treturn errors.Errorf(\"key %s already in store\", comment.ID)\n+\t\t\treturn fmt.Errorf(\"key %s already in store\", comment.ID)\n \t\t}\n \n \t\t// serialize comment to json []byte for bolt and save\n \t\tif err = b.save(postBkt, comment.ID, comment); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to put key %s to bucket %s\", comment.ID, comment.Locator.URL)\n+\t\t\treturn fmt.Errorf(\"failed to put key %s to bucket %s: %w\", comment.ID, comment.Locator.URL, err)\n \t\t}\n \n \t\tref := b.makeRef(comment) // reference combines url and comment id\n@@ -115,21 +114,21 @@ func (b *BoltDB) Create(comment store.Comment) (commentID string, err error) {\n \t\tlastBkt = tx.Bucket([]byte(lastBucketName))\n \t\tcommentTS := []byte(comment.Timestamp.Format(tsNano))\n \t\tif err = lastBkt.Put(commentTS, ref); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't put reference %s to %s\", ref, lastBucketName)\n+\t\t\treturn fmt.Errorf(\"can't put reference %s to %s: %w\", ref, lastBucketName, err)\n \t\t}\n \n \t\t// add reference to commentID to \"users\" bucket\n \t\tif userBkt, err = b.getUserBucket(tx, comment.User.ID); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't get bucket %s\", comment.User.ID)\n+\t\t\treturn fmt.Errorf(\"can't get bucket %s: %w\", comment.User.ID, err)\n \t\t}\n \t\t// put into individual user's bucket with ts as a key\n \t\tif err = userBkt.Put(commentTS, ref); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to put user comment %s for %s\", comment.ID, comment.User.ID)\n+\t\t\treturn fmt.Errorf(\"failed to put user comment %s for %s: %w\", comment.ID, comment.User.ID, err)\n \t\t}\n \n \t\t// set info with the count for post url\n \t\tif _, err = b.setInfo(tx, comment); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to set info for %s\", comment.Locator)\n+\t\t\treturn fmt.Errorf(\"failed to set info for %s: %w\", comment.Locator, err)\n \t\t}\n \t\treturn nil\n \t})\n@@ -174,7 +173,7 @@ func (b *BoltDB) Find(req FindRequest) (comments []store.Comment, err error) {\n \t\t\treturn bucket.ForEach(func(k, v []byte) error {\n \t\t\t\tcomment := store.Comment{}\n \t\t\t\tif e = json.Unmarshal(v, &comment); e != nil {\n-\t\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal\")\n+\t\t\t\t\treturn fmt.Errorf(\"failed to unmarshal: %w\", e)\n \t\t\t\t}\n \t\t\t\tif req.Since.IsZero() || comment.Timestamp.After(req.Since) {\n \t\t\t\t\tcomments = append(comments, comment)\n@@ -211,7 +210,7 @@ func (b *BoltDB) UserDetail(req UserDetailRequest) ([]UserDetailEntry, error) {\n \tswitch req.Detail {\n \tcase UserEmail, UserTelegram:\n \t\tif req.UserID == \"\" {\n-\t\t\treturn nil, errors.New(\"userid cannot be empty in request for single detail\")\n+\t\t\treturn nil, fmt.Errorf(\"userid cannot be empty in request for single detail\")\n \t\t}\n \n \t\tif req.Update == \"\" { // read detail value, no update requested\n@@ -225,9 +224,9 @@ func (b *BoltDB) UserDetail(req UserDetailRequest) ([]UserDetailEntry, error) {\n \t\tif req.Update == \"\" && req.UserID == \"\" { // read list of all details\n \t\t\treturn b.listDetails(req.Locator)\n \t\t}\n-\t\treturn nil, errors.New(\"unsupported request with userdetail all\")\n+\t\treturn nil, fmt.Errorf(\"unsupported request with userdetail all\")\n \tdefault:\n-\t\treturn nil, errors.Errorf(\"unsupported detail %q\", req.Detail)\n+\t\treturn nil, fmt.Errorf(\"unsupported detail %q\", req.Detail)\n \t}\n }\n \n@@ -277,7 +276,7 @@ func (b *BoltDB) Count(req FindRequest) (count int, err error) {\n \t\t\tusersBkt := tx.Bucket([]byte(userBucketName))\n \t\t\tuserIDBkt := usersBkt.Bucket([]byte(req.UserID))\n \t\t\tif userIDBkt == nil {\n-\t\t\t\treturn errors.Errorf(\"no comments for user %s in store for %s site\", req.UserID, req.Locator.SiteID)\n+\t\t\t\treturn fmt.Errorf(\"no comments for user %s in store for %s site\", req.UserID, req.Locator.SiteID)\n \t\t\t}\n \t\t\tstats := userIDBkt.Stats()\n \t\t\tcount = stats.KeyN\n@@ -286,7 +285,7 @@ func (b *BoltDB) Count(req FindRequest) (count int, err error) {\n \t\treturn count, err\n \t}\n \n-\treturn 0, errors.Errorf(\"invalid count request %+v\", req)\n+\treturn 0, fmt.Errorf(\"invalid count request %+v\", req)\n }\n \n // Info get post(s) meta info\n@@ -301,7 +300,7 @@ func (b *BoltDB) Info(req InfoRequest) ([]store.PostInfo, error) {\n \t\terr = bdb.View(func(tx *bolt.Tx) error {\n \t\t\tinfoBkt := tx.Bucket([]byte(infoBucketName))\n \t\t\tif e := b.load(infoBkt, req.Locator.URL, &info); e != nil {\n-\t\t\t\treturn errors.Wrapf(e, \"can't load info for %s\", req.Locator.URL)\n+\t\t\t\treturn fmt.Errorf(\"can't load info for %s: %w\", req.Locator.URL, e)\n \t\t\t}\n \t\t\treturn nil\n \t\t})\n@@ -331,7 +330,7 @@ func (b *BoltDB) Info(req InfoRequest) ([]store.PostInfo, error) {\n \t\t\t\tinfoBkt := tx.Bucket([]byte(infoBucketName))\n \t\t\t\tinfo := store.PostInfo{}\n \t\t\t\tif e := b.load(infoBkt, postURL, &info); e != nil {\n-\t\t\t\t\treturn errors.Wrapf(e, \"can't load info for %s\", postURL)\n+\t\t\t\t\treturn fmt.Errorf(\"can't load info for %s: %w\", postURL, e)\n \t\t\t\t}\n \t\t\t\tlist = append(list, info)\n \t\t\t\tif req.Limit > 0 && len(list) >= req.Limit {\n@@ -343,7 +342,7 @@ func (b *BoltDB) Info(req InfoRequest) ([]store.PostInfo, error) {\n \t\treturn list, err\n \t}\n \n-\treturn nil, errors.Errorf(\"invalid info request %+v\", req)\n+\treturn nil, fmt.Errorf(\"invalid info request %+v\", req)\n }\n \n // ListFlags get list of flagged keys, like blocked & verified user\n@@ -372,7 +371,7 @@ func (b *BoltDB) ListFlags(req FlagRequest) (res []interface{}, err error) {\n \t\t\treturn bucket.ForEach(func(k []byte, v []byte) error {\n \t\t\t\tts, errParse := time.ParseInLocation(tsNano, string(v), time.Local)\n \t\t\t\tif errParse != nil {\n-\t\t\t\t\treturn errors.Wrap(errParse, \"can't parse block ts\")\n+\t\t\t\t\treturn fmt.Errorf(\"can't parse block ts: %w\", errParse)\n \t\t\t\t}\n \t\t\t\tif time.Now().Before(ts) {\n \t\t\t\t\t// get user name from comment user section\n@@ -389,7 +388,7 @@ func (b *BoltDB) ListFlags(req FlagRequest) (res []interface{}, err error) {\n \t\t})\n \t\treturn res, err\n \t}\n-\treturn nil, errors.Errorf(\"flag %s not listable\", req.Flag)\n+\treturn nil, fmt.Errorf(\"flag %s not listable\", req.Flag)\n }\n \n // Delete post(s), user, comment, user details, or everything\n@@ -410,15 +409,17 @@ func (b *BoltDB) Delete(req DeleteRequest) error {\n \t\treturn b.deleteAll(bdb, req.Locator.SiteID)\n \t}\n \n-\treturn errors.Errorf(\"invalid delete request %+v\", req)\n+\treturn fmt.Errorf(\"invalid delete request %+v\", req)\n }\n \n // Close boltdb store\n func (b *BoltDB) Close() error {\n \terrs := new(multierror.Error)\n \tfor site, db := range b.dbs {\n-\t\terr := errors.Wrapf(db.Close(), \"can't close site %s\", site)\n-\t\terrs = multierror.Append(errs, err)\n+\t\terr := db.Close()\n+\t\tif err != nil {\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"can't close site %s: %w\", site, err))\n+\t\t}\n \t}\n \treturn errs.ErrorOrNil()\n }\n@@ -496,7 +497,7 @@ func (b *BoltDB) userComments(siteID, userID string, limit, skip int) (comments\n \t\tusersBkt := tx.Bucket([]byte(userBucketName))\n \t\tuserIDBkt := usersBkt.Bucket([]byte(userID))\n \t\tif userIDBkt == nil {\n-\t\t\treturn errors.Errorf(\"no comments for user %s in store\", userID)\n+\t\t\treturn fmt.Errorf(\"no comments for user %s in store\", userID)\n \t\t}\n \n \t\tc := userIDBkt.Cursor()\n@@ -522,7 +523,7 @@ func (b *BoltDB) userComments(siteID, userID string, limit, skip int) (comments\n \tfor _, v := range commentRefs {\n \t\turl, commentID, errParse := b.parseRef([]byte(v))\n \t\tif errParse != nil {\n-\t\t\treturn comments, errors.Wrapf(errParse, \"can't parse reference %s\", v)\n+\t\t\treturn comments, fmt.Errorf(\"can't parse reference %s: %w\", v, errParse)\n \t\t}\n \t\tgetReq := GetRequest{Locator: store.Locator{SiteID: siteID, URL: url}, CommentID: commentID}\n \t\tif c, errRef := b.Get(getReq); errRef == nil {\n@@ -600,20 +601,20 @@ func (b *BoltDB) setFlag(req FlagRequest) (res bool, err error) {\n \t\t\t\t\tval = time.Now().Add(req.TTL).Format(tsNano)\n \t\t\t\t}\n \t\t\t\tif e = bucket.Put([]byte(key), []byte(val)); e != nil {\n-\t\t\t\t\treturn errors.Wrapf(e, \"failed to put blocked to %s\", key)\n+\t\t\t\t\treturn fmt.Errorf(\"failed to put blocked to %s: %w\", key, e)\n \t\t\t\t}\n \t\t\t\tres = true\n \t\t\t\treturn nil\n \t\t\t}\n \n \t\t\tif e = bucket.Put([]byte(key), []byte(time.Now().Format(tsNano))); e != nil {\n-\t\t\t\treturn errors.Wrapf(e, \"failed to set flag %s for %s\", req.Flag, req.Locator.URL)\n+\t\t\t\treturn fmt.Errorf(\"failed to set flag %s for %s: %w\", req.Flag, req.Locator.URL, e)\n \t\t\t}\n \t\t\tres = true\n \t\t\treturn nil\n \t\tcase FlagFalse:\n \t\t\tif e = bucket.Delete([]byte(key)); e != nil {\n-\t\t\t\treturn errors.Wrapf(e, \"failed to clean flag %s for %s\", req.Flag, req.Locator.URL)\n+\t\t\t\treturn fmt.Errorf(\"failed to clean flag %s for %s: %w\", req.Flag, req.Locator.URL, e)\n \t\t\t}\n \t\t\tres = false\n \t\t}\n@@ -632,7 +633,7 @@ func (b *BoltDB) flagBucket(tx *bolt.Tx, flag Flag) (bkt *bolt.Bucket, err error\n \tcase Verified:\n \t\tbkt = tx.Bucket([]byte(verifiedBucketName))\n \tdefault:\n-\t\treturn nil, errors.Errorf(\"unsupported flag %v\", flag)\n+\t\treturn nil, fmt.Errorf(\"unsupported flag %v\", flag)\n \t}\n \treturn bkt, nil\n }\n@@ -652,7 +653,7 @@ func (b *BoltDB) getUserDetail(req UserDetailRequest) (result []UserDetailEntry,\n \t\t// return no error in case of absent entry\n \t\tif value != nil {\n \t\t\tif err = json.Unmarshal(value, &entry); err != nil {\n-\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal entry\")\n+\t\t\t\treturn fmt.Errorf(\"failed to unmarshal entry: %w\", e)\n \t\t\t}\n \t\t\tswitch req.Detail {\n \t\t\tcase UserEmail:\n@@ -682,7 +683,7 @@ func (b *BoltDB) setUserDetail(req UserDetailRequest) (result []UserDetailEntry,\n \t\t// return no error in case of absent entry\n \t\tif value != nil {\n \t\t\tif err = json.Unmarshal(value, &entry); err != nil {\n-\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal entry\")\n+\t\t\t\treturn fmt.Errorf(\"failed to unmarshal entry: %w\", e)\n \t\t\t}\n \t\t}\n \t\treturn nil\n@@ -705,7 +706,10 @@ func (b *BoltDB) setUserDetail(req UserDetailRequest) (result []UserDetailEntry,\n \n \terr = bdb.Update(func(tx *bolt.Tx) error {\n \t\terr = b.save(tx.Bucket([]byte(userDetailsBucketName)), req.UserID, entry)\n-\t\treturn errors.Wrapf(err, \"failed to update detail %s for %s in %s\", req.Detail, req.UserID, req.Locator.SiteID)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to update detail %s for %s in %s: %w\", req.Detail, req.UserID, req.Locator.SiteID, err)\n+\t\t}\n+\t\treturn nil\n \t})\n \n \treturn []UserDetailEntry{entry}, err\n@@ -723,7 +727,7 @@ func (b *BoltDB) listDetails(loc store.Locator) (result []UserDetailEntry, err e\n \t\tbucket := tx.Bucket([]byte(userDetailsBucketName))\n \t\treturn bucket.ForEach(func(userID, value []byte) error {\n \t\t\tif err = json.Unmarshal(value, &entry); err != nil {\n-\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal entry\")\n+\t\t\t\treturn fmt.Errorf(\"failed to unmarshal entry: %w\", e)\n \t\t\t}\n \t\t\tresult = append(result, entry)\n \t\t\treturn nil\n@@ -741,7 +745,7 @@ func (b *BoltDB) deleteUserDetail(bdb *bolt.DB, userID string, userDetail UserDe\n \t\t// return no error in case of absent entry\n \t\tif value != nil {\n \t\t\tif err := json.Unmarshal(value, &entry); err != nil {\n-\t\t\t\treturn errors.Wrap(err, \"failed to unmarshal entry\")\n+\t\t\t\treturn fmt.Errorf(\"failed to unmarshal entry: %w\", err)\n \t\t\t}\n \t\t}\n \t\treturn nil\n@@ -768,14 +772,20 @@ func (b *BoltDB) deleteUserDetail(bdb *bolt.DB, userID string, userDetail UserDe\n \t\t// if entry doesn't have non-empty details, we should delete it\n \t\treturn bdb.Update(func(tx *bolt.Tx) error {\n \t\t\terr := tx.Bucket([]byte(userDetailsBucketName)).Delete([]byte(userID))\n-\t\t\treturn errors.Wrapf(err, \"failed to delete user detail %s for %s\", userDetail, userID)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed to delete user detail %s for %s: %w\", userDetail, userID, err)\n+\t\t\t}\n+\t\t\treturn nil\n \t\t})\n \t}\n \n \treturn bdb.Update(func(tx *bolt.Tx) error {\n \t\t// updated entry is not empty and we need to store it's updated copy\n \t\terr := b.save(tx.Bucket([]byte(userDetailsBucketName)), userID, entry)\n-\t\treturn errors.Wrapf(err, \"failed to update detail %s for %s\", userDetail, userID)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"failed to update detail %s for %s: %w\", userDetail, userID, err)\n+\t\t}\n+\t\treturn nil\n \t})\n }\n \n@@ -788,27 +798,27 @@ func (b *BoltDB) deleteComment(bdb *bolt.DB, locator store.Locator, commentID st\n \n \t\tcomment := store.Comment{}\n \t\tif e = b.load(postBkt, commentID, &comment); e != nil {\n-\t\t\treturn errors.Wrapf(e, \"can't load key %s from bucket %s\", commentID, locator.URL)\n+\t\t\treturn fmt.Errorf(\"can't load key %s from bucket %s: %w\", commentID, locator.URL, e)\n \t\t}\n \n \t\tif !comment.Deleted {\n \t\t\t// decrement comments count for post url\n \t\t\tif _, e = b.count(tx, comment.Locator.URL, -1); e != nil {\n-\t\t\t\treturn errors.Wrapf(e, \"failed to decrement count for %s\", comment.Locator)\n+\t\t\t\treturn fmt.Errorf(\"failed to decrement count for %s: %w\", comment.Locator, e)\n \t\t\t}\n \t\t}\n \n \t\t// set deleted status and clear fields\n \t\tcomment.SetDeleted(mode)\n \n \t\tif e = b.save(postBkt, commentID, comment); e != nil {\n-\t\t\treturn errors.Wrapf(e, \"can't save deleted comment for key %s from bucket %s\", commentID, locator.URL)\n+\t\t\treturn fmt.Errorf(\"can't save deleted comment for key %s from bucket %s: %w\", commentID, locator.URL, e)\n \t\t}\n \n \t\t// delete from \"last\" bucket\n \t\tlastBkt := tx.Bucket([]byte(lastBucketName))\n \t\tif e = lastBkt.Delete([]byte(commentID)); e != nil {\n-\t\t\treturn errors.Wrapf(e, \"can't delete key %s from bucket %s\", commentID, lastBucketName)\n+\t\t\treturn fmt.Errorf(\"can't delete key %s from bucket %s: %w\", commentID, lastBucketName, e)\n \t\t}\n \n \t\treturn nil\n@@ -824,16 +834,19 @@ func (b *BoltDB) deleteAll(bdb *bolt.DB, siteID string) error {\n \terr := bdb.Update(func(tx *bolt.Tx) error {\n \t\tfor _, bktName := range toDelete {\n \t\t\tif e := tx.DeleteBucket([]byte(bktName)); e != nil {\n-\t\t\t\treturn errors.Wrapf(e, \"failed to delete top level bucket %s\", bktName)\n+\t\t\t\treturn fmt.Errorf(\"failed to delete top level bucket %s: %w\", bktName, e)\n \t\t\t}\n \t\t\tif _, e := tx.CreateBucketIfNotExists([]byte(bktName)); e != nil {\n-\t\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", bktName)\n+\t\t\t\treturn fmt.Errorf(\"failed to create top level bucket %s: %w\", bktName, e)\n \t\t\t}\n \t\t}\n \t\treturn nil\n \t})\n \n-\treturn errors.Wrapf(err, \"failed to delete top level buckets from site %s\", siteID)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to delete top level buckets from site %s: %w\", siteID, err)\n+\t}\n+\treturn nil\n }\n \n // deleteUser removes all comments and details for given user. Everything will be market as deleted\n@@ -860,14 +873,17 @@ func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID, userID string, mode store.Dele\n \t\t\terr = postBkt.ForEach(func(postURL []byte, commentVal []byte) error {\n \t\t\t\tcomment := store.Comment{}\n \t\t\t\tif err = json.Unmarshal(commentVal, &comment); err != nil {\n-\t\t\t\t\treturn errors.Wrap(err, \"failed to unmarshal\")\n+\t\t\t\t\treturn fmt.Errorf(\"failed to unmarshal: %w\", err)\n \t\t\t\t}\n \t\t\t\tif comment.User.ID == userID {\n \t\t\t\t\tcomments = append(comments, commentInfo{locator: comment.Locator, commentID: comment.ID})\n \t\t\t\t}\n \t\t\t\treturn nil\n \t\t\t})\n-\t\t\treturn errors.Wrapf(err, \"failed to collect list of comments for deletion from %s\", postInfo.URL)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed to collect list of comments for deletion from %s: %w\", postInfo.URL, err)\n+\t\t\t}\n+\t\t\treturn nil\n \t\t})\n \t\tif err != nil {\n \t\t\treturn err\n@@ -879,7 +895,7 @@ func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID, userID string, mode store.Dele\n \t// delete collected comments\n \tfor _, ci := range comments {\n \t\tif e := b.deleteComment(bdb, ci.locator, ci.commentID, mode); e != nil {\n-\t\t\treturn errors.Wrapf(err, \"failed to delete comment %+v\", ci)\n+\t\t\treturn fmt.Errorf(\"failed to delete comment %+v: %w\", ci, err)\n \t\t}\n \t}\n \n@@ -889,19 +905,19 @@ func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID, userID string, mode store.Dele\n \t\t\tusersBkt := tx.Bucket([]byte(userBucketName))\n \t\t\tif usersBkt != nil {\n \t\t\t\tif e := usersBkt.DeleteBucket([]byte(userID)); e != nil {\n-\t\t\t\t\treturn errors.Wrapf(err, \"failed to delete user bucket for %s\", userID)\n+\t\t\t\t\treturn fmt.Errorf(\"failed to delete user bucket for %s: %w\", userID, err)\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn nil\n \t\t})\n \n \t\tif err != nil {\n-\t\t\treturn errors.Wrap(err, \"can't delete user meta\")\n+\t\t\treturn fmt.Errorf(\"can't delete user meta: %w\", err)\n \t\t}\n \t}\n \n \tif len(comments) == 0 {\n-\t\treturn errors.Errorf(\"unknown user %s\", userID)\n+\t\treturn fmt.Errorf(\"unknown user %s\", userID)\n \t}\n \n \treturn b.deleteUserDetail(bdb, userID, AllUserDetails)\n@@ -911,11 +927,11 @@ func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID, userID string, mode store.Dele\n func (b *BoltDB) getPostBucket(tx *bolt.Tx, postURL string) (*bolt.Bucket, error) {\n \tpostsBkt := tx.Bucket([]byte(postsBucketName))\n \tif postsBkt == nil {\n-\t\treturn nil, errors.Errorf(\"no bucket %s\", postsBucketName)\n+\t\treturn nil, fmt.Errorf(\"no bucket %s\", postsBucketName)\n \t}\n \tres := postsBkt.Bucket([]byte(postURL))\n \tif res == nil {\n-\t\treturn nil, errors.Errorf(\"no bucket %s in store\", postURL)\n+\t\treturn nil, fmt.Errorf(\"no bucket %s in store\", postURL)\n \t}\n \treturn res, nil\n }\n@@ -924,11 +940,11 @@ func (b *BoltDB) getPostBucket(tx *bolt.Tx, postURL string) (*bolt.Bucket, error\n func (b *BoltDB) makePostBucket(tx *bolt.Tx, postURL string) (*bolt.Bucket, error) {\n \tpostsBkt := tx.Bucket([]byte(postsBucketName))\n \tif postsBkt == nil {\n-\t\treturn nil, errors.Errorf(\"no bucket %s\", postsBucketName)\n+\t\treturn nil, fmt.Errorf(\"no bucket %s\", postsBucketName)\n \t}\n \tres, err := postsBkt.CreateBucketIfNotExists([]byte(postURL))\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"no bucket %s in store\", postURL)\n+\t\treturn nil, fmt.Errorf(\"no bucket %s in store: %w\", postURL, err)\n \t}\n \treturn res, nil\n }\n@@ -937,22 +953,22 @@ func (b *BoltDB) getUserBucket(tx *bolt.Tx, userID string) (*bolt.Bucket, error)\n \tusersBkt := tx.Bucket([]byte(userBucketName))\n \tuserIDBkt, e := usersBkt.CreateBucketIfNotExists([]byte(userID)) // get bucket for userID\n \tif e != nil {\n-\t\treturn nil, errors.Wrapf(e, \"can't get bucket %s\", userID)\n+\t\treturn nil, fmt.Errorf(\"can't get bucket %s: %w\", userID, e)\n \t}\n \treturn userIDBkt, nil\n }\n \n // save marshaled value to key for bucket. Should run in update tx\n func (b *BoltDB) save(bkt *bolt.Bucket, key string, value interface{}) (err error) {\n \tif value == nil {\n-\t\treturn errors.Errorf(\"can't save nil value for %s\", key)\n+\t\treturn fmt.Errorf(\"can't save nil value for %s\", key)\n \t}\n \tjdata, jerr := json.Marshal(value)\n \tif jerr != nil {\n-\t\treturn errors.Wrap(jerr, \"can't marshal comment\")\n+\t\treturn fmt.Errorf(\"can't marshal comment: %w\", jerr)\n \t}\n \tif err = bkt.Put([]byte(key), jdata); err != nil {\n-\t\treturn errors.Wrapf(err, \"failed to save key %s\", key)\n+\t\treturn fmt.Errorf(\"failed to save key %s: %w\", key, err)\n \t}\n \treturn nil\n }\n@@ -961,11 +977,11 @@ func (b *BoltDB) save(bkt *bolt.Bucket, key string, value interface{}) (err erro\n func (b *BoltDB) load(bkt *bolt.Bucket, key string, res interface{}) error {\n \tvalue := bkt.Get([]byte(key))\n \tif value == nil {\n-\t\treturn errors.Errorf(\"no value for %s\", key)\n+\t\treturn fmt.Errorf(\"no value for %s\", key)\n \t}\n \n \tif err := json.Unmarshal(value, &res); err != nil {\n-\t\treturn errors.Wrap(err, \"failed to unmarshal\")\n+\t\treturn fmt.Errorf(\"failed to unmarshal: %w\", err)\n \t}\n \treturn nil\n }\n@@ -1008,7 +1024,7 @@ func (b *BoltDB) db(siteID string) (*bolt.DB, error) {\n \tif res, ok := b.dbs[siteID]; ok {\n \t\treturn res, nil\n \t}\n-\treturn nil, errors.Errorf(\"site %q not found\", siteID)\n+\treturn nil, fmt.Errorf(\"site %q not found\", siteID)\n }\n \n // makeRef creates reference combining url and comment id\n@@ -1020,7 +1036,7 @@ func (b *BoltDB) makeRef(comment store.Comment) []byte {\n func (b *BoltDB) parseRef(val []byte) (url, id string, err error) {\n \telems := strings.Split(string(val), \"!!\")\n \tif len(elems) != 2 {\n-\t\treturn \"\", \"\", errors.Errorf(\"invalid reference value %s\", string(val))\n+\t\treturn \"\", \"\", fmt.Errorf(\"invalid reference value %s\", string(val))\n \t}\n \treturn elems[0], elems[1], nil\n }"
    },
    {
      "sha": "9d9fe9b2deb52c270053f930d517f2ea05b39aa9",
      "filename": "backend/app/store/image/bolt_store.go",
      "status": "modified",
      "additions": 25,
      "deletions": 19,
      "changes": 44,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fimage%2Fbolt_store.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fimage%2Fbolt_store.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fimage%2Fbolt_store.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -4,10 +4,10 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"encoding/binary\"\n+\t\"fmt\"\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \tbolt \"go.etcd.io/bbolt\"\n )\n \n@@ -27,23 +27,23 @@ type Bolt struct {\n func NewBoltStorage(fileName string, options bolt.Options) (*Bolt, error) {\n \tdb, err := bolt.Open(fileName, 0o600, &options) //nolint:gocritic //octalLiteral is OK as FileMode\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"failed to make boltdb for %s\", fileName)\n+\t\treturn nil, fmt.Errorf(\"failed to make boltdb for %s: %w\", fileName, err)\n \t}\n \n \terr = db.Update(func(tx *bolt.Tx) error {\n \t\tif _, e := tx.CreateBucketIfNotExists([]byte(imagesBktName)); e != nil {\n-\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", imagesBktName)\n+\t\t\treturn fmt.Errorf(\"failed to create top level bucket %s: %w\", imagesBktName, e)\n \t\t}\n \t\tif _, e := tx.CreateBucketIfNotExists([]byte(imagesStagedBktName)); e != nil {\n-\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", imagesStagedBktName)\n+\t\t\treturn fmt.Errorf(\"failed to create top level bucket %s: %w\", imagesStagedBktName, e)\n \t\t}\n \t\tif _, e := tx.CreateBucketIfNotExists([]byte(insertTimeBktName)); e != nil {\n-\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", insertTimeBktName)\n+\t\t\treturn fmt.Errorf(\"failed to create top level bucket %s: %w\", insertTimeBktName, e)\n \t\t}\n \t\treturn nil\n \t})\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"failed to initialize boltdb db %q buckets\", fileName)\n+\t\treturn nil, fmt.Errorf(\"failed to initialize boltdb db %q buckets: %w\", fileName, err)\n \t}\n \treturn &Bolt{\n \t\tdb:       db,\n@@ -55,14 +55,14 @@ func NewBoltStorage(fileName string, options bolt.Options) (*Bolt, error) {\n func (b *Bolt) Save(id string, img []byte) error {\n \treturn b.db.Update(func(tx *bolt.Tx) error {\n \t\tif err := tx.Bucket([]byte(imagesStagedBktName)).Put([]byte(id), img); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t\t\treturn fmt.Errorf(\"can't put to bucket with %s: %w\", id, err)\n \t\t}\n \t\ttsBuf := &bytes.Buffer{}\n \t\tif err := binary.Write(tsBuf, binary.LittleEndian, time.Now().UnixNano()); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't serialize timestamp for %s\", id)\n+\t\t\treturn fmt.Errorf(\"can't serialize timestamp for %s: %w\", id, err)\n \t\t}\n \t\tif err := tx.Bucket([]byte(insertTimeBktName)).Put([]byte(id), tsBuf.Bytes()); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t\t\treturn fmt.Errorf(\"can't put to bucket with %s: %w\", id, err)\n \t\t}\n \t\treturn nil\n \t})\n@@ -74,10 +74,13 @@ func (b *Bolt) Commit(id string) error {\n \treturn b.db.Update(func(tx *bolt.Tx) error {\n \t\tdata := tx.Bucket([]byte(imagesStagedBktName)).Get([]byte(id))\n \t\tif data == nil {\n-\t\t\treturn errors.Errorf(\"failed to commit %s, not found in staging\", id)\n+\t\t\treturn fmt.Errorf(\"failed to commit %s, not found in staging\", id)\n \t\t}\n \t\terr := tx.Bucket([]byte(imagesBktName)).Put([]byte(id), data)\n-\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"can't put to bucket with %s: %w\", id, err)\n+\t\t}\n+\t\treturn nil\n \t})\n }\n \n@@ -86,10 +89,10 @@ func (b *Bolt) ResetCleanupTimer(id string) error {\n \treturn b.db.Update(func(tx *bolt.Tx) error {\n \t\ttsBuf := &bytes.Buffer{}\n \t\tif err := binary.Write(tsBuf, binary.LittleEndian, time.Now().UnixNano()); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't serialize timestamp for %s\", id)\n+\t\t\treturn fmt.Errorf(\"can't serialize timestamp for %s: %w\", id, err)\n \t\t}\n \t\tif err := tx.Bucket([]byte(insertTimeBktName)).Put([]byte(id), tsBuf.Bytes()); err != nil {\n-\t\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t\t\treturn fmt.Errorf(\"can't put to bucket with %s: %w\", id, err)\n \t\t}\n \t\treturn nil\n \t})\n@@ -104,7 +107,7 @@ func (b *Bolt) Load(id string) ([]byte, error) {\n \t\t\tdata = tx.Bucket([]byte(imagesStagedBktName)).Get([]byte(id))\n \t\t}\n \t\tif data == nil {\n-\t\t\treturn errors.Errorf(\"can't load image %s\", id)\n+\t\t\treturn fmt.Errorf(\"can't load image %s\", id)\n \t\t}\n \t\treturn nil\n \t})\n@@ -126,7 +129,7 @@ func (b *Bolt) Cleanup(_ context.Context, ttl time.Duration) error {\n \t\t\tvar ts int64\n \t\t\terr := binary.Read(bytes.NewReader(tsData), binary.LittleEndian, &ts)\n \t\t\tif err != nil {\n-\t\t\t\treturn errors.Wrapf(err, \"failed to deserialize timestamp for %s\", id)\n+\t\t\t\treturn fmt.Errorf(\"failed to deserialize timestamp for %s: %w\", id, err)\n \t\t\t}\n \n \t\t\tage := time.Since(time.Unix(0, ts))\n@@ -136,15 +139,15 @@ func (b *Bolt) Cleanup(_ context.Context, ttl time.Duration) error {\n \t\t\t\tidsToRemove = append(idsToRemove, id)\n \t\t\t\terr := c.Delete()\n \t\t\t\tif err != nil {\n-\t\t\t\t\treturn errors.Wrapf(err, \"failed to remove timestamp for %s\", id)\n+\t\t\t\t\treturn fmt.Errorf(\"failed to remove timestamp for %s: %w\", id, err)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\timgBkt := tx.Bucket([]byte(imagesStagedBktName))\n \t\tfor _, id := range idsToRemove {\n \t\t\terr := imgBkt.Delete(id)\n \t\t\tif err != nil {\n-\t\t\t\treturn errors.Wrapf(err, \"failed to remove image for %s\", id)\n+\t\t\t\treturn fmt.Errorf(\"failed to remove image for %s: %w\", id, err)\n \t\t\t}\n \t\t}\n \t\treturn nil\n@@ -161,7 +164,7 @@ func (b *Bolt) Info() (StoreInfo, error) {\n \t\t\tvar createdRaw int64\n \t\t\terr := binary.Read(bytes.NewReader(tsData), binary.LittleEndian, &createdRaw)\n \t\t\tif err != nil {\n-\t\t\t\treturn errors.Wrapf(err, \"failed to deserialize timestamp for %s\", id)\n+\t\t\t\treturn fmt.Errorf(\"failed to deserialize timestamp for %s: %w\", id, err)\n \t\t\t}\n \n \t\t\tcreated := time.Unix(0, createdRaw)\n@@ -171,5 +174,8 @@ func (b *Bolt) Info() (StoreInfo, error) {\n \t\t}\n \t\treturn nil\n \t})\n-\treturn StoreInfo{FirstStagingImageTS: ts}, errors.Wrapf(err, \"problem retrieving first timestamp from staging images\")\n+\tif err != nil {\n+\t\treturn StoreInfo{}, fmt.Errorf(\"problem retrieving first timestamp from staging images: %w\", err)\n+\t}\n+\treturn StoreInfo{FirstStagingImageTS: ts}, nil\n }"
    },
    {
      "sha": "09ca5e78e325a4b45a40a47db072143bbe2fea69",
      "filename": "backend/app/store/image/fs_store.go",
      "status": "modified",
      "additions": 23,
      "deletions": 14,
      "changes": 37,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fimage%2Ffs_store.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fimage%2Ffs_store.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fimage%2Ffs_store.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -15,7 +15,6 @@ import (\n \t\"time\"\n \n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n )\n \n // FileSystem provides image Store for local files. Saves and loads files from Location, restricts max size.\n@@ -38,11 +37,11 @@ func (f *FileSystem) Save(id string, img []byte) error {\n \tdst := f.location(f.Staging, id)\n \n \tif err := os.MkdirAll(path.Dir(dst), 0o700); err != nil {\n-\t\treturn errors.Wrap(err, \"can't make image directory\")\n+\t\treturn fmt.Errorf(\"can't make image directory: %w\", err)\n \t}\n \n \tif err := os.WriteFile(dst, img, 0o600); err != nil {\n-\t\treturn errors.Wrapf(err, \"can't write image file with id %s\", id)\n+\t\treturn fmt.Errorf(\"can't write image file with id %s: %w\", id, err)\n \t}\n \n \tlog.Printf(\"[DEBUG] file %s saved for image %s, size=%d\", dst, id, len(img))\n@@ -55,25 +54,29 @@ func (f *FileSystem) Commit(id string) error {\n \tstagingImage, permImage := f.location(f.Staging, id), f.location(f.Location, id)\n \n \tif err := os.MkdirAll(path.Dir(permImage), 0o700); err != nil {\n-\t\treturn errors.Wrap(err, \"can't make image directory\")\n+\t\treturn fmt.Errorf(\"can't make image directory: %w\", err)\n \t}\n \n-\terr := os.Rename(stagingImage, permImage)\n-\treturn errors.Wrapf(err, \"failed to commit image %s\", id)\n+\tif err := os.Rename(stagingImage, permImage); err != nil {\n+\t\treturn fmt.Errorf(\"failed to commit image %s: %w\", id, err)\n+\t}\n+\treturn nil\n }\n \n // ResetCleanupTimer resets cleanup timer for the image\n func (f *FileSystem) ResetCleanupTimer(id string) error {\n \tfile := f.location(f.Staging, id)\n \t_, err := os.Stat(file)\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, \"can't get image stats for %s\", id)\n+\t\treturn fmt.Errorf(\"can't get image stats for %s: %w\", id, err)\n \t}\n \t// we don't need to update access time (second arg),\n \t// but reading it is platform-dependent and looks different on darwin and linux,\n \t// so it's easier to update it as well\n-\terr = os.Chtimes(file, time.Now(), time.Now())\n-\treturn errors.Wrapf(err, \"problem updating %s modification time\", file)\n+\tif err = os.Chtimes(file, time.Now(), time.Now()); err != nil {\n+\t\treturn fmt.Errorf(\"problem updating %s modification time: %w\", file, err)\n+\t}\n+\treturn nil\n }\n \n // Load image from FS. Uses id to get partition subdirectory.\n@@ -86,17 +89,20 @@ func (f *FileSystem) Load(id string) ([]byte, error) {\n \t\t\tfile = f.location(f.Staging, id)\n \t\t\t_, err = os.Stat(file)\n \t\t}\n-\t\treturn file, errors.Wrapf(err, \"can't get image stats for %s\", id)\n+\t\tif err != nil {\n+\t\t\treturn file, fmt.Errorf(\"can't get image stats for %s: %w\", id, err)\n+\t\t}\n+\t\treturn file, nil\n \t}\n \n \timgFile, err := img(id)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't get image file for %s\", id)\n+\t\treturn nil, fmt.Errorf(\"can't get image file for %s: %w\", id, err)\n \t}\n \n \tfh, err := os.Open(imgFile) //nolint:gosec // we open file from known location\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't load image %s\", id)\n+\t\treturn nil, fmt.Errorf(\"can't load image %s: %w\", id, err)\n \t}\n \treturn io.ReadAll(fh)\n }\n@@ -124,7 +130,10 @@ func (f *FileSystem) Cleanup(_ context.Context, ttl time.Duration) error {\n \t\t}\n \t\treturn nil\n \t})\n-\treturn errors.Wrap(err, \"failed to cleanup images\")\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to cleanup images: %w\", err)\n+\t}\n+\treturn nil\n }\n \n // Info returns meta information about storage\n@@ -149,7 +158,7 @@ func (f *FileSystem) Info() (StoreInfo, error) {\n \t\treturn nil\n \t})\n \tif err != nil {\n-\t\treturn StoreInfo{}, errors.Wrapf(err, \"problem retrieving first timestamp from staging images on fs\")\n+\t\treturn StoreInfo{}, fmt.Errorf(\"problem retrieving first timestamp from staging images on fs: %w\", err)\n \t}\n \treturn StoreInfo{FirstStagingImageTS: ts}, nil\n }"
    },
    {
      "sha": "aae6f4de5292d03aa51f7bbe642cfa7e19c3f9ca",
      "filename": "backend/app/store/image/image.go",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fimage%2Fimage.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fimage%2Fimage.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fimage%2Fimage.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -28,7 +28,6 @@ import (\n \t\"github.com/PuerkitoBio/goquery\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/pkg/errors\"\n \t\"github.com/rs/xid\"\n \t\"golang.org/x/image/draw\"\n )\n@@ -97,7 +96,7 @@ func (s *Service) SubmitAndCommit(idsFn func() []string) error {\n \tfor _, id := range idsFn() {\n \t\terr := s.store.Commit(id)\n \t\tif err != nil {\n-\t\t\terrs = multierror.Append(errs, errors.Wrapf(err, \"failed to commit image %s\", id))\n+\t\t\terrs = multierror.Append(errs, fmt.Errorf(\"failed to commit image %s: %w\", id, err))\n \t\t}\n \t}\n \treturn errs.ErrorOrNil()\n@@ -269,7 +268,7 @@ func (s *Service) ImgContentType(img []byte) string {\n func (s *Service) prepareImage(r io.Reader) ([]byte, error) {\n \tdata, err := readAndValidateImage(r, s.MaxSize)\n \tif err != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't load image\")\n+\t\treturn nil, fmt.Errorf(\"can't load image: %w\", err)\n \t}\n \n \tdata = resize(data, s.MaxWidth, s.MaxHeight)\n@@ -343,12 +342,12 @@ func readAndValidateImage(r io.Reader, maxSize int) ([]byte, error) {\n \t}\n \n \tif len(data) > maxSize {\n-\t\treturn nil, errors.Errorf(\"file is too large (limit=%d)\", maxSize)\n+\t\treturn nil, fmt.Errorf(\"file is too large (limit=%d)\", maxSize)\n \t}\n \n \t// read header first, needs it to check if data is valid png/gif/jpeg\n \tif !isValidImage(data[:512]) {\n-\t\treturn nil, errors.Errorf(\"file format not allowed\")\n+\t\treturn nil, fmt.Errorf(\"file format not allowed\")\n \t}\n \n \treturn data, nil\n@@ -372,7 +371,7 @@ func Sha1Str(s string) string {\n func CachedImgID(imgURL string) (string, error) {\n \tparsedURL, err := url.Parse(imgURL)\n \tif err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can parse url %s\", imgURL)\n+\t\treturn \"\", fmt.Errorf(\"can parse url %s: %w\", imgURL, err)\n \t}\n \treturn fmt.Sprintf(\"cached_images/%s-%s\", Sha1Str(parsedURL.Hostname()), Sha1Str(imgURL)), nil\n }"
    },
    {
      "sha": "e60a77bdaf11bab46347056363dd478801c34953",
      "filename": "backend/app/store/service/service.go",
      "status": "modified",
      "additions": 30,
      "deletions": 28,
      "changes": 58,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fservice%2Fservice.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fservice%2Fservice.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Fservice.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -3,6 +3,7 @@\n package service\n \n import (\n+\t\"fmt\"\n \t\"math\"\n \t\"sort\"\n \t\"strings\"\n@@ -13,7 +14,6 @@ import (\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/google/uuid\"\n \t\"github.com/hashicorp/go-multierror\"\n-\t\"github.com/pkg/errors\"\n \n \t\"github.com/umputun/remark42/backend/app/store\"\n \t\"github.com/umputun/remark42/backend/app/store/admin\"\n@@ -77,12 +77,12 @@ const UnlimitedVotes = -1\n var nonAdminUser = store.User{}\n \n // ErrRestrictedWordsFound returned in case comment text contains restricted words\n-var ErrRestrictedWordsFound = errors.New(\"comment contains restricted words\")\n+var ErrRestrictedWordsFound = fmt.Errorf(\"comment contains restricted words\")\n \n // Create prepares comment and forward to Interface.Create\n func (s *DataStore) Create(comment store.Comment) (commentID string, err error) {\n \tif comment, err = s.prepareNewComment(comment); err != nil {\n-\t\treturn \"\", errors.Wrap(err, \"failed to prepare comment\")\n+\t\treturn \"\", fmt.Errorf(\"failed to prepare comment: %w\", err)\n \t}\n \n \tif s.RestrictedWordsMatcher != nil && s.RestrictedWordsMatcher.Match(comment.Locator.SiteID, comment.Text) {\n@@ -250,7 +250,9 @@ func (s *DataStore) ResubmitStagingImages(sites []string) error {\n \tfor _, site := range sites {\n \t\tlocator := store.Locator{SiteID: site}\n \t\tcomments, err := s.FindSince(locator, \"time\", store.User{}, ts)\n-\t\tresult = multierror.Append(result, errors.Wrapf(err, \"problem finding comments for site %s\", site))\n+\t\tif err != nil {\n+\t\t\tresult = multierror.Append(result, fmt.Errorf(\"problem finding comments for site %s: %w\", site, err))\n+\t\t}\n \t\tfor _, c := range comments {\n \t\t\ts.submitImages(c)\n \t\t}\n@@ -303,7 +305,7 @@ func (s *DataStore) prepareNewComment(comment store.Comment) (store.Comment, err\n \n \tsecret, err := s.getSecret(comment.Locator.SiteID)\n \tif err != nil {\n-\t\treturn store.Comment{}, errors.Wrapf(err, \"can't get secret for site %s\", comment.Locator.SiteID)\n+\t\treturn store.Comment{}, fmt.Errorf(\"can't get secret for site %s: %w\", comment.Locator.SiteID, err)\n \t}\n \tcomment.User.HashIP(secret) // replace ip by hash\n \treturn comment, nil\n@@ -347,7 +349,7 @@ func (s *DataStore) Vote(req VoteReq) (comment store.Comment, err error) {\n \t}\n \n \tif comment.User.ID == req.UserID && req.UserID != \"dev\" {\n-\t\treturn comment, errors.Errorf(\"user %s can not vote for his own comment %s\", req.UserID, req.CommentID)\n+\t\treturn comment, fmt.Errorf(\"user %s can not vote for his own comment %s\", req.UserID, req.CommentID)\n \t}\n \n \tif comment.Votes == nil {\n@@ -356,16 +358,16 @@ func (s *DataStore) Vote(req VoteReq) (comment store.Comment, err error) {\n \n \tv, voted := comment.Votes[req.UserID]\n \tif voted && v == req.Val { // voted before and same vote (+/-) again. Change allowed, i.e. +, - or -, + is fine\n-\t\treturn comment, errors.Errorf(\"user %s already voted for %s\", req.UserID, req.CommentID)\n+\t\treturn comment, fmt.Errorf(\"user %s already voted for %s\", req.UserID, req.CommentID)\n \t}\n \n \tsecret, err := s.getSecret(comment.Locator.SiteID)\n \tif err != nil {\n-\t\treturn store.Comment{}, errors.Wrapf(err, \"can't get secret for site %s\", comment.Locator.SiteID)\n+\t\treturn store.Comment{}, fmt.Errorf(\"can't get secret for site %s: %w\", comment.Locator.SiteID, err)\n \t}\n \tuserIPHash := store.HashValue(req.UserIP, secret)\n \tif s.isSameIPVote(req, userIPHash, comment) {\n-\t\treturn comment, errors.Errorf(\"the same ip %s already voted for %s\", userIPHash, req.CommentID)\n+\t\treturn comment, fmt.Errorf(\"the same ip %s already voted for %s\", userIPHash, req.CommentID)\n \t}\n \n \tmaxVotes := s.MaxVotes // 0 value allowed and treated as \"no comments allowed\"\n@@ -374,11 +376,11 @@ func (s *DataStore) Vote(req VoteReq) (comment store.Comment, err error) {\n \t}\n \n \tif maxVotes >= 0 && len(comment.Votes) >= maxVotes {\n-\t\treturn comment, errors.Errorf(\"maximum number of votes exceeded for comment %s\", req.CommentID)\n+\t\treturn comment, fmt.Errorf(\"maximum number of votes exceeded for comment %s\", req.CommentID)\n \t}\n \n \tif s.PositiveScore && comment.Score <= 0 && !req.Val {\n-\t\treturn comment, errors.Errorf(\"minimal score reached for comment %s\", req.CommentID)\n+\t\treturn comment, fmt.Errorf(\"minimal score reached for comment %s\", req.CommentID)\n \t}\n \n \t// add ip hash to voted ip map\n@@ -472,12 +474,12 @@ func (s *DataStore) EditComment(locator store.Locator, commentID string, req Edi\n \n \t\t// edit allowed in editDuration window only\n \t\tif s.EditDuration > 0 && time.Now().After(comment.Timestamp.Add(s.EditDuration)) {\n-\t\t\treturn errors.Errorf(\"too late to edit %s\", commentID)\n+\t\t\treturn fmt.Errorf(\"too late to edit %s\", commentID)\n \t\t}\n \n \t\t// edit rejected on replayed threads\n \t\tif s.HasReplies(comment) {\n-\t\t\treturn errors.Errorf(\"parent comment with reply can't be edited, %s\", commentID)\n+\t\t\treturn fmt.Errorf(\"parent comment with reply can't be edited, %s\", commentID)\n \t\t}\n \t\treturn nil\n \t}\n@@ -555,7 +557,7 @@ func (s *DataStore) HasReplies(comment store.Comment) bool {\n func (s *DataStore) UserReplies(siteID, userID string, limit int, duration time.Duration) ([]store.Comment, string, error) {\n \tcomments, e := s.Last(siteID, maxLastCommentsReply, time.Time{}, nonAdminUser)\n \tif e != nil {\n-\t\treturn nil, \"\", errors.Wrap(e, \"can't get last comments\")\n+\t\treturn nil, \"\", fmt.Errorf(\"can't get last comments: %w\", e)\n \t}\n \treplies := []store.Comment{}\n \n@@ -574,7 +576,7 @@ func (s *DataStore) UserReplies(siteID, userID string, limit int, duration time.\n \t\tif c.ParentID != \"\" && !c.Deleted && c.User.ID != userID { // not interested in replies to yourself\n \t\t\tvar pc store.Comment\n \t\t\tif pc, e = s.Get(c.Locator, c.ParentID, nonAdminUser); e != nil {\n-\t\t\t\treturn nil, \"\", errors.Wrap(e, \"can't get parent comment\")\n+\t\t\t\treturn nil, \"\", fmt.Errorf(\"can't get parent comment: %w\", e)\n \t\t\t}\n \t\t\tif pc.User.ID == userID {\n \t\t\t\treplies = append(replies, c)\n@@ -588,7 +590,7 @@ func (s *DataStore) UserReplies(siteID, userID string, limit int, duration time.\n // SetTitle puts title from the locator.URL page and overwrites any existing title\n func (s *DataStore) SetTitle(locator store.Locator, commentID string) (comment store.Comment, err error) {\n \tif s.TitleExtractor == nil {\n-\t\treturn comment, errors.New(\"no title extractor\")\n+\t\treturn comment, fmt.Errorf(\"no title extractor\")\n \t}\n \n \tcomment, err = s.Engine.Get(engine.GetRequest{Locator: locator, CommentID: commentID})\n@@ -626,13 +628,13 @@ func (s *DataStore) ValidateComment(c *store.Comment) error {\n \t\tmaxSize = defaultCommentMaxSize\n \t}\n \tif c.Orig == \"\" {\n-\t\treturn errors.New(\"empty comment text\")\n+\t\treturn fmt.Errorf(\"empty comment text\")\n \t}\n \tif len([]rune(c.Orig)) > maxSize {\n-\t\treturn errors.Errorf(\"comment text exceeded max allowed size %d (%d)\", maxSize, len([]rune(c.Orig)))\n+\t\treturn fmt.Errorf(\"comment text exceeded max allowed size %d (%d)\", maxSize, len([]rune(c.Orig)))\n \t}\n \tif c.User.ID == \"\" || c.User.Name == \"\" {\n-\t\treturn errors.Errorf(\"empty user info\")\n+\t\treturn fmt.Errorf(\"empty user info\")\n \t}\n \treturn nil\n }\n@@ -711,7 +713,7 @@ func (s *DataStore) SetBlock(siteID, userID string, status bool, ttl time.Durati\n func (s *DataStore) BlockedUsers(siteID string) (res []store.BlockedUser, err error) {\n \tblocked, e := s.Engine.ListFlags(engine.FlagRequest{Locator: store.Locator{SiteID: siteID}, Flag: engine.Blocked})\n \tif e != nil {\n-\t\treturn nil, errors.Wrapf(err, \"can't get list of blocked users for %s\", siteID)\n+\t\treturn nil, fmt.Errorf(\"can't get list of blocked users for %s: %w\", siteID, err)\n \t}\n \tfor _, v := range blocked {\n \t\tres = append(res, v.(store.BlockedUser))\n@@ -727,7 +729,7 @@ func (s *DataStore) Info(locator store.Locator, readonlyAge int) (store.PostInfo\n \t\treturn store.PostInfo{}, err\n \t}\n \tif len(res) == 0 {\n-\t\treturn store.PostInfo{}, errors.Errorf(\"post %+v not found\", locator)\n+\t\treturn store.PostInfo{}, fmt.Errorf(\"post %+v not found\", locator)\n \t}\n \treturn res[0], nil\n }\n@@ -767,7 +769,7 @@ func (s *DataStore) Metas(siteID string) (umetas []UserMetaData, pmetas []PostMe\n \t// set posts meta\n \tposts, err := s.Engine.Info(engine.InfoRequest{Locator: store.Locator{SiteID: siteID}})\n \tif err != nil {\n-\t\treturn nil, nil, errors.Wrapf(err, \"can't get list of posts for %s\", siteID)\n+\t\treturn nil, nil, fmt.Errorf(\"can't get list of posts for %s: %w\", siteID, err)\n \t}\n \n \tfor _, p := range posts {\n@@ -782,7 +784,7 @@ func (s *DataStore) Metas(siteID string) (umetas []UserMetaData, pmetas []PostMe\n \t// process blocked users\n \tblocked, err := s.BlockedUsers(siteID)\n \tif err != nil {\n-\t\treturn nil, nil, errors.Wrapf(err, \"can't get list of blocked users for %s\", siteID)\n+\t\treturn nil, nil, fmt.Errorf(\"can't get list of blocked users for %s: %w\", siteID, err)\n \t}\n \tfor _, b := range blocked {\n \t\tval, ok := m[b.ID]\n@@ -797,7 +799,7 @@ func (s *DataStore) Metas(siteID string) (umetas []UserMetaData, pmetas []PostMe\n \t// process verified users\n \tverified, err := s.Engine.ListFlags(engine.FlagRequest{Locator: store.Locator{SiteID: siteID}, Flag: engine.Verified})\n \tif err != nil {\n-\t\treturn nil, nil, errors.Wrapf(err, \"can't get list of verified users for %s\", siteID)\n+\t\treturn nil, nil, fmt.Errorf(\"can't get list of verified users for %s: %w\", siteID, err)\n \t}\n \tfor _, vi := range verified {\n \t\tv := vi.(string)\n@@ -812,7 +814,7 @@ func (s *DataStore) Metas(siteID string) (umetas []UserMetaData, pmetas []PostMe\n \t// process users details\n \tusersDetails, err := s.Engine.UserDetail(engine.UserDetailRequest{Locator: store.Locator{SiteID: siteID}, Detail: engine.AllUserDetails})\n \tif err != nil {\n-\t\treturn nil, nil, errors.Wrapf(err, \"can't get user details for %s\", siteID)\n+\t\treturn nil, nil, fmt.Errorf(\"can't get user details for %s: %w\", siteID, err)\n \t}\n \tfor _, entry := range usersDetails {\n \t\tval, ok := m[entry.UserID]\n@@ -982,15 +984,15 @@ func (s *DataStore) prepVotes(c store.Comment, user store.User) store.Comment {\n // Note: secret shared across sites, but some sites can be disabled.\n func (s *DataStore) getSecret(siteID string) (secret string, err error) {\n \tif secret, err = s.AdminStore.Key(\"any\"); err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't get secret for site %s\", siteID)\n+\t\treturn \"\", fmt.Errorf(\"can't get secret for site %s: %w\", siteID, err)\n \t}\n \n \tok, err := s.AdminStore.Enabled(siteID)\n \tif err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't check secret enabled for site %s\", siteID)\n+\t\treturn \"\", fmt.Errorf(\"can't check secret enabled for site %s: %w\", siteID, err)\n \t}\n \tif !ok {\n-\t\treturn \"\", errors.Errorf(\"site %s disabled\", siteID)\n+\t\treturn \"\", fmt.Errorf(\"site %s disabled\", siteID)\n \t}\n \treturn secret, nil\n }"
    },
    {
      "sha": "a7dd6e62f12dac245f5339ff48cc09fe7a9f5897",
      "filename": "backend/app/store/service/service_test.go",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fservice%2Fservice_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fservice%2Fservice_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Fservice_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -17,7 +17,6 @@ import (\n \t\"time\"\n \n \t\"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n \tbolt \"go.etcd.io/bbolt\"\n@@ -754,10 +753,10 @@ func TestService_ValidateComment(t *testing.T) {\n \t\tinp store.Comment\n \t\terr error\n \t}{\n-\t\t{inp: store.Comment{}, err: errors.New(\"empty comment text\")},\n+\t\t{inp: store.Comment{}, err: fmt.Errorf(\"empty comment text\")},\n \t\t{inp: store.Comment{Orig: \"something blah\", User: store.User{ID: \"myid\", Name: \"name\"}}, err: nil},\n-\t\t{inp: store.Comment{Orig: \"something blah\", User: store.User{ID: \"myid\"}}, err: errors.New(\"empty user info\")},\n-\t\t{inp: store.Comment{Orig: longText, User: store.User{ID: \"myid\", Name: \"name\"}}, err: errors.New(\"comment text exceeded max allowed size 2000 (4000)\")},\n+\t\t{inp: store.Comment{Orig: \"something blah\", User: store.User{ID: \"myid\"}}, err: fmt.Errorf(\"empty user info\")},\n+\t\t{inp: store.Comment{Orig: longText, User: store.User{ID: \"myid\", Name: \"name\"}}, err: fmt.Errorf(\"comment text exceeded max allowed size 2000 (4000)\")},\n \t}\n \n \tfor n, tt := range tbl {\n@@ -1439,7 +1438,7 @@ func TestService_ResubmitStagingImages(t *testing.T) {\n \tbError := DataStore{Engine: eng, EditDuration: 10 * time.Millisecond, ImageService: imgSvcError}\n \n \t// resubmit will receive error from image storage and should return it\n-\tmockStoreError.On(\"Info\").Once().Return(image.StoreInfo{}, errors.New(\"mock_err\"))\n+\tmockStoreError.On(\"Info\").Once().Return(image.StoreInfo{}, fmt.Errorf(\"mock_err\"))\n \terr = bError.ResubmitStagingImages([]string{\"radio-t\"})\n \tassert.EqualError(t, err, \"mock_err\")\n \n@@ -1459,7 +1458,7 @@ func TestService_ResubmitStagingImages_EngineError(t *testing.T) {\n \tsite1Req := engine.FindRequest{Locator: store.Locator{SiteID: \"site1\", URL: \"\"}, Sort: \"time\", Since: time.Time{}.Add(time.Second)}\n \tsite2Req := engine.FindRequest{Locator: store.Locator{SiteID: \"site2\", URL: \"\"}, Sort: \"time\", Since: time.Time{}.Add(time.Second)}\n \tengineMock.On(\"Find\", site1Req).Return(nil, nil)\n-\tengineMock.On(\"Find\", site2Req).Return(nil, errors.New(\"mockError\"))\n+\tengineMock.On(\"Find\", site2Req).Return(nil, fmt.Errorf(\"mockError\"))\n \tb := DataStore{Engine: &engineMock, EditDuration: 10 * time.Millisecond, ImageService: imgSvc}\n \n \t// One call without error and one with error"
    },
    {
      "sha": "01b6a1273d75d776987797ce2fe584936af0f78e",
      "filename": "backend/app/store/service/title.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fservice%2Ftitle.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fservice%2Ftitle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fservice%2Ftitle.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -1,14 +1,14 @@\n package service\n \n import (\n+\t\"fmt\"\n \t\"io\"\n \t\"net/http\"\n \t\"strings\"\n \t\"time\"\n \n \t\"github.com/go-pkgz/lcw\"\n \tlog \"github.com/go-pkgz/lgr\"\n-\t\"github.com/pkg/errors\"\n \t\"golang.org/x/net/html\"\n )\n \n@@ -43,20 +43,20 @@ func (t *TitleExtractor) Get(url string) (string, error) {\n \tb, err := t.cache.Get(url, func() (interface{}, error) {\n \t\tresp, err := client.Get(url)\n \t\tif err != nil {\n-\t\t\treturn nil, errors.Wrapf(err, \"failed to load page %s\", url)\n+\t\t\treturn nil, fmt.Errorf(\"failed to load page %s: %w\", url, err)\n \t\t}\n \t\tdefer func() {\n \t\t\tif err = resp.Body.Close(); err != nil {\n \t\t\t\tlog.Printf(\"[WARN] failed to close title extractor body, %v\", err)\n \t\t\t}\n \t\t}()\n \t\tif resp.StatusCode != 200 {\n-\t\t\treturn nil, errors.Errorf(\"can't load page %s, code %d\", url, resp.StatusCode)\n+\t\t\treturn nil, fmt.Errorf(\"can't load page %s, code %d\", url, resp.StatusCode)\n \t\t}\n \n \t\ttitle, ok := t.getTitle(resp.Body)\n \t\tif !ok {\n-\t\t\treturn nil, errors.Errorf(\"can't get title for %s\", url)\n+\t\t\treturn nil, fmt.Errorf(\"can't get title for %s\", url)\n \t\t}\n \t\treturn title, nil\n \t})"
    },
    {
      "sha": "303f024d25cc9e25182d0d4338312cc36caa36fb",
      "filename": "backend/app/store/user_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark42/blob/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fuser_test.go",
      "raw_url": "https://github.com/umputun/remark42/raw/ba86db1263fe1f45dc6ef6e1502f28233a5acbe1/backend%2Fapp%2Fstore%2Fuser_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark42/contents/backend%2Fapp%2Fstore%2Fuser_test.go?ref=ba86db1263fe1f45dc6ef6e1502f28233a5acbe1",
      "patch": "@@ -2,7 +2,7 @@ package store\n \n import (\n \t\"crypto/sha1\"\n-\t\"errors\"\n+\t\"fmt\"\n \t\"testing\"\n \n \t\"github.com/stretchr/testify/assert\"\n@@ -63,4 +63,4 @@ func (mock mockHash) Sum(_ []byte) []byte               { return nil }\n func (mock mockHash) Reset()                            {}\n func (mock mockHash) Size() int                         { return 0 }\n func (mock mockHash) BlockSize() int                    { return 0 }\n-func (mock mockHash) Write(_ []byte) (n int, err error) { return 0, errors.New(\"error\") }\n+func (mock mockHash) Write(_ []byte) (n int, err error) { return 0, fmt.Errorf(\"error\") }"
    }
  ]
}
